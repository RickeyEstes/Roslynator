assembly Roslynator.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=3aeedfaf14b2cebf
  [AssemblyCompany("Josef Pihrt")]
  [AssemblyConfiguration("Debug")]
  [AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
  [AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.Common.")]
  [AssemblyFileVersion("1.0.0.10")]
  [AssemblyInformationalVersion("1.0.0.10")]
  [AssemblyProduct("Roslynator.Core")]
  [AssemblyTitle("Roslynator.Core")]
  [AssemblyVersion("1.0.0.10")]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Roslynator.CSharp, Version=1.0.0.10, Culture=neutral, PublicKeyToken=390be46f77b79f52
  [AssemblyCompany("Josef Pihrt")]
  [AssemblyConfiguration("Debug")]
  [AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
  [AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.CSharp\n\nCommonly Used Types:\nRoslynator.CSharp.CSharpFactory\nRoslynator.CSharp.CSharpFacts\nRoslynator.CSharp.SyntaxInfo\nRoslynator.NameGenerator")]
  [AssemblyFileVersion("1.0.0.10")]
  [AssemblyInformationalVersion("1.0.0.10")]
  [AssemblyProduct("Roslynator.CSharp")]
  [AssemblyTitle("Roslynator.CSharp")]
  [AssemblyVersion("1.0.0.10")]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Roslynator.CSharp.Workspaces, Version=1.0.0.10, Culture=neutral, PublicKeyToken=ec3f0c29a7973f23
  [AssemblyCompany("Josef Pihrt")]
  [AssemblyConfiguration("Debug")]
  [AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
  [AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.CSharp.Workspaces\n\nCommonly Used Types:\nRoslynator.CSharp.CSharpFactory\nRoslynator.CSharp.CSharpFacts\nRoslynator.CSharp.SyntaxInfo\nRoslynator.NameGenerator")]
  [AssemblyFileVersion("1.0.0.10")]
  [AssemblyInformationalVersion("1.0.0.10")]
  [AssemblyProduct("Roslynator.CSharp.Workspaces")]
  [AssemblyTitle("Roslynator.CSharp.Workspaces")]
  [AssemblyVersion("1.0.0.10")]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Roslynator.Workspaces.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=be1ec334fe31b7bb
  [AssemblyCompany("Josef Pihrt")]
  [AssemblyConfiguration("Debug")]
  [AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
  [AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.Workspaces.Common.")]
  [AssemblyFileVersion("1.0.0.10")]
  [AssemblyInformationalVersion("1.0.0.10")]
  [AssemblyProduct("Roslynator.Workspaces.Core")]
  [AssemblyTitle("Roslynator.Workspaces.Core")]
  [AssemblyVersion("1.0.0.10")]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

namespace Roslynator

  <summary>A set of extension methods for <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext" />, <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext" /> and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext" />.</summary>
  public static class DiagnosticsExtensions

    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs);

  <summary>A set of extension methods for enumerations.</summary>
  public static class EnumExtensions

    <summary>Returns true if the accessibility is one of the specified accessibilities.</summary>
    public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2);
    <summary>Returns true if the method kind is one of the specified method kinds.</summary>
    public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2);
    <summary>Returns true if the special type is one of the specified special types.</summary>
    public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2);
    <summary>Returns true if the type kind is one of the specified type kinds.</summary>
    public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2);
    <summary>Returns true if the accessibility is one of the specified accessibilities.</summary>
    public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3);
    <summary>Returns true if the method kind is one of the specified method kinds.</summary>
    public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3);
    <summary>Returns true if the special type is one of the specified special types.</summary>
    public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3);
    <summary>Returns true if the type kind is one of the specified type kinds.</summary>
    public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3);
    <summary>Returns true if the accessibility is one of the specified accessibilities.</summary>
    public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4);
    <summary>Returns true if the method kind is one of the specified method kinds.</summary>
    public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4);
    <summary>Returns true if the special type is one of the specified special types.</summary>
    public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4);
    <summary>Returns true if the type kind is one of the specified type kinds.</summary>
    public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4);
    <summary>Returns true if the accessibility is one of the specified accessibilities.</summary>
    public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4, Accessibility accessibility5);
    <summary>Returns true if the method kind is one of the specified method kinds.</summary>
    public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4, MethodKind methodKind5);
    <summary>Returns true if the special type is one of the specified special types.</summary>
    public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4, SpecialType specialType5);
    <summary>Returns true if the type kind is one of the specified type kinds.</summary>
    public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4, TypeKind typeKind5);
    <summary>Returns true if the accessibility if more restrictrive than the other accessibility.</summary>
    public static bool IsMoreRestrictiveThan(this Accessibility accessibility, Accessibility other);

  <summary>A set of extension methods for <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan" />.</summary>
  public static class FileLinePositionSpanExtensions

    <summary>Returns zero-based index of the end line of the specified span.</summary>
    public static int EndLine(this FileLinePositionSpan fileLinePositionSpan);
    <summary>Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan" /> spans over multiple lines.</summary>
    public static bool IsMultiLine(this FileLinePositionSpan fileLinePositionSpan);
    <summary>Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan" /> does not span over multiple lines.</summary>
    public static bool IsSingleLine(this FileLinePositionSpan fileLinePositionSpan);
    <summary>Returns zero-based index of the start line of the specified span.</summary>
    public static int StartLine(this FileLinePositionSpan fileLinePositionSpan);

  <summary>
  Provides equality comparison for <typeparamref name="TSymbol" /> by comparing <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName" />,
  metadata name of <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType" />(s) and metadata name of <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingNamespace" />(s).
  </summary>
  public sealed class MetadataNameEqualityComparer<TSymbol> : EqualityComparer<TSymbol> where TSymbol : ISymbol

    <summary>Get the instance of <see cref="T:Roslynator.MetadataNameEqualityComparer`1" /> for the specified <typeparamref name="TSymbol" />.</summary>
    public static MetadataNameEqualityComparer<TSymbol> Instance { get; }

    <summary>When overridden in a derived class, determines whether two objects of type <typeparamref name="TSymbol" /> are equal.</summary>
    <param name="x">The first object to compare.</param>
    <param name="y">The second object to compare.</param>
    <returns>true if the specified objects are equal; otherwise, false.</returns>
    public override bool Equals(TSymbol x, TSymbol y);
    <summary>Serves as a hash function for the specified symbol.</summary>
    <param name="obj">The symbol for which to get a hash code.</param>
    <returns>A hash code for the specified symbol.</returns>
    <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> is <c>null</c>.</exception>
    public override int GetHashCode(TSymbol obj);

  <summary>Provides methods to obtain an unique identifier.</summary>
  public abstract class NameGenerator

    protected NameGenerator();

    <summary>Default implementation of <see cref="T:Roslynator.NameGenerator" /> that adds number suffix to ensure uniqueness.</summary>
    public static NameGenerator Default { get; }

    <summary>Creates a syntax identifier from the specified type symbol.</summary>
    public static string CreateName(ITypeSymbol typeSymbol, bool firstCharToLower = false);
    <summary>Returns unique enum member name for a specified enum type.</summary>
    public string EnsureUniqueEnumMemberName(string baseName, INamedTypeSymbol enumType, bool isCaseSensitive = true);
    <summary>Return a local name that will be unique at the specified position.</summary>
    public string EnsureUniqueLocalName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default);
    [Obsolete("This member is obsolete.")]
    public string EnsureUniqueMemberName(string baseName, INamedTypeSymbol typeSymbol, bool isCaseSensitive = true);
    <summary>Returns a member name that will be unique at the specified position.</summary>
    [Obsolete("This member is obsolete.")]
    public string EnsureUniqueMemberName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default);
    <summary>Returns an unique name using the specified list of reserved names.</summary>
    public abstract string EnsureUniqueName(string baseName, IEnumerable<string> reservedNames, bool isCaseSensitive = true);
    <summary>Returns an unique name using the specified list of symbols.</summary>
    public abstract string EnsureUniqueName(string baseName, ImmutableArray<ISymbol> symbols, bool isCaseSensitive = true);
    <summary>Returns a name that will be unique at the specified position.</summary>
    public string EnsureUniqueName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true);
    <summary>Returns true if the name is not contained in the specified list.</summary>
    public static bool IsUniqueName(string name, IEnumerable<string> reservedNames, bool isCaseSensitive = true);
    <summary>Returns true if the name is not contained in the specified list. <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name" /> is used to compare names.</summary>
    public static bool IsUniqueName(string name, ImmutableArray<ISymbol> symbols, bool isCaseSensitive = true);

  <summary>A set of extension methods for a <see cref="T:Microsoft.CodeAnalysis.SemanticModel" />.</summary>
  public static class SemanticModelExtensions

    <summary>Returns the innermost named type symbol that the specified position is considered inside of.</summary>
    public static INamedTypeSymbol GetEnclosingNamedType(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default);
    <summary>Returns the innermost symbol of type <typeparamref name="TSymbol" /> that the specified position is considered inside of.</summary>
    public static TSymbol GetEnclosingSymbol<TSymbol>(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default) where TSymbol : ISymbol;
    <summary>Returns what symbol, if any, the specified node bound to.</summary>
    public static ISymbol GetSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default);
    <summary>Returns the type within the compilation's assembly using its canonical CLR metadata name.</summary>
    public static INamedTypeSymbol GetTypeByMetadataName(this SemanticModel semanticModel, string fullyQualifiedMetadataName);
    <summary>Returns type information about the specified node.</summary>
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default);

  <summary>Represents selected nodes in a <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
  public class SeparatedSyntaxListSelection<TNode> : ISelection<TNode> where TNode : SyntaxNode

    <summary>Initializes a new instance of the <see cref="T:Roslynator.SeparatedSyntaxListSelection`1" />.</summary>
    protected SeparatedSyntaxListSelection(SeparatedSyntaxList<TNode> list, TextSpan span, int firstIndex, int lastIndex);

    <summary>Gets a number of selected nodes.</summary>
    public int Count { get; }
    <summary>Gets an index of the first selected node.</summary>
    public int FirstIndex { get; }
    <summary>Gets an index of the last selected node.</summary>
    public int LastIndex { get; }
    <summary>Gets the original span that was used to determine selected nodes.</summary>
    public TextSpan OriginalSpan { get; }
    <summary>Gets an underlying list that contains selected nodes.</summary>
    public SeparatedSyntaxList<TNode> UnderlyingList { get; }

    <summary>Gets the selected node at the specified index.</summary>
    <returns>The node at the specified index.</returns>
    <param name="index">The zero-based index of the node to get. </param>
    public TNode this[int index] { get; }

    <summary>Creates a new <see cref="T:Roslynator.SeparatedSyntaxListSelection`1" /> based on the specified list and span.</summary>
    public static SeparatedSyntaxListSelection<TNode> Create(SeparatedSyntaxList<TNode> list, TextSpan span);
    <summary>Gets the first selected node.</summary>
    public TNode First();
    <summary>Returns an enumerator that iterates through selected nodes.</summary>
    public SeparatedSyntaxListSelection<TNode>.Enumerator GetEnumerator();
    <summary>Gets the last selected node.</summary>
    public TNode Last();
    <summary>Creates a new <see cref="T:Roslynator.SeparatedSyntaxListSelection`1" /> based on the specified list and span.</summary>
    <returns>True if the specified span contains at least one node; otherwise, false.</returns>
    public static bool TryCreate(SeparatedSyntaxList<TNode> list, TextSpan span, out SeparatedSyntaxListSelection<TNode> selection);

    public struct Enumerator

      public TNode Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

  <summary>A set of extension methods for <see cref="T:Microsoft.CodeAnalysis.ISymbol" /> and its derived types.</summary>
  public static class SymbolExtensions

    <summary>Gets a list of base types of this type.</summary>
    public static IEnumerable<INamedTypeSymbol> BaseTypes(this ITypeSymbol type);
    <summary>Gets a list of base types of this type (including this type).</summary>
    public static IEnumerable<ITypeSymbol> BaseTypesAndSelf(this ITypeSymbol typeSymbol);
    <summary>Returns true if the type is equal or inherits from a specified base type.</summary>
    public static bool EqualsOrInheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false);
    <summary>Returns true if the type is equal or inherits from a type wit the specified name.</summary>
    public static bool EqualsOrInheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false);
    <summary>Searches for a member that matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
    public static TSymbol FindMember<TSymbol>(this ITypeSymbol typeSymbol, Func<TSymbol, bool> predicate = null) where TSymbol : ISymbol;
    <summary>Searches for a member that has the specified name and matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
    public static TSymbol FindMember<TSymbol>(this ITypeSymbol typeSymbol, string name, Func<TSymbol, bool> predicate = null) where TSymbol : ISymbol;
    <summary>Searches for a member that matches the conditions defined by the specified predicate and returns the first occurrence within the type's members.</summary>
    public static TSymbol FindMember<TSymbol>(this INamedTypeSymbol typeSymbol, Func<TSymbol, bool> predicate, bool includeBaseTypes = false) where TSymbol : ISymbol;
    <summary>Searches for a member that has the specified name and matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
    public static TSymbol FindMember<TSymbol>(this INamedTypeSymbol typeSymbol, string name, Func<TSymbol, bool> predicate = null, bool includeBaseTypes = false) where TSymbol : ISymbol;
    <summary>Searches for a type member that matches the conditions defined by the specified predicate and returns the first occurrence within the type's members.</summary>
    public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, Func<INamedTypeSymbol, bool> predicate, bool includeBaseTypes = false);
    <summary>Searches for a type member that has the specified name and matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
    public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, Func<INamedTypeSymbol, bool> predicate = null, bool includeBaseTypes = false);
    <summary>Searches for a type member that has the specified name, arity and matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
    public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, int arity, Func<INamedTypeSymbol, bool> predicate = null, bool includeBaseTypes = false);
    <summary>Returns the attribute for the symbol that matches the specified attribute class, or null if the symbol does not have the specified attribute.</summary>
    public static AttributeData GetAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass);
    <summary>Returns the attribute for the symbol that matches the specified name, or null if the symbol does not have the specified attribute.</summary>
    public static AttributeData GetAttribute(this ISymbol symbol, in MetadataName attributeName);
    <summary>Returns true if the symbol has the specified attribute.</summary>
    public static bool HasAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass);
    <summary>Returns true if the symbol has attribute with the specified name.</summary>
    public static bool HasAttribute(this ISymbol symbol, in MetadataName attributeName);
    <summary>Returns true if the type symbol has the specified attribute.</summary>
    public static bool HasAttribute(this ITypeSymbol typeSymbol, INamedTypeSymbol attributeClass, bool includeBaseTypes);
    <summary>Returns true if the type symbol has attribute with the specified name.</summary>
    public static bool HasAttribute(this ITypeSymbol typeSymbol, in MetadataName attributeName, bool includeBaseTypes);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, bool value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, char value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, sbyte value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, byte value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, short value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ushort value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, int value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, uint value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, long value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ulong value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, decimal value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, float value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, double value);
    <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, string value);
    <summary>Returns true if a symbol has the specified <see cref="T:Roslynator.MetadataName" />.</summary>
    public static bool HasMetadataName(this ISymbol symbol, in MetadataName metadataName);
    <summary>Returns true if the type implements specified interface.</summary>
    <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
    public static bool Implements(this ITypeSymbol typeSymbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false);
    <summary>Returns true if the type implements specified interface.</summary>
    <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
    public static bool Implements(this ITypeSymbol typeSymbol, SpecialType interfaceType, bool allInterfaces = false);
    <summary>Returns true if the type implements specified interface name.</summary>
    public static bool Implements(this ITypeSymbol typeSymbol, in MetadataName interfaceName, bool allInterfaces = false);
    <summary>Returns true if the type implements any of specified interfaces.</summary>
    <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
    public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, bool allInterfaces = false);
    <summary>Returns true if the type implements any of specified interfaces.</summary>
    <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
    public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, SpecialType interfaceType3, bool allInterfaces = false);
    <summary>Returns true if the the symbol implements any interface member.</summary>
    <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
    public static bool ImplementsInterfaceMember(this ISymbol symbol, bool allInterfaces = false);
    <summary>Returns true if the symbol implements any member of the specified interface.</summary>
    <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
    public static bool ImplementsInterfaceMember(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false);
    <summary>Returns true if the symbol implements any interface member.</summary>
    <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
    public static bool ImplementsInterfaceMember<TSymbol>(this ISymbol symbol, bool allInterfaces = false) where TSymbol : ISymbol;
    <summary>Returns true if the symbol implements any member of the specified interface.</summary>
    <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
    public static bool ImplementsInterfaceMember<TSymbol>(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false) where TSymbol : ISymbol;
    <summary>Returns true if the type inherits from a specified base type.</summary>
    public static bool InheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false);
    <summary>Returns true if the type inherits from a type with the specified name.</summary>
    public static bool InheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false);
    <summary>Returns true if the symbol is an async method.</summary>
    public static bool IsAsyncMethod(this ISymbol symbol);
    <summary>Returns true if the symbol represents an error.</summary>
    public static bool IsErrorType(this ISymbol symbol);
    <summary>Returns true if the type is <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
    public static bool IsIEnumerableOfT(this ITypeSymbol typeSymbol);
    <summary>Returns true if the type is <see cref="T:System.Collections.IEnumerable" /> or <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
    public static bool IsIEnumerableOrIEnumerableOfT(this ITypeSymbol typeSymbol);
    <summary>Returns true if the symbol is the specified kind.</summary>
    public static bool IsKind(this ISymbol symbol, SymbolKind kind);
    <summary>Returns true if the symbol is one of the specified kinds.</summary>
    public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2);
    <summary>Returns true if the symbol is one of the specified kinds.</summary>
    public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3);
    <summary>Returns true if the symbol is one of the specified kinds.</summary>
    public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4);
    <summary>Returns true if the symbol is one of the specified kinds.</summary>
    public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4, SymbolKind kind5);
    <summary>Returns true if the type is <see cref="T:System.Nullable`1" /> and it has specified type argument.</summary>
    public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, SpecialType specialType);
    <summary>Returns true if the type is <see cref="T:System.Nullable`1" /> and it has specified type argument.</summary>
    public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, ITypeSymbol typeArgument);
    <summary>Returns true if the type is <see cref="T:System.Nullable`1" /> and it has specified type argument.</summary>
    public static bool IsNullableOf(this ITypeSymbol typeSymbol, SpecialType specialType);
    <summary>Returns true if the type is <see cref="T:System.Nullable`1" /> and it has specified type argument.</summary>
    public static bool IsNullableOf(this ITypeSymbol typeSymbol, ITypeSymbol typeArgument);
    <summary>Returns true if the type is a nullable type.</summary>
    public static bool IsNullableType(this ITypeSymbol typeSymbol);
    <summary>Returns true if the type is <see cref="T:System.Object" />.</summary>
    public static bool IsObject(this ITypeSymbol typeSymbol);
    <summary>Returns true if this method is an ordinary extension method (i.e. "this" parameter has not been removed).</summary>
    public static bool IsOrdinaryExtensionMethod(this IMethodSymbol methodSymbol);
    <summary>Returns true if the parameter was declared as a parameter array that has a specified element type.</summary>
    public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType);
    <summary>Returns true if the parameter was declared as a parameter array that has one of specified element types.</summary>
    public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2);
    <summary>Returns true if the parameter was declared as a parameter array that has one of specified element types.</summary>
    public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2, SpecialType elementType3);
    <summary>Return true if the specified symbol is publicly visible.</summary>
    public static bool IsPubliclyVisible(this ISymbol symbol);
    <summary>Returns true if this method is a reduced extension method.</summary>
    public static bool IsReducedExtensionMethod(this IMethodSymbol methodSymbol);
    <summary>Returns true if the parameter was declared as "ref" or "out" parameter.</summary>
    public static bool IsRefOrOut(this IParameterSymbol parameterSymbol);
    <summary>Returns true if the type is a reference type or a nullable type.</summary>
    public static bool IsReferenceTypeOrNullableType(this ITypeSymbol typeSymbol);
    <summary>Returns true if the type is <see cref="T:System.String" />.</summary>
    public static bool IsString(this ITypeSymbol typeSymbol);
    <summary>Returns true if the type is <see cref="T:System.Void" />.</summary>
    public static bool IsVoid(this ITypeSymbol typeSymbol);
    <summary>If this method is a reduced extension method, returns the definition of extension method from which this was reduced. Otherwise, returns this symbol.</summary>
    public static IMethodSymbol ReducedFromOrSelf(this IMethodSymbol methodSymbol);
    <summary>Returns true if the type can be declared explicitly in a source code.</summary>
    public static bool SupportsExplicitDeclaration(this ITypeSymbol typeSymbol);

  <summary>A set of extension method for a syntax.</summary>
  public static class SyntaxExtensions

    <summary>Returns true if all tokens in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" /> matches the predicate.</summary>
    public static bool All(this SyntaxTokenList list, Func<SyntaxToken, bool> predicate);
    <summary>Returns true if all trivia in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" /> matches the predicate.</summary>
    public static bool All(this SyntaxTriviaList list, Func<SyntaxTrivia, bool> predicate);
    <summary>Returns true if all nodes in a list matches the predicate.</summary>
    public static bool All<TNode>(this SeparatedSyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode;
    <summary>Returns true if all nodes in a list matches the predicate.</summary>
    public static bool All<TNode>(this SyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode;
    <summary>Returns true if any token in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" /> matches the predicate.</summary>
    public static bool Any(this SyntaxTokenList list, Func<SyntaxToken, bool> predicate);
    <summary>Returns true if any trivia in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" /> matches the predicate.</summary>
    public static bool Any(this SyntaxTriviaList list, Func<SyntaxTrivia, bool> predicate);
    <summary>Returns true if any node in a list matches the predicate.</summary>
    public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode;
    <summary>Returns true if any node in a list matches the predicate.</summary>
    public static bool Any<TNode>(this SyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode;
    <summary>Creates a new token from this token with the leading trivia replaced with a new trivia where the specified trivia is added at the end of the leading trivia.</summary>
    public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia);
    <summary>Creates a new token from this token with the leading trivia replaced with a new trivia where the specified trivia is added at the end of the leading trivia.</summary>
    public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia);
    <summary>Creates a new node from this node with the leading trivia replaced with a new trivia where the specified trivia is added at the end of the leading trivia.</summary>
    public static TNode AppendToLeadingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode;
    <summary>Creates a new node from this node with the leading trivia replaced with a new trivia where the specified trivia is added at the end of the leading trivia.</summary>
    public static TNode AppendToLeadingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode;
    <summary>Creates a new token from this token with the trailing trivia replaced with a new trivia where the specified trivia is added at the end of the trailing trivia.</summary>
    public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia);
    <summary>Creates a new token from this token with the trailing trivia replaced with a new trivia where the specified trivia is added at the end of the trailing trivia.</summary>
    public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia);
    <summary>Creates a new node from this node with the trailing trivia replaced with a new trivia where the specified trivia is added at the end of the trailing trivia.</summary>
    public static TNode AppendToTrailingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode;
    <summary>Creates a new node from this node with the trailing trivia replaced with a new trivia where the specified trivia is added at the end of the trailing trivia.</summary>
    public static TNode AppendToTrailingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode;
    <summary>Returns true if the specified token is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
    public static bool Contains(this SyntaxTokenList tokens, SyntaxToken token);
    <summary>Returns true if the specified node is in the <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
    public static bool Contains<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    <summary>Returns true if the specified node is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
    public static bool Contains<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    <summary>Returns true if the node contains any preprocessor directives inside the specified span.</summary>
    public static bool ContainsDirectives(this SyntaxNode node, TextSpan span);
    <summary>Get a list of all the trivia associated with the nodes in the list.</summary>
    public static IEnumerable<SyntaxTrivia> DescendantTrivia<TNode>(this SyntaxList<TNode> list, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    <summary>Get a list of all the trivia associated with the nodes in the list.</summary>
    public static IEnumerable<SyntaxTrivia> DescendantTrivia<TNode>(this SyntaxList<TNode> list, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    <summary>Returns the first node of type <typeparamref name="TNode" /> that matches the predicate.</summary>
    public static TNode FirstAncestor<TNode>(this SyntaxNode node, Func<TNode, bool> predicate = null, bool ascendOutOfTrivia = true) where TNode : SyntaxNode;
    <summary>Searches a list of descendant nodes in prefix document order and returns first descendant of type <typeparamref name="TNode" />.</summary>
    public static TNode FirstDescendant<TNode>(this SyntaxNode node, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    <summary>Searches a list of descendant nodes in prefix document order and returns first descendant of type <typeparamref name="TNode" />.</summary>
    public static TNode FirstDescendant<TNode>(this SyntaxNode node, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    <summary>Searches a list of descendant nodes (including this node) in prefix document order and returns first descendant of type <typeparamref name="TNode" />.</summary>
    public static TNode FirstDescendantOrSelf<TNode>(this SyntaxNode node, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    <summary>Searches a list of descendant nodes (including this node) in prefix document order and returns first descendant of type <typeparamref name="TNode" />.</summary>
    public static TNode FirstDescendantOrSelf<TNode>(this SyntaxNode node, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    <summary>Returns leading and trailing trivia of the specified node in a single list.</summary>
    public static SyntaxTriviaList GetLeadingAndTrailingTrivia(this SyntaxNode node);
    <summary>Returns the trailing separator, if any.</summary>
    public static SyntaxToken GetTrailingSeparator<TNode>(this SeparatedSyntaxList<TNode> list) where TNode : SyntaxNode;
    <summary>Returns true if the specified list contains trailing separator.</summary>
    public static bool HasTrailingSeparator<TNode>(this SeparatedSyntaxList<TNode> list) where TNode : SyntaxNode;
    <summary>Searches for a token that matches the predicate and returns the zero-based index of the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
    public static int IndexOf(this SyntaxTokenList tokens, Func<SyntaxToken, bool> predicate);
    <summary>Searches for a trivia that matches the predicate and returns the zero-based index of the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />.</summary>
    public static int IndexOf(this SyntaxTriviaList triviaList, Func<SyntaxTrivia, bool> predicate);
    <summary>Returns true if the specified node is a first node in the list.</summary>
    public static bool IsFirst<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    <summary>Returns true if the specified node is a first node in the list.</summary>
    public static bool IsFirst<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    <summary>Returns true if the specified node is a last node in the list.</summary>
    public static bool IsLast<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    <summary>Returns true if the specified node is a last node in the list.</summary>
    public static bool IsLast<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    <summary>Returns leading and trailing trivia of the specified node in a single list.</summary>
    public static SyntaxTriviaList LeadingAndTrailingTrivia(this SyntaxToken token);
    <summary>Creates a new token from this token with the leading trivia replaced with a new trivia where the specified trivia is inserted at the begining of the leading trivia.</summary>
    public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia);
    <summary>Creates a new token from this token with the leading trivia replaced with a new trivia where the specified trivia is inserted at the begining of the leading trivia.</summary>
    public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia);
    <summary>Creates a new node from this node with the leading trivia replaced with a new trivia where the specified trivia is inserted at the begining of the leading trivia.</summary>
    public static TNode PrependToLeadingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode;
    <summary>Creates a new node from this node with the leading trivia replaced with a new trivia where the specified trivia is inserted at the begining of the leading trivia.</summary>
    public static TNode PrependToLeadingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode;
    <summary>Creates a new token from this token with the trailing trivia replaced with a new trivia where the specified trivia is inserted at the begining of the trailing trivia.</summary>
    public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia);
    <summary>Creates a new token from this token with the trailing trivia replaced with a new trivia where the specified trivia is inserted at the begining of the trailing trivia.</summary>
    public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia);
    <summary>Creates a new node from this node with the trailing trivia replaced with a new trivia where the specified trivia is inserted at the begining of the trailing trivia.</summary>
    public static TNode PrependToTrailingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode;
    <summary>Creates a new node from this node with the trailing trivia replaced with a new trivia where the specified trivia is inserted at the begining of the trailing trivia.</summary>
    public static TNode PrependToTrailingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode;
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" /> with a token at the specified index replaced with a new token.</summary>
    public static SyntaxTokenList ReplaceAt(this SyntaxTokenList tokenList, int index, SyntaxToken newToken);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" /> with a trivia at the specified index replaced with new trivia.</summary>
    public static SyntaxTriviaList ReplaceAt(this SyntaxTriviaList triviaList, int index, SyntaxTrivia newTrivia);
    <summary>Creates a new list with a node at the specified index replaced with a new node.</summary>
    public static SeparatedSyntaxList<TNode> ReplaceAt<TNode>(this SeparatedSyntaxList<TNode> list, int index, TNode newNode) where TNode : SyntaxNode;
    <summary>Creates a new list with the node at the specified index replaced with a new node.</summary>
    public static SyntaxList<TNode> ReplaceAt<TNode>(this SyntaxList<TNode> list, int index, TNode newNode) where TNode : SyntaxNode;
    <summary>Returns true if the node's span contains any preprocessor directives.</summary>
    public static bool SpanContainsDirectives(this SyntaxNode node);
    <summary>Gets a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" /> the specified trivia is contained in.</summary>
    <param name="allowLeading">If true, trivia can be part of leading trivia.</param>
    <param name="allowTrailing">If true, trivia can be part of trailing trivia.</param>
    public static bool TryGetContainingList(this SyntaxTrivia trivia, out SyntaxTriviaList triviaList, bool allowLeading = true, bool allowTrailing = true);
    <summary>Creates a new token from this token with both the leading and trailing trivia of the specified node.</summary>
    public static SyntaxToken WithTriviaFrom(this SyntaxToken token, SyntaxNode node);
    <summary>
    Creates a new separated list with both leading and trailing trivia of the specified node.
    If the list contains more than one item, first item is updated with leading trivia and last item is updated with trailing trivia.
    </summary>
    public static SeparatedSyntaxList<TNode> WithTriviaFrom<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxNode node) where TNode : SyntaxNode;
    <summary>
    Creates a new list with both leading and trailing trivia of the specified node.
    If the list contains more than one item, first item is updated with leading trivia and last item is updated with trailing trivia.
    </summary>
    public static SyntaxList<TNode> WithTriviaFrom<TNode>(this SyntaxList<TNode> list, SyntaxNode node) where TNode : SyntaxNode;
    <summary>Creates a new node from this node with both the leading and trailing trivia of the specified token.</summary>
    public static TNode WithTriviaFrom<TNode>(this TNode node, SyntaxToken token) where TNode : SyntaxNode;
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> with the leading trivia removed.</summary>
    public static SyntaxNodeOrToken WithoutLeadingTrivia(this SyntaxNodeOrToken nodeOrToken);
    <summary>Creates a new token from this token with the leading trivia removed.</summary>
    public static SyntaxToken WithoutLeadingTrivia(this SyntaxToken token);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> with the trailing trivia removed.</summary>
    public static SyntaxNodeOrToken WithoutTrailingTrivia(this SyntaxNodeOrToken nodeOrToken);
    <summary>Creates a new token from this token with the trailing trivia removed.</summary>
    public static SyntaxToken WithoutTrailingTrivia(this SyntaxToken token);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> from this node without leading and trailing trivia.</summary>
    public static SyntaxNodeOrToken WithoutTrivia(this SyntaxNodeOrToken nodeOrToken);

  <summary>Represents selected nodes in a <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
  public class SyntaxListSelection<TNode> : ISelection<TNode> where TNode : SyntaxNode

    <summary>Initializes a new instance of the <see cref="T:Roslynator.SyntaxListSelection`1" />.</summary>
    protected SyntaxListSelection(SyntaxList<TNode> list, TextSpan span, int firstIndex, int lastIndex);

    <summary>Gets a number of selected nodes.</summary>
    public int Count { get; }
    <summary>Gets an index of the first selected node.</summary>
    public int FirstIndex { get; }
    <summary>Gets an index of the last selected node.</summary>
    public int LastIndex { get; }
    <summary>Gets the original span that was used to determine selected nodes.</summary>
    public TextSpan OriginalSpan { get; }
    <summary>Gets an underlying list that contains selected nodes.</summary>
    public SyntaxList<TNode> UnderlyingList { get; }

    <summary>Gets the selected node at the specified index.</summary>
    <returns>The node at the specified index.</returns>
    <param name="index">The zero-based index of the node to get. </param>
    public TNode this[int index] { get; }

    <summary>Creates a new <see cref="T:Roslynator.SyntaxListSelection`1" /> based on the specified list and span.</summary>
    public static SyntaxListSelection<TNode> Create(SyntaxList<TNode> list, TextSpan span);
    <summary>Gets the first selected node.</summary>
    public TNode First();
    <summary>Returns an enumerator that iterates through selected nodes.</summary>
    public SyntaxListSelection<TNode>.Enumerator GetEnumerator();
    <summary>Gets the last selected node.</summary>
    public TNode Last();
    <summary>Creates a new <see cref="T:Roslynator.SyntaxListSelection`1" /> based on the specified list and span.</summary>
    <returns>True if the specified span contains at least one node; otherwise, false.</returns>
    public static bool TryCreate(SyntaxList<TNode> list, TextSpan span, out SyntaxListSelection<TNode> selection);

    public struct Enumerator

      public TNode Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

  <summary>A set of extension methods for <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
  public static class SyntaxTreeExtensions

    <summary>Returns zero-based index of the end line of the specified span.</summary>
    public static int GetEndLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default);
    <summary>Returns zero-based index of the start line of the specified span.</summary>
    public static int GetStartLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default);
    <summary>Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan" /> spans over multiple lines.</summary>
    public static bool IsMultiLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default);
    <summary>Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan" /> does not span over multiple lines.</summary>
    public static bool IsSingleLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default);

  <summary>A set of extension methods for the workspace layer.</summary>
  public static class WorkspaceExtensions

    <summary>Creates a new document with a new node inserted after the specified node.</summary>
    public static Task<Document> InsertNodeAfterAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default);
    <summary>Creates a new document with a new node inserted before the specified node.</summary>
    public static Task<Document> InsertNodeBeforeAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default);
    <summary>Creates a new document with new nodes inserted after the specified node.</summary>
    public static Task<Document> InsertNodesAfterAsync(this Document document, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default);
    <summary>Creates a new document with new nodes inserted before the specified node.</summary>
    public static Task<Document> InsertNodesBeforeAsync(this Document document, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default);
    <summary>Creates a new document with the specified node removed.</summary>
    public static Task<Document> RemoveNodeAsync(this Document document, SyntaxNode node, SyntaxRemoveOptions options, CancellationToken cancellationToken = default);
    <summary>Creates a new document with the specified nodes removed.</summary>
    public static Task<Document> RemoveNodesAsync(this Document document, IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options, CancellationToken cancellationToken = default);
    <summary>Creates a new document with the specified old node replaced with a new node.</summary>
    public static Task<Document> ReplaceNodeAsync(this Document document, SyntaxNode oldNode, SyntaxNode newNode, CancellationToken cancellationToken = default);
    <summary>Creates a new document with the specified old node replaced with new nodes.</summary>
    public static Task<Document> ReplaceNodeAsync(this Document document, SyntaxNode oldNode, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default);
    <summary>Creates a new solution with the specified old node replaced with a new node.</summary>
    public static Task<Solution> ReplaceNodeAsync<TNode>(this Solution solution, TNode oldNode, TNode newNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode;
    <summary>Creates a new document with the specified old nodes replaced with new nodes.</summary>
    public static Task<Document> ReplaceNodesAsync<TNode>(this Document document, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode;
    <summary>Creates a new solution with the specified old nodes replaced with new nodes.</summary>
    public static Task<Solution> ReplaceNodesAsync<TNode>(this Solution solution, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNodes, CancellationToken cancellationToken = default) where TNode : SyntaxNode;
    <summary>Creates a new document with the specified old token replaced with a new token.</summary>
    public static Task<Document> ReplaceTokenAsync(this Document document, SyntaxToken oldToken, SyntaxToken newToken, CancellationToken cancellationToken = default);
    <summary>Creates a new document with the specified old token replaced with new tokens.</summary>
    public static Task<Document> ReplaceTokenAsync(this Document document, SyntaxToken oldToken, IEnumerable<SyntaxToken> newTokens, CancellationToken cancellationToken = default);
    <summary>Creates a new document with the specified old trivia replaced with a new trivia.</summary>
    public static Task<Document> ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia, CancellationToken cancellationToken = default);
    <summary>Creates a new document with the specified old trivia replaced with a new trivia.</summary>
    public static Task<Document> ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, IEnumerable<SyntaxTrivia> newTrivia, CancellationToken cancellationToken = default);
    <summary>Creates a new document updated with the specified text change.</summary>
    public static Task<Document> WithTextChangeAsync(this Document document, TextChange textChange, CancellationToken cancellationToken = default);
    <summary>Creates a new document updated with the specified text changes.</summary>
    public static Task<Document> WithTextChangesAsync(this Document document, TextChange[] textChanges, CancellationToken cancellationToken = default);
    <summary>Creates a new document updated with the specified text changes.</summary>
    public static Task<Document> WithTextChangesAsync(this Document document, IEnumerable<TextChange> textChanges, CancellationToken cancellationToken = default);

  <summary>Represents an extension method symbol.</summary>
  public readonly struct ExtensionMethodSymbolInfo : IEquatable<ExtensionMethodSymbolInfo>

    <summary>True if the symbol was reduced.</summary>
    public bool IsReduced { get; }
    <summary>The definition of extension method from which this symbol was reduced, or null, if the symbol was not reduced.</summary>
    public IMethodSymbol ReducedSymbol { get; }
    <summary>The reduced symbol or the symbol if the reduced symbol is null.</summary>
    public IMethodSymbol ReducedSymbolOrSymbol { get; }
    <summary>The extension method symbol.</summary>
    public IMethodSymbol Symbol { get; }

    public override bool Equals(object obj);
    public bool Equals(ExtensionMethodSymbolInfo other);
    public override int GetHashCode();

    public static bool operator ==(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2);
    public static bool operator !=(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2);

  <summary>Represents fully qualified metadata name of a symbol.</summary>
  public readonly struct MetadataName : IEquatable<MetadataName>

    <summary>Initializes a new instance of <see cref="T:Roslynator.MetadataName" />.</summary>
    public MetadataName(IEnumerable<string> containingNamespaces, string name);
    <summary>Initializes a new instance of <see cref="T:Roslynator.MetadataName" />.</summary>
    public MetadataName(ImmutableArray<string> containingNamespaces, string name);
    <summary>Initializes a new instance of <see cref="T:Roslynator.MetadataName" />.</summary>
    public MetadataName(IEnumerable<string> containingNamespaces, IEnumerable<string> containingTypes, string name);
    <summary>Initializes a new instance of <see cref="T:Roslynator.MetadataName" />.</summary>
    public MetadataName(ImmutableArray<string> containingNamespaces, ImmutableArray<string> containingTypes, string name);

    <summary>Gets metadata names of containing namespaces</summary>
    public ImmutableArray<string> ContainingNamespaces { get; }
    <summary>Get metadata names of containing types.</summary>
    public ImmutableArray<string> ContainingTypes { get; }
    <summary>Determines whether this struct was initialized with an actual names.</summary>
    public bool IsDefault { get; }
    <summary>Get metadata name.</summary>
    public string Name { get; }

    <summary>Indicates whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance.</param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Indicates whether this instance and a specified <see cref="T:Roslynator.MetadataName" /> are equal.</summary>
    public bool Equals(MetadataName other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Converts the string representation of a fully qualified metadata name to its <see cref="T:Roslynator.MetadataName" /> equivalent.</summary>
    <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <c>null</c>.</exception>
    <exception cref="T:System.ArgumentException"><paramref name="name" /> is empty or invalid.</exception>
    public static MetadataName Parse(string name);
    <summary>Returns the fully qualified metadata name.</summary>
    public override string ToString();
    <summary>
    Converts the string representation of a fully qualified metadata name to its <see cref="T:Roslynator.MetadataName" /> equivalent.
    A return value indicates whether the parsing succeeded.
    </summary>
    public static bool TryParse(string name, out MetadataName metadataName);

    public static bool operator ==(in MetadataName metadataName1, in MetadataName metadataName2);
    public static bool operator !=(in MetadataName metadataName1, in MetadataName metadataName2);

  <summary>Represents consecutive sequence of selected items in a collection.</summary>
  public interface ISelection<T> : IReadOnlyList<T>

    <summary>Gets an index of the first selected item.</summary>
    int FirstIndex { get; }
    <summary>Gets an index of the last selected item.</summary>
    int LastIndex { get; }

    <summary>Gets the first selected item.</summary>
    T First();
    <summary>Gets the last selected item.</summary>
    T Last();

  <summary>Specifies visibility of a symbol.</summary>
  public enum Visibility

    <summary>No visibility specified.</summary>
    NotApplicable = 0,
    <summary>Symbol is privately visible.</summary>
    Private = 1,
    <summary>Symbol is internally visible.</summary>
    Internal = 2,
    <summary>Symbol is publicly visible.</summary>
    Public = 3,

namespace Roslynator.CSharp

  <summary>A set of extension methods for a <see cref="T:Microsoft.CodeAnalysis.SemanticModel" />.</summary>
  public static class CSharpExtensions

    <summary>
    Determines a parameter symbol that matches to the specified argument.
    Returns null if no matching parameter is found.
    </summary>
    public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, ArgumentSyntax argument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default);
    <summary>
    Determines a parameter symbol that matches to the specified attribute argument.
    Returns null if not matching parameter is found.
    </summary>
    public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, AttributeArgumentSyntax attributeArgument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default);
    <summary>Returns what extension method symbol, if any, the specified expression syntax bound to.</summary>
    public static ExtensionMethodSymbolInfo GetExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    <summary>Returns method symbol, if any, the specified expression syntax bound to.</summary>
    public static IMethodSymbol GetMethodSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    <summary>Returns what extension method symbol, if any, the specified expression syntax bound to.</summary>
    public static ExtensionMethodSymbolInfo GetReducedExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    <summary>Returns what symbol, if any, the specified attribute syntax bound to.</summary>
    public static ISymbol GetSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default);
    <summary>Returns what symbol, if any, the specified constructor initializer syntax bound to.</summary>
    public static ISymbol GetSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default);
    <summary>Returns what symbol, if any, the specified cref syntax bound to.</summary>
    public static ISymbol GetSymbol(this SemanticModel semanticModel, CrefSyntax cref, CancellationToken cancellationToken = default);
    <summary>Returns what symbol, if any, the specified expression syntax bound to.</summary>
    public static ISymbol GetSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    <summary>Returns what symbol, if any, the specified ordering syntax bound to.</summary>
    public static ISymbol GetSymbol(this SemanticModel semanticModel, OrderingSyntax ordering, CancellationToken cancellationToken = default);
    <summary>Returns what symbol, if any, the specified select or group clause bound to.</summary>
    public static ISymbol GetSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default);
    <summary>Returns type information about an attribute syntax.</summary>
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default);
    <summary>Returns type information about a constructor initializer syntax.</summary>
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default);
    <summary>Returns type information about an expression syntax.</summary>
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    <summary>Returns type information about a select or group clause.</summary>
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default);
    <summary>Returns true if the specified node has a constant value.</summary>
    public static bool HasConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    <summary>Returns true if the specified expression represents default value of the specified type.</summary>
    public static bool IsDefaultValue(this SemanticModel semanticModel, ITypeSymbol typeSymbol, ExpressionSyntax expression, CancellationToken cancellationToken = default);

  <summary>A factory for syntax nodes, tokens and trivia. This class is built on top of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxFactory" /> members.</summary>
  public static class CSharpFactory

    public static AccessorListSyntax AccessorList(AccessorDeclarationSyntax accessor);
    public static AccessorListSyntax AccessorList(params AccessorDeclarationSyntax[] accessors);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, ExpressionSyntax expression);
    public static ArgumentListSyntax ArgumentList(ArgumentSyntax argument);
    public static ArgumentListSyntax ArgumentList(params ArgumentSyntax[] arguments);
    public static InitializerExpressionSyntax ArrayInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax ArrayInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentSyntax argument);
    public static AttributeArgumentSyntax AttributeArgument(NameColonSyntax nameColon, ExpressionSyntax expression);
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public static AttributeArgumentListSyntax AttributeArgumentList(AttributeArgumentSyntax attributeArgument);
    public static AttributeArgumentListSyntax AttributeArgumentList(params AttributeArgumentSyntax[] attributeArguments);
    public static AttributeListSyntax AttributeList(AttributeSyntax attribute);
    public static AttributeListSyntax AttributeList(params AttributeSyntax[] attributes);
    public static AccessorDeclarationSyntax AutoGetAccessorDeclaration(SyntaxTokenList modifiers = default);
    public static AccessorDeclarationSyntax AutoSetAccessorDeclaration(SyntaxTokenList modifiers = default);
    public static ConstructorInitializerSyntax BaseConstructorInitializer(ArgumentListSyntax argumentList = null);
    public static ConstructorInitializerSyntax BaseConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList);
    public static BaseListSyntax BaseList(BaseTypeSyntax type);
    public static BaseListSyntax BaseList(params BaseTypeSyntax[] types);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, BaseTypeSyntax baseType);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, params BaseTypeSyntax[] types);
    public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BlockSyntax Block(StatementSyntax statement);
    public static BlockSyntax Block(SyntaxToken openBrace, StatementSyntax statement, SyntaxToken closeBrace);
    public static LiteralExpressionSyntax BooleanLiteralExpression(bool value);
    public static BracketedArgumentListSyntax BracketedArgumentList(ArgumentSyntax argument);
    public static BracketedArgumentListSyntax BracketedArgumentList(params ArgumentSyntax[] arguments);
    public static BracketedParameterListSyntax BracketedParameterList(ParameterSyntax parameter);
    public static BracketedParameterListSyntax BracketedParameterList(params ParameterSyntax[] parameters);
    public static LiteralExpressionSyntax CharacterLiteralExpression(char value);
    public static CheckedExpressionSyntax CheckedExpression(ExpressionSyntax expression);
    public static CheckedExpressionSyntax CheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static ClassOrStructConstraintSyntax ClassConstraint();
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static InitializerExpressionSyntax CollectionInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax CollectionInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static CompilationUnitSyntax CompilationUnit(MemberDeclarationSyntax member);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<UsingDirectiveSyntax> usings, MemberDeclarationSyntax member);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members);
    public static InitializerExpressionSyntax ComplexElementInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax ComplexElementInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static LiteralExpressionSyntax DefaultLiteralExpression();
    public static SwitchSectionSyntax DefaultSwitchSection(StatementSyntax statement);
    public static SwitchSectionSyntax DefaultSwitchSection(SyntaxList<StatementSyntax> statements);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, string identifier, ParameterListSyntax parameterList);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList);
    public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static SyntaxTrivia EmptyWhitespace();
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, ExpressionSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, EqualsValueClauseSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, ExpressionSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, EqualsValueClauseSyntax value);
    public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, AccessorListSyntax accessorList);
    public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier);
    public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static LiteralExpressionSyntax FalseLiteralExpression();
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, ExpressionSyntax value = null);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null);
    public static GenericNameSyntax GenericName(string identifier, TypeSyntax typeArgument);
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeSyntax typeArgument);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static LiteralExpressionSyntax LiteralExpression(object value);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, ExpressionSyntax value = null);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static InvocationExpressionSyntax NameOfExpression(ExpressionSyntax expression);
    public static InvocationExpressionSyntax NameOfExpression(string identifier);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, MemberDeclarationSyntax member);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList<MemberDeclarationSyntax> members);
    public static SyntaxTrivia NewLine();
    public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static LiteralExpressionSyntax NullLiteralExpression();
    public static LiteralExpressionSyntax NumericLiteralExpression(int value);
    public static LiteralExpressionSyntax NumericLiteralExpression(uint value);
    public static LiteralExpressionSyntax NumericLiteralExpression(sbyte value);
    public static LiteralExpressionSyntax NumericLiteralExpression(decimal value);
    public static LiteralExpressionSyntax NumericLiteralExpression(double value);
    public static LiteralExpressionSyntax NumericLiteralExpression(float value);
    public static LiteralExpressionSyntax NumericLiteralExpression(long value);
    public static LiteralExpressionSyntax NumericLiteralExpression(ulong value);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList);
    public static InitializerExpressionSyntax ObjectInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax ObjectInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ParameterSyntax Parameter(TypeSyntax type, string identifier, ExpressionSyntax @default = null);
    public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax @default = null);
    public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default);
    public static ParameterListSyntax ParameterList(ParameterSyntax parameter);
    public static ParameterListSyntax ParameterList(params ParameterSyntax[] parameters);
    public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand);
    public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand);
    public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PredefinedTypeSyntax PredefinedBoolType();
    public static PredefinedTypeSyntax PredefinedByteType();
    public static PredefinedTypeSyntax PredefinedCharType();
    public static PredefinedTypeSyntax PredefinedDecimalType();
    public static PredefinedTypeSyntax PredefinedDoubleType();
    public static PredefinedTypeSyntax PredefinedFloatType();
    public static PredefinedTypeSyntax PredefinedIntType();
    public static PredefinedTypeSyntax PredefinedLongType();
    public static PredefinedTypeSyntax PredefinedObjectType();
    public static PredefinedTypeSyntax PredefinedSByteType();
    public static PredefinedTypeSyntax PredefinedShortType();
    public static PredefinedTypeSyntax PredefinedStringType();
    public static PredefinedTypeSyntax PredefinedUIntType();
    public static PredefinedTypeSyntax PredefinedULongType();
    public static PredefinedTypeSyntax PredefinedUShortType();
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ArrowExpressionClauseSyntax expressionBody);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList, ExpressionSyntax value = null);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentSyntax argument);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentListSyntax argumentList);
    public static LiteralExpressionSyntax StringLiteralExpression(string value);
    public static ClassOrStructConstraintSyntax StructConstraint();
    public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, StatementSyntax statement);
    public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, SyntaxList<StatementSyntax> statements);
    public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> switchLabels, StatementSyntax statement);
    public static ConstructorInitializerSyntax ThisConstructorInitializer(ArgumentListSyntax argumentList = null);
    public static ConstructorInitializerSyntax ThisConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList);
    <summary>Creates a list of modifiers from the specified accessibility.</summary>
    public static SyntaxTokenList TokenList(Accessibility accessibility);
    public static SyntaxTokenList TokenList(SyntaxKind kind);
    public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2);
    public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static LiteralExpressionSyntax TrueLiteralExpression();
    public static TryStatementSyntax TryStatement(BlockSyntax block, CatchClauseSyntax @catch, FinallyClauseSyntax @finally = null);
    public static TypeArgumentListSyntax TypeArgumentList(TypeSyntax argument);
    public static TypeArgumentListSyntax TypeArgumentList(params TypeSyntax[] arguments);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax identifierName, TypeParameterConstraintSyntax typeParameterConstraint);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name, TypeParameterConstraintSyntax typeParameterConstraint);
    public static TypeParameterListSyntax TypeParameterList(TypeParameterSyntax parameter);
    public static TypeParameterListSyntax TypeParameterList(params TypeParameterSyntax[] parameters);
    public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static CheckedExpressionSyntax UncheckedExpression(ExpressionSyntax expression);
    public static CheckedExpressionSyntax UncheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static UsingDirectiveSyntax UsingStaticDirective(NameSyntax name);
    public static UsingDirectiveSyntax UsingStaticDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameSyntax name, SyntaxToken semicolonToken);
    public static IdentifierNameSyntax VarType();
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, VariableDeclaratorSyntax variable);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, string identifier, ExpressionSyntax value = null);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null);
    public static VariableDeclaratorSyntax VariableDeclarator(string identifier, EqualsValueClauseSyntax initializer);
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static PredefinedTypeSyntax VoidType();
    public static YieldStatementSyntax YieldBreakStatement();
    public static YieldStatementSyntax YieldReturnStatement(ExpressionSyntax expression);

  public static class CSharpFacts

    <summary>Returns true if a syntax of the specified kind can be an embedded statement.</summary>
    public static bool CanBeEmbeddedStatement(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind can have an embedded statement.</summary>
    public static bool CanHaveEmbeddedStatement(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind can have expression body.</summary>
    public static bool CanHaveExpressionBody(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind can have members.</summary>
    public static bool CanHaveMembers(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind can have modifiers.</summary>
    public static bool CanHaveModifiers(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind can have statements. It can be either <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" /> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax" />.</summary>
    public static bool CanHaveStatements(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is an anonymous method or lambda expression.</summary>
    public static bool IsAnonymousFunctionExpression(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is a boolean expression.</summary>
    public static bool IsBooleanExpression(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is true or false literal expression.</summary>
    public static bool IsBooleanLiteralExpression(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is comment trivia.</summary>
    public static bool IsCommentTrivia(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is a compound assignment expression.</summary>
    public static bool IsCompoundAssignmentExpression(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is a constraint.</summary>
    public static bool IsConstraint(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind if local function or anonymous function.</summary>
    public static bool IsFunction(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is #if, #else, #elif or #endif directive.</summary>
    public static bool IsIfElseDirective(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is pre/post increment/decrement expression.</summary>
    public static bool IsIncrementOrDecrementExpression(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is a for, foreach, while or do statement.</summary>
    public static bool IsIterationStatement(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is a jump statement.</summary>
    public static bool IsJumpStatement(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is a lambda expression.</summary>
    public static bool IsLambdaExpression(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is a literal expression.</summary>
    public static bool IsLiteralExpression(SyntaxKind kind);
    <summary>Returns true if a syntax of the specified kind is a predefined type.</summary>
    public static bool IsPredefinedType(SpecialType specialType);
    <summary>Returns true if a syntax of the specified kind is a simple type.</summary>
    public static bool IsSimpleType(SpecialType specialType);
    <summary>Returns true if a syntax of the specified kind is a switch label.</summary>
    public static bool IsSwitchLabel(SyntaxKind kind);
    <summary>Returns true if an expression of the specified type can be used in a prefix or postfix unary operator.</summary>
    public static bool SupportsPrefixOrPostfixUnaryOperator(SpecialType specialType);

  <summary>A set of extension methods for enumerations.</summary>
  public static class EnumExtensions

    <summary>Returns true if the kind is one of the specified kinds.</summary>
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2);
    <summary>Returns true if the kind is one of the specified kinds.</summary>
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    <summary>Returns true if the kind is one of the specified kinds.</summary>
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    <summary>Returns true if the kind is one of the specified kinds.</summary>
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    <summary>Returns true if the kind is one of the specified kinds.</summary>
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);

  <summary>Represents selected member declarations in a <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
  public sealed class MemberDeclarationListSelection : SyntaxListSelection<MemberDeclarationSyntax>

    <summary>Gets a node that contains selected members.</summary>
    public SyntaxNode Parent { get; }

    <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified compilation unit and span.</summary>
    public static MemberDeclarationListSelection Create(CompilationUnitSyntax compilationUnit, TextSpan span);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified namespace declaration and span.</summary>
    public static MemberDeclarationListSelection Create(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified type declaration and span.</summary>
    public static MemberDeclarationListSelection Create(TypeDeclarationSyntax typeDeclaration, TextSpan span);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified namespace declaration and span.</summary>
    <returns>True if the specified span contains at least one member; otherwise, false.</returns>
    public static bool TryCreate(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified type declaration and span.</summary>
    <returns>True if the specified span contains at least one member; otherwise, false.</returns>
    public static bool TryCreate(TypeDeclarationSyntax typeDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers);

  <summary>A set of static methods that allows manipulation with modifiers.</summary>
  public static class ModifierList

    <summary>Returns an index a token with the specified kind should be inserted at.</summary>
    public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxKind kind, IComparer<SyntaxKind> comparer = null);
    <summary>Returns an index the specified token should be inserted at.</summary>
    public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxToken token, IComparer<SyntaxToken> comparer = null);
    <summary>Creates a new list of modifiers with the modifier of the specified kind inserted.</summary>
    public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxKind kind, IComparer<SyntaxKind> comparer = null);
    <summary>Creates a new list of modifiers with a specified modifier inserted.</summary>
    public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null);
    <summary>Creates a new node with a modifier of the specified kind inserted.</summary>
    public static TNode Insert<TNode>(TNode node, SyntaxKind kind, IComparer<SyntaxKind> comparer = null) where TNode : SyntaxNode;
    <summary>Creates a new node with the specified modifier inserted.</summary>
    public static TNode Insert<TNode>(TNode node, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null) where TNode : SyntaxNode;
    <summary>Creates a new node with a modifier of the specified kind removed.</summary>
    public static TNode Remove<TNode>(TNode node, SyntaxKind kind) where TNode : SyntaxNode;
    <summary>Creates a new node with the specified modifier removed.</summary>
    public static TNode Remove<TNode>(TNode node, SyntaxToken modifier) where TNode : SyntaxNode;
    <summary>Creates a new node with all modifiers removed.</summary>
    public static TNode RemoveAll<TNode>(TNode node) where TNode : SyntaxNode;
    <summary>Creates a new node with modifiers that matches the predicate removed.</summary>
    public static TNode RemoveAll<TNode>(TNode node, Func<SyntaxToken, bool> predicate) where TNode : SyntaxNode;
    <summary>Creates a new node with a modifier at the specified index removed.</summary>
    public static TNode RemoveAt<TNode>(TNode node, int index) where TNode : SyntaxNode;

  <summary>Represents a list of modifiers.</summary>
  public abstract class ModifierList<TNode> where TNode : SyntaxNode

    <summary>Gets an instance of the <see cref="T:Roslynator.CSharp.ModifierList`1" /> for a syntax specified by the generic argument.</summary>
    public static ModifierList<TNode> Instance { get; }

    <summary>Creates a new node with a modifier of the specified kind inserted.</summary>
    public TNode Insert(TNode node, SyntaxKind kind, IComparer<SyntaxKind> comparer = null);
    <summary>Creates a new node with the specified modifier inserted.</summary>
    public TNode Insert(TNode node, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null);
    <summary>Creates a new node with a modifier of the specified kind removed.</summary>
    public TNode Remove(TNode node, SyntaxKind kind);
    <summary>Creates a new node with the specified modifier removed.</summary>
    public TNode Remove(TNode node, SyntaxToken modifier);
    <summary>Creates a new node with all modifiers removed.</summary>
    public TNode RemoveAll(TNode node);
    <summary>Creates a new node with modifiers that matches the predicate removed.</summary>
    public TNode RemoveAll(TNode node, Func<SyntaxToken, bool> predicate);
    <summary>Creates a new node with a modifier at the specified index removed.</summary>
    public TNode RemoveAt(TNode node, int index);

  <summary>Serves as a factory for a modifier list.</summary>
  public static class Modifiers

    <summary>Creates a list of modifiers that contains "const" modifier.</summary>
    public static SyntaxTokenList Const();
    <summary>Creates a list of modifiers that contains "internal" modifier.</summary>
    public static SyntaxTokenList Internal();
    <summary>Creates a list of modifiers that contains "internal abstract" modifiers.</summary>
    public static SyntaxTokenList Internal_Abstract();
    <summary>Creates a list of modifiers that contains "internal const" modifiers.</summary>
    public static SyntaxTokenList Internal_Const();
    <summary>Creates a list of modifiers that contains "internal override" modifiers.</summary>
    public static SyntaxTokenList Internal_Override();
    <summary>Creates a list of modifiers that contains "internal partial" modifiers.</summary>
    public static SyntaxTokenList Internal_Partial();
    <summary>Creates a list of modifiers that contains "internal readonly" modifiers.</summary>
    public static SyntaxTokenList Internal_ReadOnly();
    <summary>Creates a list of modifiers that contains "internal static" modifiers.</summary>
    public static SyntaxTokenList Internal_Static();
    <summary>Creates a list of modifiers that contains "internal static partial" modifiers.</summary>
    public static SyntaxTokenList Internal_Static_Partial();
    <summary>Creates a list of modifiers that contains "internal static readonly" modifiers.</summary>
    public static SyntaxTokenList Internal_Static_ReadOnly();
    <summary>Creates a list of modifiers that contains "internal virtual" modifiers.</summary>
    public static SyntaxTokenList Internal_Virtual();
    <summary>Creates a list of modifiers that contains "partial" modifier.</summary>
    public static SyntaxTokenList Partial();
    <summary>Creates a list of modifiers that contains "private" modifier.</summary>
    public static SyntaxTokenList Private();
    <summary>Creates a list of modifiers that contains "private const" modifiers.</summary>
    public static SyntaxTokenList Private_Const();
    <summary>Creates a list of modifiers that contains "private partial" modifiers.</summary>
    public static SyntaxTokenList Private_Partial();
    <summary>Creates a list of modifiers that contains "private protected" modifiers.</summary>
    public static SyntaxTokenList Private_Protected();
    <summary>Creates a list of modifiers that contains "private readonly" modifiers.</summary>
    public static SyntaxTokenList Private_ReadOnly();
    <summary>Creates a list of modifiers that contains "private static" modifiers.</summary>
    public static SyntaxTokenList Private_Static();
    <summary>Creates a list of modifiers that contains "private static partial" modifiers.</summary>
    public static SyntaxTokenList Private_Static_Partial();
    <summary>Creates a list of modifiers that contains "private static readonly" modifiers.</summary>
    public static SyntaxTokenList Private_Static_ReadOnly();
    <summary>Creates a list of modifiers that contains "protected" modifier.</summary>
    public static SyntaxTokenList Protected();
    <summary>Creates a list of modifiers that contains "protected abstract" modifiers.</summary>
    public static SyntaxTokenList Protected_Abstract();
    <summary>Creates a list of modifiers that contains "protected const" modifiers.</summary>
    public static SyntaxTokenList Protected_Const();
    <summary>Return modifier list that contains "protected internal" modifiers.</summary>
    public static SyntaxTokenList Protected_Internal();
    <summary>Creates a list of modifiers that contains "protected override" modifiers.</summary>
    public static SyntaxTokenList Protected_Override();
    <summary>Creates a list of modifiers that contains "protected readonly" modifiers.</summary>
    public static SyntaxTokenList Protected_ReadOnly();
    <summary>Creates a list of modifiers that contains "protected static" modifiers.</summary>
    public static SyntaxTokenList Protected_Static();
    <summary>Creates a list of modifiers that contains "protected static readonly" modifiers.</summary>
    public static SyntaxTokenList Protected_Static_ReadOnly();
    <summary>Creates a list of modifiers that contains "protected virtual" modifiers.</summary>
    public static SyntaxTokenList Protected_Virtual();
    <summary>Creates a list of modifiers that contains "public" modifier.</summary>
    public static SyntaxTokenList Public();
    <summary>Creates a list of modifiers that contains "public abstract" modifiers.</summary>
    public static SyntaxTokenList Public_Abstract();
    <summary>Creates a list of modifiers that contains "public const" modifiers.</summary>
    public static SyntaxTokenList Public_Const();
    <summary>Creates a list of modifiers that contains "public override" modifiers.</summary>
    public static SyntaxTokenList Public_Override();
    <summary>Creates a list of modifiers that contains "public partial" modifiers.</summary>
    public static SyntaxTokenList Public_Partial();
    <summary>Creates a list of modifiers that contains "public readonly" modifiers.</summary>
    public static SyntaxTokenList Public_ReadOnly();
    <summary>Creates a list of modifiers that contains "public static" modifiers.</summary>
    public static SyntaxTokenList Public_Static();
    <summary>Creates a list of modifiers that contains "public static partial" modifiers.</summary>
    public static SyntaxTokenList Public_Static_Partial();
    <summary>Creates a list of modifiers that contains "public static readonly" modifiers.</summary>
    public static SyntaxTokenList Public_Static_ReadOnly();
    <summary>Creates a list of modifiers that contains "public virtual" modifiers.</summary>
    public static SyntaxTokenList Public_Virtual();
    <summary>Creates a list of modifiers that contains "readonly" modifier.</summary>
    public static SyntaxTokenList ReadOnly();
    <summary>Creates a list of modifiers that contains "ref readonly" modifiers.</summary>
    public static SyntaxTokenList Ref_ReadOnly();
    <summary>Creates a list of modifiers that contains "static" modifier.</summary>
    public static SyntaxTokenList Static();
    <summary>Creates a list of modifiers that contains "static readonly" modifiers.</summary>
    public static SyntaxTokenList Static_ReadOnly();
    <summary>Creates a list of modifiers that contains "virtual" modifier.</summary>
    public static SyntaxTokenList Virtual();

  <summary>Represents selected statements in a <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
  public sealed class StatementListSelection : SyntaxListSelection<StatementSyntax>

    <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified block and span.</summary>
    public static StatementListSelection Create(BlockSyntax block, TextSpan span);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified switch section and span.</summary>
    public static StatementListSelection Create(SwitchSectionSyntax switchSection, TextSpan span);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> and span.</summary>
    public static StatementListSelection Create(in StatementListInfo statementsInfo, TextSpan span);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified block and span.</summary>
    <returns>True if the specified span contains at least one statement; otherwise, false.</returns>
    public static bool TryCreate(BlockSyntax block, TextSpan span, out StatementListSelection selectedStatements);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified switch section and span.</summary>
    <returns>True if the specified span contains at least one statement; otherwise, false.</returns>
    public static bool TryCreate(SwitchSectionSyntax switchSection, TextSpan span, out StatementListSelection selectedStatements);

  <summary>A set of static methods for <see cref="T:Microsoft.CodeAnalysis.ISymbol" /> and derived types.</summary>
  public static class SymbolExtensions

    <summary>Returns true if the specified type can be used to declare constant value.</summary>
    public static bool SupportsConstantValue(this ITypeSymbol typeSymbol);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified namespace or type symbol</summary>
    public static TypeSyntax ToMinimalTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified namespace symbol.</summary>
    public static TypeSyntax ToMinimalTypeSyntax(this INamespaceSymbol namespaceSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified type symbol.</summary>
    public static TypeSyntax ToMinimalTypeSyntax(this ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified namespace or type symbol.</summary>
    public static TypeSyntax ToTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SymbolDisplayFormat format = null);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified namespace symbol.</summary>
    public static TypeSyntax ToTypeSyntax(this INamespaceSymbol namespaceSymbol, SymbolDisplayFormat format = null);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified type symbol.</summary>
    public static TypeSyntax ToTypeSyntax(this ITypeSymbol typeSymbol, SymbolDisplayFormat format = null);

  <summary>A set of static methods that are related to C# accessibility.</summary>
  public static class SyntaxAccessibility

    <summary>Returns an accessibility of the specified declaration.</summary>
    public static Accessibility GetAccessibility(SyntaxNode declaration);
    <summary>Returns a default accessibility of the specified declaration.</summary>
    public static Accessibility GetDefaultAccessibility(SyntaxNode declaration);
    <summary>Returns a default explicit accessibility of the specified declaration.</summary>
    public static Accessibility GetDefaultExplicitAccessibility(SyntaxNode declaration);
    <summary>Returns an explicit accessibility of the specified declaration.</summary>
    public static Accessibility GetExplicitAccessibility(SyntaxNode declaration);
    <summary>Returns an explicit accessibility of the specified modifiers.</summary>
    public static Accessibility GetExplicitAccessibility(SyntaxTokenList modifiers);
    <summary>Return true if the specified declaration is publicly visible.</summary>
    public static bool IsPubliclyVisible(MemberDeclarationSyntax declaration);
    <summary>Returns true if the node can have specified accessibility.</summary>
    <param name="ignoreOverride">Ignore "override" modifier.</param>
    public static bool IsValidAccessibility(SyntaxNode node, Accessibility accessibility, bool ignoreOverride = false);
    <summary>Creates a new node with the specified explicit accessibility updated.</summary>
    public static TNode WithExplicitAccessibility<TNode>(TNode node, Accessibility newAccessibility, IComparer<SyntaxKind> comparer = null) where TNode : SyntaxNode;
    <summary>Creates a new node with the explicit accessibility removed.</summary>
    public static TNode WithoutExplicitAccessibility<TNode>(TNode node) where TNode : SyntaxNode;

  <summary>A set of extension methods for syntax (types derived from <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode" />).</summary>
  public static class SyntaxExtensions

    <summary>Creates a new list with the specified node added or inserted.</summary>
    <param name="ignoreLocalFunctions">Insert statement before local function statements at the end of the list.</param>
    public static SyntaxList<StatementSyntax> Add(this SyntaxList<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions);
    <summary>Creates a new class declaration with the specified attribute lists added.</summary>
    <param name="keepDocumentationCommentOnTop">If the declaration has no attribute lists and has a documentation comment the specified attribute lists will be inserted after the documentation comment.</param>
    [Obsolete("This method is obsolete.")]
    public static ClassDeclarationSyntax AddAttributeLists(this ClassDeclarationSyntax classDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists);
    <summary>Creates a new interface declaration with the specified attribute lists added.</summary>
    <param name="keepDocumentationCommentOnTop">If the declaration has no attribute lists and has a documentation comment the specified attribute lists will be inserted after the documentation comment.</param>
    [Obsolete("This method is obsolete.")]
    public static InterfaceDeclarationSyntax AddAttributeLists(this InterfaceDeclarationSyntax interfaceDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists);
    <summary>Creates a new struct declaration with the specified attribute lists added.</summary>
    <param name="keepDocumentationCommentOnTop">If the declaration has no attribute lists and has a documentation comment the specified attribute lists will be inserted after the documentation comment.</param>
    [Obsolete("This method is obsolete.")]
    public static StructDeclarationSyntax AddAttributeLists(this StructDeclarationSyntax structDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax" /> with the specified using directives added.</summary>
    public static CompilationUnitSyntax AddUsings(this CompilationUnitSyntax compilationUnit, bool keepSingleLineCommentsOnTop, params UsingDirectiveSyntax[] usings);
    <summary>Returns <see cref="T:Roslynator.CSharp.IfStatementCascade" /> that enables to enumerate if-else cascade.</summary>
    public static IfStatementCascade AsCascade(this IfStatementSyntax ifStatement);
    <summary>Returns <see cref="T:Roslynator.CSharp.ExpressionChain" /> that enables to enumerate expressions of a binary expression.</summary>
    public static ExpressionChain AsChain(this BinaryExpressionSyntax binaryExpression, TextSpan? span = null);
    <summary>Returns accessor body or an expression body if the body is null.</summary>
    public static CSharpSyntaxNode BodyOrExpressionBody(this AccessorDeclarationSyntax accessorDeclaration);
    <summary>Returns constructor body or an expression body if the body is null.</summary>
    public static CSharpSyntaxNode BodyOrExpressionBody(this ConstructorDeclarationSyntax constructorDeclaration);
    <summary>Returns conversion operator body or an expression body if the body is null.</summary>
    public static CSharpSyntaxNode BodyOrExpressionBody(this ConversionOperatorDeclarationSyntax conversionOperatorDeclaration);
    <summary>Returns destructor body or an expression body if the body is null.</summary>
    public static CSharpSyntaxNode BodyOrExpressionBody(this DestructorDeclarationSyntax destructorDeclaration);
    <summary>Returns local function body or an expression body if the body is null.</summary>
    public static CSharpSyntaxNode BodyOrExpressionBody(this LocalFunctionStatementSyntax localFunctionStatement);
    <summary>Returns method body or an expression body if the body is null.</summary>
    public static CSharpSyntaxNode BodyOrExpressionBody(this MethodDeclarationSyntax methodDeclaration);
    <summary>Returns operator body or an expression body if the body is null.</summary>
    public static CSharpSyntaxNode BodyOrExpressionBody(this OperatorDeclarationSyntax operatorDeclaration);
    <summary>The absolute span of the braces, not including its leading and trailing trivia.</summary>
    public static TextSpan BracesSpan(this ClassDeclarationSyntax classDeclaration);
    <summary>The absolute span of the braces, not including its leading and trailing trivia.</summary>
    public static TextSpan BracesSpan(this EnumDeclarationSyntax enumDeclaration);
    <summary>The absolute span of the braces, not including it leading and trailing trivia.</summary>
    public static TextSpan BracesSpan(this InterfaceDeclarationSyntax interfaceDeclaration);
    <summary>The absolute span of the braces, not including leading and trailing trivia.</summary>
    public static TextSpan BracesSpan(this NamespaceDeclarationSyntax namespaceDeclaration);
    <summary>The absolute span of the braces, not including its leading and trailing trivia.</summary>
    public static TextSpan BracesSpan(this StructDeclarationSyntax structDeclaration);
    <summary>Returns true if a token of the specified kind is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
    public static bool Contains(this SyntaxTokenList tokenList, SyntaxKind kind);
    <summary>Returns true if a trivia of the specified kind is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />.</summary>
    public static bool Contains(this SyntaxTriviaList triviaList, SyntaxKind kind);
    <summary>Searches for a node of the specified kind and returns the zero-based index of the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
    public static bool Contains<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    <summary>Returns true if a node of the specified kind is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
    public static bool Contains<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    <summary>Returns true if a token of the specified kinds is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
    public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2);
    <summary>Returns true if a token of the specified kinds is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
    public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    <summary>Returns true if a token of the specified kinds is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
    public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    <summary>Returns true if a token of the specified kinds is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
    public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    <summary>Returns true if the specified switch section contains default switch label.</summary>
    public static bool ContainsDefaultLabel(this SwitchSectionSyntax switchSection);
    <summary>Returns true if the specified local function contains yield statement. Nested local functions are excluded.</summary>
    public static bool ContainsYield(this LocalFunctionStatementSyntax localFunctionStatement);
    <summary>Returns true if the specified method contains yield statement. Nested local functions are excluded.</summary>
    public static bool ContainsYield(this MethodDeclarationSyntax methodDeclaration);
    <summary>Returns using statement's declaration or an expression if the declaration is null.</summary>
    public static CSharpSyntaxNode DeclarationOrExpression(this UsingStatementSyntax usingStatement);
    <summary>Returns a section that contains default label, or null if the specified swtich statement does not contains section with default label.</summary>
    public static SwitchSectionSyntax DefaultSection(this SwitchStatementSyntax switchStatement);
    <summary>Gets a list of xml elements with the specified local name.</summary>
    public static IEnumerable<XmlElementSyntax> Elements(this DocumentationCommentTriviaSyntax documentationComment, string localName);
    <summary>Searches for a token of the specified kind and returns the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
    public static SyntaxToken Find(this SyntaxTokenList tokenList, SyntaxKind kind);
    <summary>Searches for a trivia of the specified kind and returns the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
    public static SyntaxTrivia Find(this SyntaxTriviaList triviaList, SyntaxKind kind);
    <summary>Searches for a node of the specified kind and returns the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
    public static TNode Find<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    <summary>Searches for a node of the specified kind and returns the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
    public static TNode Find<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    <summary>Gets the first ancestor of the specified kind.</summary>
    public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true);
    <summary>Gets the first ancestor that matches the predicate.</summary>
    public static SyntaxNode FirstAncestor(this SyntaxNode node, Func<SyntaxNode, bool> predicate, bool ascendOutOfTrivia = true);
    <summary>Gets the first ancestor of the specified kinds.</summary>
    public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true);
    <summary>Gets the first ancestor of the specified kinds.</summary>
    public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true);
    <summary>Gets the first ancestor of the specified kind.</summary>
    public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true);
    <summary>Gets the first ancestor that matches the predicate.</summary>
    public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, Func<SyntaxNode, bool> predicate, bool ascendOutOfTrivia = true);
    <summary>Gets the first ancestor of the specified kinds.</summary>
    public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true);
    <summary>Gets the first ancestor of the specified kinds.</summary>
    public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true);
    <summary>Returns <see cref="T:Roslynator.CSharp.IfStatementCascadeInfo" /> that summarizes information about if-else cascade.</summary>
    public static IfStatementCascadeInfo GetCascadeInfo(this IfStatementSyntax ifStatement);
    <summary>Returns documentation comment syntax that is part of the specified declaration.</summary>
    public static DocumentationCommentTriviaSyntax GetDocumentationComment(this MemberDeclarationSyntax member);
    <summary>Returns documentation comment that is part of the specified declaration.</summary>
    public static SyntaxTrivia GetDocumentationCommentTrivia(this MemberDeclarationSyntax member);
    <summary>Returns endregion directive that is related to the specified region directive. Returns null if no matching endregion directive is found.</summary>
    public static EndRegionDirectiveTriviaSyntax GetEndRegionDirective(this RegionDirectiveTriviaSyntax regionDirective);
    <summary>Gets the first directive of the tree rooted by this node.</summary>
    public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, TextSpan span, Func<DirectiveTriviaSyntax, bool> predicate = null);
    <summary>Returns the next related directive.</summary>
    public static DirectiveTriviaSyntax GetNextRelatedDirective(this DirectiveTriviaSyntax directiveTrivia);
    <summary>Gets preprocessing message for the specified endregion directive if such message exists.</summary>
    public static SyntaxTrivia GetPreprocessingMessageTrivia(this EndRegionDirectiveTriviaSyntax endRegionDirective);
    <summary>Gets preprocessing message for the specified region directive if such message exists.</summary>
    public static SyntaxTrivia GetPreprocessingMessageTrivia(this RegionDirectiveTriviaSyntax regionDirective);
    <summary>Returns region directive that is related to the specified endregion directive. Returns null if no matching region directive is found.</summary>
    public static RegionDirectiveTriviaSyntax GetRegionDirective(this EndRegionDirectiveTriviaSyntax endRegionDirective);
    <summary>Returns single-line documentation comment syntax that is part of the specified declaration.</summary>
    public static DocumentationCommentTriviaSyntax GetSingleLineDocumentationComment(this MemberDeclarationSyntax member);
    <summary>Returns single-line documentation comment that is part of the specified declaration.</summary>
    public static SyntaxTrivia GetSingleLineDocumentationCommentTrivia(this MemberDeclarationSyntax member);
    <summary>Returns topmost if statement of the if-else cascade the specified else clause is part of.</summary>
    public static IfStatementSyntax GetTopmostIf(this ElseClauseSyntax elseClause);
    <summary>Returns topmost if statement of the if-else cascade the specified if statement is part of.</summary>
    public static IfStatementSyntax GetTopmostIf(this IfStatementSyntax ifStatement);
    <summary>Returns a get accessor contained in the specified list.</summary>
    public static AccessorDeclarationSyntax Getter(this AccessorListSyntax accessorList);
    <summary>Returns a get accessor that is contained in the specified indexer declaration.</summary>
    public static AccessorDeclarationSyntax Getter(this IndexerDeclarationSyntax indexerDeclaration);
    <summary>Returns property get accessor, if any.</summary>
    public static AccessorDeclarationSyntax Getter(this PropertyDeclarationSyntax propertyDeclaration);
    <summary>Returns true if the specified declaration has a documentation comment.</summary>
    public static bool HasDocumentationComment(this MemberDeclarationSyntax member);
    <summary>Returns true if the specified declaration has a single-line documentation comment.</summary>
    public static bool HasSingleLineDocumentationComment(this MemberDeclarationSyntax member);
    <summary>Returns true is the specified accessor is auto-implemented accessor.</summary>
    public static bool IsAutoImplemented(this AccessorDeclarationSyntax accessorDeclaration);
    <summary>Returns true if a node is a descendant of a node with the specified kind.</summary>
    public static bool IsDescendantOf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true);
    <summary>Returns true if the specified statement is an embedded statement.</summary>
    <param name="canBeBlock">Block can be considered as embedded statement</param>
    <param name="canBeIfInsideElse">If statement that is a child of an else statement can be considered as an embedded statement.</param>
    <param name="canBeUsingInsideUsing">Using statement that is a child of an using statement can be considered as en embedded statement.</param>
    public static bool IsEmbedded(this StatementSyntax statement, bool canBeBlock = false, bool canBeIfInsideElse = true, bool canBeUsingInsideUsing = true);
    <summary>Returns true if the list of either empty or contains only whitespace.</summary>
    public static bool IsEmptyOrWhitespace(this SyntaxTriviaList triviaList);
    <summary>Returns true if the trivia is <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" />.</summary>
    public static bool IsEndOfLineTrivia(this SyntaxTrivia trivia);
    <summary>Returns true if the specified literal expression is a hexadecimal numeric literal expression.</summary>
    public static bool IsHexNumericLiteral(this LiteralExpressionSyntax literalExpression);
    <summary>Returns true if a node's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2);
    <summary>Returns true if a trivia's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2);
    <summary>Returns true if a node's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    <summary>Returns true if a node's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    <summary>Returns true if a node's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    <summary>Returns true if a node's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    <summary>Returns true if a token's kind is one of the specified kinds.</summary>
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    <summary>Returns true if the specified statement is a last statement in the list.</summary>
    <param name="ignoreLocalFunctions">Ignore local function statements at the end of the list.</param>
    public static bool IsLast(this SyntaxList<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions);
    <summary>Returns true if the specified parameter has "params" modifier.</summary>
    public static bool IsParams(this ParameterSyntax parameter);
    <summary>Returns true if a node parent's kind is the specified kind.</summary>
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind);
    <summary>Returns true if a token parent's kind is the specified kind.</summary>
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind);
    <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2);
    <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    <summary>
    Returns true if the specified if statement is a simple if statement.
    Simple if statement is defined as follows: it is not a child of an else clause and it has no else clause.
    </summary>
    public static bool IsSimpleIf(this IfStatementSyntax ifStatement);
    <summary>Returns true if the specified if statement is not a child of an else clause.</summary>
    public static bool IsTopmostIf(this IfStatementSyntax ifStatement);
    <summary>Returns true if the specified interpolated string is a verbatim.</summary>
    public static bool IsVerbatim(this InterpolatedStringExpressionSyntax interpolatedString);
    <summary>Returns true if the type is <see cref="T:System.Void" />.</summary>
    public static bool IsVoid(this TypeSyntax type);
    <summary>Returns true if the trivia is either <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> or <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" />.</summary>
    public static bool IsWhitespaceOrEndOfLineTrivia(this SyntaxTrivia trivia);
    <summary>Returns true if the trivia is <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" />.</summary>
    public static bool IsWhitespaceTrivia(this SyntaxTrivia trivia);
    <summary>Returns true if the specified statement is a yield break statement.</summary>
    public static bool IsYieldBreak(this YieldStatementSyntax yieldStatement);
    <summary>Returns true if the specified statement is a yield return statement.</summary>
    public static bool IsYieldReturn(this YieldStatementSyntax yieldStatement);
    <summary>Searches for a trivia of the specified kind and returns the zero-based index of the last occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />.</summary>
    public static int LastIndexOf(this SyntaxTriviaList triviaList, SyntaxKind kind);
    <summary>Searches for a node of the specified kind and returns the zero-based index of the last occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
    public static int LastIndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    <summary>Searches for a node of the specified kind and returns the zero-based index of the last occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
    public static int LastIndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    <summary>
    Gets the next statement of the specified statement.
    If the specified statement is not contained in the list, or if there is no next statement, then this method returns null.
    </summary>
    public static StatementSyntax NextStatement(this StatementSyntax statement);
    <summary>The absolute span of the parentheses, not including its leading and trailing trivia.</summary>
    public static TextSpan ParenthesesSpan(this CastExpressionSyntax castExpression);
    <summary>The absolute span of the parentheses, not including its leading and trailing trivia.</summary>
    public static TextSpan ParenthesesSpan(this CommonForEachStatementSyntax forEachStatement);
    <summary>Absolute span of the parentheses, not including the leading and trailing trivia.</summary>
    public static TextSpan ParenthesesSpan(this ForStatementSyntax forStatement);
    <summary>
    Gets the previous statement of the specified statement.
    If the specified statement is not contained in the list, or if there is no previous statement, then this method returns null.
    </summary>
    public static StatementSyntax PreviousStatement(this StatementSyntax statement);
    <summary>Creates a new list with tokens in the specified range removed.</summary>
    <param name="index">An index of the first element to remove.</param>
    <param name="count">A number of elements to remove.</param>
    public static SyntaxTokenList RemoveRange(this SyntaxTokenList list, int index, int count);
    <summary>Creates a new list with trivia in the specified range removed.</summary>
    <param name="index">An index of the first element to remove.</param>
    <param name="count">A number of elements to remove.</param>
    public static SyntaxTriviaList RemoveRange(this SyntaxTriviaList list, int index, int count);
    <summary>Creates a new list with elements in the specified range removed.</summary>
    <param name="index">An index of the first element to remove.</param>
    <param name="count">A number of elements to remove.</param>
    public static SeparatedSyntaxList<TNode> RemoveRange<TNode>(this SeparatedSyntaxList<TNode> list, int index, int count) where TNode : SyntaxNode;
    <summary>Creates a new list with elements in the specified range removed.</summary>
    <param name="index">An index of the first element to remove.</param>
    <param name="count">A number of elements to remove.</param>
    public static SyntaxList<TNode> RemoveRange<TNode>(this SyntaxList<TNode> list, int index, int count) where TNode : SyntaxNode;
    <summary>Creates a new node with the trivia removed.</summary>
    public static TNode RemoveTrivia<TNode>(this TNode node, TextSpan? span = null) where TNode : SyntaxNode;
    <summary>Creates a new node with the whitespace removed.</summary>
    public static TNode RemoveWhitespace<TNode>(this TNode node, TextSpan? span = null) where TNode : SyntaxNode;
    <summary>Creates a new list with the tokens in the specified range replaced with new tokens.</summary>
    public static SyntaxTokenList ReplaceRange(this SyntaxTokenList list, int index, int count, IEnumerable<SyntaxToken> newTokens);
    <summary>Creates a new list with the trivia in the specified range replaced with new trivia.</summary>
    public static SyntaxTriviaList ReplaceRange(this SyntaxTriviaList list, int index, int count, IEnumerable<SyntaxTrivia> newTrivia);
    <summary>Creates a new list with the elements in the specified range replaced with new nodes.</summary>
    public static SeparatedSyntaxList<TNode> ReplaceRange<TNode>(this SeparatedSyntaxList<TNode> list, int index, int count, IEnumerable<TNode> newNodes) where TNode : SyntaxNode;
    <summary>Creates a new list with the elements in the specified range replaced with new nodes.</summary>
    public static SyntaxList<TNode> ReplaceRange<TNode>(this SyntaxList<TNode> list, int index, int count, IEnumerable<TNode> newNodes) where TNode : SyntaxNode;
    <summary>Creates a new node with the whitespace replaced.</summary>
    public static TNode ReplaceWhitespace<TNode>(this TNode node, SyntaxTrivia replacement, TextSpan? span = null) where TNode : SyntaxNode;
    <summary>Returns true the specified delegate return type is <see cref="T:System.Void" />.</summary>
    public static bool ReturnsVoid(this DelegateDeclarationSyntax delegateDeclaration);
    <summary>Returns true if the specified local function' return type is <see cref="T:System.Void" />.</summary>
    public static bool ReturnsVoid(this LocalFunctionStatementSyntax localFunctionStatement);
    <summary>Returns true if the specified method return type is <see cref="T:System.Void" />.</summary>
    public static bool ReturnsVoid(this MethodDeclarationSyntax methodDeclaration);
    <summary>Returns a set accessor contained in the specified list.</summary>
    public static AccessorDeclarationSyntax Setter(this AccessorListSyntax accessorList);
    <summary>Returns a set accessor that is contained in the specified indexer declaration.</summary>
    public static AccessorDeclarationSyntax Setter(this IndexerDeclarationSyntax indexerDeclaration);
    <summary>Returns property set accessor, if any.</summary>
    public static AccessorDeclarationSyntax Setter(this PropertyDeclarationSyntax propertyDeclaration);
    <summary>Creates a separated list of syntax nodes from a sequence of nodes.</summary>
    public static SeparatedSyntaxList<TNode> ToSeparatedSyntaxList<TNode>(this IEnumerable<TNode> nodes) where TNode : SyntaxNode;
    <summary>Creates a separated list of syntax nodes from a sequence of nodes and tokens.</summary>
    public static SeparatedSyntaxList<TNode> ToSeparatedSyntaxList<TNode>(this IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode;
    <summary>Creates a list of syntax nodes from a sequence of nodes.</summary>
    public static SyntaxList<TNode> ToSyntaxList<TNode>(this IEnumerable<TNode> nodes) where TNode : SyntaxNode;
    <summary>Creates a list of syntax tokens from a sequence of tokens.</summary>
    public static SyntaxTokenList ToSyntaxTokenList(this IEnumerable<SyntaxToken> tokens);
    <summary>
    Removes all leading whitespace from the leading trivia and returns a new token with the new leading trivia.
    <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
    Returns the same token if there is nothing to trim.
    </summary>
    public static SyntaxToken TrimLeadingTrivia(this SyntaxToken token);
    <summary>
    Removes all leading whitespace from the leading trivia and returns a new node with the new leading trivia.
    <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
    Returns the same node if there is nothing to trim.
    </summary>
    public static TNode TrimLeadingTrivia<TNode>(this TNode node) where TNode : SyntaxNode;
    <summary>
    Removes all trailing whitespace from the trailing trivia and returns a new token with the new trailing trivia.
    <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
    Returns the same token if there is nothing to trim.
    </summary>
    public static SyntaxToken TrimTrailingTrivia(this SyntaxToken token);
    <summary>
    Removes all trailing whitespace from the trailing trivia and returns a new node with the new trailing trivia.
    <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
    Returns the same node if there is nothing to trim.
    </summary>
    public static TNode TrimTrailingTrivia<TNode>(this TNode node) where TNode : SyntaxNode;
    <summary>
    Removes all leading whitespace from the leading trivia and all trailing whitespace from the trailing trivia and returns a new token with the new trivia.
    <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
    Returns the same token if there is nothing to trim.
    </summary>
    public static SyntaxToken TrimTrivia(this SyntaxToken token);
    <summary>
    Removes all leading whitespace from the leading trivia and all trailing whitespace from the trailing trivia and returns a new node with the new trivia.
    <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
    Returns the same node if there is nothing to trim.
    </summary>
    public static TNode TrimTrivia<TNode>(this TNode node) where TNode : SyntaxNode;
    <summary>
    Gets a list the specified statement is contained in.
    This method succeeds if the statement is in a block's statements or a switch section's statements.
    </summary>
    <returns>True if the statement is contained in the list; otherwise, false.</returns>
    public static bool TryGetContainingList(this StatementSyntax statement, out SyntaxList<StatementSyntax> statements);
    <summary>Returns lowest expression in parentheses or self if the expression is not parenthesized.</summary>
    public static ExpressionSyntax WalkDownParentheses(this ExpressionSyntax expression);
    <summary>Returns topmost parenthesized expression or self if the expression if not parenthesized.</summary>
    public static ExpressionSyntax WalkUpParentheses(this ExpressionSyntax expression);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax" /> with the members updated.</summary>
    public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax" /> with the members updated.</summary>
    public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, IEnumerable<MemberDeclarationSyntax> members);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax" /> with the members updated.</summary>
    public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax" /> with the members updated.</summary>
    public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, IEnumerable<MemberDeclarationSyntax> members);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax" /> with the members updated.</summary>
    public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax" /> with the members updated.</summary>
    public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, IEnumerable<MemberDeclarationSyntax> members);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax" /> with the members updated.</summary>
    public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax" /> with the members updated.</summary>
    public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, IEnumerable<MemberDeclarationSyntax> members);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax" /> with the members updated.</summary>
    public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member);
    <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax" /> with the members updated.</summary>
    public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, IEnumerable<MemberDeclarationSyntax> members);

  <summary>Serves as a factory for types in Roslynator.CSharp.Syntax namespace.</summary>
  public static class SyntaxInfo

    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.AsExpressionInfo" /> from the specified binary expression.</summary>
    public static AsExpressionInfo AsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.AsExpressionInfo" /> from the specified node.</summary>
    public static AsExpressionInfo AsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.AssignmentExpressionInfo" /> from the specified assignment expression.</summary>
    public static AssignmentExpressionInfo AssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.AssignmentExpressionInfo" /> from the specified node.</summary>
    public static AssignmentExpressionInfo AssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.BinaryExpressionInfo" /> from the specified binary expression.</summary>
    public static BinaryExpressionInfo BinaryExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.BinaryExpressionInfo" /> from the specified node.</summary>
    public static BinaryExpressionInfo BinaryExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ConditionalExpressionInfo" /> from the specified conditional expression.</summary>
    public static ConditionalExpressionInfo ConditionalExpressionInfo(ConditionalExpressionSyntax conditionalExpression, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ConditionalExpressionInfo" /> from the specified node.</summary>
    public static ConditionalExpressionInfo ConditionalExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified constraint clause.</summary>
    public static GenericInfo GenericInfo(TypeParameterConstraintClauseSyntax constraintClause);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified delegate declaration.</summary>
    public static GenericInfo GenericInfo(DelegateDeclarationSyntax delegateDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified local function.</summary>
    public static GenericInfo GenericInfo(LocalFunctionStatementSyntax localFunctionStatement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified method declaration.</summary>
    public static GenericInfo GenericInfo(MethodDeclarationSyntax methodDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified node.</summary>
    public static GenericInfo GenericInfo(SyntaxNode node);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified type declaration.</summary>
    public static GenericInfo GenericInfo(TypeDeclarationSyntax typeDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified type parameter.</summary>
    public static GenericInfo GenericInfo(TypeParameterSyntax typeParameter);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified type parameter constraint.</summary>
    public static GenericInfo GenericInfo(TypeParameterConstraintSyntax typeParameterConstraint);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified type parameter list.</summary>
    public static GenericInfo GenericInfo(TypeParameterListSyntax typeParameterList);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.IsExpressionInfo" /> from the specified binary expression.</summary>
    public static IsExpressionInfo IsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.IsExpressionInfo" /> from the specified node.</summary>
    public static IsExpressionInfo IsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.LocalDeclarationStatementInfo" /> from the specified local declaration statement.</summary>
    public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.LocalDeclarationStatementInfo" /> from the specified expression.</summary>
    public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(ExpressionSyntax value, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified compilation unit.</summary>
    public static MemberDeclarationListInfo MemberDeclarationListInfo(CompilationUnitSyntax compilationUnit);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
    public static MemberDeclarationListInfo MemberDeclarationListInfo(NamespaceDeclarationSyntax declaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
    public static MemberDeclarationListInfo MemberDeclarationListInfo(TypeDeclarationSyntax declaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
    public static MemberDeclarationListInfo MemberDeclarationListInfo(ClassDeclarationSyntax declaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
    public static MemberDeclarationListInfo MemberDeclarationListInfo(StructDeclarationSyntax declaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
    public static MemberDeclarationListInfo MemberDeclarationListInfo(InterfaceDeclarationSyntax declaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified node.</summary>
    public static MemberDeclarationListInfo MemberDeclarationListInfo(SyntaxNode node);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified accessor declaration.</summary>
    public static ModifierListInfo ModifierListInfo(AccessorDeclarationSyntax accessorDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified class declaration.</summary>
    public static ModifierListInfo ModifierListInfo(ClassDeclarationSyntax classDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified constructor declaration.</summary>
    public static ModifierListInfo ModifierListInfo(ConstructorDeclarationSyntax constructorDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified conversion operator declaration.</summary>
    public static ModifierListInfo ModifierListInfo(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified delegate declaration.</summary>
    public static ModifierListInfo ModifierListInfo(DelegateDeclarationSyntax delegateDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified destructor declaration.</summary>
    public static ModifierListInfo ModifierListInfo(DestructorDeclarationSyntax destructorDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified enum declaration.</summary>
    public static ModifierListInfo ModifierListInfo(EnumDeclarationSyntax enumDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified event declaration.</summary>
    public static ModifierListInfo ModifierListInfo(EventDeclarationSyntax eventDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified event field declaration.</summary>
    public static ModifierListInfo ModifierListInfo(EventFieldDeclarationSyntax eventFieldDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified field declaration.</summary>
    public static ModifierListInfo ModifierListInfo(FieldDeclarationSyntax fieldDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified incomplete member.</summary>
    public static ModifierListInfo ModifierListInfo(IncompleteMemberSyntax incompleteMember);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified indexer declaration.</summary>
    public static ModifierListInfo ModifierListInfo(IndexerDeclarationSyntax indexerDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified interface declaration.</summary>
    public static ModifierListInfo ModifierListInfo(InterfaceDeclarationSyntax interfaceDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified local declaration statement.</summary>
    public static ModifierListInfo ModifierListInfo(LocalDeclarationStatementSyntax localDeclarationStatement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified local function.</summary>
    public static ModifierListInfo ModifierListInfo(LocalFunctionStatementSyntax localFunctionStatement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified method declaration.</summary>
    public static ModifierListInfo ModifierListInfo(MethodDeclarationSyntax methodDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified node.</summary>
    public static ModifierListInfo ModifierListInfo(SyntaxNode node);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified operator declaration.</summary>
    public static ModifierListInfo ModifierListInfo(OperatorDeclarationSyntax operatorDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified parameter.</summary>
    public static ModifierListInfo ModifierListInfo(ParameterSyntax parameter);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified property declaration.</summary>
    public static ModifierListInfo ModifierListInfo(PropertyDeclarationSyntax propertyDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified struct declaration.</summary>
    public static ModifierListInfo ModifierListInfo(StructDeclarationSyntax structDeclaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.NullCheckExpressionInfo" /> from the specified node.</summary>
    public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, NullCheckStyles allowedStyles = ComparisonToNull | IsPattern, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.NullCheckExpressionInfo" /> from the specified node.</summary>
    public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles = All, bool walkDownParentheses = true, bool allowMissing = false, CancellationToken cancellationToken = default);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.RegionInfo" /> from the specified endregion directive.</summary>
    public static RegionInfo RegionInfo(EndRegionDirectiveTriviaSyntax endRegionDirective);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.RegionInfo" /> from the specified region directive.</summary>
    public static RegionInfo RegionInfo(RegionDirectiveTriviaSyntax regionDirective);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentExpressionInfo" /> from the specified assignment expression.</summary>
    public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentExpressionInfo" /> from the specified node.</summary>
    public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo" /> from the specified assignment expression.</summary>
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo" /> from the specified expression statement.</summary>
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(ExpressionStatementSyntax expressionStatement, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo" /> from the specified statement.</summary>
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(StatementSyntax statement, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleIfElseInfo" /> from the specified if statement.</summary>
    public static SimpleIfElseInfo SimpleIfElseInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleIfStatementInfo" /> from the specified if statement.</summary>
    public static SimpleIfStatementInfo SimpleIfStatementInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleIfStatementInfo" /> from the specified node.</summary>
    public static SimpleIfStatementInfo SimpleIfStatementInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationExpressionInfo" /> from the specified invocation expression.</summary>
    public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationExpressionInfo" /> from the specified node.</summary>
    public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo" /> from the specified expression statement.</summary>
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(ExpressionStatementSyntax expressionStatement, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo" /> from the specified invocation expression.</summary>
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo" /> from the specified node.</summary>
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(SyntaxNode node, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo" /> from the specified value.</summary>
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(ExpressionSyntax value);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo" /> from the specified local declaration statement.</summary>
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo" /> from the specified variable declaration.</summary>
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(VariableDeclarationSyntax variableDeclaration, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleParameterLambdaExpressionInfo" /> from the specified lambda expression.</summary>
    public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(LambdaExpressionSyntax lambdaExpression, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleParameterLambdaExpressionInfo" /> from the specified node.</summary>
    public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> from the specified statement.</summary>
    public static StatementListInfo StatementListInfo(StatementSyntax statement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo" /> from the specified node.</summary>
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken = default);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo" /> from the specified expression chain.</summary>
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(in ExpressionChain expressionChain, SemanticModel semanticModel, CancellationToken cancellationToken = default);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo" /> from the specified node.</summary>
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(SyntaxNode node, SemanticModel semanticModel, bool walkDownParentheses = true, CancellationToken cancellationToken = default);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringLiteralExpressionInfo" /> from the specified literal expression.</summary>
    public static StringLiteralExpressionInfo StringLiteralExpressionInfo(LiteralExpressionSyntax literalExpression);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringLiteralExpressionInfo" /> from the specified node.</summary>
    public static StringLiteralExpressionInfo StringLiteralExpressionInfo(SyntaxNode node, bool walkDownParentheses = true);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> from the specified compilation unit.</summary>
    public static UsingDirectiveListInfo UsingDirectiveListInfo(CompilationUnitSyntax compilationUnit);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> from the specified declaration.</summary>
    public static UsingDirectiveListInfo UsingDirectiveListInfo(NamespaceDeclarationSyntax declaration);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> from the specified node.</summary>
    public static UsingDirectiveListInfo UsingDirectiveListInfo(SyntaxNode node);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.XmlElementInfo" /> from the specified xml node.</summary>
    public static XmlElementInfo XmlElementInfo(XmlNodeSyntax xmlNode);

  <summary>Provides static methods for syntax inversion.</summary>
  public static class SyntaxInverter

    <summary>Returns new expression that represents logical inversion of the specified expression.</summary>
    public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, CancellationToken cancellationToken = default);
    <summary>Returns new expression that represents logical inversion of the specified expression.</summary>
    public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken = default);

  <summary>A set of extension methods for the workspace layer.</summary>
  public static class WorkspaceExtensions

    <summary>Creates a new document with comments of the specified kind removed.</summary>
    public static Task<Document> RemoveCommentsAsync(this Document document, CommentFilter comments, CancellationToken cancellationToken = default);
    <summary>Creates a new document with comments of the specified kind removed.</summary>
    public static Task<Document> RemoveCommentsAsync(this Document document, TextSpan span, CommentFilter comments, CancellationToken cancellationToken = default);
    <summary>Creates a new document with preprocessor directives of the specified kind removed.</summary>
    public static Task<Document> RemovePreprocessorDirectivesAsync(this Document document, PreprocessorDirectiveFilter directiveFilter, CancellationToken cancellationToken = default);
    <summary>Creates a new document with preprocessor directives of the specified kind removed.</summary>
    public static Task<Document> RemovePreprocessorDirectivesAsync(this Document document, TextSpan span, PreprocessorDirectiveFilter directiveFilter, CancellationToken cancellationToken = default);
    <summary>Creates a new document with the specified region removed.</summary>
    public static Task<Document> RemoveRegionAsync(this Document document, RegionInfo region, CancellationToken cancellationToken = default);
    <summary>Creates a new document with trivia inside the specified span removed.</summary>
    public static Task<Document> RemoveTriviaAsync(this Document document, TextSpan span, CancellationToken cancellationToken = default);

  <summary>A set of extension methods for syntax. These methods are dependent on the workspace layer.</summary>
  public static class WorkspaceSyntaxExtensions

    <summary>Creates parenthesized expression that is parenthesizing the specified expression.</summary>
    <param name="includeElasticTrivia">If true, add elastic trivia.</param>
    <param name="simplifiable">If true, attach <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> to the parenthesized expression.</param>
    public static ParenthesizedExpressionSyntax Parenthesize(this ExpressionSyntax expression, bool includeElasticTrivia = true, bool simplifiable = true);
    <summary>Adds <see cref="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation" /> to the specified token, creating a new token of the same type with the <see cref="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation" /> on it.</summary>
    public static SyntaxToken WithFormatterAnnotation(this SyntaxToken token);
    <summary>Creates a new node with the <see cref="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation" /> attached.</summary>
    public static TNode WithFormatterAnnotation<TNode>(this TNode node) where TNode : SyntaxNode;
    <summary>
    Adds "rename" annotation to the specified token, creating a new token of the same type with the "rename" annotation on it.
    "Rename" annotation is specified by <see cref="F:Microsoft.CodeAnalysis.CodeActions.RenameAnnotation.Kind" />.
    </summary>
    public static SyntaxToken WithRenameAnnotation(this SyntaxToken token);
    <summary>
    Adds <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> to the specified token, creating a new token of the same type with the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> on it.
    "Rename" annotation is specified by <see cref="F:Microsoft.CodeAnalysis.CodeActions.RenameAnnotation.Kind" />.
    </summary>
    public static SyntaxToken WithSimplifierAnnotation(this SyntaxToken token);
    <summary>Creates a new node with the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> attached.</summary>
    public static TNode WithSimplifierAnnotation<TNode>(this TNode node) where TNode : SyntaxNode;

  <summary>Enables to enumerate expressions of a binary expression and expressions of nested binary expressions of the same kind as parent binary expression.</summary>
  public readonly struct ExpressionChain : IEquatable<ExpressionChain>, IEnumerable<ExpressionSyntax>

    <summary>The binary expression.</summary>
    public BinaryExpressionSyntax BinaryExpression { get; }
    <summary>The span that represents selected expressions.</summary>
    public TextSpan? Span { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(ExpressionChain other);
    <summary>Gets the enumerator for the expressions.</summary>
    public ExpressionChain.Enumerator GetEnumerator();
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns a chain which contains all expressions of <see cref="T:Roslynator.CSharp.ExpressionChain" /> in reversed order.</summary>
    public ExpressionChain.Reversed Reverse();
    <summary>Returns the string representation of the expressions, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in ExpressionChain info1, in ExpressionChain info2);
    public static bool operator !=(in ExpressionChain info1, in ExpressionChain info2);

    public struct Enumerator

      public ExpressionSyntax Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

    <summary>Enables to enumerate expressions of <see cref="T:Roslynator.CSharp.ExpressionChain" /> in a reversed order.</summary>
    public readonly struct Reversed : IEquatable<ExpressionChain.Reversed>, IEnumerable<ExpressionSyntax>

      public Reversed(in ExpressionChain chain);

      public override bool Equals(object obj);
      public bool Equals(ExpressionChain.Reversed other);
      public ExpressionChain.Reversed.Enumerator GetEnumerator();
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2);
      public static bool operator !=(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2);

      public struct Enumerator

        public ExpressionSyntax Current { get; }

        public override bool Equals(object obj);
        public override int GetHashCode();
        public bool MoveNext();
        public void Reset();

  <summary>Enables to enumerate if statement cascade.</summary>
  public readonly struct IfStatementCascade : IEquatable<IfStatementCascade>, IEnumerable<IfStatementOrElseClause>

    <summary>The if statement.</summary>
    public IfStatementSyntax IfStatement { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(IfStatementCascade other);
    <summary>Gets the enumerator for the if-else cascade.</summary>
    public IfStatementCascade.Enumerator GetEnumerator();
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in IfStatementCascade cascade1, in IfStatementCascade cascade2);
    public static bool operator !=(in IfStatementCascade cascade1, in IfStatementCascade cascade2);

    public struct Enumerator

      public IfStatementOrElseClause Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

  <summary>Summarizes information about <see cref="T:Roslynator.CSharp.IfStatementCascade" />.</summary>
  public readonly struct IfStatementCascadeInfo : IEquatable<IfStatementCascadeInfo>

    <summary>Initializes a new instance of <see cref="T:Roslynator.CSharp.IfStatementCascadeInfo" />.</summary>
    public IfStatementCascadeInfo(IfStatementSyntax ifStatement);

    <summary>Gets a number of 'if' statements plus optional 'else' clause at the end of a cascade.</summary>
    public int Count { get; }
    <summary>Determines whether the cascade ends with 'else' clause.</summary>
    public bool EndsWithElse { get; }
    <summary>Determines whether the cascade ends with 'if' statement.</summary>
    public bool EndsWithIf { get; }
    <summary>Gets the topmost 'if' statement.</summary>
    public IfStatementSyntax IfStatement { get; }
    <summary>Determines whether the cascade consists of single 'if' statement.</summary>
    public bool IsSimpleIf { get; }
    <summary>Determines whether the cascade consists of single if-else.</summary>
    public bool IsSimpleIfElse { get; }
    <summary>Gets a last 'if' or 'else' in a cascade.</summary>
    public IfStatementOrElseClause Last { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(IfStatementCascadeInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2);
    public static bool operator !=(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2);

  <summary>A wrapper for either an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax" /> or an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax" />.</summary>
  public readonly struct IfStatementOrElseClause : IEquatable<IfStatementOrElseClause>

    public IfStatementOrElseClause(ElseClauseSyntax elseClause);
    public IfStatementOrElseClause(IfStatementSyntax ifStatement);

    <summary>The absolute span of this node in characters, including its leading and trailing trivia.</summary>
    public TextSpan FullSpan { get; }
    <summary>Determines whether this <see cref="T:Roslynator.CSharp.IfStatementOrElseClause" /> is wrapping an else clause.</summary>
    public bool IsElse { get; }
    <summary>Determines whether this <see cref="T:Roslynator.CSharp.IfStatementOrElseClause" /> is wrapping an if statement.</summary>
    public bool IsIf { get; }
    <summary>Gets an underlying node kind.</summary>
    public SyntaxKind Kind { get; }
    <summary>The node that contains the underlying node in its <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes" /> collection.</summary>
    public SyntaxNode Parent { get; }
    <summary>The absolute span of this node in characters, not including its leading and trailing trivia.</summary>
    public TextSpan Span { get; }
    <summary>Gets <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Statement" /> or <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax.Statement" />.</summary>
    public StatementSyntax Statement { get; }

    <summary>Returns the underlying else clause if this <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax" /> is wrapping else clause.</summary>
    public ElseClauseSyntax AsElse();
    <summary>Returns the underlying if statement if this <see cref="T:Roslynator.CSharp.IfStatementOrElseClause" /> is wrapping if statement.</summary>
    public IfStatementSyntax AsIf();
    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(IfStatementOrElseClause other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying node, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static implicit operator IfStatementOrElseClause(IfStatementSyntax ifStatement);
    public static implicit operator IfStatementSyntax(in IfStatementOrElseClause ifOrElse);
    public static implicit operator IfStatementOrElseClause(ElseClauseSyntax elseClause);
    public static implicit operator ElseClauseSyntax(in IfStatementOrElseClause ifOrElse);

    public static bool operator ==(in IfStatementOrElseClause left, in IfStatementOrElseClause right);
    public static bool operator !=(in IfStatementOrElseClause left, in IfStatementOrElseClause right);

  <summary>Specifies C# comments.</summary>
  [Flags]
  public enum CommentFilter

    <summary>None comment specified.</summary>
    None = 0,
    <summary>Single-line comment.</summary>
    SingleLine = 1,
    <summary>Multi-line comment.</summary>
    MultiLine = 2,
    <summary>Non-documentation comment (single-line or multi-line).</summary>
    NonDocumentation = SingleLine | MultiLine,
    <summary>Single-line documentation comment.</summary>
    SingleLineDocumentation = 4,
    <summary>Multi-line documentation comment.</summary>
    MultiLineDocumentation = 8,
    <summary>Documentation comment (single-line or multi-line).</summary>
    Documentation = SingleLineDocumentation | MultiLineDocumentation,
    <summary>Documentation or non-documentation comment.</summary>
    All = NonDocumentation | Documentation,

  <summary>Specifies C# modifier.</summary>
  [Flags]
  public enum ModifierFilter

    <summary>None modifier.</summary>
    None = 0,
    <summary>A "new" modifier.</summary>
    New = 1,
    <summary>A "public" modifier.</summary>
    Public = 2,
    <summary>A "private" modifier.</summary>
    Private = 4,
    <summary>A "protected" modifier.</summary>
    Protected = 8,
    <summary>An "internal" modifier.</summary>
    Internal = 16,
    <summary>An accessibility modifier.</summary>
    Accessibility = Public | Private | Protected | Internal,
    <summary>A "const" modifier.</summary>
    Const = 32,
    <summary>A "static" modifier.</summary>
    Static = 64,
    <summary>A "virtual" modifier.</summary>
    Virtual = 128,
    <summary>A "sealed" modifier.</summary>
    Sealed = 256,
    <summary>An "override" modifier.</summary>
    Override = 512,
    <summary>An "abstract" modifier.</summary>
    Abstract = 1024,
    <summary>"abstract", "virtual" or "override" modifier.</summary>
    AbstractVirtualOverride = Virtual | Override | Abstract,
    <summary>A "readonly" modifier.</summary>
    ReadOnly = 2048,
    <summary>An "extern" modifier.</summary>
    Extern = 4096,
    <summary>A "unsafe" modifier.</summary>
    Unsafe = 8192,
    <summary>A "volatile" modifier.</summary>
    Volatile = 16384,
    <summary>An "async" modifier.</summary>
    Async = 32768,
    <summary>A "partial" modifier.</summary>
    Partial = 65536,
    <summary>A "ref" modifier.</summary>
    Ref = 131072,
    <summary>An "out" modifier.</summary>
    Out = 262144,
    <summary>An "in" modifier.</summary>
    In = 524288,
    <summary>A "params" modifier.</summary>
    Params = 1048576,
    <summary>A "this" modifier.</summary>
    This = 2097152,

  <summary>Specifies a null check.</summary>
  [Flags]
  public enum NullCheckStyles

    <summary>No null check specified.</summary>
    None = 0,
    <summary><c>x == null</c></summary>
    EqualsToNull = 1,
    <summary><c>x != null</c></summary>
    NotEqualsToNull = 2,
    <summary>Expression that uses equality/inequality operator.</summary>
    ComparisonToNull = EqualsToNull | NotEqualsToNull,
    <summary><c>x is null</c></summary>
    IsNull = 4,
    <summary><c>!(x is null)</c></summary>
    NotIsNull = 8,
    <summary>Expression that uses pattern syntax.</summary>
    IsPattern = IsNull | NotIsNull,
    <summary><c>!x.HasValue</c></summary>
    NotHasValue = 16,
    <summary>Expression that checks whether an expression is null.</summary>
    CheckingNull = EqualsToNull | IsNull | NotHasValue,
    <summary><c>x.HasValue</c></summary>
    HasValue = 32,
    <summary>Expression that checks whether an expression is not null.</summary>
    CheckingNotNull = NotEqualsToNull | NotIsNull | HasValue,
    <summary>Expression that uses <see cref="P:System.Nullable`1.HasValue" /> property.</summary>
    HasValueProperty = NotHasValue | HasValue,
    <summary>All null check styles.</summary>
    All = ComparisonToNull | IsPattern | HasValueProperty,

  <summary>Specifies C# preprocessor directives.</summary>
  [Flags]
  public enum PreprocessorDirectiveFilter

    <summary>No preprocessor directive.</summary>
    None = 0,
    <summary>#if preprocessor directive.</summary>
    If = 1,
    <summary>#elif preprocessor directive.</summary>
    Elif = 2,
    <summary>#else preprocessor directive.</summary>
    Else = 4,
    <summary>#endif preprocessor directive.</summary>
    EndIf = 8,
    <summary>#region preprocessor directive.</summary>
    Region = 16,
    <summary>#endregion preprocessor directive.</summary>
    EndRegion = 32,
    <summary>#define preprocessor directive.</summary>
    Define = 64,
    <summary>#undef preprocessor directive.</summary>
    Undef = 128,
    <summary>#error preprocessor directive.</summary>
    Error = 256,
    <summary>#warning preprocessor directive.</summary>
    Warning = 512,
    <summary>#line preprocessor directive.</summary>
    Line = 1024,
    <summary>#pragma warning preprocessor directive.</summary>
    PragmaWarning = 2048,
    <summary>#pragma checksum preprocessor directive.</summary>
    PragmaChecksum = 4096,
    <summary>#pragma preprocessor directive.</summary>
    Pragma = PragmaWarning | PragmaChecksum,
    <summary>#r preprocessor directive.</summary>
    Reference = 8192,
    <summary>#load preprocessor directive.</summary>
    Load = 16384,
    <summary>Bad preprocessor directive.</summary>
    Bad = 32768,
    <summary>Shebang preprocessor directive.</summary>
    Shebang = 65536,
    <summary>All preprocessor directives.</summary>
    All = If | Elif | Else | EndIf | Region | EndRegion | Define | Undef | Error | Warning | Line | Pragma | Reference | Load | Bad | Shebang,

namespace Roslynator.CSharp.Syntax

  <summary>Provides information about "as" expression.</summary>
  public readonly struct AsExpressionInfo : IEquatable<AsExpressionInfo>

    <summary>The "as" expression.</summary>
    public BinaryExpressionSyntax AsExpression { get; }
    <summary>The expression that is being casted.</summary>
    public ExpressionSyntax Expression { get; }
    <summary>The "as" operator token.</summary>
    public SyntaxToken OperatorToken { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>The type to which the expression is being cast.</summary>
    public TypeSyntax Type { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(AsExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in AsExpressionInfo info1, in AsExpressionInfo info2);
    public static bool operator !=(in AsExpressionInfo info1, in AsExpressionInfo info2);

  <summary>Provides information about simple assignment expression.</summary>
  public readonly struct AssignmentExpressionInfo : IEquatable<AssignmentExpressionInfo>

    <summary>The simple assignment expression.</summary>
    public AssignmentExpressionSyntax AssignmentExpression { get; }
    <summary>The kind of the assignment expression.</summary>
    public SyntaxKind Kind { get; }
    <summary>The expression on the left of the assignment operator.</summary>
    public ExpressionSyntax Left { get; }
    <summary>The operator of the simple assignment expression.</summary>
    public SyntaxToken OperatorToken { get; }
    <summary>The expression on the right of the assignment operator.</summary>
    public ExpressionSyntax Right { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(AssignmentExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2);
    public static bool operator !=(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2);

  <summary>Provides information about binary expression.</summary>
  public readonly struct BinaryExpressionInfo : IEquatable<BinaryExpressionInfo>

    <summary>The binary expression.</summary>
    public BinaryExpressionSyntax BinaryExpression { get; }
    <summary>The kind of the binary expression.</summary>
    public SyntaxKind Kind { get; }
    <summary>The expression on the left of the binary operator.</summary>
    public ExpressionSyntax Left { get; }
    <summary>The operator of the binary expression.</summary>
    public SyntaxToken OperatorToken { get; }
    <summary>The expression on the right of the binary operator.</summary>
    public ExpressionSyntax Right { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Returns <see cref="T:Roslynator.CSharp.ExpressionChain" /> that enables to enumerate expressions of a binary expression.</summary>
    public ExpressionChain AsChain();
    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(BinaryExpressionInfo other);
    <summary>Returns expressions of this binary expression, including expressions of nested binary expressions of the same kind as parent binary expression.</summary>
    <param name="leftToRight">If true expressions are enumerated as they are displayed in the source code.</param>
    [Obsolete("This method is obsolete. Use method 'AsChain' instead.")]
    public IEnumerable<ExpressionSyntax> Expressions(bool leftToRight = false);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2);
    public static bool operator !=(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2);

  <summary>Provides information about conditional expression.</summary>
  public readonly struct ConditionalExpressionInfo : IEquatable<ConditionalExpressionInfo>

    <summary>The token representing the colon.</summary>
    public SyntaxToken ColonToken { get; }
    <summary>The condition expression.</summary>
    public ExpressionSyntax Condition { get; }
    <summary>The conditional expression.</summary>
    public ConditionalExpressionSyntax ConditionalExpression { get; }
    <summary>The token representing the question mark.</summary>
    public SyntaxToken QuestionToken { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>The expression to be executed when the expression is false.</summary>
    public ExpressionSyntax WhenFalse { get; }
    <summary>The expression to be executed when the expression is true.</summary>
    public ExpressionSyntax WhenTrue { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(ConditionalExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2);
    public static bool operator !=(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2);

  <summary>Provides information about generic syntax (class, struct, interface, delegate, method or local function).</summary>
  public readonly struct GenericInfo : IEquatable<GenericInfo>

    <summary>A list of constraint clauses.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    <summary>The kind of this syntax node.</summary>
    public SyntaxKind Kind { get; }
    <summary>The syntax node that can be generic (for example <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax" /> for a class or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax" /> for a local function).</summary>
    public SyntaxNode Node { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>The type parameter list.</summary>
    public TypeParameterListSyntax TypeParameterList { get; }
    <summary>A list of type parameters.</summary>
    public SeparatedSyntaxList<TypeParameterSyntax> TypeParameters { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(GenericInfo other);
    <summary>Searches for a constraint clause with the specified type parameter name and returns the first occurrence within the constraint clauses.</summary>
    public TypeParameterConstraintClauseSyntax FindConstraintClause(string typeParameterName);
    <summary>Searches for a type parameter with the specified name and returns the first occurrence within the type parameters.</summary>
    public TypeParameterSyntax FindTypeParameter(string name);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with all constraint clauses removed.</summary>
    public GenericInfo RemoveAllConstraintClauses();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with the specified constraint clause removed.</summary>
    public GenericInfo RemoveConstraintClause(TypeParameterConstraintClauseSyntax constraintClause);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with the specified type parameter removed.</summary>
    public GenericInfo RemoveTypeParameter(TypeParameterSyntax typeParameter);
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with the constraint clauses updated.</summary>
    public GenericInfo WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with the type parameter list updated.</summary>
    public GenericInfo WithTypeParameterList(TypeParameterListSyntax typeParameterList);

    public static bool operator ==(in GenericInfo info1, in GenericInfo info2);
    public static bool operator !=(in GenericInfo info1, in GenericInfo info2);

  <summary>Provides information about "is" expression.</summary>
  public readonly struct IsExpressionInfo : IEquatable<IsExpressionInfo>

    <summary>The expression that is being casted.</summary>
    public ExpressionSyntax Expression { get; }
    <summary>The "is" expression.</summary>
    public BinaryExpressionSyntax IsExpression { get; }
    <summary>The "is" operator token.</summary>
    public SyntaxToken OperatorToken { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>The type to which the expression is being cast.</summary>
    public TypeSyntax Type { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(IsExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in IsExpressionInfo info1, in IsExpressionInfo info2);
    public static bool operator !=(in IsExpressionInfo info1, in IsExpressionInfo info2);

  <summary>Provides information about local declaration statement.</summary>
  public readonly struct LocalDeclarationStatementInfo : IEquatable<LocalDeclarationStatementInfo>

    <summary>The variable declaration.</summary>
    public VariableDeclarationSyntax Declaration { get; }
    <summary>The modifier list.</summary>
    public SyntaxTokenList Modifiers { get; }
    <summary>The semicolon token.</summary>
    public SyntaxToken SemicolonToken { get; }
    <summary>The local declaration statement.</summary>
    public LocalDeclarationStatementSyntax Statement { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>The type of the declaration.</summary>
    public TypeSyntax Type { get; }
    <summary>A list of variables.</summary>
    public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(LocalDeclarationStatementInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2);
    public static bool operator !=(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2);

  <summary>Provides information about a list of member declaration list.</summary>
  public readonly struct MemberDeclarationListInfo : IEquatable<MemberDeclarationListInfo>, IReadOnlyList<MemberDeclarationSyntax>

    <summary>A number of members in the list.</summary>
    public int Count { get; }
    <summary>A list of members.</summary>
    public SyntaxList<MemberDeclarationSyntax> Members { get; }
    <summary>The declaration that contains the members.</summary>
    public SyntaxNode Parent { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Gets the member at the specified index in the list.</summary>
    <returns>The member at the specified index in the list.</returns>
    <param name="index">The zero-based index of the member to get. </param>
    public MemberDeclarationSyntax this[int index] { get; }

    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member added at the end.</summary>
    public MemberDeclarationListInfo Add(MemberDeclarationSyntax member);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified members added at the end.</summary>
    public MemberDeclarationListInfo AddRange(IEnumerable<MemberDeclarationSyntax> members);
    <summary>True if the list has at least one member.</summary>
    public bool Any();
    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(MemberDeclarationListInfo other);
    <summary>The first member in the list.</summary>
    public MemberDeclarationSyntax First();
    <summary>The first member in the list or null if the list is empty.</summary>
    public MemberDeclarationSyntax FirstOrDefault();
    <summary>Gets the enumerator for the list of members.</summary>
    public SyntaxList<MemberDeclarationSyntax>.Enumerator GetEnumerator();
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>The index of the member in the list.</summary>
    public int IndexOf(MemberDeclarationSyntax member);
    <summary>Searches for a member that matches the predicate and returns returns zero-based index of the first occurrence in the list.</summary>
    public int IndexOf(Func<MemberDeclarationSyntax, bool> predicate);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member inserted at the index.</summary>
    public MemberDeclarationListInfo Insert(int index, MemberDeclarationSyntax member);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified members inserted at the index.</summary>
    public MemberDeclarationListInfo InsertRange(int index, IEnumerable<MemberDeclarationSyntax> members);
    <summary>The last member in the list.</summary>
    public MemberDeclarationSyntax Last();
    <summary>Searches for a member and returns zero-based index of the last occurrence in the list.</summary>
    public int LastIndexOf(MemberDeclarationSyntax member);
    <summary>Searches for a member that matches the predicate and returns returns zero-based index of the last occurrence in the list.</summary>
    public int LastIndexOf(Func<MemberDeclarationSyntax, bool> predicate);
    <summary>The last member in the list or null if the list is empty.</summary>
    public MemberDeclarationSyntax LastOrDefault();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member removed.</summary>
    public MemberDeclarationListInfo Remove(MemberDeclarationSyntax member);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the member at the specified index removed.</summary>
    public MemberDeclarationListInfo RemoveAt(int index);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified node removed.</summary>
    public MemberDeclarationListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member replaced with the new member.</summary>
    public MemberDeclarationListInfo Replace(MemberDeclarationSyntax memberInList, MemberDeclarationSyntax newMember);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the member at the specified index replaced with a new member.</summary>
    public MemberDeclarationListInfo ReplaceAt(int index, MemberDeclarationSyntax newMember);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified old node replaced with a new node.</summary>
    public MemberDeclarationListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member replaced with new members.</summary>
    public MemberDeclarationListInfo ReplaceRange(MemberDeclarationSyntax memberInList, IEnumerable<MemberDeclarationSyntax> newMembers);
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the members updated.</summary>
    public MemberDeclarationListInfo WithMembers(IEnumerable<MemberDeclarationSyntax> members);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the members updated.</summary>
    public MemberDeclarationListInfo WithMembers(SyntaxList<MemberDeclarationSyntax> members);

    public static bool operator ==(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2);
    public static bool operator !=(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2);

  <summary>Provides information about modifier list.</summary>
  public readonly struct ModifierListInfo : IEquatable<ModifierListInfo>

    <summary>The explicit accessibility.</summary>
    public Accessibility ExplicitAccessibility { get; }
    <summary>True if the modifier list contains "abstract" modifier.</summary>
    public bool IsAbstract { get; }
    <summary>True if the modifier list contains "async" modifier.</summary>
    public bool IsAsync { get; }
    <summary>True if the modifier list contains "const" modifier.</summary>
    public bool IsConst { get; }
    <summary>True if the modifier list contains "extern" modifier.</summary>
    public bool IsExtern { get; }
    <summary>True if the modifier list contains "in" modifier.</summary>
    public bool IsIn { get; }
    <summary>True if the modifier list contains "new" modifier.</summary>
    public bool IsNew { get; }
    <summary>True if the modifier list contains "out" modifier.</summary>
    public bool IsOut { get; }
    <summary>True if the modifier list contains "override" modifier.</summary>
    public bool IsOverride { get; }
    <summary>True if the modifier list contains "params" modifier.</summary>
    public bool IsParams { get; }
    <summary>True if the modifier list contains "partial" modifier.</summary>
    public bool IsPartial { get; }
    <summary>True if the modifier list contains "readonly" modifier.</summary>
    public bool IsReadOnly { get; }
    <summary>True if the modifier list contains "ref" modifier.</summary>
    public bool IsRef { get; }
    <summary>True if the modifier list contains "sealed" modifier.</summary>
    public bool IsSealed { get; }
    <summary>True if the modifier list contains "static" modifier.</summary>
    public bool IsStatic { get; }
    <summary>True if the modifier list contains "unsafe" modifier.</summary>
    public bool IsUnsafe { get; }
    <summary>True if the modifier list contains "virtual" modifier.</summary>
    public bool IsVirtual { get; }
    <summary>True if the modifier list contains "volatile" modifier.</summary>
    public bool IsVolatile { get; }
    <summary>The modifier list.</summary>
    public SyntaxTokenList Modifiers { get; }
    <summary>The node that contains the modifiers.</summary>
    public SyntaxNode Parent { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(ModifierListInfo other);
    <summary>Gets the modifier filter.</summary>
    public ModifierFilter GetFilter();
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> with accessibility modifiers updated.</summary>
    public ModifierListInfo WithExplicitAccessibility(Accessibility newAccessibility, IComparer<SyntaxKind> comparer = null);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> with the specified modifiers updated.</summary>
    public ModifierListInfo WithModifiers(SyntaxTokenList modifiers);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> with accessibility modifiers removed.</summary>
    public ModifierListInfo WithoutExplicitAccessibility();

    public static bool operator ==(in ModifierListInfo info1, in ModifierListInfo info2);
    public static bool operator !=(in ModifierListInfo info1, in ModifierListInfo info2);

  <summary>Provides information about a null check expression.</summary>
  public readonly struct NullCheckExpressionInfo : IEquatable<NullCheckExpressionInfo>

    <summary>The expression that is evaluated whether is (not) null. for example "x" in "x == null".</summary>
    public ExpressionSyntax Expression { get; }
    <summary>Determines whether this null check is checking if the expression is not null.</summary>
    public bool IsCheckingNotNull { get; }
    <summary>Determines whether this null check is checking if the expression is null.</summary>
    public bool IsCheckingNull { get; }
    <summary>The null check expression, e.g. "x == null".</summary>
    public ExpressionSyntax NullCheckExpression { get; }
    <summary>The style of this null check.</summary>
    public NullCheckStyles Style { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(NullCheckExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2);
    public static bool operator !=(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2);

  <summary>Provides information about a region.</summary>
  public readonly struct RegionInfo : IEquatable<RegionInfo>

    <summary>#region directive.</summary>
    public RegionDirectiveTriviaSyntax Directive { get; }
    <summary>#endregion directive.</summary>
    public EndRegionDirectiveTriviaSyntax EndDirective { get; }
    <summary>The absolute span of this region, including its leading and trailing trivia.</summary>
    public TextSpan FullSpan { get; }
    <summary>Determines whether this region is empty, i.e. contains only white-space.</summary>
    public bool IsEmpty { get; }
    <summary>The absolute span of this region, not including its leading and trailing trivia.</summary>
    public TextSpan Span { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(RegionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in RegionInfo info1, in RegionInfo info2);
    public static bool operator !=(in RegionInfo info1, in RegionInfo info2);

  <summary>Provides information about simple assignment expression.</summary>
  public readonly struct SimpleAssignmentExpressionInfo : IEquatable<SimpleAssignmentExpressionInfo>

    <summary>The simple assignment expression.</summary>
    public AssignmentExpressionSyntax AssignmentExpression { get; }
    <summary>The expression on the left of the assignment operator.</summary>
    public ExpressionSyntax Left { get; }
    <summary>The operator of the simple assignment expression.</summary>
    public SyntaxToken OperatorToken { get; }
    <summary>The expression on the right of the assignment operator.</summary>
    public ExpressionSyntax Right { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(SimpleAssignmentExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2);
    public static bool operator !=(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2);

  <summary>Provides information about a simple assignment expression in an expression statement.</summary>
  public readonly struct SimpleAssignmentStatementInfo : IEquatable<SimpleAssignmentStatementInfo>

    <summary>The simple assignment expression.</summary>
    public AssignmentExpressionSyntax AssignmentExpression { get; }
    <summary>The expression on the left of the assignment operator.</summary>
    public ExpressionSyntax Left { get; }
    <summary>The operator of the simple assignment expression.</summary>
    public SyntaxToken OperatorToken { get; }
    <summary>The expression of the right of the assignment operator.</summary>
    public ExpressionSyntax Right { get; }
    <summary>The expression statement the simple assignment expression is contained in.</summary>
    public ExpressionStatementSyntax Statement { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(SimpleAssignmentStatementInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2);
    public static bool operator !=(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2);

  <summary>
  Provides information about a simple if-else.
  Simple if-else is defined as follows: it is not a child of an else clause and it has an else clause and the else clause does not continue with another if statement.
  </summary>
  public readonly struct SimpleIfElseInfo : IEquatable<SimpleIfElseInfo>

    <summary>The condition.</summary>
    public ExpressionSyntax Condition { get; }
    <summary>The else clause.</summary>
    public ElseClauseSyntax Else { get; }
    <summary>The if statement.</summary>
    public IfStatementSyntax IfStatement { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>The statement that is executed if the condition evaluates to false.</summary>
    public StatementSyntax WhenFalse { get; }
    <summary>The statement that is executed if the condition evaluates to true.</summary>
    public StatementSyntax WhenTrue { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(SimpleIfElseInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2);
    public static bool operator !=(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2);

  <summary>
  Provides information about a simple if statement.
  Simple if statement is defined as follows: it is not a child of an else clause and it has no else clause.
  </summary>
  public readonly struct SimpleIfStatementInfo : IEquatable<SimpleIfStatementInfo>

    <summary>The condition.</summary>
    public ExpressionSyntax Condition { get; }
    <summary>The if statement.</summary>
    public IfStatementSyntax IfStatement { get; }
    <summary>The statement.</summary>
    public StatementSyntax Statement { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(SimpleIfStatementInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2);
    public static bool operator !=(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2);

  <summary>Provides information about invocation expression.</summary>
  public readonly struct SimpleMemberInvocationExpressionInfo : IEquatable<SimpleMemberInvocationExpressionInfo>

    <summary>The argumet list.</summary>
    public ArgumentListSyntax ArgumentList { get; }
    <summary>The list of the arguments.</summary>
    public SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
    <summary>The expression that contains the member being invoked.</summary>
    public ExpressionSyntax Expression { get; }
    <summary>The invocation expression.</summary>
    public InvocationExpressionSyntax InvocationExpression { get; }
    <summary>The member access expression.</summary>
    public MemberAccessExpressionSyntax MemberAccessExpression { get; }
    <summary>The name of the member being invoked.</summary>
    public SimpleNameSyntax Name { get; }
    <summary>The name of the member being invoked.</summary>
    public string NameText { get; }
    <summary>The operator in the member access expression.</summary>
    public SyntaxToken OperatorToken { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(SimpleMemberInvocationExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2);
    public static bool operator !=(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2);

  <summary>Provides information about invocation expression in an expression statement.</summary>
  public readonly struct SimpleMemberInvocationStatementInfo : IEquatable<SimpleMemberInvocationStatementInfo>

    <summary>The argument list.</summary>
    public ArgumentListSyntax ArgumentList { get; }
    <summary>A list of arguments.</summary>
    public SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
    <summary>The expression that contains the member being invoked.</summary>
    public ExpressionSyntax Expression { get; }
    <summary>The invocation expression.</summary>
    public InvocationExpressionSyntax InvocationExpression { get; }
    <summary>The member access expression.</summary>
    public MemberAccessExpressionSyntax MemberAccessExpression { get; }
    <summary>The name of the member being invoked.</summary>
    public SimpleNameSyntax Name { get; }
    <summary>The name of the member being invoked.</summary>
    public string NameText { get; }
    <summary>The expression statement that contains the invocation expression.</summary>
    public ExpressionStatementSyntax Statement { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(SimpleMemberInvocationStatementInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2);
    public static bool operator !=(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2);

  <summary>Provides information about a local declaration statement with a single variable.</summary>
  public readonly struct SingleLocalDeclarationStatementInfo : IEquatable<SingleLocalDeclarationStatementInfo>

    <summary>The variable declaration.</summary>
    public VariableDeclarationSyntax Declaration { get; }
    <summary>The variable declarator.</summary>
    public VariableDeclaratorSyntax Declarator { get; }
    <summary>The equals token.</summary>
    public SyntaxToken EqualsToken { get; }
    <summary>Variable identifier.</summary>
    public SyntaxToken Identifier { get; }
    <summary>Variable name.</summary>
    public string IdentifierText { get; }
    <summary>The variable initializer, if any.</summary>
    public EqualsValueClauseSyntax Initializer { get; }
    <summary>The modifier list.</summary>
    public SyntaxTokenList Modifiers { get; }
    <summary>The semicolon.</summary>
    public SyntaxToken SemicolonToken { get; }
    <summary>The local declaration statement.</summary>
    public LocalDeclarationStatementSyntax Statement { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>The type of a declaration.</summary>
    public TypeSyntax Type { get; }
    <summary>The initialized value, if any.</summary>
    public ExpressionSyntax Value { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(SingleLocalDeclarationStatementInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2);
    public static bool operator !=(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2);

  <summary>Provides information about a lambda expression with a single parameter.</summary>
  public readonly struct SingleParameterLambdaExpressionInfo : IEquatable<SingleParameterLambdaExpressionInfo>

    <summary>The body of the lambda expression.</summary>
    public CSharpSyntaxNode Body { get; }
    <summary>True if this instance is a parenthesized lambda expression.</summary>
    public bool IsParenthesizedLambda { get; }
    <summary>True if this instance is a simple lambda expression.</summary>
    public bool IsSimpleLambda { get; }
    <summary>The lambda expression.</summary>
    public LambdaExpressionSyntax LambdaExpression { get; }
    <summary>The parameter.</summary>
    public ParameterSyntax Parameter { get; }
    <summary>The parameter list that contains the parameter.</summary>
    public ParameterListSyntax ParameterList { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(SingleParameterLambdaExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2);
    public static bool operator !=(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2);

  <summary>Provides information about a list of statements.</summary>
  public readonly struct StatementListInfo : IEquatable<StatementListInfo>, IReadOnlyList<StatementSyntax>

    <summary>The number of statement in the list.</summary>
    public int Count { get; }
    <summary>Determines whether the statements are contained in a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" />.</summary>
    public bool IsParentBlock { get; }
    <summary>Determines whether the statements are contained in a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax" />.</summary>
    public bool IsParentSwitchSection { get; }
    <summary>The node that contains the statements. It can be either a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" /> or a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax" />.</summary>
    public SyntaxNode Parent { get; }
    <summary>Gets a block that contains the statements. Returns null if the statements are not contained in a block.</summary>
    public BlockSyntax ParentAsBlock { get; }
    <summary>Gets a switch section that contains the statements. Returns null if the statements are not contained in a switch section.</summary>
    public SwitchSectionSyntax ParentAsSwitchSection { get; }
    <summary>The list of statements.</summary>
    public SyntaxList<StatementSyntax> Statements { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Gets the statement at the specified index in the list.</summary>
    <returns>The statement at the specified index in the list.</returns>
    <param name="index">The zero-based index of the statement to get. </param>
    public StatementSyntax this[int index] { get; }

    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement added at the end.</summary>
    public StatementListInfo Add(StatementSyntax statement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statements added at the end.</summary>
    public StatementListInfo AddRange(IEnumerable<StatementSyntax> statements);
    <summary>True if the list has at least one statement.</summary>
    public bool Any();
    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(StatementListInfo other);
    <summary>The first statement in the list.</summary>
    public StatementSyntax First();
    <summary>The first statement in the list or null if the list is empty.</summary>
    public StatementSyntax FirstOrDefault();
    <summary>Gets the enumerator the list of statements.</summary>
    public SyntaxList<StatementSyntax>.Enumerator GetEnumerator();
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Searches for a statement that matches the predicate and returns returns zero-based index of the first occurrence in the list.</summary>
    public int IndexOf(Func<StatementSyntax, bool> predicate);
    <summary>The index of the statement in the list.</summary>
    public int IndexOf(StatementSyntax statement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement inserted at the index.</summary>
    public StatementListInfo Insert(int index, StatementSyntax statement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statements inserted at the index.</summary>
    public StatementListInfo InsertRange(int index, IEnumerable<StatementSyntax> statements);
    <summary>The last statement in the list.</summary>
    public StatementSyntax Last();
    <summary>Searches for a statement that matches the predicate and returns returns zero-based index of the last occurrence in the list.</summary>
    public int LastIndexOf(Func<StatementSyntax, bool> predicate);
    <summary>Searches for a statement and returns zero-based index of the last occurrence in the list.</summary>
    public int LastIndexOf(StatementSyntax statement);
    <summary>The last statement in the list or null if the list is empty.</summary>
    public StatementSyntax LastOrDefault();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement removed.</summary>
    public StatementListInfo Remove(StatementSyntax statement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the statement at the specified index removed.</summary>
    public StatementListInfo RemoveAt(int index);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified node removed.</summary>
    public StatementListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement replaced with the new statement.</summary>
    public StatementListInfo Replace(StatementSyntax statementInList, StatementSyntax newStatement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the statement at the specified index replaced with a new statement.</summary>
    public StatementListInfo ReplaceAt(int index, StatementSyntax newStatement);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified old node replaced with a new node.</summary>
    public StatementListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement replaced with new statements.</summary>
    public StatementListInfo ReplaceRange(StatementSyntax statementInList, IEnumerable<StatementSyntax> newStatements);
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the statements updated.</summary>
    public StatementListInfo WithStatements(IEnumerable<StatementSyntax> statements);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the statements updated.</summary>
    public StatementListInfo WithStatements(SyntaxList<StatementSyntax> statements);

    public static bool operator ==(in StatementListInfo info1, in StatementListInfo info2);
    public static bool operator !=(in StatementListInfo info1, in StatementListInfo info2);

  <summary>Provides information about string concatenation, i.e. a binary expression that binds to string '+' operator.</summary>
  public readonly struct StringConcatenationExpressionInfo : IEquatable<StringConcatenationExpressionInfo>

    <summary>The binary expression that represents the string concatenation.</summary>
    public BinaryExpressionSyntax BinaryExpression { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Returns <see cref="T:Roslynator.CSharp.ExpressionChain" /> that enables to enumerate expressions of a string concatenation.</summary>
    public ExpressionChain AsChain();
    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(StringConcatenationExpressionInfo other);
    <summary>Returns expressions of this binary expression, including expressions of nested binary expressions of the same kind as parent binary expression.</summary>
    <param name="leftToRight">If true expressions are enumerated as they are displayed in the source code.</param>
    [Obsolete("This method is obsolete. Use method 'AsChain' instead.")]
    public IEnumerable<ExpressionSyntax> Expressions(bool leftToRight = false);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2);
    public static bool operator !=(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2);

  <summary>Provides information about string literal expression.</summary>
  public readonly struct StringLiteralExpressionInfo : IEquatable<StringLiteralExpressionInfo>

    <summary>True if the string literal expression contains escape sequence.</summary>
    public bool ContainsEscapeSequence { get; }
    <summary>True if the string literal contains linefeed.</summary>
    public bool ContainsLinefeed { get; }
    <summary>The string literal expression.</summary>
    public LiteralExpressionSyntax Expression { get; }
    <summary>The token text, not including leading ampersand, if any, and enclosing quotation marks.</summary>
    public string InnerText { get; }
    <summary>True if this instance is regular string literal expression.</summary>
    public bool IsRegular { get; }
    <summary>True if this instance is verbatim string literal expression.</summary>
    public bool IsVerbatim { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>The token text.</summary>
    public string Text { get; }
    <summary>The token representing the string literal expression.</summary>
    public SyntaxToken Token { get; }
    <summary>The token value text.</summary>
    public string ValueText { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(StringLiteralExpressionInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2);
    public static bool operator !=(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2);

  <summary>Provides information about a list of using directives.</summary>
  public readonly struct UsingDirectiveListInfo : IEquatable<UsingDirectiveListInfo>, IReadOnlyList<UsingDirectiveSyntax>

    <summary>A number of usings in the list.</summary>
    public int Count { get; }
    <summary>The declaration that contains the usings.</summary>
    public SyntaxNode Parent { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }
    <summary>A list of usings.</summary>
    public SyntaxList<UsingDirectiveSyntax> Usings { get; }

    <summary>Gets the using directive at the specified index in the list.</summary>
    <returns>The using directive at the specified index in the list.</returns>
    <param name="index">The zero-based index of the using directive to get. </param>
    public UsingDirectiveSyntax this[int index] { get; }

    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive added at the end.</summary>
    public UsingDirectiveListInfo Add(UsingDirectiveSyntax usingDirective);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified usings added at the end.</summary>
    public UsingDirectiveListInfo AddRange(IEnumerable<UsingDirectiveSyntax> usings);
    <summary>True if the list has at least one using directive.</summary>
    public bool Any();
    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(UsingDirectiveListInfo other);
    <summary>The first using directive in the list.</summary>
    public UsingDirectiveSyntax First();
    <summary>The first using directive in the list or null if the list is empty.</summary>
    public UsingDirectiveSyntax FirstOrDefault();
    <summary>Gets the enumerator for the list of usings.</summary>
    public SyntaxList<UsingDirectiveSyntax>.Enumerator GetEnumerator();
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Searches for an using directive that matches the predicate and returns returns zero-based index of the first occurrence in the list.</summary>
    public int IndexOf(Func<UsingDirectiveSyntax, bool> predicate);
    <summary>The index of the using directive in the list.</summary>
    public int IndexOf(UsingDirectiveSyntax usingDirective);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive inserted at the index.</summary>
    public UsingDirectiveListInfo Insert(int index, UsingDirectiveSyntax usingDirective);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified usings inserted at the index.</summary>
    public UsingDirectiveListInfo InsertRange(int index, IEnumerable<UsingDirectiveSyntax> usings);
    <summary>The last using directive in the list.</summary>
    public UsingDirectiveSyntax Last();
    <summary>Searches for an using directive that matches the predicate and returns returns zero-based index of the last occurrence in the list.</summary>
    public int LastIndexOf(Func<UsingDirectiveSyntax, bool> predicate);
    <summary>Searches for an using directive and returns zero-based index of the last occurrence in the list.</summary>
    public int LastIndexOf(UsingDirectiveSyntax usingDirective);
    <summary>The last using directive in the list or null if the list is empty.</summary>
    public UsingDirectiveSyntax LastOrDefault();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive removed.</summary>
    public UsingDirectiveListInfo Remove(UsingDirectiveSyntax usingDirective);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the using directive at the specified index removed.</summary>
    public UsingDirectiveListInfo RemoveAt(int index);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified node removed.</summary>
    public UsingDirectiveListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive replaced with the new using directive.</summary>
    public UsingDirectiveListInfo Replace(UsingDirectiveSyntax usingInLine, UsingDirectiveSyntax newUsingDirective);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the using directive at the specified index replaced with a new using directive.</summary>
    public UsingDirectiveListInfo ReplaceAt(int index, UsingDirectiveSyntax newUsingDirective);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified old node replaced with a new node.</summary>
    public UsingDirectiveListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive replaced with new usings.</summary>
    public UsingDirectiveListInfo ReplaceRange(UsingDirectiveSyntax usingInLine, IEnumerable<UsingDirectiveSyntax> newUsingDirectives);
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the usings updated.</summary>
    public UsingDirectiveListInfo WithUsings(IEnumerable<UsingDirectiveSyntax> usings);
    <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the usings updated.</summary>
    public UsingDirectiveListInfo WithUsings(SyntaxList<UsingDirectiveSyntax> usings);

    public static bool operator ==(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2);
    public static bool operator !=(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2);

  <summary>Provides information about a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax" /> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax" />.</summary>
  public readonly struct XmlElementInfo : IEquatable<XmlElementInfo>

    <summary>The xml element.</summary>
    public XmlNodeSyntax Element { get; }
    <summary>Determines whether the element is <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlEmptyElement" />.</summary>
    public bool IsEmptyElement { get; }
    <summary>Element kind.</summary>
    public SyntaxKind Kind { get; }
    <summary>Local name of the element.</summary>
    public string LocalName { get; }
    <summary>Determines whether this struct was initialized with an actual syntax.</summary>
    public bool Success { get; }

    <summary>Determines whether this instance and a specified object are equal.</summary>
    <param name="obj">The object to compare with the current instance. </param>
    <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
    public override bool Equals(object obj);
    <summary>Determines whether this instance is equal to another object of the same type.</summary>
    <param name="other">An object to compare with this object.</param>
    <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
    public bool Equals(XmlElementInfo other);
    <summary>Returns the hash code for this instance.</summary>
    <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
    public override int GetHashCode();
    <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
    public override string ToString();

    public static bool operator ==(in XmlElementInfo info1, in XmlElementInfo info2);
    public static bool operator !=(in XmlElementInfo info1, in XmlElementInfo info2);

namespace Roslynator.Text

  <summary>Represents selected lines in a <see cref="T:Microsoft.CodeAnalysis.Text.TextLineCollection" />.</summary>
  public class TextLineCollectionSelection : ISelection<TextLine>

    <summary>Initializes a new instance of <see cref="T:Roslynator.Text.TextLineCollectionSelection" />.</summary>
    protected TextLineCollectionSelection(TextLineCollection lines, TextSpan span, int firstIndex, int lastIndex);

    <summary>Gets a number of selected lines.</summary>
    public int Count { get; }
    <summary>Gets an index of the first selected line.</summary>
    public int FirstIndex { get; }
    <summary>Gets an index of the last selected line.</summary>
    public int LastIndex { get; }
    <summary>Gets the original span that was used to determine selected lines.</summary>
    public TextSpan OriginalSpan { get; }
    <summary>Gets an underlying collection that contains selected lines.</summary>
    public TextLineCollection UnderlyingLines { get; }

    <summary>Gets the selected line at the specified index.</summary>
    <returns>The line at the specified index.</returns>
    <param name="index">The zero-based index of the line to get. </param>
    public TextLine this[int index] { get; }

    <summary>Creates a new <see cref="T:Roslynator.Text.TextLineCollectionSelection" /> based on the specified list and span.</summary>
    public static TextLineCollectionSelection Create(TextLineCollection lines, TextSpan span);
    <summary>Gets the first selected line.</summary>
    public TextLine First();
    <summary>Returns an enumerator that iterates through selected lines.</summary>
    public TextLineCollectionSelection.Enumerator GetEnumerator();
    <summary>Gets the last selected line.</summary>
    public TextLine Last();
    <summary>Creates a new <see cref="T:Roslynator.Text.TextLineCollectionSelection" /> based on the specified list and span.</summary>
    <returns>True if the specified span contains at least one line; otherwise, false.</returns>
    public static bool TryCreate(TextLineCollection lines, TextSpan span, out TextLineCollectionSelection selectedLines);

    public struct Enumerator

      public TextLine Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();
