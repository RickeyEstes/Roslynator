* assembly Microsoft\.CodeAnalysis, Version=2\.3\.0\.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
* &emsp; \[AssemblyCompany\("Microsoft Corporation"\)\]
* &emsp; \[AssemblyCopyright\("© Microsoft Corporation\. All rights reserved\."\)\]
* &emsp; \[AssemblyFileVersion\("2\.3\.0\.61908"\)\]
* &emsp; \[AssemblyInformationalVersion\("2\.3\.0\-beta4\-61908\-01\. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c"\)\]
* &emsp; \[AssemblyMetadata\("Serviceable", "True"\)\]
* &emsp; \[RuntimeCompatibility\(WrapNonExceptionThrows = true\)\]
* &emsp; \[TargetFramework\("\.NETStandard,Version=v1\.3", FrameworkDisplayName = ""\)\]
* assembly Microsoft\.CodeAnalysis\.CSharp, Version=2\.3\.0\.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
* &emsp; \[AssemblyCompany\("Microsoft Corporation"\)\]
* &emsp; \[AssemblyCopyright\("© Microsoft Corporation\. All rights reserved\."\)\]
* &emsp; \[AssemblyFileVersion\("2\.3\.0\.61908"\)\]
* &emsp; \[AssemblyInformationalVersion\("2\.3\.0\-beta4\-61908\-01\. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c"\)\]
* &emsp; \[AssemblyMetadata\("Serviceable", "True"\)\]
* &emsp; \[CommitHash\("281ac90b8b5dd9fd923a353afd4af74f3246ca5c"\)\]
* &emsp; \[RuntimeCompatibility\(WrapNonExceptionThrows = true\)\]
* &emsp; \[TargetFramework\("\.NETStandard,Version=v1\.3", FrameworkDisplayName = ""\)\]
* assembly Microsoft\.CodeAnalysis\.CSharp\.Workspaces, Version=2\.3\.0\.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
* &emsp; \[AssemblyCompany\("Microsoft Corporation"\)\]
* &emsp; \[AssemblyCopyright\("© Microsoft Corporation\. All rights reserved\."\)\]
* &emsp; \[AssemblyFileVersion\("2\.3\.0\.61908"\)\]
* &emsp; \[AssemblyInformationalVersion\("2\.3\.0\-beta4\-61908\-01\. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c"\)\]
* &emsp; \[AssemblyMetadata\("Serviceable", "True"\)\]
* &emsp; \[RuntimeCompatibility\(WrapNonExceptionThrows = true\)\]
* &emsp; \[TargetFramework\("\.NETStandard,Version=v1\.3", FrameworkDisplayName = ""\)\]
* assembly Microsoft\.CodeAnalysis\.Workspaces, Version=2\.3\.0\.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
* &emsp; \[AssemblyCompany\("Microsoft Corporation"\)\]
* &emsp; \[AssemblyCopyright\("© Microsoft Corporation\. All rights reserved\."\)\]
* &emsp; \[AssemblyFileVersion\("2\.3\.0\.61908"\)\]
* &emsp; \[AssemblyInformationalVersion\("2\.3\.0\-beta4\-61908\-01\. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c"\)\]
* &emsp; \[AssemblyMetadata\("Serviceable", "True"\)\]
* &emsp; \[RuntimeCompatibility\(WrapNonExceptionThrows = true\)\]
* &emsp; \[TargetFramework\("\.NETStandard,Version=v1\.3", FrameworkDisplayName = ""\)\]
* assembly Roslynator\.Core, Version=1\.0\.0\.10, Culture=neutral, PublicKeyToken=3aeedfaf14b2cebf
* &emsp; \[AssemblyCompany\("Josef Pihrt"\)\]
* &emsp; \[AssemblyConfiguration\("Debug"\)\]
* &emsp; \[AssemblyCopyright\("Copyright \(c\) 2017\-2018 Josef Pihrt"\)\]
* &emsp; \[AssemblyDescription\("This library extends functionality of package Microsoft\.CodeAnalysis\.Common\."\)\]
* &emsp; \[AssemblyFileVersion\("1\.0\.0\.10"\)\]
* &emsp; \[AssemblyInformationalVersion\("1\.0\.0\.10"\)\]
* &emsp; \[AssemblyProduct\("Roslynator\.Core"\)\]
* &emsp; \[AssemblyTitle\("Roslynator\.Core"\)\]
* &emsp; \[AssemblyVersion\("1\.0\.0\.10"\)\]
* &emsp; \[TargetFramework\("\.NETStandard,Version=v1\.3", FrameworkDisplayName = ""\)\]
* assembly Roslynator\.CSharp, Version=1\.0\.0\.10, Culture=neutral, PublicKeyToken=390be46f77b79f52
* &emsp; \[AssemblyCompany\("Josef Pihrt"\)\]
* &emsp; \[AssemblyConfiguration\("Debug"\)\]
* &emsp; \[AssemblyCopyright\("Copyright \(c\) 2017\-2018 Josef Pihrt"\)\]
* &emsp; \[AssemblyDescription\("This library extends functionality of package Microsoft\.CodeAnalysis\.CSharp\\n\\nCommonly Used Types:\\nRoslynator\.CSharp\.CSharpFactory\\nRoslynator\.CSharp\.CSharpFacts\\nRoslynator\.CSharp\.SyntaxInfo\\nRoslynator\.NameGenerator"\)\]
* &emsp; \[AssemblyFileVersion\("1\.0\.0\.10"\)\]
* &emsp; \[AssemblyInformationalVersion\("1\.0\.0\.10"\)\]
* &emsp; \[AssemblyProduct\("Roslynator\.CSharp"\)\]
* &emsp; \[AssemblyTitle\("Roslynator\.CSharp"\)\]
* &emsp; \[AssemblyVersion\("1\.0\.0\.10"\)\]
* &emsp; \[TargetFramework\("\.NETStandard,Version=v1\.3", FrameworkDisplayName = ""\)\]
* assembly Roslynator\.CSharp\.Workspaces, Version=1\.0\.0\.10, Culture=neutral, PublicKeyToken=ec3f0c29a7973f23
* &emsp; \[AssemblyCompany\("Josef Pihrt"\)\]
* &emsp; \[AssemblyConfiguration\("Debug"\)\]
* &emsp; \[AssemblyCopyright\("Copyright \(c\) 2017\-2018 Josef Pihrt"\)\]
* &emsp; \[AssemblyDescription\("This library extends functionality of package Microsoft\.CodeAnalysis\.CSharp\.Workspaces\\n\\nCommonly Used Types:\\nRoslynator\.CSharp\.CSharpFactory\\nRoslynator\.CSharp\.CSharpFacts\\nRoslynator\.CSharp\.SyntaxInfo\\nRoslynator\.NameGenerator"\)\]
* &emsp; \[AssemblyFileVersion\("1\.0\.0\.10"\)\]
* &emsp; \[AssemblyInformationalVersion\("1\.0\.0\.10"\)\]
* &emsp; \[AssemblyProduct\("Roslynator\.CSharp\.Workspaces"\)\]
* &emsp; \[AssemblyTitle\("Roslynator\.CSharp\.Workspaces"\)\]
* &emsp; \[AssemblyVersion\("1\.0\.0\.10"\)\]
* &emsp; \[TargetFramework\("\.NETStandard,Version=v1\.3", FrameworkDisplayName = ""\)\]
* assembly Roslynator\.Workspaces\.Core, Version=1\.0\.0\.10, Culture=neutral, PublicKeyToken=be1ec334fe31b7bb
* &emsp; \[AssemblyCompany\("Josef Pihrt"\)\]
* &emsp; \[AssemblyConfiguration\("Debug"\)\]
* &emsp; \[AssemblyCopyright\("Copyright \(c\) 2017\-2018 Josef Pihrt"\)\]
* &emsp; \[AssemblyDescription\("This library extends functionality of package Microsoft\.CodeAnalysis\.Workspaces\.Common\."\)\]
* &emsp; \[AssemblyFileVersion\("1\.0\.0\.10"\)\]
* &emsp; \[AssemblyInformationalVersion\("1\.0\.0\.10"\)\]
* &emsp; \[AssemblyProduct\("Roslynator\.Workspaces\.Core"\)\]
* &emsp; \[AssemblyTitle\("Roslynator\.Workspaces\.Core"\)\]
* &emsp; \[AssemblyVersion\("1\.0\.0\.10"\)\]
* &emsp; \[TargetFramework\("\.NETStandard,Version=v1\.3", FrameworkDisplayName = ""\)\]
* public class System\.Object
* &emsp; public abstract class System\.Attribute
* &emsp; \| &emsp; public class System\.Composition\.ExportAttribute : Attribute
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CodeFixes\.ExportCodeFixProviderAttribute : ExportAttribute
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExportCodeFixProviderAttribute\(string firstLanguage, params string\[\] additionalLanguages\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string\[\] Languages \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string Name \{ get; set; \}
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CodeRefactorings\.ExportCodeRefactoringProviderAttribute : ExportAttribute
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExportCodeRefactoringProviderAttribute\(string firstLanguage, params string\[\] additionalLanguages\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string\[\] Languages \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string Name \{ get; set; \}
* &emsp; \| &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.Host\.Mef\.ExportLanguageServiceAttribute : ExportAttribute
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExportLanguageServiceAttribute\(Type type, string language, string layer = "Default"\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string Layer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string ServiceType \{ get; \}
* &emsp; \| &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.Host\.Mef\.ExportLanguageServiceFactoryAttribute : ExportAttribute
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExportLanguageServiceFactoryAttribute\(Type type, string language, string layer = "Default"\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string Layer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string ServiceType \{ get; \}
* &emsp; \| &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.Host\.Mef\.ExportWorkspaceServiceAttribute : ExportAttribute
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExportWorkspaceServiceAttribute\(Type serviceType, string layer = "Default"\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string Layer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string ServiceType \{ get; \}
* &emsp; \| &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.Host\.Mef\.ExportWorkspaceServiceFactoryAttribute : ExportAttribute
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExportWorkspaceServiceFactoryAttribute\(Type serviceType, string layer = "Default"\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string Layer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public string ServiceType \{ get; \}
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.ExtensionOrderAttribute : Attribute
* &emsp; \| &emsp; \| &emsp; public ExtensionOrderAttribute\(\);
* &emsp; \| &emsp; \| &emsp; public string After \{ get; set; \}
* &emsp; \| &emsp; \| &emsp; public string Before \{ get; set; \}
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.DiagnosticAnalyzerAttribute : Attribute
* &emsp; \| &emsp; \| &emsp; public DiagnosticAnalyzerAttribute\(string firstLanguage, params string\[\] additionalLanguages\);
* &emsp; \| &emsp; \| &emsp; public string\[\] Languages \{ get; \}
* &emsp; public abstract class System\.Delegate
* &emsp; \| &emsp; public abstract class System\.MulticastDelegate : Delegate
* &emsp; \| &emsp; \| &emsp; public delegate Task Microsoft\.CodeAnalysis\.Editing\.SymbolEditor\.AsyncDeclarationEditAction\(DocumentEditor editor, SyntaxNode declaration, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public delegate void Microsoft\.CodeAnalysis\.Editing\.SymbolEditor\.DeclarationEditAction\(DocumentEditor editor, SyntaxNode declaration\);
* &emsp; \| &emsp; \| &emsp; public delegate bool Microsoft\.CodeAnalysis\.Host\.HostWorkspaceServices\.MetadataFilter\(IReadOnlyDictionary\<string, object> metadata\);
* &emsp; public class System\.EventArgs
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.DocumentActiveContextChangedEventArgs : EventArgs
* &emsp; \| &emsp; \| &emsp; public DocumentActiveContextChangedEventArgs\(Solution solution, SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId\);
* &emsp; \| &emsp; \| &emsp; public DocumentId NewActiveContextDocumentId \{ get; \}
* &emsp; \| &emsp; \| &emsp; public DocumentId OldActiveContextDocumentId \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Solution Solution \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SourceTextContainer SourceTextContainer \{ get; \}
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.DocumentEventArgs : EventArgs
* &emsp; \| &emsp; \| &emsp; public DocumentEventArgs\(Document document\);
* &emsp; \| &emsp; \| &emsp; public Document Document \{ get; \}
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.WorkspaceChangeEventArgs : EventArgs
* &emsp; \| &emsp; \| &emsp; public WorkspaceChangeEventArgs\(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId = null, DocumentId documentId = null\);
* &emsp; \| &emsp; \| &emsp; public DocumentId DocumentId \{ get; \}
* &emsp; \| &emsp; \| &emsp; public WorkspaceChangeKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Solution NewSolution \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Solution OldSolution \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ProjectId ProjectId \{ get; \}
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.WorkspaceDiagnosticEventArgs : EventArgs
* &emsp; \| &emsp; \| &emsp; public WorkspaceDiagnosticEventArgs\(WorkspaceDiagnostic diagnostic\);
* &emsp; \| &emsp; \| &emsp; public WorkspaceDiagnostic Diagnostic \{ get; \}
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.AnalyzerLoadFailureEventArgs : EventArgs
* &emsp; \| &emsp; \| &emsp; public AnalyzerLoadFailureEventArgs\(AnalyzerLoadFailureEventArgs\.FailureErrorCode errorCode, string message, Exception exceptionOpt = null, string typeNameOpt = null\);
* &emsp; \| &emsp; \| &emsp; public AnalyzerLoadFailureEventArgs\.FailureErrorCode ErrorCode \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Exception Exception \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Message \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string TypeName \{ get; \}
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.Text\.TextChangeEventArgs : EventArgs
* &emsp; \| &emsp; \| &emsp; public TextChangeEventArgs\(SourceText oldText, SourceText newText, IEnumerable\<TextChangeRange> changes\);
* &emsp; \| &emsp; \| &emsp; public TextChangeEventArgs\(SourceText oldText, SourceText newText, params TextChangeRange\[\] changes\);
* &emsp; \| &emsp; \| &emsp; public IReadOnlyList\<TextChangeRange> Changes \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SourceText NewText \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SourceText OldText \{ get; \}
* &emsp; public abstract class System\.ValueType
* &emsp; \| &emsp; public abstract class System\.Enum : ValueType, IComparable, IConvertible, IFormattable
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Accessibility
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotApplicable = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Private = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProtectedAndInternal = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProtectedAndFriend = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Protected = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Internal = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Friend = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProtectedOrInternal = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProtectedOrFriend = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Public = 6,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.ApplyChangesKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddProject = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveProject = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddProjectReference = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveProjectReference = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddMetadataReference = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveMetadataReference = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddDocument = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveDocument = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ChangeDocument = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddAnalyzerReference = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveAnalyzerReference = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddAdditionalDocument = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveAdditionalDocument = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ChangeAdditionalDocument = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ChangeCompilationOptions = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ChangeParseOptions = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ChangeDocumentInfo = 16,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.AssemblyIdentityComparer\.ComparisonResult
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotEquivalent = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Equivalent = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EquivalentIgnoringVersion = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.AssemblyIdentityParts
* &emsp; \| &emsp; \| &emsp; \| &emsp; Name = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Version = VersionMajor \| VersionMinor \| VersionBuild \| VersionRevision,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VersionMajor = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VersionMinor = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VersionBuild = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VersionRevision = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Culture = 32,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PublicKey = 64,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PublicKeyToken = 128,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PublicKeyOrToken = PublicKey \| PublicKeyToken,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Retargetability = 256,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ContentType = 512,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Unknown = 1024,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.CandidateReason
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotATypeOrNamespace = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotAnEvent = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotAWithEventsMember = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotAnAttributeType = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WrongArity = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotCreatable = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotReferencable = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Inaccessible = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotAValue = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotAVariable = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotInvocable = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StaticInstanceMismatch = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OverloadResolutionFailure = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LateBound = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Ambiguous = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MemberGroup = 16,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.DiagnosticSeverity
* &emsp; \| &emsp; \| &emsp; \| &emsp; Hidden = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Info = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Warning = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Error = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.DocumentationMode
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Parse = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Diagnose = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.LineVisibility
* &emsp; \| &emsp; \| &emsp; \| &emsp; BeforeFirstLineDirective = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Hidden = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Visible = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.LocationKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SourceFile = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MetadataFile = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlFile = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExternalFile = 4,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.MetadataImageKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Assembly = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Module = 1,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.MethodKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; AnonymousFunction = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LambdaMethod = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Constructor = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Conversion = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DelegateInvoke = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Destructor = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventAdd = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventRaise = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventRemove = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExplicitInterfaceImplementation = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UserDefinedOperator = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Ordinary = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PropertyGet = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PropertySet = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReducedExtension = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StaticConstructor = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SharedConstructor = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BuiltinOperator = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DeclareMethod = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LocalFunction = 17,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.NamespaceKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Module = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Assembly = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Compilation = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.OperationKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InvalidStatement = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BlockStatement = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VariableDeclarationStatement = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SwitchStatement = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IfStatement = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LoopStatement = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LabelStatement = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BranchStatement = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EmptyStatement = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ThrowStatement = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReturnStatement = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; YieldBreakStatement = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LockStatement = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TryStatement = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UsingStatement = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; YieldReturnStatement = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExpressionStatement = 17,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FixedStatement = 48,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LocalFunctionStatement = 49,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StopStatement = 80,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndStatement = 81,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WithStatement = 82,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InvalidExpression = 256,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LiteralExpression = 257,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConversionExpression = 258,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InvocationExpression = 259,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrayElementReferenceExpression = 260,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LocalReferenceExpression = 261,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParameterReferenceExpression = 262,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SyntheticLocalReferenceExpression = 263,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FieldReferenceExpression = 264,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MethodBindingExpression = 265,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PropertyReferenceExpression = 266,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IndexedPropertyReferenceExpression = 267,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventReferenceExpression = 268,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnaryOperatorExpression = 269,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BinaryOperatorExpression = 270,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConditionalChoiceExpression = 271,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NullCoalescingExpression = 272,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LambdaExpression = 273,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectCreationExpression = 274,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameterObjectCreationExpression = 275,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrayCreationExpression = 276,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InstanceReferenceExpression = 277,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IsTypeExpression = 278,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AwaitExpression = 279,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AssignmentExpression = 280,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CompoundAssignmentExpression = 281,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParenthesizedExpression = 282,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventAssignmentExpression = 283,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConditionalAccessExpression = 284,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConditionalAccessInstanceExpression = 285,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DefaultValueExpression = 512,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeOfExpression = 513,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SizeOfExpression = 514,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddressOfExpression = 515,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerIndirectionReferenceExpression = 516,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnboundLambdaExpression = 517,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncrementExpression = 518,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OmittedArgumentExpression = 768,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LateBoundMemberReferenceExpression = 769,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PlaceholderExpression = 770,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FieldInitializerInCreation = 1024,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FieldInitializerAtDeclaration = 1025,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PropertyInitializerInCreation = 1026,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PropertyInitializerAtDeclaration = 1027,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParameterInitializerAtDeclaration = 1028,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrayInitializer = 1029,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VariableDeclaration = 1030,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Argument = 1031,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CatchClause = 1032,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SwitchCase = 1033,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SingleValueCaseClause = 1034,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RelationalCaseClause = 1035,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RangeCaseClause = 1036,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.OptimizationLevel
* &emsp; \| &emsp; \| &emsp; \| &emsp; Debug = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Release = 1,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.OutputKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConsoleApplication = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WindowsApplication = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicallyLinkedLibrary = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NetModule = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WindowsRuntimeMetadata = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WindowsRuntimeApplication = 5,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Platform
* &emsp; \| &emsp; \| &emsp; \| &emsp; AnyCpu = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; X86 = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; X64 = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Itanium = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AnyCpu32BitPreferred = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Arm = 5,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.PreservationMode
* &emsp; \| &emsp; \| &emsp; \| &emsp; PreserveValue = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PreserveIdentity = 1,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.RefKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Ref = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Out = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.ReportDiagnostic
* &emsp; \| &emsp; \| &emsp; \| &emsp; Default = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Error = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Warn = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Info = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Hidden = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Suppress = 5,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SourceCodeKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Regular = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Script = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Interactive = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SpecialType
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Object = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Enum = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_MulticastDelegate = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Delegate = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_ValueType = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Void = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Boolean = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Char = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_SByte = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Byte = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Int16 = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_UInt16 = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Int32 = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_UInt32 = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Int64 = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_UInt64 = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Decimal = 17,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Single = 18,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Double = 19,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_String = 20,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_IntPtr = 21,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_UIntPtr = 22,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Array = 23,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Collections\_IEnumerable = 24,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Collections\_Generic\_IEnumerable\_T = 25,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Collections\_Generic\_IList\_T = 26,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Collections\_Generic\_ICollection\_T = 27,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Collections\_IEnumerator = 28,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Collections\_Generic\_IEnumerator\_T = 29,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Collections\_Generic\_IReadOnlyList\_T = 30,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Collections\_Generic\_IReadOnlyCollection\_T = 31,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Nullable\_T = 32,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_DateTime = 33,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_Runtime\_CompilerServices\_IsVolatile = 34,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_IDisposable = 35,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_TypedReference = 36,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_ArgIterator = 37,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_RuntimeArgumentHandle = 38,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_RuntimeFieldHandle = 39,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_RuntimeMethodHandle = 40,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_RuntimeTypeHandle = 41,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_IAsyncResult = 42,
* &emsp; \| &emsp; \| &emsp; \| &emsp; System\_AsyncCallback = 43,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Count = 43,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SpeculativeBindingOption
* &emsp; \| &emsp; \| &emsp; \| &emsp; BindAsExpression = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BindAsTypeOrNamespace = 1,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayDelegateStyle
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameOnly = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameAndParameters = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameAndSignature = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayExtensionMethodStyle
* &emsp; \| &emsp; \| &emsp; \| &emsp; Default = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InstanceMethod = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StaticMethod = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayGenericsOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeTypeParameters = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeTypeConstraints = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeVariance = 4,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayGlobalNamespaceStyle
* &emsp; \| &emsp; \| &emsp; \| &emsp; Omitted = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OmittedAsContaining = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Included = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayKindOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeNamespaceKeyword = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeTypeKeyword = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeMemberKeyword = 4,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayLocalOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeType = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeConstantValue = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeRef = 4,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayMemberOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeType = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeModifiers = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeAccessibility = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeExplicitInterface = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeParameters = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeContainingType = 32,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeConstantValue = 64,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeRef = 128,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayMiscellaneousOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UseSpecialTypes = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EscapeKeywordIdentifiers = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UseAsterisksInMultiDimensionalArrays = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UseErrorTypeSymbolName = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveAttributeSuffix = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExpandNullable = 32,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayParameterOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeExtensionThis = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeParamsRefOut = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeType = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeName = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeDefaultValue = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncludeOptionalBrackets = 32,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayPartKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; AliasName = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AssemblyName = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ClassName = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DelegateName = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumName = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ErrorTypeName = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventName = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FieldName = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterfaceName = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Keyword = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LabelName = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LineBreak = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NumericLiteral = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StringLiteral = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LocalName = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MethodName = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ModuleName = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NamespaceName = 17,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Operator = 18,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParameterName = 19,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PropertyName = 20,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Punctuation = 21,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Space = 22,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StructName = 23,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AnonymousTypeIndicator = 24,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Text = 25,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameterName = 26,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RangeVariableName = 27,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayPropertyStyle
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameOnly = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ShowReadWriteDescriptor = 1,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolDisplayTypeQualificationStyle
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameOnly = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameAndContainingTypes = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameAndContainingTypesAndNamespaces = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolFilter
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Namespace = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Type = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Member = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeAndMember = Type \| Member,
* &emsp; \| &emsp; \| &emsp; \| &emsp; All = Namespace \| TypeAndMember,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SymbolKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Alias = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrayType = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Assembly = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicType = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ErrorType = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Event = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Field = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Label = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Local = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Method = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NetModule = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NamedType = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Namespace = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Parameter = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerType = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Property = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RangeVariable = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameter = 17,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Preprocessing = 18,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Discard = 19,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SyntaxRemoveOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; KeepNoTrivia = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; KeepLeadingTrivia = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; KeepTrailingTrivia = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; KeepExteriorTrivia = KeepLeadingTrivia \| KeepTrailingTrivia,
* &emsp; \| &emsp; \| &emsp; \| &emsp; KeepUnbalancedDirectives = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; KeepDirectives = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; KeepEndOfLine = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddElasticMarker = 32,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.SyntaxWalkerDepth
* &emsp; \| &emsp; \| &emsp; \| &emsp; Node = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Token = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Trivia = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StructuredTrivia = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.TypeKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Unknown = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Array = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Class = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Delegate = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Dynamic = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Enum = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Error = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Interface = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Module = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Pointer = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Struct = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Structure = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameter = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Submission = 12,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.TypeParameterKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Type = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Method = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Cref = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.TypedConstantKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Error = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Primitive = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Enum = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Type = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Array = 4,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.VarianceKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Out = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; In = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.WorkspaceChangeKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; SolutionChanged = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SolutionAdded = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SolutionRemoved = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SolutionCleared = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SolutionReloaded = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProjectAdded = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProjectRemoved = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProjectChanged = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProjectReloaded = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DocumentAdded = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DocumentRemoved = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DocumentReloaded = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DocumentChanged = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AdditionalDocumentAdded = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AdditionalDocumentRemoved = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AdditionalDocumentReloaded = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AdditionalDocumentChanged = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DocumentInfoChanged = 17,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.WorkspaceDiagnosticKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Failure = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Warning = 1,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.CSharp\.LanguageVersion
* &emsp; \| &emsp; \| &emsp; \| &emsp; Default = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp1 = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp2 = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp3 = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp4 = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp5 = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp6 = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp7 = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp7\_1 = 701,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Latest = 2147483647,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.CSharp\.SyntaxKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; List = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TildeToken = 8193,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExclamationToken = 8194,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DollarToken = 8195,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PercentToken = 8196,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CaretToken = 8197,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AmpersandToken = 8198,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AsteriskToken = 8199,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OpenParenToken = 8200,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CloseParenToken = 8201,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MinusToken = 8202,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PlusToken = 8203,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EqualsToken = 8204,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OpenBraceToken = 8205,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CloseBraceToken = 8206,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OpenBracketToken = 8207,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CloseBracketToken = 8208,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BarToken = 8209,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BackslashToken = 8210,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ColonToken = 8211,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SemicolonToken = 8212,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DoubleQuoteToken = 8213,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SingleQuoteToken = 8214,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanToken = 8215,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CommaToken = 8216,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThanToken = 8217,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DotToken = 8218,
* &emsp; \| &emsp; \| &emsp; \| &emsp; QuestionToken = 8219,
* &emsp; \| &emsp; \| &emsp; \| &emsp; HashToken = 8220,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SlashToken = 8221,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SlashGreaterThanToken = 8232,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanSlashToken = 8233,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlCommentStartToken = 8234,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlCommentEndToken = 8235,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlCDataStartToken = 8236,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlCDataEndToken = 8237,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlProcessingInstructionStartToken = 8238,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlProcessingInstructionEndToken = 8239,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BarBarToken = 8260,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AmpersandAmpersandToken = 8261,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MinusMinusToken = 8262,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PlusPlusToken = 8263,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ColonColonToken = 8264,
* &emsp; \| &emsp; \| &emsp; \| &emsp; QuestionQuestionToken = 8265,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MinusGreaterThanToken = 8266,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExclamationEqualsToken = 8267,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EqualsEqualsToken = 8268,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EqualsGreaterThanToken = 8269,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanEqualsToken = 8270,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanLessThanToken = 8271,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanLessThanEqualsToken = 8272,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThanEqualsToken = 8273,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThanGreaterThanToken = 8274,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThanGreaterThanEqualsToken = 8275,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SlashEqualsToken = 8276,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AsteriskEqualsToken = 8277,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BarEqualsToken = 8278,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AmpersandEqualsToken = 8279,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PlusEqualsToken = 8280,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MinusEqualsToken = 8281,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CaretEqualsToken = 8282,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PercentEqualsToken = 8283,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BoolKeyword = 8304,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ByteKeyword = 8305,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SByteKeyword = 8306,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ShortKeyword = 8307,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UShortKeyword = 8308,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntKeyword = 8309,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UIntKeyword = 8310,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LongKeyword = 8311,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ULongKeyword = 8312,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DoubleKeyword = 8313,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatKeyword = 8314,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalKeyword = 8315,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StringKeyword = 8316,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CharKeyword = 8317,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VoidKeyword = 8318,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectKeyword = 8319,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeOfKeyword = 8320,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SizeOfKeyword = 8321,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NullKeyword = 8322,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TrueKeyword = 8323,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FalseKeyword = 8324,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IfKeyword = 8325,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ElseKeyword = 8326,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WhileKeyword = 8327,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ForKeyword = 8328,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ForEachKeyword = 8329,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DoKeyword = 8330,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SwitchKeyword = 8331,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CaseKeyword = 8332,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DefaultKeyword = 8333,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TryKeyword = 8334,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CatchKeyword = 8335,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FinallyKeyword = 8336,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LockKeyword = 8337,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GotoKeyword = 8338,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BreakKeyword = 8339,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ContinueKeyword = 8340,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReturnKeyword = 8341,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ThrowKeyword = 8342,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PublicKeyword = 8343,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PrivateKeyword = 8344,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InternalKeyword = 8345,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ProtectedKeyword = 8346,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StaticKeyword = 8347,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReadOnlyKeyword = 8348,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SealedKeyword = 8349,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConstKeyword = 8350,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FixedKeyword = 8351,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StackAllocKeyword = 8352,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VolatileKeyword = 8353,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NewKeyword = 8354,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OverrideKeyword = 8355,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AbstractKeyword = 8356,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VirtualKeyword = 8357,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventKeyword = 8358,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExternKeyword = 8359,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RefKeyword = 8360,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OutKeyword = 8361,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InKeyword = 8362,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IsKeyword = 8363,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AsKeyword = 8364,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParamsKeyword = 8365,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArgListKeyword = 8366,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MakeRefKeyword = 8367,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RefTypeKeyword = 8368,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RefValueKeyword = 8369,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ThisKeyword = 8370,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BaseKeyword = 8371,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NamespaceKeyword = 8372,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UsingKeyword = 8373,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ClassKeyword = 8374,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StructKeyword = 8375,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterfaceKeyword = 8376,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumKeyword = 8377,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DelegateKeyword = 8378,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CheckedKeyword = 8379,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UncheckedKeyword = 8380,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsafeKeyword = 8381,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorKeyword = 8382,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExplicitKeyword = 8383,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ImplicitKeyword = 8384,
* &emsp; \| &emsp; \| &emsp; \| &emsp; YieldKeyword = 8405,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PartialKeyword = 8406,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AliasKeyword = 8407,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GlobalKeyword = 8408,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AssemblyKeyword = 8409,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ModuleKeyword = 8410,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeKeyword = 8411,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FieldKeyword = 8412,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MethodKeyword = 8413,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParamKeyword = 8414,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PropertyKeyword = 8415,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeVarKeyword = 8416,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GetKeyword = 8417,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SetKeyword = 8418,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddKeyword = 8419,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveKeyword = 8420,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WhereKeyword = 8421,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FromKeyword = 8422,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GroupKeyword = 8423,
* &emsp; \| &emsp; \| &emsp; \| &emsp; JoinKeyword = 8424,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntoKeyword = 8425,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LetKeyword = 8426,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ByKeyword = 8427,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SelectKeyword = 8428,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OrderByKeyword = 8429,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OnKeyword = 8430,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EqualsKeyword = 8431,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AscendingKeyword = 8432,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DescendingKeyword = 8433,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameOfKeyword = 8434,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AsyncKeyword = 8435,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AwaitKeyword = 8436,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WhenKeyword = 8437,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ElifKeyword = 8467,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndIfKeyword = 8468,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RegionKeyword = 8469,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndRegionKeyword = 8470,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DefineKeyword = 8471,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UndefKeyword = 8472,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WarningKeyword = 8473,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ErrorKeyword = 8474,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LineKeyword = 8475,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PragmaKeyword = 8476,
* &emsp; \| &emsp; \| &emsp; \| &emsp; HiddenKeyword = 8477,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ChecksumKeyword = 8478,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DisableKeyword = 8479,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RestoreKeyword = 8480,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReferenceKeyword = 8481,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LoadKeyword = 8485,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolatedStringStartToken = 8482,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolatedStringEndToken = 8483,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolatedVerbatimStringStartToken = 8484,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnderscoreToken = 8491,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OmittedTypeArgumentToken = 8492,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OmittedArraySizeExpressionToken = 8493,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndOfDirectiveToken = 8494,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndOfDocumentationCommentToken = 8495,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndOfFileToken = 8496,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BadToken = 8507,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IdentifierToken = 8508,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NumericLiteralToken = 8509,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CharacterLiteralToken = 8510,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StringLiteralToken = 8511,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlEntityLiteralToken = 8512,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlTextLiteralToken = 8513,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlTextLiteralNewLineToken = 8514,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolatedStringToken = 8515,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolatedStringTextToken = 8517,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndOfLineTrivia = 8539,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WhitespaceTrivia = 8540,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SingleLineCommentTrivia = 8541,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MultiLineCommentTrivia = 8542,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DocumentationCommentExteriorTrivia = 8543,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SingleLineDocumentationCommentTrivia = 8544,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MultiLineDocumentationCommentTrivia = 8545,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DisabledTextTrivia = 8546,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PreprocessingMessageTrivia = 8547,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IfDirectiveTrivia = 8548,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ElifDirectiveTrivia = 8549,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ElseDirectiveTrivia = 8550,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndIfDirectiveTrivia = 8551,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RegionDirectiveTrivia = 8552,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndRegionDirectiveTrivia = 8553,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DefineDirectiveTrivia = 8554,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UndefDirectiveTrivia = 8555,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ErrorDirectiveTrivia = 8556,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WarningDirectiveTrivia = 8557,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LineDirectiveTrivia = 8558,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PragmaWarningDirectiveTrivia = 8559,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PragmaChecksumDirectiveTrivia = 8560,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReferenceDirectiveTrivia = 8561,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BadDirectiveTrivia = 8562,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SkippedTokensTrivia = 8563,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConflictMarkerTrivia = 8564,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlElement = 8574,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlElementStartTag = 8575,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlElementEndTag = 8576,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlEmptyElement = 8577,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlTextAttribute = 8578,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlCrefAttribute = 8579,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlNameAttribute = 8580,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlName = 8581,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlPrefix = 8582,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlText = 8583,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlCDataSection = 8584,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlComment = 8585,
* &emsp; \| &emsp; \| &emsp; \| &emsp; XmlProcessingInstruction = 8586,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeCref = 8597,
* &emsp; \| &emsp; \| &emsp; \| &emsp; QualifiedCref = 8598,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameMemberCref = 8599,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IndexerMemberCref = 8600,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMemberCref = 8601,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConversionOperatorMemberCref = 8602,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CrefParameterList = 8603,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CrefBracketedParameterList = 8604,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CrefParameter = 8605,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IdentifierName = 8616,
* &emsp; \| &emsp; \| &emsp; \| &emsp; QualifiedName = 8617,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GenericName = 8618,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeArgumentList = 8619,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AliasQualifiedName = 8620,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PredefinedType = 8621,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrayType = 8622,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrayRankSpecifier = 8623,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerType = 8624,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NullableType = 8625,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OmittedTypeArgument = 8626,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParenthesizedExpression = 8632,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConditionalExpression = 8633,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InvocationExpression = 8634,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ElementAccessExpression = 8635,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArgumentList = 8636,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BracketedArgumentList = 8637,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Argument = 8638,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameColon = 8639,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CastExpression = 8640,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AnonymousMethodExpression = 8641,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SimpleLambdaExpression = 8642,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParenthesizedLambdaExpression = 8643,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectInitializerExpression = 8644,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CollectionInitializerExpression = 8645,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrayInitializerExpression = 8646,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AnonymousObjectMemberDeclarator = 8647,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ComplexElementInitializerExpression = 8648,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectCreationExpression = 8649,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AnonymousObjectCreationExpression = 8650,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrayCreationExpression = 8651,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ImplicitArrayCreationExpression = 8652,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StackAllocArrayCreationExpression = 8653,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OmittedArraySizeExpression = 8654,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolatedStringExpression = 8655,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ImplicitElementAccess = 8656,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IsPatternExpression = 8657,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddExpression = 8668,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SubtractExpression = 8669,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MultiplyExpression = 8670,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DivideExpression = 8671,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ModuloExpression = 8672,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LeftShiftExpression = 8673,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RightShiftExpression = 8674,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LogicalOrExpression = 8675,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LogicalAndExpression = 8676,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BitwiseOrExpression = 8677,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BitwiseAndExpression = 8678,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExclusiveOrExpression = 8679,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EqualsExpression = 8680,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotEqualsExpression = 8681,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanExpression = 8682,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanOrEqualExpression = 8683,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThanExpression = 8684,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThanOrEqualExpression = 8685,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IsExpression = 8686,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AsExpression = 8687,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CoalesceExpression = 8688,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SimpleMemberAccessExpression = 8689,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerMemberAccessExpression = 8690,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConditionalAccessExpression = 8691,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MemberBindingExpression = 8707,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ElementBindingExpression = 8708,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SimpleAssignmentExpression = 8714,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddAssignmentExpression = 8715,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SubtractAssignmentExpression = 8716,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MultiplyAssignmentExpression = 8717,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DivideAssignmentExpression = 8718,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ModuloAssignmentExpression = 8719,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AndAssignmentExpression = 8720,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExclusiveOrAssignmentExpression = 8721,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OrAssignmentExpression = 8722,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LeftShiftAssignmentExpression = 8723,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RightShiftAssignmentExpression = 8724,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnaryPlusExpression = 8730,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnaryMinusExpression = 8731,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BitwiseNotExpression = 8732,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LogicalNotExpression = 8733,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PreIncrementExpression = 8734,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PreDecrementExpression = 8735,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerIndirectionExpression = 8736,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddressOfExpression = 8737,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PostIncrementExpression = 8738,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PostDecrementExpression = 8739,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AwaitExpression = 8740,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ThisExpression = 8746,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BaseExpression = 8747,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArgListExpression = 8748,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NumericLiteralExpression = 8749,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StringLiteralExpression = 8750,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CharacterLiteralExpression = 8751,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TrueLiteralExpression = 8752,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FalseLiteralExpression = 8753,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NullLiteralExpression = 8754,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DefaultLiteralExpression = 8755,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeOfExpression = 8760,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SizeOfExpression = 8761,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CheckedExpression = 8762,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UncheckedExpression = 8763,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DefaultExpression = 8764,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MakeRefExpression = 8765,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RefValueExpression = 8766,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RefTypeExpression = 8767,
* &emsp; \| &emsp; \| &emsp; \| &emsp; QueryExpression = 8774,
* &emsp; \| &emsp; \| &emsp; \| &emsp; QueryBody = 8775,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FromClause = 8776,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LetClause = 8777,
* &emsp; \| &emsp; \| &emsp; \| &emsp; JoinClause = 8778,
* &emsp; \| &emsp; \| &emsp; \| &emsp; JoinIntoClause = 8779,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WhereClause = 8780,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OrderByClause = 8781,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AscendingOrdering = 8782,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DescendingOrdering = 8783,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SelectClause = 8784,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GroupClause = 8785,
* &emsp; \| &emsp; \| &emsp; \| &emsp; QueryContinuation = 8786,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Block = 8792,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LocalDeclarationStatement = 8793,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VariableDeclaration = 8794,
* &emsp; \| &emsp; \| &emsp; \| &emsp; VariableDeclarator = 8795,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EqualsValueClause = 8796,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExpressionStatement = 8797,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EmptyStatement = 8798,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LabeledStatement = 8799,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GotoStatement = 8800,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GotoCaseStatement = 8801,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GotoDefaultStatement = 8802,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BreakStatement = 8803,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ContinueStatement = 8804,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReturnStatement = 8805,
* &emsp; \| &emsp; \| &emsp; \| &emsp; YieldReturnStatement = 8806,
* &emsp; \| &emsp; \| &emsp; \| &emsp; YieldBreakStatement = 8807,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ThrowStatement = 8808,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WhileStatement = 8809,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DoStatement = 8810,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ForStatement = 8811,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ForEachStatement = 8812,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UsingStatement = 8813,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FixedStatement = 8814,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CheckedStatement = 8815,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UncheckedStatement = 8816,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsafeStatement = 8817,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LockStatement = 8818,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IfStatement = 8819,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ElseClause = 8820,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SwitchStatement = 8821,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SwitchSection = 8822,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CaseSwitchLabel = 8823,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DefaultSwitchLabel = 8824,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TryStatement = 8825,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CatchClause = 8826,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CatchDeclaration = 8827,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CatchFilterClause = 8828,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FinallyClause = 8829,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LocalFunctionStatement = 8830,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CompilationUnit = 8840,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GlobalStatement = 8841,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NamespaceDeclaration = 8842,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UsingDirective = 8843,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExternAliasDirective = 8844,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AttributeList = 8847,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AttributeTargetSpecifier = 8848,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Attribute = 8849,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AttributeArgumentList = 8850,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AttributeArgument = 8851,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NameEquals = 8852,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ClassDeclaration = 8855,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StructDeclaration = 8856,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterfaceDeclaration = 8857,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumDeclaration = 8858,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DelegateDeclaration = 8859,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BaseList = 8864,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SimpleBaseType = 8865,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameterConstraintClause = 8866,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConstructorConstraint = 8867,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ClassConstraint = 8868,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StructConstraint = 8869,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeConstraint = 8870,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExplicitInterfaceSpecifier = 8871,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumMemberDeclaration = 8872,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FieldDeclaration = 8873,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventFieldDeclaration = 8874,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MethodDeclaration = 8875,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorDeclaration = 8876,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConversionOperatorDeclaration = 8877,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConstructorDeclaration = 8878,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BaseConstructorInitializer = 8889,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ThisConstructorInitializer = 8890,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DestructorDeclaration = 8891,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PropertyDeclaration = 8892,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EventDeclaration = 8893,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IndexerDeclaration = 8894,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AccessorList = 8895,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GetAccessorDeclaration = 8896,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SetAccessorDeclaration = 8897,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddAccessorDeclaration = 8898,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveAccessorDeclaration = 8899,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnknownAccessorDeclaration = 8900,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParameterList = 8906,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BracketedParameterList = 8907,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Parameter = 8908,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameterList = 8909,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameter = 8910,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IncompleteMember = 8916,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ArrowExpressionClause = 8917,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Interpolation = 8918,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolatedStringText = 8919,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolationAlignmentClause = 8920,
* &emsp; \| &emsp; \| &emsp; \| &emsp; InterpolationFormatClause = 8921,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ShebangDirectiveTrivia = 8922,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LoadDirectiveTrivia = 8923,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TupleType = 8924,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TupleElement = 8925,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TupleExpression = 8926,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SingleVariableDesignation = 8927,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParenthesizedVariableDesignation = 8928,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ForEachVariableStatement = 8929,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DeclarationPattern = 9000,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConstantPattern = 9002,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CasePatternSwitchLabel = 9009,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WhenClause = 9013,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DiscardDesignation = 9014,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DeclarationExpression = 9040,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RefExpression = 9050,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RefType = 9051,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ThrowExpression = 9052,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.CSharp\.Formatting\.BinaryOperatorSpacingOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; Single = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Ignore = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Remove = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.CSharp\.Formatting\.LabelPositionOptions
* &emsp; \| &emsp; \| &emsp; \| &emsp; LeftMost = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OneLess = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NoIndent = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlNameAttributeElementKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; Parameter = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParameterReference = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameter = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TypeParameterReference = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.CodeFixes\.FixAllScope
* &emsp; \| &emsp; \| &emsp; \| &emsp; Document = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Project = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Solution = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Custom = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Diagnostics\.AnalyzerLoadFailureEventArgs\.FailureErrorCode
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnableToLoadAnalyzer = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnableToCreateAnalyzer = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NoAnalyzers = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Diagnostics\.GeneratedCodeAnalysisFlags
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Analyze = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReportDiagnostics = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Differencing\.EditKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Update = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Insert = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Delete = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Move = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Reorder = 5,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Editing\.DeclarationKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CompilationUnit = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Class = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Struct = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Interface = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Enum = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Delegate = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Method = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Operator = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConversionOperator = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Constructor = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Destructor = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Field = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Property = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Indexer = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumMember = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Event = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CustomEvent = 17,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Namespace = 18,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NamespaceImport = 19,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Parameter = 20,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Variable = 21,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Attribute = 22,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LambdaExpression = 23,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GetAccessor = 24,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SetAccessor = 25,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AddAccessor = 26,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RemoveAccessor = 27,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RaiseAccessor = 28,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Editing\.OperatorKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; ImplicitConversion = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExplicitConversion = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Addition = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BitwiseAnd = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BitwiseOr = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Decrement = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Division = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Equality = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExclusiveOr = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; False = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThan = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThanOrEqual = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Increment = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Inequality = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LeftShift = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThan = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanOrEqual = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LogicalNot = 17,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Modulus = 18,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Multiply = 19,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OnesComplement = 20,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RightShift = 21,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Subtraction = 22,
* &emsp; \| &emsp; \| &emsp; \| &emsp; True = 23,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnaryNegation = 24,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnaryPlus = 25,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Editing\.SpecialTypeConstraintKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReferenceType = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ValueType = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Constructor = 4,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Emit\.DebugInformationFormat
* &emsp; \| &emsp; \| &emsp; \| &emsp; Pdb = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PortablePdb = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Embedded = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Emit\.InstrumentationKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TestCoverage = 1,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Emit\.SemanticEditKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Update = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Insert = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Delete = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Formatting\.FormattingOptions\.IndentStyle
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Block = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Smart = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Rename\.RenameEntityKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; BaseSymbol = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OverloadedSymbols = 1,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.ArgumentKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Explicit = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ParamArray = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DefaultValue = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.BinaryOperandsKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethod = 256,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Integer = 512,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Unsigned = 768,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Floating = 1024,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Decimal = 1280,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Boolean = 1536,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Enum = 1792,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Dynamic = 2048,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Object = 2304,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Pointer = 2560,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerInteger = 2816,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerPointer = 3072,
* &emsp; \| &emsp; \| &emsp; \| &emsp; String = 3328,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Delegate = 3584,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Nullable = 3840,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Invalid = 65280,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.BinaryOperationKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodAdd = 257,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodSubtract = 258,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodMultiply = 259,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodDivide = 260,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodIntegerDivide = 261,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodRemainder = 262,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodLeftShift = 264,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodRightShift = 265,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodAnd = 266,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodOr = 267,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodExclusiveOr = 268,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodConditionalAnd = 269,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodConditionalOr = 270,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerAdd = 513,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerSubtract = 514,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerMultiply = 515,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerDivide = 516,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerRemainder = 518,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerLeftShift = 520,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerRightShift = 521,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerAnd = 522,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerOr = 523,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerExclusiveOr = 524,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedAdd = 769,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedSubtract = 770,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedMultiply = 771,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedDivide = 772,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedRemainder = 774,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedLeftShift = 776,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedRightShift = 777,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedAnd = 778,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedOr = 779,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedExclusiveOr = 780,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingAdd = 1025,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingSubtract = 1026,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingMultiply = 1027,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingDivide = 1028,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingRemainder = 1030,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingPower = 1031,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalAdd = 1281,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalSubtract = 1282,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalMultiply = 1283,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalDivide = 1284,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanAnd = 1546,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanOr = 1547,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanExclusiveOr = 1548,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanConditionalAnd = 1549,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanConditionalOr = 1550,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumAdd = 1793,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumSubtract = 1794,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumAnd = 1802,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumOr = 1803,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumExclusiveOr = 1804,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerIntegerAdd = 2817,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerPointerAdd = 3073,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerIntegerSubtract = 2818,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerSubtract = 2562,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicAdd = 2049,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicSubtract = 2050,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicMultiply = 2051,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicDivide = 2052,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicRemainder = 2054,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicLeftShift = 2056,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicRightShift = 2057,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicAnd = 2058,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicOr = 2059,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicExclusiveOr = 2060,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectAdd = 2305,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectSubtract = 2306,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectMultiply = 2307,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectDivide = 2308,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectIntegerDivide = 2309,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectRemainder = 2310,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectPower = 2311,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectLeftShift = 2312,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectRightShift = 2313,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectAnd = 2314,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectOr = 2315,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectExclusiveOr = 2316,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectConditionalAnd = 2317,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectConditionalOr = 2318,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectConcatenate = 2319,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StringConcatenate = 3343,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodEquals = 272,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodNotEquals = 274,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodLessThan = 276,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodLessThanOrEqual = 277,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodGreaterThanOrEqual = 278,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodGreaterThan = 279,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodPower = 263,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerEquals = 528,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerNotEquals = 530,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerLessThan = 532,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerLessThanOrEqual = 533,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerGreaterThanOrEqual = 534,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerGreaterThan = 535,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedLessThan = 788,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedLessThanOrEqual = 789,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedGreaterThanOrEqual = 790,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedGreaterThan = 791,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingEquals = 1040,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingNotEquals = 1042,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingLessThan = 1044,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingLessThanOrEqual = 1045,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingGreaterThanOrEqual = 1046,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingGreaterThan = 1047,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalEquals = 1296,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalNotEquals = 1298,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalLessThan = 1300,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalLessThanOrEqual = 1301,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalGreaterThanOrEqual = 1302,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalGreaterThan = 1303,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanEquals = 1552,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanNotEquals = 1554,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StringEquals = 3344,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StringNotEquals = 3346,
* &emsp; \| &emsp; \| &emsp; \| &emsp; StringLike = 3352,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DelegateEquals = 3600,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DelegateNotEquals = 3602,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NullableEquals = 3856,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NullableNotEquals = 3858,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectEquals = 2320,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectNotEquals = 2322,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectVBEquals = 2321,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectVBNotEquals = 2323,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectLike = 2328,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectLessThan = 2324,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectLessThanOrEqual = 2325,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectGreaterThanOrEqual = 2326,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectGreaterThan = 2327,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumEquals = 1808,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumNotEquals = 1810,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumLessThan = 1812,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumLessThanOrEqual = 1813,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumGreaterThanOrEqual = 1814,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumGreaterThan = 1815,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerEquals = 2576,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerNotEquals = 2578,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerLessThan = 2580,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerLessThanOrEqual = 2581,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerGreaterThanOrEqual = 2582,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerGreaterThan = 2583,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicEquals = 2064,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicNotEquals = 2066,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicLessThan = 2068,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicLessThanOrEqual = 2069,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicGreaterThanOrEqual = 2070,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicGreaterThan = 2071,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Invalid = 65535,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.BranchKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Continue = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Break = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GoTo = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.CaseKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SingleValue = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Relational = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Range = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Default = 4,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.ConversionKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Cast = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; TryCast = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Basic = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CSharp = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethod = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Invalid = 15,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.InstanceReferenceKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Implicit = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Explicit = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BaseClass = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ThisClass = 4,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.LoopKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; WhileUntil = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; For = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ForEach = 3,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.SimpleBinaryOperationKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Add = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Subtract = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Multiply = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Divide = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerDivide = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Remainder = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Power = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LeftShift = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; RightShift = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; And = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Or = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ExclusiveOr = 12,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConditionalAnd = 13,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ConditionalOr = 14,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Concatenate = 15,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Equals = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectValueEquals = 17,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotEquals = 18,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectValueNotEquals = 19,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThan = 20,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LessThanOrEqual = 21,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThanOrEqual = 22,
* &emsp; \| &emsp; \| &emsp; \| &emsp; GreaterThan = 23,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Like = 24,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Invalid = 255,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.SimpleUnaryOperationKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BitwiseNegation = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; LogicalNot = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PostfixIncrement = 3,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PostfixDecrement = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PrefixIncrement = 5,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PrefixDecrement = 6,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Plus = 7,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Minus = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; True = 9,
* &emsp; \| &emsp; \| &emsp; \| &emsp; False = 10,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BitwiseOrLogicalNot = 11,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Invalid = 255,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.SyntheticLocalKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ForLoopStepValue = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ForLoopLimitValue = 2,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.UnaryOperandKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethod = 256,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Integer = 512,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Unsigned = 768,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Floating = 1024,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Decimal = 1280,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Boolean = 1536,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Enum = 1792,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Dynamic = 2048,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Object = 2304,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Pointer = 2560,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Invalid = 65280,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Semantics\.UnaryOperationKind
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodBitwiseNegation = 257,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodLogicalNot = 258,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodPostfixIncrement = 259,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodPostfixDecrement = 260,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodPrefixIncrement = 261,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodPrefixDecrement = 262,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodPlus = 263,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodMinus = 264,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodTrue = 265,
* &emsp; \| &emsp; \| &emsp; \| &emsp; OperatorMethodFalse = 266,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerBitwiseNegation = 513,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerPlus = 519,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerMinus = 520,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerPostfixIncrement = 515,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerPostfixDecrement = 516,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerPrefixIncrement = 517,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IntegerPrefixDecrement = 518,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedPostfixIncrement = 771,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedPostfixDecrement = 772,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedPrefixIncrement = 773,
* &emsp; \| &emsp; \| &emsp; \| &emsp; UnsignedPrefixDecrement = 774,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingPlus = 1031,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingMinus = 1032,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingPostfixIncrement = 1027,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingPostfixDecrement = 1028,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingPrefixIncrement = 1029,
* &emsp; \| &emsp; \| &emsp; \| &emsp; FloatingPrefixDecrement = 1030,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalPlus = 1287,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalMinus = 1288,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalPostfixIncrement = 1283,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalPostfixDecrement = 1284,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalPrefixIncrement = 1285,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DecimalPrefixDecrement = 1286,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanBitwiseNegation = 1537,
* &emsp; \| &emsp; \| &emsp; \| &emsp; BooleanLogicalNot = 1538,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumPostfixIncrement = 1795,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumPostfixDecrement = 1796,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumPrefixIncrement = 1797,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EnumPrefixDecrement = 1798,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerPostfixIncrement = 2563,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerPostfixDecrement = 2564,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerPrefixIncrement = 2565,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PointerPrefixDecrement = 2566,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicBitwiseNegation = 2049,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicLogicalNot = 2050,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicTrue = 2057,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicFalse = 2058,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicPlus = 2055,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicMinus = 2056,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicPostfixIncrement = 2051,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicPostfixDecrement = 2052,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicPrefixIncrement = 2053,
* &emsp; \| &emsp; \| &emsp; \| &emsp; DynamicPrefixDecrement = 2054,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectPlus = 2311,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectMinus = 2312,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ObjectNot = 2315,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Invalid = 65535,
* &emsp; \| &emsp; \| &emsp; public enum Microsoft\.CodeAnalysis\.Text\.SourceHashAlgorithm
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Sha1 = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Sha256 = 2,
* &emsp; \| &emsp; \| &emsp; public enum Roslynator\.Visibility
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotApplicable = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Private = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Internal = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Public = 3,
* &emsp; \| &emsp; \| &emsp; public enum Roslynator\.CSharp\.CommentFilter
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SingleLine = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MultiLine = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NonDocumentation = SingleLine \| MultiLine,
* &emsp; \| &emsp; \| &emsp; \| &emsp; SingleLineDocumentation = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; MultiLineDocumentation = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Documentation = SingleLineDocumentation \| MultiLineDocumentation,
* &emsp; \| &emsp; \| &emsp; \| &emsp; All = NonDocumentation \| Documentation,
* &emsp; \| &emsp; \| &emsp; public enum Roslynator\.CSharp\.ModifierFilter
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; New = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Public = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Private = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Protected = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Internal = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Accessibility = Public \| Private \| Protected \| Internal,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Const = 32,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Static = 64,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Virtual = 128,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Sealed = 256,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Override = 512,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Abstract = 1024,
* &emsp; \| &emsp; \| &emsp; \| &emsp; AbstractVirtualOverride = Virtual \| Override \| Abstract,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ReadOnly = 2048,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Extern = 4096,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Unsafe = 8192,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Volatile = 16384,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Async = 32768,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Partial = 65536,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Ref = 131072,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Out = 262144,
* &emsp; \| &emsp; \| &emsp; \| &emsp; In = 524288,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Params = 1048576,
* &emsp; \| &emsp; \| &emsp; \| &emsp; This = 2097152,
* &emsp; \| &emsp; \| &emsp; public enum Roslynator\.CSharp\.NullCheckStyles
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EqualsToNull = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotEqualsToNull = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; ComparisonToNull = EqualsToNull \| NotEqualsToNull,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IsNull = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotIsNull = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; IsPattern = IsNull \| NotIsNull,
* &emsp; \| &emsp; \| &emsp; \| &emsp; NotHasValue = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CheckingNull = EqualsToNull \| IsNull \| NotHasValue,
* &emsp; \| &emsp; \| &emsp; \| &emsp; HasValue = 32,
* &emsp; \| &emsp; \| &emsp; \| &emsp; CheckingNotNull = NotEqualsToNull \| NotIsNull \| HasValue,
* &emsp; \| &emsp; \| &emsp; \| &emsp; HasValueProperty = NotHasValue \| HasValue,
* &emsp; \| &emsp; \| &emsp; \| &emsp; All = ComparisonToNull \| IsPattern \| HasValueProperty,
* &emsp; \| &emsp; \| &emsp; public enum Roslynator\.CSharp\.PreprocessorDirectiveFilter
* &emsp; \| &emsp; \| &emsp; \| &emsp; None = 0,
* &emsp; \| &emsp; \| &emsp; \| &emsp; If = 1,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Elif = 2,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Else = 4,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndIf = 8,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Region = 16,
* &emsp; \| &emsp; \| &emsp; \| &emsp; EndRegion = 32,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Define = 64,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Undef = 128,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Error = 256,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Warning = 512,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Line = 1024,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PragmaWarning = 2048,
* &emsp; \| &emsp; \| &emsp; \| &emsp; PragmaChecksum = 4096,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Pragma = PragmaWarning \| PragmaChecksum,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Reference = 8192,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Load = 16384,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Bad = 32768,
* &emsp; \| &emsp; \| &emsp; \| &emsp; Shebang = 65536,
* &emsp; \| &emsp; \| &emsp; \| &emsp; All = If \| Elif \| Else \| EndIf \| Region \| EndRegion \| Define \| Undef \| Error \| Warning \| Line \| Pragma \| Reference \| Load \| Bad \| Shebang,
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.ChildSyntaxList : IEquatable\<ChildSyntaxList>, IEnumerable\<SyntaxNodeOrToken>, IReadOnlyCollection\<SyntaxNodeOrToken>, IReadOnlyList\<SyntaxNodeOrToken>
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ChildSyntaxList other\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken First\(\);
* &emsp; \| &emsp; \| &emsp; public ChildSyntaxList\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken Last\(\);
* &emsp; \| &emsp; \| &emsp; public ChildSyntaxList\.Reversed Reverse\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(ChildSyntaxList list1, ChildSyntaxList list2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(ChildSyntaxList list1, ChildSyntaxList list2\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.ChildSyntaxList\.Enumerator
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.ChildSyntaxList\.Reversed : IEquatable\<ChildSyntaxList\.Reversed>, IEnumerable\<SyntaxNodeOrToken>
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ChildSyntaxList\.Reversed other\);
* &emsp; \| &emsp; \| &emsp; public ChildSyntaxList\.Reversed\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.ChildSyntaxList\.Reversed\.Enumerator
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CommandLineAnalyzerReference : IEquatable\<CommandLineAnalyzerReference>
* &emsp; \| &emsp; \| &emsp; public CommandLineAnalyzerReference\(string path\);
* &emsp; \| &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(CommandLineAnalyzerReference other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CommandLineReference : IEquatable\<CommandLineReference>
* &emsp; \| &emsp; \| &emsp; public CommandLineReference\(string reference, MetadataReferenceProperties properties\);
* &emsp; \| &emsp; \| &emsp; public MetadataReferenceProperties Properties \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Reference \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(CommandLineReference other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CommandLineSourceFile
* &emsp; \| &emsp; \| &emsp; public CommandLineSourceFile\(string path, bool isScript\);
* &emsp; \| &emsp; \| &emsp; public bool IsScript \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Path \{ get; \}
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.FileLinePositionSpan : IEquatable\<FileLinePositionSpan>
* &emsp; \| &emsp; \| &emsp; public FileLinePositionSpan\(string path, LinePositionSpan span\);
* &emsp; \| &emsp; \| &emsp; public FileLinePositionSpan\(string path, LinePosition start, LinePosition end\);
* &emsp; \| &emsp; \| &emsp; public LinePosition EndLinePosition \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool HasMappedPath \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsValid \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Path \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LinePositionSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LinePosition StartLinePosition \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Equals\(FileLinePositionSpan other\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.MetadataReferenceProperties : IEquatable\<MetadataReferenceProperties>
* &emsp; \| &emsp; \| &emsp; public MetadataReferenceProperties\(MetadataImageKind kind = Assembly, ImmutableArray\<string> aliases = default, bool embedInteropTypes = false\);
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<string> Aliases \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static MetadataReferenceProperties Assembly \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool EmbedInteropTypes \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static string GlobalAlias \{ get; \}
* &emsp; \| &emsp; \| &emsp; public MetadataImageKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static MetadataReferenceProperties Module \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(MetadataReferenceProperties other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public MetadataReferenceProperties WithAliases\(IEnumerable\<string> aliases\);
* &emsp; \| &emsp; \| &emsp; public MetadataReferenceProperties WithAliases\(ImmutableArray\<string> aliases\);
* &emsp; \| &emsp; \| &emsp; public MetadataReferenceProperties WithEmbedInteropTypes\(bool embedInteropTypes\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(MetadataReferenceProperties left, MetadataReferenceProperties right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(MetadataReferenceProperties left, MetadataReferenceProperties right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Optional\<T>
* &emsp; \| &emsp; \| &emsp; public Optional\(T value\);
* &emsp; \| &emsp; \| &emsp; public bool HasValue \{ get; \}
* &emsp; \| &emsp; \| &emsp; public T Value \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static implicit operator Optional\<T>\(T value\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.PreprocessingSymbolInfo : IEquatable\<PreprocessingSymbolInfo>
* &emsp; \| &emsp; \| &emsp; public bool IsDefined \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IPreprocessingSymbol Symbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(PreprocessingSymbolInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.ProjectChanges
* &emsp; \| &emsp; \| &emsp; public Project NewProject \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Project OldProject \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ProjectId ProjectId \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<DocumentId> GetAddedAdditionalDocuments\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<AnalyzerReference> GetAddedAnalyzerReferences\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<DocumentId> GetAddedDocuments\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<MetadataReference> GetAddedMetadataReferences\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<ProjectReference> GetAddedProjectReferences\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<DocumentId> GetChangedAdditionalDocuments\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<DocumentId> GetChangedDocuments\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<DocumentId> GetRemovedAdditionalDocuments\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<AnalyzerReference> GetRemovedAnalyzerReferences\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<DocumentId> GetRemovedDocuments\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<MetadataReference> GetRemovedMetadataReferences\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<ProjectReference> GetRemovedProjectReferences\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SeparatedSyntaxList\<TNode> : IEquatable\<SeparatedSyntaxList\<TNode>>, IEnumerable\<TNode>, IReadOnlyCollection\<TNode>, IReadOnlyList\<TNode> where TNode : SyntaxNode
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int SeparatorCount \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TNode this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> Add\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> AddRange\(IEnumerable\<TNode> nodes\);
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public bool Contains\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SeparatedSyntaxList\<TNode> other\);
* &emsp; \| &emsp; \| &emsp; public TNode First\(\);
* &emsp; \| &emsp; \| &emsp; public TNode FirstOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode>\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken GetSeparator\(int index\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxToken> GetSeparators\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList GetWithSeparators\(\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(Func\<TNode, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> Insert\(int index, TNode node\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> InsertRange\(int index, IEnumerable\<TNode> nodes\);
* &emsp; \| &emsp; \| &emsp; public TNode Last\(\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(Func\<TNode, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public TNode LastOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> Remove\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> RemoveAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> Replace\(TNode nodeInList, TNode newNode\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> ReplaceRange\(TNode nodeInList, IEnumerable\<TNode> newNodes\);
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> ReplaceSeparator\(SyntaxToken separatorToken, SyntaxToken newSeparator\);
* &emsp; \| &emsp; \| &emsp; public string ToFullString\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator SeparatedSyntaxList\<SyntaxNode>\(SeparatedSyntaxList\<TNode> nodes\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator SeparatedSyntaxList\<TNode>\(SeparatedSyntaxList\<SyntaxNode> nodes\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(SeparatedSyntaxList\<TNode> left, SeparatedSyntaxList\<TNode> right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(SeparatedSyntaxList\<TNode> left, SeparatedSyntaxList\<TNode> right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SeparatedSyntaxList\<TNode>\.Enumerator
* &emsp; \| &emsp; \| &emsp; public TNode Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SolutionChanges
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<Project> GetAddedProjects\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<ProjectChanges> GetProjectChanges\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<Project> GetRemovedProjects\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SubsystemVersion : IEquatable\<SubsystemVersion>
* &emsp; \| &emsp; \| &emsp; public bool IsValid \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int Major \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int Minor \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SubsystemVersion None \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SubsystemVersion Windows2000 \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SubsystemVersion Windows7 \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SubsystemVersion Windows8 \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SubsystemVersion WindowsVista \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SubsystemVersion WindowsXP \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SubsystemVersion Create\(int major, int minor\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SubsystemVersion other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool TryParse\(string str, out SubsystemVersion version\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SymbolDisplayPart
* &emsp; \| &emsp; \| &emsp; public SymbolDisplayPart\(SymbolDisplayPartKind kind, ISymbol symbol, string text\);
* &emsp; \| &emsp; \| &emsp; public SymbolDisplayPartKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol Symbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SymbolInfo : IEquatable\<SymbolInfo>
* &emsp; \| &emsp; \| &emsp; public CandidateReason CandidateReason \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<ISymbol> CandidateSymbols \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol Symbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SymbolInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxList\<TNode> : IEquatable\<SyntaxList\<TNode>>, IEnumerable\<TNode>, IReadOnlyCollection\<TNode>, IReadOnlyList\<TNode> where TNode : SyntaxNode
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TNode this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode> Add\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode> AddRange\(IEnumerable\<TNode> nodes\);
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxList\<TNode> other\);
* &emsp; \| &emsp; \| &emsp; public TNode First\(\);
* &emsp; \| &emsp; \| &emsp; public TNode FirstOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode>\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(Func\<TNode, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode> Insert\(int index, TNode node\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode> InsertRange\(int index, IEnumerable\<TNode> nodes\);
* &emsp; \| &emsp; \| &emsp; public TNode Last\(\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(Func\<TNode, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public TNode LastOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode> Remove\(TNode node\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode> RemoveAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode> Replace\(TNode nodeInList, TNode newNode\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TNode> ReplaceRange\(TNode nodeInList, IEnumerable\<TNode> newNodes\);
* &emsp; \| &emsp; \| &emsp; public string ToFullString\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator SyntaxList\<TNode>\(SyntaxList\<SyntaxNode> nodes\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator SyntaxList\<SyntaxNode>\(SyntaxList\<TNode> nodes\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(SyntaxList\<TNode> left, SyntaxList\<TNode> right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(SyntaxList\<TNode> left, SyntaxList\<TNode> right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxList\<TNode>\.Enumerator
* &emsp; \| &emsp; \| &emsp; public TNode Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxNodeOrToken : IEquatable\<SyntaxNodeOrToken>
* &emsp; \| &emsp; \| &emsp; public bool ContainsAnnotations \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool ContainsDiagnostics \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool ContainsDirectives \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool HasLeadingTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool HasTrailingTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsMissing \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsNode \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int RawKind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int SpanStart \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTree SyntaxTree \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode AsNode\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken AsToken\(\);
* &emsp; \| &emsp; \| &emsp; public ChildSyntaxList ChildNodesAndTokens\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxNodeOrToken other\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(IEnumerable\<string> annotationKinds\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<Diagnostic> GetDiagnostics\(\);
* &emsp; \| &emsp; \| &emsp; public static int GetFirstChildIndexSpanningPosition\(SyntaxNode node, int position\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList GetLeadingTrivia\(\);
* &emsp; \| &emsp; \| &emsp; public Location GetLocation\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken GetNextSibling\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken GetPreviousSibling\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList GetTrailingTrivia\(\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotation\(SyntaxAnnotation annotation\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotations\(IEnumerable\<string> annotationKinds\);
* &emsp; \| &emsp; \| &emsp; public bool IsEquivalentTo\(SyntaxNodeOrToken other\);
* &emsp; \| &emsp; \| &emsp; public string ToFullString\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithAdditionalAnnotations\(params SyntaxAnnotation\[\] annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithAdditionalAnnotations\(IEnumerable\<SyntaxAnnotation> annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithLeadingTrivia\(IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithLeadingTrivia\(params SyntaxTrivia\[\] trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithTrailingTrivia\(IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithTrailingTrivia\(params SyntaxTrivia\[\] trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithoutAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithoutAnnotations\(params SyntaxAnnotation\[\] annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken WithoutAnnotations\(IEnumerable\<SyntaxAnnotation> annotations\);
* &emsp; \| &emsp; \| &emsp; public void WriteTo\(TextWriter writer\);
* &emsp; \| &emsp; \| &emsp; public static explicit operator SyntaxToken\(SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; \| &emsp; public static explicit operator SyntaxNode\(SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator SyntaxNodeOrToken\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator SyntaxNodeOrToken\(SyntaxNode node\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(SyntaxNodeOrToken left, SyntaxNodeOrToken right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(SyntaxNodeOrToken left, SyntaxNodeOrToken right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxNodeOrTokenList : IEquatable\<SyntaxNodeOrTokenList>, IEnumerable\<SyntaxNodeOrToken>, IReadOnlyCollection\<SyntaxNodeOrToken>
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList Add\(SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList AddRange\(IEnumerable\<SyntaxNodeOrToken> nodesOrTokens\);
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxNodeOrTokenList other\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken First\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken FirstOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList Insert\(int index, SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList InsertRange\(int index, IEnumerable\<SyntaxNodeOrToken> nodesAndTokens\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken Last\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken LastOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList Remove\(SyntaxNodeOrToken nodeOrTokenInList\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList RemoveAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList Replace\(SyntaxNodeOrToken nodeOrTokenInList, SyntaxNodeOrToken newNodeOrToken\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrTokenList ReplaceRange\(SyntaxNodeOrToken nodeOrTokenInList, IEnumerable\<SyntaxNodeOrToken> newNodesAndTokens\);
* &emsp; \| &emsp; \| &emsp; public string ToFullString\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxNodeOrTokenList\.Enumerator : IDisposable, IEnumerator, IEnumerator\<SyntaxNodeOrToken>
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeOrToken Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxToken : IEquatable\<SyntaxToken>
* &emsp; \| &emsp; \| &emsp; public bool ContainsAnnotations \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool ContainsDiagnostics \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool ContainsDirectives \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool HasLeadingTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool HasStructuredTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool HasTrailingTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsMissing \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList LeadingTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int RawKind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int SpanStart \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTree SyntaxTree \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Text \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList TrailingTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; public object Value \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string ValueText \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken CopyAnnotationsTo\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxToken other\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxTrivia> GetAllTrivia\(\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(params string\[\] annotationKinds\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(IEnumerable\<string> annotationKinds\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<Diagnostic> GetDiagnostics\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public Location GetLocation\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken GetNextToken\(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken GetPreviousToken\(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotation\(SyntaxAnnotation annotation\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotations\(params string\[\] annotationKinds\);
* &emsp; \| &emsp; \| &emsp; public bool IsEquivalentTo\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public bool IsPartOfStructuredTrivia\(\);
* &emsp; \| &emsp; \| &emsp; public string ToFullString\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithAdditionalAnnotations\(params SyntaxAnnotation\[\] annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithAdditionalAnnotations\(IEnumerable\<SyntaxAnnotation> annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithLeadingTrivia\(SyntaxTriviaList trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithLeadingTrivia\(params SyntaxTrivia\[\] trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithLeadingTrivia\(IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithTrailingTrivia\(SyntaxTriviaList trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithTrailingTrivia\(params SyntaxTrivia\[\] trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithTrailingTrivia\(IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithTriviaFrom\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithoutAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithoutAnnotations\(params SyntaxAnnotation\[\] annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken WithoutAnnotations\(IEnumerable\<SyntaxAnnotation> annotations\);
* &emsp; \| &emsp; \| &emsp; public void WriteTo\(TextWriter writer\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(SyntaxToken left, SyntaxToken right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(SyntaxToken left, SyntaxToken right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTokenList : IEquatable\<SyntaxTokenList>, IEnumerable\<SyntaxToken>, IReadOnlyCollection\<SyntaxToken>, IReadOnlyList\<SyntaxToken>
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Add\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList AddRange\(IEnumerable\<SyntaxToken> tokens\);
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public static SyntaxTokenList Create\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxTokenList other\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken First\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(SyntaxToken tokenInList\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Insert\(int index, SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList InsertRange\(int index, IEnumerable\<SyntaxToken> tokens\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken Last\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Remove\(SyntaxToken tokenInList\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList RemoveAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Replace\(SyntaxToken tokenInList, SyntaxToken newToken\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList ReplaceRange\(SyntaxToken tokenInList, IEnumerable\<SyntaxToken> newTokens\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList\.Reversed Reverse\(\);
* &emsp; \| &emsp; \| &emsp; public string ToFullString\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(SyntaxTokenList left, SyntaxTokenList right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(SyntaxTokenList left, SyntaxTokenList right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTokenList\.Enumerator
* &emsp; \| &emsp; \| &emsp; public SyntaxToken Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTokenList\.Reversed : IEquatable\<SyntaxTokenList\.Reversed>, IEnumerable\<SyntaxToken>
* &emsp; \| &emsp; \| &emsp; public Reversed\(SyntaxTokenList list\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxTokenList\.Reversed other\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList\.Reversed\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTokenList\.Reversed\.Enumerator
* &emsp; \| &emsp; \| &emsp; public Enumerator\(ref SyntaxTokenList list\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTrivia : IEquatable\<SyntaxTrivia>
* &emsp; \| &emsp; \| &emsp; public bool ContainsDiagnostics \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool HasStructure \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsDirective \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int RawKind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int SpanStart \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTree SyntaxTree \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken Token \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia CopyAnnotationsTo\(SyntaxTrivia trivia\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxTrivia other\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(params string\[\] annotationKinds\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<Diagnostic> GetDiagnostics\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public Location GetLocation\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNode GetStructure\(\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotation\(SyntaxAnnotation annotation\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public bool HasAnnotations\(params string\[\] annotationKinds\);
* &emsp; \| &emsp; \| &emsp; public bool IsEquivalentTo\(SyntaxTrivia trivia\);
* &emsp; \| &emsp; \| &emsp; public bool IsPartOfStructuredTrivia\(\);
* &emsp; \| &emsp; \| &emsp; public string ToFullString\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia WithAdditionalAnnotations\(params SyntaxAnnotation\[\] annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia WithAdditionalAnnotations\(IEnumerable\<SyntaxAnnotation> annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia WithoutAnnotations\(string annotationKind\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia WithoutAnnotations\(params SyntaxAnnotation\[\] annotations\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia WithoutAnnotations\(IEnumerable\<SyntaxAnnotation> annotations\);
* &emsp; \| &emsp; \| &emsp; public void WriteTo\(TextWriter writer\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(SyntaxTrivia left, SyntaxTrivia right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(SyntaxTrivia left, SyntaxTrivia right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTriviaList : IEquatable\<SyntaxTriviaList>, IEnumerable\<SyntaxTrivia>, IReadOnlyCollection\<SyntaxTrivia>, IReadOnlyList\<SyntaxTrivia>
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SyntaxTriviaList Empty \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList Add\(SyntaxTrivia trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList AddRange\(IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public static SyntaxTriviaList Create\(SyntaxTrivia trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia ElementAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxTriviaList other\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia First\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(SyntaxTrivia triviaInList\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList Insert\(int index, SyntaxTrivia trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList InsertRange\(int index, IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia Last\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList Remove\(SyntaxTrivia triviaInList\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList RemoveAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList Replace\(SyntaxTrivia triviaInList, SyntaxTrivia newTrivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList ReplaceRange\(SyntaxTrivia triviaInList, IEnumerable\<SyntaxTrivia> newTrivia\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList\.Reversed Reverse\(\);
* &emsp; \| &emsp; \| &emsp; public string ToFullString\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(SyntaxTriviaList left, SyntaxTriviaList right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(SyntaxTriviaList left, SyntaxTriviaList right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTriviaList\.Enumerator
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTriviaList\.Reversed : IEquatable\<SyntaxTriviaList\.Reversed>, IEnumerable\<SyntaxTrivia>
* &emsp; \| &emsp; \| &emsp; public Reversed\(SyntaxTriviaList list\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SyntaxTriviaList\.Reversed other\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList\.Reversed\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.SyntaxTriviaList\.Reversed\.Enumerator
* &emsp; \| &emsp; \| &emsp; public Enumerator\(ref SyntaxTriviaList list\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.TypeInfo : IEquatable\<TypeInfo>
* &emsp; \| &emsp; \| &emsp; public ITypeSymbol ConvertedType \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ITypeSymbol Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(TypeInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.TypedConstant : IEquatable\<TypedConstant>
* &emsp; \| &emsp; \| &emsp; public bool IsNull \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TypedConstantKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ITypeSymbol Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; public object Value \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<TypedConstant> Values \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(TypedConstant other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.VersionStamp : IEquatable\<VersionStamp>, IObjectWritable
* &emsp; \| &emsp; \| &emsp; public static VersionStamp Default \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static VersionStamp Create\(\);
* &emsp; \| &emsp; \| &emsp; public static VersionStamp Create\(DateTime utcTimeLastModified\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(VersionStamp version\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public VersionStamp GetNewerVersion\(\);
* &emsp; \| &emsp; \| &emsp; public VersionStamp GetNewerVersion\(VersionStamp version\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(VersionStamp left, VersionStamp right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(VersionStamp left, VersionStamp right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CSharp\.AwaitExpressionInfo : IEquatable\<AwaitExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol GetAwaiterMethod \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol GetResultMethod \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IPropertySymbol IsCompletedProperty \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsDynamic \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(AwaitExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CSharp\.Conversion : IEquatable\<Conversion>
* &emsp; \| &emsp; \| &emsp; public bool Exists \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsAnonymousFunction \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsBoxing \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsConstantExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsDynamic \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsEnumeration \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsExplicit \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsIdentity \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsImplicit \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsIntPtr \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsInterpolatedString \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsMethodGroup \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsNullLiteral \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsNullable \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsNumeric \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsPointer \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsReference \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsThrow \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsTupleConversion \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsTupleLiteralConversion \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsUnboxing \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsUserDefined \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol MethodSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(Conversion other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(Conversion left, Conversion right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(Conversion left, Conversion right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CSharp\.ForEachStatementInfo : IEquatable\<ForEachStatementInfo>
* &emsp; \| &emsp; \| &emsp; public Conversion CurrentConversion \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IPropertySymbol CurrentProperty \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol DisposeMethod \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Conversion ElementConversion \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ITypeSymbol ElementType \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol GetEnumeratorMethod \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol MoveNextMethod \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ForEachStatementInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CSharp\.QueryClauseInfo : IEquatable\<QueryClauseInfo>
* &emsp; \| &emsp; \| &emsp; public SymbolInfo CastInfo \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SymbolInfo OperationInfo \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(QueryClauseInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Classification\.ClassifiedSpan : IEquatable\<ClassifiedSpan>
* &emsp; \| &emsp; \| &emsp; public ClassifiedSpan\(string classificationType, TextSpan textSpan\);
* &emsp; \| &emsp; \| &emsp; public ClassifiedSpan\(TextSpan textSpan, string classificationType\);
* &emsp; \| &emsp; \| &emsp; public string ClassificationType \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan TextSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ClassifiedSpan other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CodeFixes\.CodeFixContext
* &emsp; \| &emsp; \| &emsp; public CodeFixContext\(Document document, Diagnostic diagnostic, Action\<CodeAction, ImmutableArray\<Diagnostic>> registerCodeFix, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CodeFixContext\(Document document, TextSpan span, ImmutableArray\<Diagnostic> diagnostics, Action\<CodeAction, ImmutableArray\<Diagnostic>> registerCodeFix, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<Diagnostic> Diagnostics \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Document Document \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void RegisterCodeFix\(CodeAction action, Diagnostic diagnostic\);
* &emsp; \| &emsp; \| &emsp; public void RegisterCodeFix\(CodeAction action, IEnumerable\<Diagnostic> diagnostics\);
* &emsp; \| &emsp; \| &emsp; public void RegisterCodeFix\(CodeAction action, ImmutableArray\<Diagnostic> diagnostics\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.CodeRefactorings\.CodeRefactoringContext
* &emsp; \| &emsp; \| &emsp; public CodeRefactoringContext\(Document document, TextSpan span, Action\<CodeAction> registerRefactoring, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Document Document \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void RegisterRefactoring\(CodeAction action\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Diagnostics\.CodeBlockAnalysisContext
* &emsp; \| &emsp; \| &emsp; public CodeBlockAnalysisContext\(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode CodeBlock \{ get; \}
* &emsp; \| &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol OwningSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SemanticModel SemanticModel \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void ReportDiagnostic\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Diagnostics\.CompilationAnalysisContext
* &emsp; \| &emsp; \| &emsp; public CompilationAnalysisContext\(Compilation compilation, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void ReportDiagnostic\(Diagnostic diagnostic\);
* &emsp; \| &emsp; \| &emsp; public bool TryGetValue\<TValue>\(SourceText text, SourceTextValueProvider\<TValue> valueProvider, out TValue value\);
* &emsp; \| &emsp; \| &emsp; public bool TryGetValue\<TValue>\(SyntaxTree tree, SyntaxTreeValueProvider\<TValue> valueProvider, out TValue value\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Diagnostics\.OperationAnalysisContext
* &emsp; \| &emsp; \| &emsp; public OperationAnalysisContext\(IOperation operation, ISymbol containingSymbol, Compilation compilation, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol ContainingSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IOperation Operation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void ReportDiagnostic\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Diagnostics\.OperationBlockAnalysisContext
* &emsp; \| &emsp; \| &emsp; public OperationBlockAnalysisContext\(ImmutableArray\<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<IOperation> OperationBlocks \{ get; \}
* &emsp; \| &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol OwningSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void ReportDiagnostic\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Diagnostics\.SemanticModelAnalysisContext
* &emsp; \| &emsp; \| &emsp; public SemanticModelAnalysisContext\(SemanticModel semanticModel, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SemanticModel SemanticModel \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void ReportDiagnostic\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Diagnostics\.SymbolAnalysisContext
* &emsp; \| &emsp; \| &emsp; public SymbolAnalysisContext\(ISymbol symbol, Compilation compilation, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol Symbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void ReportDiagnostic\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Diagnostics\.SyntaxNodeAnalysisContext
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeAnalysisContext\(SyntaxNode node, SemanticModel semanticModel, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public SyntaxNodeAnalysisContext\(SyntaxNode node, ISymbol containingSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol ContainingSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Node \{ get; \}
* &emsp; \| &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SemanticModel SemanticModel \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void ReportDiagnostic\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Diagnostics\.SyntaxTreeAnalysisContext
* &emsp; \| &emsp; \| &emsp; public SyntaxTreeAnalysisContext\(SyntaxTree tree, AnalyzerOptions options, Action\<Diagnostic> reportDiagnostic, Func\<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTree Tree \{ get; \}
* &emsp; \| &emsp; \| &emsp; public void ReportDiagnostic\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Differencing\.Edit\<TNode> : IEquatable\<Edit\<TNode>>
* &emsp; \| &emsp; \| &emsp; public EditKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TNode NewNode \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TNode OldNode \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(Edit\<TNode> other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Editing\.DeclarationModifiers : IEquatable\<DeclarationModifiers>
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Abstract \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Async \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Const \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsAbstract \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsAsync \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsConst \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsNew \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsOverride \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsPartial \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsReadOnly \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsSealed \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsStatic \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsUnsafe \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsVirtual \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsWithEvents \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsWriteOnly \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers New \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers None \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Override \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Partial \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers ReadOnly \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Sealed \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Static \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Unsafe \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers Virtual \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers WithEvents \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers WriteOnly \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Equals\(DeclarationModifiers modifiers\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers From\(ISymbol symbol\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool TryParse\(string value, out DeclarationModifiers modifiers\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithAsync\(bool isAsync\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsAbstract\(bool isAbstract\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsConst\(bool isConst\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsNew\(bool isNew\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsOverride\(bool isOverride\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsReadOnly\(bool isReadOnly\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsSealed\(bool isSealed\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsStatic\(bool isStatic\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsUnsafe\(bool isUnsafe\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsVirtual\(bool isVirtual\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithIsWriteOnly\(bool isWriteOnly\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithPartial\(bool isPartial\);
* &emsp; \| &emsp; \| &emsp; public DeclarationModifiers WithWithEvents\(bool withEvents\);
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers operator \+\(DeclarationModifiers left, DeclarationModifiers right\);
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers operator &\(DeclarationModifiers left, DeclarationModifiers right\);
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers operator \|\(DeclarationModifiers left, DeclarationModifiers right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(DeclarationModifiers left, DeclarationModifiers right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(DeclarationModifiers left, DeclarationModifiers right\);
* &emsp; \| &emsp; \| &emsp; public static DeclarationModifiers operator \-\(DeclarationModifiers left, DeclarationModifiers right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Emit\.EditAndContinueMethodDebugInformation
* &emsp; \| &emsp; \| &emsp; public static EditAndContinueMethodDebugInformation Create\(ImmutableArray\<byte> compressedSlotMap, ImmutableArray\<byte> compressedLambdaMap\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Emit\.SemanticEdit : IEquatable\<SemanticEdit>
* &emsp; \| &emsp; \| &emsp; public SemanticEdit\(SemanticEditKind kind, ISymbol oldSymbol, ISymbol newSymbol, Func\<SyntaxNode, SyntaxNode> syntaxMap = null, bool preserveLocalVariables = false\);
* &emsp; \| &emsp; \| &emsp; public SemanticEditKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol NewSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol OldSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool PreserveLocalVariables \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Func\<SyntaxNode, SyntaxNode> SyntaxMap \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SemanticEdit other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.FindSymbols\.ReferenceLocation : IComparable\<ReferenceLocation>, IEquatable\<ReferenceLocation>
* &emsp; \| &emsp; \| &emsp; public IAliasSymbol Alias \{ get; \}
* &emsp; \| &emsp; \| &emsp; public CandidateReason CandidateReason \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Document Document \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsCandidateLocation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsImplicit \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Location Location \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int CompareTo\(ReferenceLocation other\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ReferenceLocation other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(ReferenceLocation left, ReferenceLocation right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(ReferenceLocation left, ReferenceLocation right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.FindSymbols\.SymbolCallerInfo
* &emsp; \| &emsp; \| &emsp; public ISymbol CalledSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ISymbol CallingSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsDirect \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<Location> Locations \{ get; \}
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Options\.OptionKey : IEquatable\<OptionKey>
* &emsp; \| &emsp; \| &emsp; public OptionKey\(IOption option, string language = null\);
* &emsp; \| &emsp; \| &emsp; public string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IOption Option \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(OptionKey other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(OptionKey left, OptionKey right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(OptionKey left, OptionKey right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Text\.LinePosition : IComparable\<LinePosition>, IEquatable\<LinePosition>
* &emsp; \| &emsp; \| &emsp; public LinePosition\(int line, int character\);
* &emsp; \| &emsp; \| &emsp; public int Character \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int Line \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static LinePosition Zero \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int CompareTo\(LinePosition other\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(LinePosition other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(LinePosition left, LinePosition right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator >\(LinePosition left, LinePosition right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator >=\(LinePosition left, LinePosition right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(LinePosition left, LinePosition right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \<\(LinePosition left, LinePosition right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \<=\(LinePosition left, LinePosition right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Text\.LinePositionSpan : IEquatable\<LinePositionSpan>
* &emsp; \| &emsp; \| &emsp; public LinePositionSpan\(LinePosition start, LinePosition end\);
* &emsp; \| &emsp; \| &emsp; public LinePosition End \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LinePosition Start \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(LinePositionSpan other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(LinePositionSpan left, LinePositionSpan right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(LinePositionSpan left, LinePositionSpan right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Text\.TextChange : IEquatable\<TextChange>
* &emsp; \| &emsp; \| &emsp; public TextChange\(TextSpan span, string newText\);
* &emsp; \| &emsp; \| &emsp; public string NewText \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static IReadOnlyList\<TextChange> NoChanges \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(TextChange other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator TextChangeRange\(TextChange change\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(TextChange left, TextChange right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(TextChange left, TextChange right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Text\.TextChangeRange : IEquatable\<TextChangeRange>
* &emsp; \| &emsp; \| &emsp; public TextChangeRange\(TextSpan span, int newLength\);
* &emsp; \| &emsp; \| &emsp; public int NewLength \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static IReadOnlyList\<TextChangeRange> NoChanges \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static TextChangeRange Collapse\(IEnumerable\<TextChangeRange> changes\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(TextChangeRange other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(TextChangeRange left, TextChangeRange right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(TextChangeRange left, TextChangeRange right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Text\.TextLine : IEquatable\<TextLine>
* &emsp; \| &emsp; \| &emsp; public int End \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int EndIncludingLineBreak \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int LineNumber \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan SpanIncludingLineBreak \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int Start \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SourceText Text \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(TextLine other\);
* &emsp; \| &emsp; \| &emsp; public static TextLine FromSpan\(SourceText text, TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(TextLine left, TextLine right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(TextLine left, TextLine right\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Text\.TextLineCollection\.Enumerator : IDisposable, IEnumerator, IEnumerator\<TextLine>
* &emsp; \| &emsp; \| &emsp; public TextLine Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; public struct Microsoft\.CodeAnalysis\.Text\.TextSpan : IComparable\<TextSpan>, IEquatable\<TextSpan>
* &emsp; \| &emsp; \| &emsp; public TextSpan\(int start, int length\);
* &emsp; \| &emsp; \| &emsp; public int End \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsEmpty \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int Length \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int Start \{ get; \}
* &emsp; \| &emsp; \| &emsp; public int CompareTo\(TextSpan other\);
* &emsp; \| &emsp; \| &emsp; public bool Contains\(int position\);
* &emsp; \| &emsp; \| &emsp; public bool Contains\(TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(TextSpan other\);
* &emsp; \| &emsp; \| &emsp; public static TextSpan FromBounds\(int start, int end\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public TextSpan? Intersection\(TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public bool IntersectsWith\(int position\);
* &emsp; \| &emsp; \| &emsp; public bool IntersectsWith\(TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public TextSpan? Overlap\(TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public bool OverlapsWith\(TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(TextSpan left, TextSpan right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(TextSpan left, TextSpan right\);
* &emsp; \| &emsp; public readonly struct Roslynator\.ExtensionMethodSymbolInfo : IEquatable\<ExtensionMethodSymbolInfo>
* &emsp; \| &emsp; \| &emsp; public bool IsReduced \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol ReducedSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol ReducedSymbolOrSymbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IMethodSymbol Symbol \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ExtensionMethodSymbolInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.MetadataName : IEquatable\<MetadataName>
* &emsp; \| &emsp; \| &emsp; public MetadataName\(IEnumerable\<string> containingNamespaces, string name\);
* &emsp; \| &emsp; \| &emsp; public MetadataName\(ImmutableArray\<string> containingNamespaces, string name\);
* &emsp; \| &emsp; \| &emsp; public MetadataName\(IEnumerable\<string> containingNamespaces, IEnumerable\<string> containingTypes, string name\);
* &emsp; \| &emsp; \| &emsp; public MetadataName\(ImmutableArray\<string> containingNamespaces, ImmutableArray\<string> containingTypes, string name\);
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<string> ContainingNamespaces \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<string> ContainingTypes \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsDefault \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(MetadataName other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public static MetadataName Parse\(string name\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool TryParse\(string name, out MetadataName metadataName\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in MetadataName metadataName1, in MetadataName metadataName2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in MetadataName metadataName1, in MetadataName metadataName2\);
* &emsp; \| &emsp; public struct Roslynator\.SeparatedSyntaxListSelection\<TNode>\.Enumerator
* &emsp; \| &emsp; \| &emsp; public TNode Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public struct Roslynator\.SyntaxListSelection\<TNode>\.Enumerator
* &emsp; \| &emsp; \| &emsp; public TNode Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.ExpressionChain : IEquatable\<ExpressionChain>, IEnumerable\<ExpressionSyntax>
* &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax BinaryExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan? Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ExpressionChain other\);
* &emsp; \| &emsp; \| &emsp; public ExpressionChain\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public ExpressionChain\.Reversed Reverse\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in ExpressionChain info1, in ExpressionChain info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in ExpressionChain info1, in ExpressionChain info2\);
* &emsp; \| &emsp; public struct Roslynator\.CSharp\.ExpressionChain\.Enumerator
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.ExpressionChain\.Reversed : IEquatable\<ExpressionChain\.Reversed>, IEnumerable\<ExpressionSyntax>
* &emsp; \| &emsp; \| &emsp; public Reversed\(in ExpressionChain chain\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ExpressionChain\.Reversed other\);
* &emsp; \| &emsp; \| &emsp; public ExpressionChain\.Reversed\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in ExpressionChain\.Reversed reversed1, in ExpressionChain\.Reversed reversed2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in ExpressionChain\.Reversed reversed1, in ExpressionChain\.Reversed reversed2\);
* &emsp; \| &emsp; public struct Roslynator\.CSharp\.ExpressionChain\.Reversed\.Enumerator
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.IfStatementCascade : IEquatable\<IfStatementCascade>, IEnumerable\<IfStatementOrElseClause>
* &emsp; \| &emsp; \| &emsp; public IfStatementSyntax IfStatement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(IfStatementCascade other\);
* &emsp; \| &emsp; \| &emsp; public IfStatementCascade\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in IfStatementCascade cascade1, in IfStatementCascade cascade2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in IfStatementCascade cascade1, in IfStatementCascade cascade2\);
* &emsp; \| &emsp; public struct Roslynator\.CSharp\.IfStatementCascade\.Enumerator
* &emsp; \| &emsp; \| &emsp; public IfStatementOrElseClause Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.IfStatementCascadeInfo : IEquatable\<IfStatementCascadeInfo>
* &emsp; \| &emsp; \| &emsp; public IfStatementCascadeInfo\(IfStatementSyntax ifStatement\);
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool EndsWithElse \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool EndsWithIf \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IfStatementSyntax IfStatement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsSimpleIf \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsSimpleIfElse \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IfStatementOrElseClause Last \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(IfStatementCascadeInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.IfStatementOrElseClause : IEquatable\<IfStatementOrElseClause>
* &emsp; \| &emsp; \| &emsp; public IfStatementOrElseClause\(ElseClauseSyntax elseClause\);
* &emsp; \| &emsp; \| &emsp; public IfStatementOrElseClause\(IfStatementSyntax ifStatement\);
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsElse \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsIf \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ElseClauseSyntax AsElse\(\);
* &emsp; \| &emsp; \| &emsp; public IfStatementSyntax AsIf\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(IfStatementOrElseClause other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator IfStatementOrElseClause\(IfStatementSyntax ifStatement\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator IfStatementSyntax\(in IfStatementOrElseClause ifOrElse\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator IfStatementOrElseClause\(ElseClauseSyntax elseClause\);
* &emsp; \| &emsp; \| &emsp; public static implicit operator ElseClauseSyntax\(in IfStatementOrElseClause ifOrElse\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in IfStatementOrElseClause left, in IfStatementOrElseClause right\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in IfStatementOrElseClause left, in IfStatementOrElseClause right\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.AsExpressionInfo : IEquatable\<AsExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax AsExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(AsExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in AsExpressionInfo info1, in AsExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in AsExpressionInfo info1, in AsExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.AssignmentExpressionInfo : IEquatable\<AssignmentExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public AssignmentExpressionSyntax AssignmentExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Left \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Right \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(AssignmentExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.BinaryExpressionInfo : IEquatable\<BinaryExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax BinaryExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Left \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Right \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionChain AsChain\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(BinaryExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<ExpressionSyntax> Expressions\(bool leftToRight = false\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.ConditionalExpressionInfo : IEquatable\<ConditionalExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ConditionalExpressionSyntax ConditionalExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken QuestionToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax WhenFalse \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax WhenTrue \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ConditionalExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.GenericInfo : IEquatable\<GenericInfo>
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<TypeParameterConstraintClauseSyntax> ConstraintClauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Node \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax TypeParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TypeParameterSyntax> TypeParameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(GenericInfo other\);
* &emsp; \| &emsp; \| &emsp; public TypeParameterConstraintClauseSyntax FindConstraintClause\(string typeParameterName\);
* &emsp; \| &emsp; \| &emsp; public TypeParameterSyntax FindTypeParameter\(string name\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public GenericInfo RemoveAllConstraintClauses\(\);
* &emsp; \| &emsp; \| &emsp; public GenericInfo RemoveConstraintClause\(TypeParameterConstraintClauseSyntax constraintClause\);
* &emsp; \| &emsp; \| &emsp; public GenericInfo RemoveTypeParameter\(TypeParameterSyntax typeParameter\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public GenericInfo WithConstraintClauses\(SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses\);
* &emsp; \| &emsp; \| &emsp; public GenericInfo WithTypeParameterList\(TypeParameterListSyntax typeParameterList\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in GenericInfo info1, in GenericInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in GenericInfo info1, in GenericInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.IsExpressionInfo : IEquatable\<IsExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax IsExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(IsExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in IsExpressionInfo info1, in IsExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in IsExpressionInfo info1, in IsExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.LocalDeclarationStatementInfo : IEquatable\<LocalDeclarationStatementInfo>
* &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LocalDeclarationStatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<VariableDeclaratorSyntax> Variables \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(LocalDeclarationStatementInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.MemberDeclarationListInfo : IEquatable\<MemberDeclarationListInfo>, IReadOnlyList\<MemberDeclarationSyntax>
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<MemberDeclarationSyntax> Members \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationSyntax this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo Add\(MemberDeclarationSyntax member\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo AddRange\(IEnumerable\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(MemberDeclarationListInfo other\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationSyntax First\(\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationSyntax FirstOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<MemberDeclarationSyntax>\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(MemberDeclarationSyntax member\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(Func\<MemberDeclarationSyntax, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo Insert\(int index, MemberDeclarationSyntax member\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo InsertRange\(int index, IEnumerable\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationSyntax Last\(\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(MemberDeclarationSyntax member\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(Func\<MemberDeclarationSyntax, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationSyntax LastOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo Remove\(MemberDeclarationSyntax member\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo RemoveAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo RemoveNode\(SyntaxNode node, SyntaxRemoveOptions options\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo Replace\(MemberDeclarationSyntax memberInList, MemberDeclarationSyntax newMember\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo ReplaceAt\(int index, MemberDeclarationSyntax newMember\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo ReplaceNode\(SyntaxNode oldNode, SyntaxNode newNode\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo ReplaceRange\(MemberDeclarationSyntax memberInList, IEnumerable\<MemberDeclarationSyntax> newMembers\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo WithMembers\(IEnumerable\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; public MemberDeclarationListInfo WithMembers\(SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.ModifierListInfo : IEquatable\<ModifierListInfo>
* &emsp; \| &emsp; \| &emsp; public Accessibility ExplicitAccessibility \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsAbstract \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsAsync \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsConst \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsExtern \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsIn \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsNew \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsOut \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsOverride \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsParams \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsPartial \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsReadOnly \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsRef \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsSealed \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsStatic \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsUnsafe \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsVirtual \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsVolatile \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(ModifierListInfo other\);
* &emsp; \| &emsp; \| &emsp; public ModifierFilter GetFilter\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public ModifierListInfo WithExplicitAccessibility\(Accessibility newAccessibility, IComparer\<SyntaxKind> comparer = null\);
* &emsp; \| &emsp; \| &emsp; public ModifierListInfo WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; public ModifierListInfo WithoutExplicitAccessibility\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in ModifierListInfo info1, in ModifierListInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in ModifierListInfo info1, in ModifierListInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.NullCheckExpressionInfo : IEquatable\<NullCheckExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsCheckingNotNull \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsCheckingNull \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax NullCheckExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public NullCheckStyles Style \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(NullCheckExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.RegionInfo : IEquatable\<RegionInfo>
* &emsp; \| &emsp; \| &emsp; public RegionDirectiveTriviaSyntax Directive \{ get; \}
* &emsp; \| &emsp; \| &emsp; public EndRegionDirectiveTriviaSyntax EndDirective \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsEmpty \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(RegionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in RegionInfo info1, in RegionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in RegionInfo info1, in RegionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.SimpleAssignmentExpressionInfo : IEquatable\<SimpleAssignmentExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public AssignmentExpressionSyntax AssignmentExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Left \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Right \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SimpleAssignmentExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.SimpleAssignmentStatementInfo : IEquatable\<SimpleAssignmentStatementInfo>
* &emsp; \| &emsp; \| &emsp; public AssignmentExpressionSyntax AssignmentExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Left \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Right \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionStatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SimpleAssignmentStatementInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.SimpleIfElseInfo : IEquatable\<SimpleIfElseInfo>
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ElseClauseSyntax Else \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IfStatementSyntax IfStatement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public StatementSyntax WhenFalse \{ get; \}
* &emsp; \| &emsp; \| &emsp; public StatementSyntax WhenTrue \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SimpleIfElseInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.SimpleIfStatementInfo : IEquatable\<SimpleIfStatementInfo>
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; public IfStatementSyntax IfStatement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SimpleIfStatementInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.SimpleMemberInvocationExpressionInfo : IEquatable\<SimpleMemberInvocationExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<ArgumentSyntax> Arguments \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public InvocationExpressionSyntax InvocationExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public MemberAccessExpressionSyntax MemberAccessExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SimpleNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string NameText \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SimpleMemberInvocationExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.SimpleMemberInvocationStatementInfo : IEquatable\<SimpleMemberInvocationStatementInfo>
* &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<ArgumentSyntax> Arguments \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public InvocationExpressionSyntax InvocationExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public MemberAccessExpressionSyntax MemberAccessExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SimpleNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string NameText \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionStatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SimpleMemberInvocationStatementInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.SingleLocalDeclarationStatementInfo : IEquatable\<SingleLocalDeclarationStatementInfo>
* &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; public VariableDeclaratorSyntax Declarator \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken EqualsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string IdentifierText \{ get; \}
* &emsp; \| &emsp; \| &emsp; public EqualsValueClauseSyntax Initializer \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LocalDeclarationStatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Value \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SingleLocalDeclarationStatementInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.SingleParameterLambdaExpressionInfo : IEquatable\<SingleParameterLambdaExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public CSharpSyntaxNode Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsParenthesizedLambda \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsSimpleLambda \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LambdaExpressionSyntax LambdaExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ParameterSyntax Parameter \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SingleParameterLambdaExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.StatementListInfo : IEquatable\<StatementListInfo>, IReadOnlyList\<StatementSyntax>
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsParentBlock \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsParentSwitchSection \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; \| &emsp; public BlockSyntax ParentAsBlock \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SwitchSectionSyntax ParentAsSwitchSection \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<StatementSyntax> Statements \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public StatementSyntax this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public StatementListInfo Add\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo AddRange\(IEnumerable\<StatementSyntax> statements\);
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(StatementListInfo other\);
* &emsp; \| &emsp; \| &emsp; public StatementSyntax First\(\);
* &emsp; \| &emsp; \| &emsp; public StatementSyntax FirstOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<StatementSyntax>\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(Func\<StatementSyntax, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo Insert\(int index, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo InsertRange\(int index, IEnumerable\<StatementSyntax> statements\);
* &emsp; \| &emsp; \| &emsp; public StatementSyntax Last\(\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(Func\<StatementSyntax, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; public StatementSyntax LastOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo Remove\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo RemoveAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo RemoveNode\(SyntaxNode node, SyntaxRemoveOptions options\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo Replace\(StatementSyntax statementInList, StatementSyntax newStatement\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo ReplaceAt\(int index, StatementSyntax newStatement\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo ReplaceNode\(SyntaxNode oldNode, SyntaxNode newNode\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo ReplaceRange\(StatementSyntax statementInList, IEnumerable\<StatementSyntax> newStatements\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo WithStatements\(IEnumerable\<StatementSyntax> statements\);
* &emsp; \| &emsp; \| &emsp; public StatementListInfo WithStatements\(SyntaxList\<StatementSyntax> statements\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in StatementListInfo info1, in StatementListInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in StatementListInfo info1, in StatementListInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.StringConcatenationExpressionInfo : IEquatable\<StringConcatenationExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax BinaryExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ExpressionChain AsChain\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(StringConcatenationExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<ExpressionSyntax> Expressions\(bool leftToRight = false\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.StringLiteralExpressionInfo : IEquatable\<StringLiteralExpressionInfo>
* &emsp; \| &emsp; \| &emsp; public bool ContainsEscapeSequence \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool ContainsLinefeed \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LiteralExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string InnerText \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsRegular \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsVerbatim \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Text \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxToken Token \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string ValueText \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(StringLiteralExpressionInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.UsingDirectiveListInfo : IEquatable\<UsingDirectiveListInfo>, IReadOnlyList\<UsingDirectiveSyntax>
* &emsp; \| &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<UsingDirectiveSyntax> Usings \{ get; \}
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax this\[int index\] \{ get; \}
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo Add\(UsingDirectiveSyntax usingDirective\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo AddRange\(IEnumerable\<UsingDirectiveSyntax> usings\);
* &emsp; \| &emsp; \| &emsp; public bool Any\(\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(UsingDirectiveListInfo other\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax First\(\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax FirstOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxList\<UsingDirectiveSyntax>\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(Func\<UsingDirectiveSyntax, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public int IndexOf\(UsingDirectiveSyntax usingDirective\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo Insert\(int index, UsingDirectiveSyntax usingDirective\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo InsertRange\(int index, IEnumerable\<UsingDirectiveSyntax> usings\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax Last\(\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(Func\<UsingDirectiveSyntax, bool> predicate\);
* &emsp; \| &emsp; \| &emsp; public int LastIndexOf\(UsingDirectiveSyntax usingDirective\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax LastOrDefault\(\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo Remove\(UsingDirectiveSyntax usingDirective\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo RemoveAt\(int index\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo RemoveNode\(SyntaxNode node, SyntaxRemoveOptions options\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo Replace\(UsingDirectiveSyntax usingInLine, UsingDirectiveSyntax newUsingDirective\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo ReplaceAt\(int index, UsingDirectiveSyntax newUsingDirective\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo ReplaceNode\(SyntaxNode oldNode, SyntaxNode newNode\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo ReplaceRange\(UsingDirectiveSyntax usingInLine, IEnumerable\<UsingDirectiveSyntax> newUsingDirectives\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo WithUsings\(IEnumerable\<UsingDirectiveSyntax> usings\);
* &emsp; \| &emsp; \| &emsp; public UsingDirectiveListInfo WithUsings\(SyntaxList\<UsingDirectiveSyntax> usings\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2\);
* &emsp; \| &emsp; public readonly struct Roslynator\.CSharp\.Syntax\.XmlElementInfo : IEquatable\<XmlElementInfo>
* &emsp; \| &emsp; \| &emsp; public XmlNodeSyntax Element \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool IsEmptyElement \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SyntaxKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string LocalName \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(XmlElementInfo other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; \| &emsp; public static bool operator ==\(in XmlElementInfo info1, in XmlElementInfo info2\);
* &emsp; \| &emsp; \| &emsp; public static bool operator \!=\(in XmlElementInfo info1, in XmlElementInfo info2\);
* &emsp; \| &emsp; public struct Roslynator\.Text\.TextLineCollectionSelection\.Enumerator
* &emsp; \| &emsp; \| &emsp; public TextLine Current \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public bool MoveNext\(\);
* &emsp; \| &emsp; \| &emsp; public void Reset\(\);
* &emsp; public abstract class System\.Collections\.Generic\.EqualityComparer\<T> : IEqualityComparer, IEqualityComparer\<T>
* &emsp; \| &emsp; public sealed class Roslynator\.MetadataNameEqualityComparer\<TSymbol> : EqualityComparer\<TSymbol> where TSymbol : ISymbol
* &emsp; \| &emsp; \| &emsp; public static MetadataNameEqualityComparer\<TSymbol> Instance \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(TSymbol x, TSymbol y\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(TSymbol obj\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.AdditionalText
* &emsp; \| &emsp; protected AdditionalText\(\);
* &emsp; \| &emsp; public abstract string Path \{ get; \}
* &emsp; \| &emsp; public abstract SourceText GetText\(CancellationToken cancellationToken = default\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.AssemblyIdentity : IEquatable\<AssemblyIdentity>
* &emsp; \| &emsp; public AssemblyIdentity\(string name, Version version = null, string cultureName = null, ImmutableArray\<byte> publicKeyOrToken = default, bool hasPublicKey = false, bool isRetargetable = false, AssemblyContentType contentType = Default\);
* &emsp; \| &emsp; public AssemblyContentType ContentType \{ get; \}
* &emsp; \| &emsp; public string CultureName \{ get; \}
* &emsp; \| &emsp; public AssemblyNameFlags Flags \{ get; \}
* &emsp; \| &emsp; public bool HasPublicKey \{ get; \}
* &emsp; \| &emsp; public bool IsRetargetable \{ get; \}
* &emsp; \| &emsp; public bool IsStrongName \{ get; \}
* &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<byte> PublicKey \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<byte> PublicKeyToken \{ get; \}
* &emsp; \| &emsp; public Version Version \{ get; \}
* &emsp; \| &emsp; public bool Equals\(AssemblyIdentity obj\);
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public static AssemblyIdentity FromAssemblyDefinition\(Assembly assembly\);
* &emsp; \| &emsp; public string GetDisplayName\(bool fullKey = false\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public static bool TryParseDisplayName\(string displayName, out AssemblyIdentity identity\);
* &emsp; \| &emsp; public static bool TryParseDisplayName\(string displayName, out AssemblyIdentity identity, out AssemblyIdentityParts parts\);
* &emsp; \| &emsp; public static bool operator ==\(AssemblyIdentity left, AssemblyIdentity right\);
* &emsp; \| &emsp; public static bool operator \!=\(AssemblyIdentity left, AssemblyIdentity right\);
* &emsp; public class Microsoft\.CodeAnalysis\.AssemblyIdentityComparer
* &emsp; \| &emsp; public static StringComparer CultureComparer \{ get; \}
* &emsp; \| &emsp; public static AssemblyIdentityComparer Default \{ get; \}
* &emsp; \| &emsp; public static StringComparer SimpleNameComparer \{ get; \}
* &emsp; \| &emsp; public AssemblyIdentityComparer\.ComparisonResult Compare\(AssemblyIdentity reference, AssemblyIdentity definition\);
* &emsp; \| &emsp; public bool ReferenceMatchesDefinition\(AssemblyIdentity reference, AssemblyIdentity definition\);
* &emsp; \| &emsp; public bool ReferenceMatchesDefinition\(string referenceDisplayName, AssemblyIdentity definition\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.DesktopAssemblyIdentityComparer : AssemblyIdentityComparer
* &emsp; \| &emsp; \| &emsp; public static DesktopAssemblyIdentityComparer Default \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static DesktopAssemblyIdentityComparer LoadFromXml\(Stream input\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.AttributeData
* &emsp; \| &emsp; protected AttributeData\(\);
* &emsp; \| &emsp; public SyntaxReference ApplicationSyntaxReference \{ get; \}
* &emsp; \| &emsp; public INamedTypeSymbol AttributeClass \{ get; \}
* &emsp; \| &emsp; public IMethodSymbol AttributeConstructor \{ get; \}
* &emsp; \| &emsp; protected abstract SyntaxReference CommonApplicationSyntaxReference \{ get; \}
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonAttributeClass \{ get; \}
* &emsp; \| &emsp; protected abstract IMethodSymbol CommonAttributeConstructor \{ get; \}
* &emsp; \| &emsp; protected internal abstract ImmutableArray\<TypedConstant> CommonConstructorArguments \{ get; \}
* &emsp; \| &emsp; protected internal abstract ImmutableArray\<KeyValuePair\<string, TypedConstant>> CommonNamedArguments \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<TypedConstant> ConstructorArguments \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<KeyValuePair\<string, TypedConstant>> NamedArguments \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CommandLineArguments
* &emsp; \| &emsp; public ImmutableArray\<CommandLineSourceFile> AdditionalFiles \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<CommandLineAnalyzerReference> AnalyzerReferences \{ get; \}
* &emsp; \| &emsp; public string AppConfigPath \{ get; \}
* &emsp; \| &emsp; public string BaseDirectory \{ get; \}
* &emsp; \| &emsp; public SourceHashAlgorithm ChecksumAlgorithm \{ get; \}
* &emsp; \| &emsp; public string CompilationName \{ get; \}
* &emsp; \| &emsp; public CompilationOptions CompilationOptions \{ get; \}
* &emsp; \| &emsp; protected abstract CompilationOptions CompilationOptionsCore \{ get; \}
* &emsp; \| &emsp; public bool DisplayHelp \{ get; \}
* &emsp; \| &emsp; public bool DisplayLogo \{ get; \}
* &emsp; \| &emsp; public bool DisplayVersion \{ get; \}
* &emsp; \| &emsp; public string DocumentationPath \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<CommandLineSourceFile> EmbeddedFiles \{ get; \}
* &emsp; \| &emsp; public EmitOptions EmitOptions \{ get; \}
* &emsp; \| &emsp; public bool EmitPdb \{ get; \}
* &emsp; \| &emsp; public Encoding Encoding \{ get; \}
* &emsp; \| &emsp; public string ErrorLogPath \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<Diagnostic> Errors \{ get; \}
* &emsp; \| &emsp; public bool InteractiveMode \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<string> KeyFileSearchPaths \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<ResourceDescription> ManifestResources \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<CommandLineReference> MetadataReferences \{ get; \}
* &emsp; \| &emsp; public bool NoWin32Manifest \{ get; \}
* &emsp; \| &emsp; public string OutputDirectory \{ get; \}
* &emsp; \| &emsp; public string OutputFileName \{ get; \}
* &emsp; \| &emsp; public string OutputRefFilePath \{ get; \}
* &emsp; \| &emsp; public ParseOptions ParseOptions \{ get; \}
* &emsp; \| &emsp; protected abstract ParseOptions ParseOptionsCore \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<KeyValuePair\<string, string>> PathMap \{ get; \}
* &emsp; \| &emsp; public string PdbPath \{ get; \}
* &emsp; \| &emsp; public CultureInfo PreferredUILang \{ get; \}
* &emsp; \| &emsp; public bool PrintFullPaths \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<string> ReferencePaths \{ get; \}
* &emsp; \| &emsp; public bool ReportAnalyzer \{ get; \}
* &emsp; \| &emsp; public string RuleSetPath \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<string> ScriptArguments \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<CommandLineSourceFile> SourceFiles \{ get; \}
* &emsp; \| &emsp; public string SourceLink \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<string> SourcePaths \{ get; \}
* &emsp; \| &emsp; public string TouchedFilesPath \{ get; \}
* &emsp; \| &emsp; public bool Utf8Output \{ get; \}
* &emsp; \| &emsp; public string Win32Icon \{ get; \}
* &emsp; \| &emsp; public string Win32Manifest \{ get; \}
* &emsp; \| &emsp; public string Win32ResourceFile \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<AnalyzerReference> ResolveAnalyzerReferences\(IAnalyzerAssemblyLoader analyzerLoader\);
* &emsp; \| &emsp; public IEnumerable\<MetadataReference> ResolveMetadataReferences\(MetadataReferenceResolver metadataResolver\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.CSharpCommandLineArguments : CommandLineArguments
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions CompilationOptions \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CompilationOptionsCore \{ get; \}
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions ParseOptions \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override ParseOptions ParseOptionsCore \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CommandLineParser
* &emsp; \| &emsp; protected abstract string RegularFileExtension \{ get; \}
* &emsp; \| &emsp; protected abstract string ScriptFileExtension \{ get; \}
* &emsp; \| &emsp; public CommandLineArguments Parse\(IEnumerable\<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories\);
* &emsp; \| &emsp; protected ImmutableArray\<KeyValuePair\<string, string>> ParsePathMap\(string pathMap, IList\<Diagnostic> errors\);
* &emsp; \| &emsp; public static IEnumerable\<string> SplitCommandLineIntoArguments\(string commandLine, bool removeHashComments\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.CSharp\.CSharpCommandLineParser : CommandLineParser
* &emsp; \| &emsp; \| &emsp; public static CSharpCommandLineParser Default \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override string RegularFileExtension \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override string ScriptFileExtension \{ get; \}
* &emsp; \| &emsp; \| &emsp; public CSharpCommandLineArguments Parse\(IEnumerable\<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories = null\);
* &emsp; \| &emsp; \| &emsp; public static IEnumerable\<string> ParseConditionalCompilationSymbols\(string value, out IEnumerable\<Diagnostic> diagnostics\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Compilation
* &emsp; \| &emsp; public IAssemblySymbol Assembly \{ get; \}
* &emsp; \| &emsp; public string AssemblyName \{ get; \}
* &emsp; \| &emsp; protected abstract IAssemblySymbol CommonAssembly \{ get; \}
* &emsp; \| &emsp; protected abstract ITypeSymbol CommonDynamicType \{ get; \}
* &emsp; \| &emsp; protected abstract INamespaceSymbol CommonGlobalNamespace \{ get; \}
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonObjectType \{ get; \}
* &emsp; \| &emsp; protected abstract CompilationOptions CommonOptions \{ get; \}
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonScriptClass \{ get; \}
* &emsp; \| &emsp; protected abstract IModuleSymbol CommonSourceModule \{ get; \}
* &emsp; \| &emsp; protected abstract IEnumerable\<SyntaxTree> CommonSyntaxTrees \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<MetadataReference> DirectiveReferences \{ get; \}
* &emsp; \| &emsp; public ITypeSymbol DynamicType \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<MetadataReference> ExternalReferences \{ get; \}
* &emsp; \| &emsp; public INamespaceSymbol GlobalNamespace \{ get; \}
* &emsp; \| &emsp; public abstract bool IsCaseSensitive \{ get; \}
* &emsp; \| &emsp; public abstract string Language \{ get; \}
* &emsp; \| &emsp; public INamedTypeSymbol ObjectType \{ get; \}
* &emsp; \| &emsp; public CompilationOptions Options \{ get; \}
* &emsp; \| &emsp; public abstract IEnumerable\<AssemblyIdentity> ReferencedAssemblyNames \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<MetadataReference> References \{ get; \}
* &emsp; \| &emsp; public INamedTypeSymbol ScriptClass \{ get; \}
* &emsp; \| &emsp; public ScriptCompilationInfo ScriptCompilationInfo \{ get; \}
* &emsp; \| &emsp; public IModuleSymbol SourceModule \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<SyntaxTree> SyntaxTrees \{ get; \}
* &emsp; \| &emsp; public Compilation AddReferences\(params MetadataReference\[\] references\);
* &emsp; \| &emsp; public Compilation AddReferences\(IEnumerable\<MetadataReference> references\);
* &emsp; \| &emsp; public Compilation AddSyntaxTrees\(params SyntaxTree\[\] trees\);
* &emsp; \| &emsp; public Compilation AddSyntaxTrees\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; protected abstract void AppendDefaultVersionResource\(Stream resourceStream\);
* &emsp; \| &emsp; protected static void CheckTupleElementLocations\(int cardinality, ImmutableArray\<Location> elementLocations\);
* &emsp; \| &emsp; protected static ImmutableArray\<string> CheckTupleElementNames\(int cardinality, ImmutableArray\<string> elementNames\);
* &emsp; \| &emsp; public Compilation Clone\(\);
* &emsp; \| &emsp; protected abstract Compilation CommonAddSyntaxTrees\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; protected INamedTypeSymbol CommonBindScriptClass\(\);
* &emsp; \| &emsp; protected abstract Compilation CommonClone\(\);
* &emsp; \| &emsp; protected abstract bool CommonContainsSyntaxTree\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonCreateAnonymousTypeSymbol\(ImmutableArray\<ITypeSymbol> memberTypes, ImmutableArray\<string> memberNames, ImmutableArray\<Location> memberLocations, ImmutableArray\<bool> memberIsReadOnly\);
* &emsp; \| &emsp; protected abstract IArrayTypeSymbol CommonCreateArrayTypeSymbol\(ITypeSymbol elementType, int rank\);
* &emsp; \| &emsp; protected abstract INamespaceSymbol CommonCreateErrorNamespaceSymbol\(INamespaceSymbol container, string name\);
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonCreateErrorTypeSymbol\(INamespaceOrTypeSymbol container, string name, int arity\);
* &emsp; \| &emsp; protected abstract IPointerTypeSymbol CommonCreatePointerTypeSymbol\(ITypeSymbol elementType\);
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonCreateTupleTypeSymbol\(ImmutableArray\<ITypeSymbol> elementTypes, ImmutableArray\<string> elementNames, ImmutableArray\<Location> elementLocations\);
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonCreateTupleTypeSymbol\(INamedTypeSymbol underlyingType, ImmutableArray\<string> elementNames, ImmutableArray\<Location> elementLocations\);
* &emsp; \| &emsp; protected abstract ISymbol CommonGetAssemblyOrModuleSymbol\(MetadataReference reference\);
* &emsp; \| &emsp; protected abstract INamespaceSymbol CommonGetCompilationNamespace\(INamespaceSymbol namespaceSymbol\);
* &emsp; \| &emsp; protected abstract IMethodSymbol CommonGetEntryPoint\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; protected abstract SemanticModel CommonGetSemanticModel\(SyntaxTree syntaxTree, bool ignoreAccessibility\);
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonGetSpecialType\(SpecialType specialType\);
* &emsp; \| &emsp; protected abstract INamedTypeSymbol CommonGetTypeByMetadataName\(string metadataName\);
* &emsp; \| &emsp; protected abstract Compilation CommonRemoveAllSyntaxTrees\(\);
* &emsp; \| &emsp; protected abstract Compilation CommonRemoveSyntaxTrees\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; protected abstract Compilation CommonReplaceSyntaxTree\(SyntaxTree oldTree, SyntaxTree newTree\);
* &emsp; \| &emsp; protected abstract Compilation CommonWithAssemblyName\(string outputName\);
* &emsp; \| &emsp; protected abstract Compilation CommonWithOptions\(CompilationOptions options\);
* &emsp; \| &emsp; protected abstract Compilation CommonWithReferences\(IEnumerable\<MetadataReference> newReferences\);
* &emsp; \| &emsp; protected abstract Compilation CommonWithScriptCompilationInfo\(ScriptCompilationInfo info\);
* &emsp; \| &emsp; public abstract bool ContainsSymbolsWithName\(Func\<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public bool ContainsSyntaxTree\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; public INamedTypeSymbol CreateAnonymousTypeSymbol\(ImmutableArray\<ITypeSymbol> memberTypes, ImmutableArray\<string> memberNames, ImmutableArray\<bool> memberIsReadOnly = default, ImmutableArray\<Location> memberLocations = default\);
* &emsp; \| &emsp; public IArrayTypeSymbol CreateArrayTypeSymbol\(ITypeSymbol elementType, int rank = 1\);
* &emsp; \| &emsp; public Stream CreateDefaultWin32Resources\(bool versionResource, bool noManifest, Stream manifestContents, Stream iconInIcoFormat\);
* &emsp; \| &emsp; public INamespaceSymbol CreateErrorNamespaceSymbol\(INamespaceSymbol container, string name\);
* &emsp; \| &emsp; public INamedTypeSymbol CreateErrorTypeSymbol\(INamespaceOrTypeSymbol container, string name, int arity\);
* &emsp; \| &emsp; public IPointerTypeSymbol CreatePointerTypeSymbol\(ITypeSymbol pointedAtType\);
* &emsp; \| &emsp; public INamedTypeSymbol CreateTupleTypeSymbol\(ImmutableArray\<ITypeSymbol> elementTypes, ImmutableArray\<string> elementNames = default, ImmutableArray\<Location> elementLocations = default\);
* &emsp; \| &emsp; public INamedTypeSymbol CreateTupleTypeSymbol\(INamedTypeSymbol underlyingType, ImmutableArray\<string> elementNames = default, ImmutableArray\<Location> elementLocations = default\);
* &emsp; \| &emsp; public EmitResult Emit\(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable\<ResourceDescription> manifestResources, EmitOptions options, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public EmitResult Emit\(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable\<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public EmitResult Emit\(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable\<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable\<EmbeddedText> embeddedTexts, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public EmitResult Emit\(Stream peStream, Stream pdbStream = null, Stream xmlDocumentationStream = null, Stream win32Resources = null, IEnumerable\<ResourceDescription> manifestResources = null, EmitOptions options = null, IMethodSymbol debugEntryPoint = null, Stream sourceLinkStream = null, IEnumerable\<EmbeddedText> embeddedTexts = null, Stream metadataPEStream = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public EmitDifferenceResult EmitDifference\(EmitBaseline baseline, IEnumerable\<SemanticEdit> edits, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection\<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public EmitDifferenceResult EmitDifference\(EmitBaseline baseline, IEnumerable\<SemanticEdit> edits, Func\<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection\<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public ISymbol GetAssemblyOrModuleSymbol\(MetadataReference reference\);
* &emsp; \| &emsp; public INamespaceSymbol GetCompilationNamespace\(INamespaceSymbol namespaceSymbol\);
* &emsp; \| &emsp; public abstract ImmutableArray\<Diagnostic> GetDeclarationDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract ImmutableArray\<Diagnostic> GetDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public IMethodSymbol GetEntryPoint\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public MetadataReference GetMetadataReference\(IAssemblySymbol assemblySymbol\);
* &emsp; \| &emsp; public abstract ImmutableArray\<Diagnostic> GetMethodBodyDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract ImmutableArray\<Diagnostic> GetParseDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static string GetRequiredLanguageVersion\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public SemanticModel GetSemanticModel\(SyntaxTree syntaxTree, bool ignoreAccessibility = false\);
* &emsp; \| &emsp; public INamedTypeSymbol GetSpecialType\(SpecialType specialType\);
* &emsp; \| &emsp; public abstract IEnumerable\<ISymbol> GetSymbolsWithName\(Func\<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public INamedTypeSymbol GetTypeByMetadataName\(string fullyQualifiedMetadataName\);
* &emsp; \| &emsp; public ImmutableArray\<AssemblyIdentity> GetUnreferencedAssemblyIdentities\(Diagnostic diagnostic\);
* &emsp; \| &emsp; public Compilation RemoveAllReferences\(\);
* &emsp; \| &emsp; public Compilation RemoveAllSyntaxTrees\(\);
* &emsp; \| &emsp; public Compilation RemoveReferences\(params MetadataReference\[\] references\);
* &emsp; \| &emsp; public Compilation RemoveReferences\(IEnumerable\<MetadataReference> references\);
* &emsp; \| &emsp; public Compilation RemoveSyntaxTrees\(params SyntaxTree\[\] trees\);
* &emsp; \| &emsp; public Compilation RemoveSyntaxTrees\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; public Compilation ReplaceReference\(MetadataReference oldReference, MetadataReference newReference\);
* &emsp; \| &emsp; public Compilation ReplaceSyntaxTree\(SyntaxTree oldTree, SyntaxTree newTree\);
* &emsp; \| &emsp; protected static IReadOnlyDictionary\<string, string> SyntaxTreeCommonFeatures\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; public abstract CompilationReference ToMetadataReference\(ImmutableArray\<string> aliases = default, bool embedInteropTypes = false\);
* &emsp; \| &emsp; public Compilation WithAssemblyName\(string assemblyName\);
* &emsp; \| &emsp; public Compilation WithOptions\(CompilationOptions options\);
* &emsp; \| &emsp; public Compilation WithReferences\(IEnumerable\<MetadataReference> newReferences\);
* &emsp; \| &emsp; public Compilation WithReferences\(params MetadataReference\[\] newReferences\);
* &emsp; \| &emsp; public Compilation WithScriptCompilationInfo\(ScriptCompilationInfo info\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.CSharpCompilation : Compilation
* &emsp; \| &emsp; \| &emsp; protected override IAssemblySymbol CommonAssembly \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override ITypeSymbol CommonDynamicType \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override INamespaceSymbol CommonGlobalNamespace \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override INamedTypeSymbol CommonObjectType \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonOptions \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override INamedTypeSymbol CommonScriptClass \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override IModuleSymbol CommonSourceModule \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override IEnumerable\<SyntaxTree> CommonSyntaxTrees \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<MetadataReference> DirectiveReferences \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool IsCaseSensitive \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LanguageVersion LanguageVersion \{ get; \}
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override IEnumerable\<AssemblyIdentity> ReferencedAssemblyNames \{ get; \}
* &emsp; \| &emsp; \| &emsp; public CSharpScriptCompilationInfo ScriptCompilationInfo \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<SyntaxTree> SyntaxTrees \{ get; \}
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation AddReferences\(params MetadataReference\[\] references\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation AddReferences\(IEnumerable\<MetadataReference> references\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation AddSyntaxTrees\(params SyntaxTree\[\] trees\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation AddSyntaxTrees\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; \| &emsp; protected override void AppendDefaultVersionResource\(Stream resourceStream\);
* &emsp; \| &emsp; \| &emsp; public Conversion ClassifyConversion\(ITypeSymbol source, ITypeSymbol destination\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation Clone\(\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonAddSyntaxTrees\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonClone\(\);
* &emsp; \| &emsp; \| &emsp; protected override bool CommonContainsSyntaxTree\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; \| &emsp; protected override INamedTypeSymbol CommonCreateAnonymousTypeSymbol\(ImmutableArray\<ITypeSymbol> memberTypes, ImmutableArray\<string> memberNames, ImmutableArray\<Location> memberLocations, ImmutableArray\<bool> memberIsReadOnly\);
* &emsp; \| &emsp; \| &emsp; protected override IArrayTypeSymbol CommonCreateArrayTypeSymbol\(ITypeSymbol elementType, int rank\);
* &emsp; \| &emsp; \| &emsp; protected override INamespaceSymbol CommonCreateErrorNamespaceSymbol\(INamespaceSymbol container, string name\);
* &emsp; \| &emsp; \| &emsp; protected override INamedTypeSymbol CommonCreateErrorTypeSymbol\(INamespaceOrTypeSymbol container, string name, int arity\);
* &emsp; \| &emsp; \| &emsp; protected override IPointerTypeSymbol CommonCreatePointerTypeSymbol\(ITypeSymbol elementType\);
* &emsp; \| &emsp; \| &emsp; protected override INamedTypeSymbol CommonCreateTupleTypeSymbol\(ImmutableArray\<ITypeSymbol> elementTypes, ImmutableArray\<string> elementNames, ImmutableArray\<Location> elementLocations\);
* &emsp; \| &emsp; \| &emsp; protected override INamedTypeSymbol CommonCreateTupleTypeSymbol\(INamedTypeSymbol underlyingType, ImmutableArray\<string> elementNames, ImmutableArray\<Location> elementLocations\);
* &emsp; \| &emsp; \| &emsp; protected override ISymbol CommonGetAssemblyOrModuleSymbol\(MetadataReference reference\);
* &emsp; \| &emsp; \| &emsp; protected override INamespaceSymbol CommonGetCompilationNamespace\(INamespaceSymbol namespaceSymbol\);
* &emsp; \| &emsp; \| &emsp; protected override IMethodSymbol CommonGetEntryPoint\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; protected override SemanticModel CommonGetSemanticModel\(SyntaxTree syntaxTree, bool ignoreAccessibility\);
* &emsp; \| &emsp; \| &emsp; protected override INamedTypeSymbol CommonGetSpecialType\(SpecialType specialType\);
* &emsp; \| &emsp; \| &emsp; protected override INamedTypeSymbol CommonGetTypeByMetadataName\(string metadataName\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonRemoveAllSyntaxTrees\(\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonRemoveSyntaxTrees\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonReplaceSyntaxTree\(SyntaxTree oldTree, SyntaxTree newTree\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonWithAssemblyName\(string assemblyName\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonWithOptions\(CompilationOptions options\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonWithReferences\(IEnumerable\<MetadataReference> newReferences\);
* &emsp; \| &emsp; \| &emsp; protected override Compilation CommonWithScriptCompilationInfo\(ScriptCompilationInfo info\);
* &emsp; \| &emsp; \| &emsp; public override bool ContainsSymbolsWithName\(Func\<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public bool ContainsSyntaxTree\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; \| &emsp; public static CSharpCompilation Create\(string assemblyName, IEnumerable\<SyntaxTree> syntaxTrees = null, IEnumerable\<MetadataReference> references = null, CSharpCompilationOptions options = null\);
* &emsp; \| &emsp; \| &emsp; public static CSharpCompilation CreateScriptCompilation\(string assemblyName, SyntaxTree syntaxTree = null, IEnumerable\<MetadataReference> references = null, CSharpCompilationOptions options = null, CSharpCompilation previousScriptCompilation = null, Type returnType = null, Type globalsType = null\);
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<Diagnostic> GetDeclarationDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<Diagnostic> GetDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public MetadataReference GetDirectiveReference\(ReferenceDirectiveTriviaSyntax directive\);
* &emsp; \| &emsp; \| &emsp; public MetadataReference GetMetadataReference\(IAssemblySymbol assemblySymbol\);
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<Diagnostic> GetMethodBodyDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<Diagnostic> GetParseDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public SemanticModel GetSemanticModel\(SyntaxTree syntaxTree, bool ignoreAccessibility\);
* &emsp; \| &emsp; \| &emsp; public override IEnumerable\<ISymbol> GetSymbolsWithName\(Func\<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation RemoveAllReferences\(\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation RemoveAllSyntaxTrees\(\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation RemoveReferences\(params MetadataReference\[\] references\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation RemoveReferences\(IEnumerable\<MetadataReference> references\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation RemoveSyntaxTrees\(params SyntaxTree\[\] trees\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation RemoveSyntaxTrees\(IEnumerable\<SyntaxTree> trees\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation ReplaceReference\(MetadataReference oldReference, MetadataReference newReference\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation ReplaceSyntaxTree\(SyntaxTree oldTree, SyntaxTree newTree\);
* &emsp; \| &emsp; \| &emsp; public override CompilationReference ToMetadataReference\(ImmutableArray\<string> aliases = default, bool embedInteropTypes = false\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation WithAssemblyName\(string assemblyName\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation WithOptions\(CSharpCompilationOptions options\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation WithReferences\(IEnumerable\<MetadataReference> references\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation WithReferences\(params MetadataReference\[\] references\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation WithScriptCompilationInfo\(CSharpScriptCompilationInfo info\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CompilationOptions
* &emsp; \| &emsp; public AssemblyIdentityComparer AssemblyIdentityComparer \{ get; protected set; \}
* &emsp; \| &emsp; public bool CheckOverflow \{ get; protected set; \}
* &emsp; \| &emsp; public bool ConcurrentBuild \{ get; protected set; \}
* &emsp; \| &emsp; public string CryptoKeyContainer \{ get; protected set; \}
* &emsp; \| &emsp; public string CryptoKeyFile \{ get; protected set; \}
* &emsp; \| &emsp; public ImmutableArray\<byte> CryptoPublicKey \{ get; protected set; \}
* &emsp; \| &emsp; public bool? DelaySign \{ get; protected set; \}
* &emsp; \| &emsp; public bool Deterministic \{ get; protected set; \}
* &emsp; \| &emsp; public ImmutableArray\<Diagnostic> Errors \{ get; \}
* &emsp; \| &emsp; protected internal ImmutableArray\<string> Features \{ get; protected set; \}
* &emsp; \| &emsp; public ReportDiagnostic GeneralDiagnosticOption \{ get; protected set; \}
* &emsp; \| &emsp; public abstract string Language \{ get; \}
* &emsp; \| &emsp; public string MainTypeName \{ get; protected set; \}
* &emsp; \| &emsp; public MetadataReferenceResolver MetadataReferenceResolver \{ get; protected set; \}
* &emsp; \| &emsp; public string ModuleName \{ get; protected set; \}
* &emsp; \| &emsp; public OptimizationLevel OptimizationLevel \{ get; protected set; \}
* &emsp; \| &emsp; public OutputKind OutputKind \{ get; protected set; \}
* &emsp; \| &emsp; public Platform Platform \{ get; protected set; \}
* &emsp; \| &emsp; public bool PublicSign \{ get; protected set; \}
* &emsp; \| &emsp; public bool ReportSuppressedDiagnostics \{ get; protected set; \}
* &emsp; \| &emsp; public string ScriptClassName \{ get; protected set; \}
* &emsp; \| &emsp; public SourceReferenceResolver SourceReferenceResolver \{ get; protected set; \}
* &emsp; \| &emsp; public ImmutableDictionary\<string, ReportDiagnostic> SpecificDiagnosticOptions \{ get; protected set; \}
* &emsp; \| &emsp; public StrongNameProvider StrongNameProvider \{ get; protected set; \}
* &emsp; \| &emsp; public int WarningLevel \{ get; protected set; \}
* &emsp; \| &emsp; public XmlReferenceResolver XmlReferenceResolver \{ get; protected set; \}
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithAssemblyIdentityComparer\(AssemblyIdentityComparer comparer\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithCheckOverflow\(bool checkOverflow\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithConcurrentBuild\(bool concurrent\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithCryptoKeyContainer\(string cryptoKeyContainer\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithCryptoKeyFile\(string cryptoKeyFile\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithCryptoPublicKey\(ImmutableArray\<byte> cryptoPublicKey\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithDelaySign\(bool? delaySign\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithDeterministic\(bool deterministic\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithFeatures\(ImmutableArray\<string> features\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithGeneralDiagnosticOption\(ReportDiagnostic generalDiagnosticOption\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithMainTypeName\(string mainTypeName\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithMetadataReferenceResolver\(MetadataReferenceResolver resolver\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithModuleName\(string moduleName\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithOptimizationLevel\(OptimizationLevel value\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithOutputKind\(OutputKind kind\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithPlatform\(Platform platform\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithPublicSign\(bool publicSign\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithReportSuppressedDiagnostics\(bool reportSuppressedDiagnostics\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithScriptClassName\(string scriptClassName\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithSourceReferenceResolver\(SourceReferenceResolver resolver\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions\(ImmutableDictionary\<string, ReportDiagnostic> specificDiagnosticOptions\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions\(IEnumerable\<KeyValuePair\<string, ReportDiagnostic>> specificDiagnosticOptions\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithStrongNameProvider\(StrongNameProvider provider\);
* &emsp; \| &emsp; protected abstract CompilationOptions CommonWithXmlReferenceResolver\(XmlReferenceResolver resolver\);
* &emsp; \| &emsp; public override abstract bool Equals\(object obj\);
* &emsp; \| &emsp; protected bool EqualsHelper\(CompilationOptions other\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; protected int GetHashCodeHelper\(\);
* &emsp; \| &emsp; public CompilationOptions WithAssemblyIdentityComparer\(AssemblyIdentityComparer comparer\);
* &emsp; \| &emsp; public CompilationOptions WithConcurrentBuild\(bool concurrent\);
* &emsp; \| &emsp; public CompilationOptions WithCryptoKeyContainer\(string cryptoKeyContainer\);
* &emsp; \| &emsp; public CompilationOptions WithCryptoKeyFile\(string cryptoKeyFile\);
* &emsp; \| &emsp; public CompilationOptions WithCryptoPublicKey\(ImmutableArray\<byte> cryptoPublicKey\);
* &emsp; \| &emsp; public CompilationOptions WithDelaySign\(bool? delaySign\);
* &emsp; \| &emsp; public CompilationOptions WithDeterministic\(bool deterministic\);
* &emsp; \| &emsp; public CompilationOptions WithGeneralDiagnosticOption\(ReportDiagnostic value\);
* &emsp; \| &emsp; public CompilationOptions WithMainTypeName\(string mainTypeName\);
* &emsp; \| &emsp; public CompilationOptions WithMetadataReferenceResolver\(MetadataReferenceResolver resolver\);
* &emsp; \| &emsp; public CompilationOptions WithModuleName\(string moduleName\);
* &emsp; \| &emsp; public CompilationOptions WithOptimizationLevel\(OptimizationLevel value\);
* &emsp; \| &emsp; public CompilationOptions WithOutputKind\(OutputKind kind\);
* &emsp; \| &emsp; public CompilationOptions WithOverflowChecks\(bool checkOverflow\);
* &emsp; \| &emsp; public CompilationOptions WithPlatform\(Platform platform\);
* &emsp; \| &emsp; public CompilationOptions WithPublicSign\(bool publicSign\);
* &emsp; \| &emsp; public CompilationOptions WithReportSuppressedDiagnostics\(bool value\);
* &emsp; \| &emsp; public CompilationOptions WithScriptClassName\(string scriptClassName\);
* &emsp; \| &emsp; public CompilationOptions WithSourceReferenceResolver\(SourceReferenceResolver resolver\);
* &emsp; \| &emsp; public CompilationOptions WithSpecificDiagnosticOptions\(ImmutableDictionary\<string, ReportDiagnostic> value\);
* &emsp; \| &emsp; public CompilationOptions WithSpecificDiagnosticOptions\(IEnumerable\<KeyValuePair\<string, ReportDiagnostic>> value\);
* &emsp; \| &emsp; public CompilationOptions WithStrongNameProvider\(StrongNameProvider provider\);
* &emsp; \| &emsp; public CompilationOptions WithXmlReferenceResolver\(XmlReferenceResolver resolver\);
* &emsp; \| &emsp; public static bool operator ==\(CompilationOptions left, CompilationOptions right\);
* &emsp; \| &emsp; public static bool operator \!=\(CompilationOptions left, CompilationOptions right\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.CSharpCompilationOptions : CompilationOptions, IEquatable\<CSharpCompilationOptions>
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions\(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable\<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray\<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable\<KeyValuePair\<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions\(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable\<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray\<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable\<KeyValuePair\<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions\(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, IEnumerable\<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray\<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable\<KeyValuePair\<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions\(OutputKind outputKind, bool reportSuppressedDiagnostics = false, string moduleName = null, string mainTypeName = null, string scriptClassName = null, IEnumerable\<string> usings = null, OptimizationLevel optimizationLevel = Debug, bool checkOverflow = false, bool allowUnsafe = false, string cryptoKeyContainer = null, string cryptoKeyFile = null, ImmutableArray\<byte> cryptoPublicKey = default, bool? delaySign = null, Platform platform = AnyCpu, ReportDiagnostic generalDiagnosticOption = Default, int warningLevel = 4, IEnumerable\<KeyValuePair\<string, ReportDiagnostic>> specificDiagnosticOptions = null, bool concurrentBuild = true, bool deterministic = false, XmlReferenceResolver xmlReferenceResolver = null, SourceReferenceResolver sourceReferenceResolver = null, MetadataReferenceResolver metadataReferenceResolver = null, AssemblyIdentityComparer assemblyIdentityComparer = null, StrongNameProvider strongNameProvider = null, bool publicSign = false\);
* &emsp; \| &emsp; \| &emsp; public bool AllowUnsafe \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<string> Usings \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithAssemblyIdentityComparer\(AssemblyIdentityComparer comparer\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithCheckOverflow\(bool checkOverflow\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithConcurrentBuild\(bool concurrent\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithCryptoKeyContainer\(string cryptoKeyContainer\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithCryptoKeyFile\(string cryptoKeyFile\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithCryptoPublicKey\(ImmutableArray\<byte> cryptoPublicKey\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithDelaySign\(bool? delaySign\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithDeterministic\(bool deterministic\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithFeatures\(ImmutableArray\<string> features\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithGeneralDiagnosticOption\(ReportDiagnostic value\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithMainTypeName\(string mainTypeName\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithMetadataReferenceResolver\(MetadataReferenceResolver resolver\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithModuleName\(string moduleName\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithOptimizationLevel\(OptimizationLevel value\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithOutputKind\(OutputKind kind\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithPlatform\(Platform platform\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithPublicSign\(bool publicSign\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithReportSuppressedDiagnostics\(bool reportSuppressedDiagnostics\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithScriptClassName\(string scriptClassName\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithSourceReferenceResolver\(SourceReferenceResolver resolver\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithSpecificDiagnosticOptions\(ImmutableDictionary\<string, ReportDiagnostic> specificDiagnosticOptions\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithSpecificDiagnosticOptions\(IEnumerable\<KeyValuePair\<string, ReportDiagnostic>> specificDiagnosticOptions\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithStrongNameProvider\(StrongNameProvider provider\);
* &emsp; \| &emsp; \| &emsp; protected override CompilationOptions CommonWithXmlReferenceResolver\(XmlReferenceResolver resolver\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(CSharpCompilationOptions other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithAllowUnsafe\(bool enabled\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithAssemblyIdentityComparer\(AssemblyIdentityComparer comparer\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithConcurrentBuild\(bool concurrentBuild\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithCryptoKeyContainer\(string name\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithCryptoKeyFile\(string path\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithCryptoPublicKey\(ImmutableArray\<byte> value\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithDelaySign\(bool? value\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithDeterministic\(bool deterministic\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithGeneralDiagnosticOption\(ReportDiagnostic value\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithMainTypeName\(string name\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithMetadataReferenceResolver\(MetadataReferenceResolver resolver\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithModuleName\(string moduleName\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithOptimizationLevel\(OptimizationLevel value\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithOutputKind\(OutputKind kind\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithOverflowChecks\(bool enabled\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithPlatform\(Platform platform\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithPublicSign\(bool publicSign\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithReportSuppressedDiagnostics\(bool reportSuppressedDiagnostics\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithScriptClassName\(string name\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithSourceReferenceResolver\(SourceReferenceResolver resolver\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithSpecificDiagnosticOptions\(ImmutableDictionary\<string, ReportDiagnostic> values\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithSpecificDiagnosticOptions\(IEnumerable\<KeyValuePair\<string, ReportDiagnostic>> values\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithStrongNameProvider\(StrongNameProvider provider\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithUsings\(ImmutableArray\<string> usings\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithUsings\(IEnumerable\<string> usings\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithUsings\(params string\[\] usings\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithWarningLevel\(int warningLevel\);
* &emsp; \| &emsp; \| &emsp; public CSharpCompilationOptions WithXmlReferenceResolver\(XmlReferenceResolver resolver\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.ControlFlowAnalysis
* &emsp; \| &emsp; protected ControlFlowAnalysis\(\);
* &emsp; \| &emsp; public abstract bool EndPointIsReachable \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<SyntaxNode> EntryPoints \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<SyntaxNode> ExitPoints \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<SyntaxNode> ReturnStatements \{ get; \}
* &emsp; \| &emsp; public abstract bool StartPointIsReachable \{ get; \}
* &emsp; \| &emsp; public abstract bool Succeeded \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CustomModifier : ICustomModifier
* &emsp; \| &emsp; protected CustomModifier\(\);
* &emsp; \| &emsp; public abstract bool IsOptional \{ get; \}
* &emsp; \| &emsp; public abstract INamedTypeSymbol Modifier \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.DataFlowAnalysis
* &emsp; \| &emsp; protected DataFlowAnalysis\(\);
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> AlwaysAssigned \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> Captured \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> DataFlowsIn \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> DataFlowsOut \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> ReadInside \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> ReadOutside \{ get; \}
* &emsp; \| &emsp; public abstract bool Succeeded \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> UnsafeAddressTaken \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> VariablesDeclared \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> WrittenInside \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<ISymbol> WrittenOutside \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Diagnostic : IEquatable\<Diagnostic>, IFormattable
* &emsp; \| &emsp; protected Diagnostic\(\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<Location> AdditionalLocations \{ get; \}
* &emsp; \| &emsp; public virtual DiagnosticSeverity DefaultSeverity \{ get; \}
* &emsp; \| &emsp; public abstract DiagnosticDescriptor Descriptor \{ get; \}
* &emsp; \| &emsp; public abstract string Id \{ get; \}
* &emsp; \| &emsp; public abstract bool IsSuppressed \{ get; \}
* &emsp; \| &emsp; public bool IsWarningAsError \{ get; \}
* &emsp; \| &emsp; public abstract Location Location \{ get; \}
* &emsp; \| &emsp; public virtual ImmutableDictionary\<string, string> Properties \{ get; \}
* &emsp; \| &emsp; public abstract DiagnosticSeverity Severity \{ get; \}
* &emsp; \| &emsp; public abstract int WarningLevel \{ get; \}
* &emsp; \| &emsp; public static Diagnostic Create\(DiagnosticDescriptor descriptor, Location location, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static Diagnostic Create\(DiagnosticDescriptor descriptor, Location location, IEnumerable\<Location> additionalLocations, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static Diagnostic Create\(DiagnosticDescriptor descriptor, Location location, ImmutableDictionary\<string, string> properties, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static Diagnostic Create\(DiagnosticDescriptor descriptor, Location location, IEnumerable\<Location> additionalLocations, ImmutableDictionary\<string, string> properties, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static Diagnostic Create\(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, LocalizableString title = null, LocalizableString description = null, string helpLink = null, Location location = null, IEnumerable\<Location> additionalLocations = null, IEnumerable\<string> customTags = null, ImmutableDictionary\<string, string> properties = null\);
* &emsp; \| &emsp; public static Diagnostic Create\(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, bool isSuppressed, LocalizableString title = null, LocalizableString description = null, string helpLink = null, Location location = null, IEnumerable\<Location> additionalLocations = null, IEnumerable\<string> customTags = null, ImmutableDictionary\<string, string> properties = null\);
* &emsp; \| &emsp; public override abstract bool Equals\(object obj\);
* &emsp; \| &emsp; public abstract bool Equals\(Diagnostic obj\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; public abstract string GetMessage\(IFormatProvider formatProvider = null\);
* &emsp; \| &emsp; public SuppressionInfo GetSuppressionInfo\(Compilation compilation\);
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.DiagnosticDescriptor : IEquatable\<DiagnosticDescriptor>
* &emsp; \| &emsp; public DiagnosticDescriptor\(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description = null, string helpLinkUri = null, params string\[\] customTags\);
* &emsp; \| &emsp; public DiagnosticDescriptor\(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description = null, string helpLinkUri = null, params string\[\] customTags\);
* &emsp; \| &emsp; public string Category \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<string> CustomTags \{ get; \}
* &emsp; \| &emsp; public DiagnosticSeverity DefaultSeverity \{ get; \}
* &emsp; \| &emsp; public LocalizableString Description \{ get; \}
* &emsp; \| &emsp; public string HelpLinkUri \{ get; \}
* &emsp; \| &emsp; public string Id \{ get; \}
* &emsp; \| &emsp; public bool IsEnabledByDefault \{ get; \}
* &emsp; \| &emsp; public LocalizableString MessageFormat \{ get; \}
* &emsp; \| &emsp; public LocalizableString Title \{ get; \}
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public bool Equals\(DiagnosticDescriptor other\);
* &emsp; \| &emsp; public ReportDiagnostic GetEffectiveSeverity\(CompilationOptions compilationOptions\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; public class Microsoft\.CodeAnalysis\.DiagnosticFormatter
* &emsp; \| &emsp; public DiagnosticFormatter\(\);
* &emsp; \| &emsp; public virtual string Format\(Diagnostic diagnostic, IFormatProvider formatter = null\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.CSharp\.CSharpDiagnosticFormatter : DiagnosticFormatter
* &emsp; \| &emsp; \| &emsp; public static CSharpDiagnosticFormatter Instance \{ get; \}
* &emsp; public sealed class Microsoft\.CodeAnalysis\.DllImportData : IPlatformInvokeInformation
* &emsp; \| &emsp; public bool? BestFitMapping \{ get; \}
* &emsp; \| &emsp; public CallingConvention CallingConvention \{ get; \}
* &emsp; \| &emsp; public CharSet CharacterSet \{ get; \}
* &emsp; \| &emsp; public string EntryPointName \{ get; \}
* &emsp; \| &emsp; public bool ExactSpelling \{ get; \}
* &emsp; \| &emsp; public string ModuleName \{ get; \}
* &emsp; \| &emsp; public bool SetLastError \{ get; \}
* &emsp; \| &emsp; public bool? ThrowOnUnmappableCharacter \{ get; \}
* &emsp; public sealed class Microsoft\.CodeAnalysis\.DocumentId : IEquatable\<DocumentId>, IObjectWritable
* &emsp; \| &emsp; public Guid Id \{ get; \}
* &emsp; \| &emsp; public ProjectId ProjectId \{ get; \}
* &emsp; \| &emsp; public static DocumentId CreateFromSerialized\(ProjectId projectId, Guid id, string debugName = null\);
* &emsp; \| &emsp; public static DocumentId CreateNewId\(ProjectId projectId, string debugName = null\);
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public bool Equals\(DocumentId other\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public static bool operator ==\(DocumentId left, DocumentId right\);
* &emsp; \| &emsp; public static bool operator \!=\(DocumentId left, DocumentId right\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.DocumentInfo
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<string> Folders \{ get; \}
* &emsp; \| &emsp; public DocumentId Id \{ get; \}
* &emsp; \| &emsp; public bool IsGenerated \{ get; \}
* &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; public SourceCodeKind SourceCodeKind \{ get; \}
* &emsp; \| &emsp; public TextLoader TextLoader \{ get; \}
* &emsp; \| &emsp; public static DocumentInfo Create\(DocumentId id, string name, IEnumerable\<string> folders = null, SourceCodeKind sourceCodeKind = Regular, TextLoader loader = null, string filePath = null, bool isGenerated = false\);
* &emsp; \| &emsp; public DocumentInfo WithFilePath\(string filePath\);
* &emsp; \| &emsp; public DocumentInfo WithFolders\(IEnumerable\<string> folders\);
* &emsp; \| &emsp; public DocumentInfo WithId\(DocumentId id\);
* &emsp; \| &emsp; public DocumentInfo WithName\(string name\);
* &emsp; \| &emsp; public DocumentInfo WithSourceCodeKind\(SourceCodeKind kind\);
* &emsp; \| &emsp; public DocumentInfo WithTextLoader\(TextLoader loader\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.DocumentationProvider
* &emsp; \| &emsp; protected DocumentationProvider\(\);
* &emsp; \| &emsp; public static DocumentationProvider Default \{ get; \}
* &emsp; \| &emsp; public override abstract bool Equals\(object obj\);
* &emsp; \| &emsp; protected internal abstract string GetDocumentationForSymbol\(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.XmlDocumentationProvider : DocumentationProvider
* &emsp; \| &emsp; \| &emsp; protected XmlDocumentationProvider\(\);
* &emsp; \| &emsp; \| &emsp; public static XmlDocumentationProvider CreateFromBytes\(byte\[\] xmlDocCommentBytes\);
* &emsp; \| &emsp; \| &emsp; public static XmlDocumentationProvider CreateFromFile\(string xmlDocCommentFilePath\);
* &emsp; \| &emsp; \| &emsp; protected override string GetDocumentationForSymbol\(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; protected abstract Stream GetSourceStream\(CancellationToken cancellationToken\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.EmbeddedText
* &emsp; \| &emsp; public ImmutableArray\<byte> Checksum \{ get; \}
* &emsp; \| &emsp; public SourceHashAlgorithm ChecksumAlgorithm \{ get; \}
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public static EmbeddedText FromBytes\(string filePath, ArraySegment\<byte> bytes, SourceHashAlgorithm checksumAlgorithm = Sha1\);
* &emsp; \| &emsp; public static EmbeddedText FromSource\(string filePath, SourceText text\);
* &emsp; \| &emsp; public static EmbeddedText FromStream\(string filePath, Stream stream, SourceHashAlgorithm checksumAlgorithm = Sha1\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.LocalizableString : IEquatable\<LocalizableString>, IFormattable
* &emsp; \| &emsp; protected LocalizableString\(\);
* &emsp; \| &emsp; public event EventHandler\<Exception> OnException;
* &emsp; \| &emsp; protected abstract bool AreEqual\(object other\);
* &emsp; \| &emsp; public override sealed bool Equals\(object other\);
* &emsp; \| &emsp; public bool Equals\(LocalizableString other\);
* &emsp; \| &emsp; protected abstract int GetHash\(\);
* &emsp; \| &emsp; public override sealed int GetHashCode\(\);
* &emsp; \| &emsp; protected abstract string GetText\(IFormatProvider formatProvider\);
* &emsp; \| &emsp; public override sealed string ToString\(\);
* &emsp; \| &emsp; public string ToString\(IFormatProvider formatProvider\);
* &emsp; \| &emsp; public static explicit operator string\(LocalizableString localizableResource\);
* &emsp; \| &emsp; public static implicit operator LocalizableString\(string fixedResource\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.LocalizableResourceString : LocalizableString, IObjectWritable
* &emsp; \| &emsp; \| &emsp; public LocalizableResourceString\(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource\);
* &emsp; \| &emsp; \| &emsp; public LocalizableResourceString\(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource, params string\[\] formatArguments\);
* &emsp; \| &emsp; \| &emsp; protected override bool AreEqual\(object other\);
* &emsp; \| &emsp; \| &emsp; protected override int GetHash\(\);
* &emsp; \| &emsp; \| &emsp; protected override string GetText\(IFormatProvider formatProvider\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Location
* &emsp; \| &emsp; public bool IsInMetadata \{ get; \}
* &emsp; \| &emsp; public bool IsInSource \{ get; \}
* &emsp; \| &emsp; public abstract LocationKind Kind \{ get; \}
* &emsp; \| &emsp; public virtual IModuleSymbol MetadataModule \{ get; \}
* &emsp; \| &emsp; public static Location None \{ get; \}
* &emsp; \| &emsp; public virtual TextSpan SourceSpan \{ get; \}
* &emsp; \| &emsp; public virtual SyntaxTree SourceTree \{ get; \}
* &emsp; \| &emsp; public static Location Create\(SyntaxTree syntaxTree, TextSpan textSpan\);
* &emsp; \| &emsp; public static Location Create\(string filePath, TextSpan textSpan, LinePositionSpan lineSpan\);
* &emsp; \| &emsp; public override abstract bool Equals\(object obj\);
* &emsp; \| &emsp; protected virtual string GetDebuggerDisplay\(\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; public virtual FileLinePositionSpan GetLineSpan\(\);
* &emsp; \| &emsp; public virtual FileLinePositionSpan GetMappedLineSpan\(\);
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public static bool operator ==\(Location left, Location right\);
* &emsp; \| &emsp; public static bool operator \!=\(Location left, Location right\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Metadata : IDisposable
* &emsp; \| &emsp; public MetadataId Id \{ get; \}
* &emsp; \| &emsp; public abstract MetadataImageKind Kind \{ get; \}
* &emsp; \| &emsp; protected abstract Metadata CommonCopy\(\);
* &emsp; \| &emsp; public Metadata Copy\(\);
* &emsp; \| &emsp; public abstract void Dispose\(\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.AssemblyMetadata : Metadata
* &emsp; \| &emsp; \| &emsp; public override MetadataImageKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override Metadata CommonCopy\(\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata Create\(ModuleMetadata module\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata Create\(ImmutableArray\<ModuleMetadata> modules\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata Create\(IEnumerable\<ModuleMetadata> modules\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata Create\(params ModuleMetadata\[\] modules\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata CreateFromFile\(string path\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata CreateFromImage\(ImmutableArray\<byte> peImage\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata CreateFromImage\(IEnumerable\<byte> peImage\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata CreateFromStream\(Stream peStream, bool leaveOpen = false\);
* &emsp; \| &emsp; \| &emsp; public static AssemblyMetadata CreateFromStream\(Stream peStream, PEStreamOptions options\);
* &emsp; \| &emsp; \| &emsp; public override void Dispose\(\);
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<ModuleMetadata> GetModules\(\);
* &emsp; \| &emsp; \| &emsp; public PortableExecutableReference GetReference\(DocumentationProvider documentation = null, ImmutableArray\<string> aliases = default, bool embedInteropTypes = false, string filePath = null, string display = null\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.ModuleMetadata : Metadata
* &emsp; \| &emsp; \| &emsp; public override MetadataImageKind Kind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override Metadata CommonCopy\(\);
* &emsp; \| &emsp; \| &emsp; public static ModuleMetadata CreateFromFile\(string path\);
* &emsp; \| &emsp; \| &emsp; public static ModuleMetadata CreateFromImage\(IEnumerable\<byte> peImage\);
* &emsp; \| &emsp; \| &emsp; public static ModuleMetadata CreateFromImage\(ImmutableArray\<byte> peImage\);
* &emsp; \| &emsp; \| &emsp; public static ModuleMetadata CreateFromImage\(IntPtr peImage, int size\);
* &emsp; \| &emsp; \| &emsp; public static ModuleMetadata CreateFromMetadata\(IntPtr metadata, int size\);
* &emsp; \| &emsp; \| &emsp; public static ModuleMetadata CreateFromStream\(Stream peStream, bool leaveOpen = false\);
* &emsp; \| &emsp; \| &emsp; public static ModuleMetadata CreateFromStream\(Stream peStream, PEStreamOptions options\);
* &emsp; \| &emsp; \| &emsp; public override void Dispose\(\);
* &emsp; \| &emsp; \| &emsp; public MetadataReader GetMetadataReader\(\);
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<string> GetModuleNames\(\);
* &emsp; \| &emsp; \| &emsp; public Guid GetModuleVersionId\(\);
* &emsp; \| &emsp; \| &emsp; public PortableExecutableReference GetReference\(DocumentationProvider documentation = null, string filePath = null, string display = null\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.MetadataId
* &emsp; public abstract class Microsoft\.CodeAnalysis\.MetadataReference
* &emsp; \| &emsp; protected MetadataReference\(MetadataReferenceProperties properties\);
* &emsp; \| &emsp; public virtual string Display \{ get; \}
* &emsp; \| &emsp; public MetadataReferenceProperties Properties \{ get; \}
* &emsp; \| &emsp; public static MetadataReference CreateFromAssembly\(Assembly assembly\);
* &emsp; \| &emsp; public static MetadataReference CreateFromAssembly\(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation = null\);
* &emsp; \| &emsp; public static PortableExecutableReference CreateFromFile\(string path, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null\);
* &emsp; \| &emsp; public static PortableExecutableReference CreateFromImage\(ImmutableArray\<byte> peImage, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null\);
* &emsp; \| &emsp; public static PortableExecutableReference CreateFromImage\(IEnumerable\<byte> peImage, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null\);
* &emsp; \| &emsp; public static PortableExecutableReference CreateFromStream\(Stream peStream, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null\);
* &emsp; \| &emsp; public MetadataReference WithAliases\(IEnumerable\<string> aliases\);
* &emsp; \| &emsp; public MetadataReference WithAliases\(ImmutableArray\<string> aliases\);
* &emsp; \| &emsp; public MetadataReference WithEmbedInteropTypes\(bool value\);
* &emsp; \| &emsp; public MetadataReference WithProperties\(MetadataReferenceProperties properties\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CompilationReference : MetadataReference, IEquatable\<CompilationReference>
* &emsp; \| &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override string Display \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(CompilationReference other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public CompilationReference WithAliases\(IEnumerable\<string> aliases\);
* &emsp; \| &emsp; \| &emsp; public CompilationReference WithAliases\(ImmutableArray\<string> aliases\);
* &emsp; \| &emsp; \| &emsp; public CompilationReference WithEmbedInteropTypes\(bool value\);
* &emsp; \| &emsp; \| &emsp; public CompilationReference WithProperties\(MetadataReferenceProperties properties\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.PortableExecutableReference : MetadataReference
* &emsp; \| &emsp; \| &emsp; protected PortableExecutableReference\(MetadataReferenceProperties properties, string fullPath = null, DocumentationProvider initialDocumentation = null\);
* &emsp; \| &emsp; \| &emsp; public override string Display \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected abstract DocumentationProvider CreateDocumentationProvider\(\);
* &emsp; \| &emsp; \| &emsp; public Metadata GetMetadata\(\);
* &emsp; \| &emsp; \| &emsp; public MetadataId GetMetadataId\(\);
* &emsp; \| &emsp; \| &emsp; protected abstract Metadata GetMetadataImpl\(\);
* &emsp; \| &emsp; \| &emsp; public PortableExecutableReference WithAliases\(IEnumerable\<string> aliases\);
* &emsp; \| &emsp; \| &emsp; public PortableExecutableReference WithAliases\(ImmutableArray\<string> aliases\);
* &emsp; \| &emsp; \| &emsp; public PortableExecutableReference WithEmbedInteropTypes\(bool value\);
* &emsp; \| &emsp; \| &emsp; public PortableExecutableReference WithProperties\(MetadataReferenceProperties properties\);
* &emsp; \| &emsp; \| &emsp; protected abstract PortableExecutableReference WithPropertiesImpl\(MetadataReferenceProperties properties\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.UnresolvedMetadataReference : MetadataReference
* &emsp; \| &emsp; \| &emsp; public override string Display \{ get; \}
* &emsp; \| &emsp; \| &emsp; public string Reference \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.MetadataReferenceResolver
* &emsp; \| &emsp; protected MetadataReferenceResolver\(\);
* &emsp; \| &emsp; public virtual bool ResolveMissingAssemblies \{ get; \}
* &emsp; \| &emsp; public override abstract bool Equals\(object other\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; public virtual PortableExecutableReference ResolveMissingAssembly\(MetadataReference definition, AssemblyIdentity referenceIdentity\);
* &emsp; \| &emsp; public abstract ImmutableArray\<PortableExecutableReference> ResolveReference\(string reference, string baseFilePath, MetadataReferenceProperties properties\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.ParseOptions
* &emsp; \| &emsp; public DocumentationMode DocumentationMode \{ get; protected set; \}
* &emsp; \| &emsp; public ImmutableArray\<Diagnostic> Errors \{ get; \}
* &emsp; \| &emsp; public abstract IReadOnlyDictionary\<string, string> Features \{ get; \}
* &emsp; \| &emsp; public SourceCodeKind Kind \{ get; protected set; \}
* &emsp; \| &emsp; public abstract string Language \{ get; \}
* &emsp; \| &emsp; public abstract IEnumerable\<string> PreprocessorSymbolNames \{ get; \}
* &emsp; \| &emsp; public SourceCodeKind SpecifiedKind \{ get; protected set; \}
* &emsp; \| &emsp; protected abstract ParseOptions CommonWithDocumentationMode\(DocumentationMode documentationMode\);
* &emsp; \| &emsp; protected abstract ParseOptions CommonWithFeatures\(IEnumerable\<KeyValuePair\<string, string>> features\);
* &emsp; \| &emsp; public abstract ParseOptions CommonWithKind\(SourceCodeKind kind\);
* &emsp; \| &emsp; public override abstract bool Equals\(object obj\);
* &emsp; \| &emsp; protected bool EqualsHelper\(ParseOptions other\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; protected int GetHashCodeHelper\(\);
* &emsp; \| &emsp; public ParseOptions WithDocumentationMode\(DocumentationMode documentationMode\);
* &emsp; \| &emsp; public ParseOptions WithFeatures\(IEnumerable\<KeyValuePair\<string, string>> features\);
* &emsp; \| &emsp; public ParseOptions WithKind\(SourceCodeKind kind\);
* &emsp; \| &emsp; public static bool operator ==\(ParseOptions left, ParseOptions right\);
* &emsp; \| &emsp; public static bool operator \!=\(ParseOptions left, ParseOptions right\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.CSharpParseOptions : ParseOptions, IEquatable\<CSharpParseOptions>
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions\(LanguageVersion languageVersion = Default, DocumentationMode documentationMode = Parse, SourceCodeKind kind = Regular, IEnumerable\<string> preprocessorSymbols = null\);
* &emsp; \| &emsp; \| &emsp; public static CSharpParseOptions Default \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override IReadOnlyDictionary\<string, string> Features \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LanguageVersion LanguageVersion \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override IEnumerable\<string> PreprocessorSymbolNames \{ get; \}
* &emsp; \| &emsp; \| &emsp; public LanguageVersion SpecifiedLanguageVersion \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override ParseOptions CommonWithDocumentationMode\(DocumentationMode documentationMode\);
* &emsp; \| &emsp; \| &emsp; protected override ParseOptions CommonWithFeatures\(IEnumerable\<KeyValuePair\<string, string>> features\);
* &emsp; \| &emsp; \| &emsp; public override ParseOptions CommonWithKind\(SourceCodeKind kind\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(CSharpParseOptions other\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions WithDocumentationMode\(DocumentationMode documentationMode\);
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions WithFeatures\(IEnumerable\<KeyValuePair\<string, string>> features\);
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions WithKind\(SourceCodeKind kind\);
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions WithLanguageVersion\(LanguageVersion version\);
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions WithPreprocessorSymbols\(IEnumerable\<string> preprocessorSymbols\);
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions WithPreprocessorSymbols\(params string\[\] preprocessorSymbols\);
* &emsp; \| &emsp; \| &emsp; public CSharpParseOptions WithPreprocessorSymbols\(ImmutableArray\<string> symbols\);
* &emsp; public class Microsoft\.CodeAnalysis\.Project
* &emsp; \| &emsp; public IReadOnlyList\<DocumentId> AdditionalDocumentIds \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<TextDocument> AdditionalDocuments \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<ProjectReference> AllProjectReferences \{ get; \}
* &emsp; \| &emsp; public AnalyzerOptions AnalyzerOptions \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<AnalyzerReference> AnalyzerReferences \{ get; \}
* &emsp; \| &emsp; public string AssemblyName \{ get; \}
* &emsp; \| &emsp; public CompilationOptions CompilationOptions \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<DocumentId> DocumentIds \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<Document> Documents \{ get; \}
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public bool HasDocuments \{ get; \}
* &emsp; \| &emsp; public ProjectId Id \{ get; \}
* &emsp; \| &emsp; public bool IsSubmission \{ get; \}
* &emsp; \| &emsp; public string Language \{ get; \}
* &emsp; \| &emsp; public HostLanguageServices LanguageServices \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<MetadataReference> MetadataReferences \{ get; \}
* &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; public string OutputFilePath \{ get; \}
* &emsp; \| &emsp; public ParseOptions ParseOptions \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<ProjectReference> ProjectReferences \{ get; \}
* &emsp; \| &emsp; public Solution Solution \{ get; \}
* &emsp; \| &emsp; public bool SupportsCompilation \{ get; \}
* &emsp; \| &emsp; public VersionStamp Version \{ get; \}
* &emsp; \| &emsp; public TextDocument AddAdditionalDocument\(string name, SourceText text, IEnumerable\<string> folders = null, string filePath = null\);
* &emsp; \| &emsp; public TextDocument AddAdditionalDocument\(string name, string text, IEnumerable\<string> folders = null, string filePath = null\);
* &emsp; \| &emsp; public Project AddAnalyzerReference\(AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; public Project AddAnalyzerReferences\(IEnumerable\<AnalyzerReference> analyzerReferences\);
* &emsp; \| &emsp; public Document AddDocument\(string name, SyntaxNode syntaxRoot, IEnumerable\<string> folders = null, string filePath = null\);
* &emsp; \| &emsp; public Document AddDocument\(string name, SourceText text, IEnumerable\<string> folders = null, string filePath = null\);
* &emsp; \| &emsp; public Document AddDocument\(string name, string text, IEnumerable\<string> folders = null, string filePath = null\);
* &emsp; \| &emsp; public Project AddMetadataReference\(MetadataReference metadataReference\);
* &emsp; \| &emsp; public Project AddMetadataReferences\(IEnumerable\<MetadataReference> metadataReferences\);
* &emsp; \| &emsp; public Project AddProjectReference\(ProjectReference projectReference\);
* &emsp; \| &emsp; public Project AddProjectReferences\(IEnumerable\<ProjectReference> projectReferences\);
* &emsp; \| &emsp; public bool ContainsAdditionalDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public bool ContainsDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public TextDocument GetAdditionalDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public ProjectChanges GetChanges\(Project oldProject\);
* &emsp; \| &emsp; public Task\<Compilation> GetCompilationAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<VersionStamp> GetDependentSemanticVersionAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<VersionStamp> GetDependentVersionAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Document GetDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public Document GetDocument\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; public DocumentId GetDocumentId\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; public Task\<VersionStamp> GetLatestDocumentVersionAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<VersionStamp> GetSemanticVersionAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Project RemoveAdditionalDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public Project RemoveAnalyzerReference\(AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; public Project RemoveDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public Project RemoveMetadataReference\(MetadataReference metadataReference\);
* &emsp; \| &emsp; public Project RemoveProjectReference\(ProjectReference projectReference\);
* &emsp; \| &emsp; public bool TryGetCompilation\(out Compilation compilation\);
* &emsp; \| &emsp; public Project WithAnalyzerReferences\(IEnumerable\<AnalyzerReference> analyzerReferencs\);
* &emsp; \| &emsp; public Project WithAssemblyName\(string assemblyName\);
* &emsp; \| &emsp; public Project WithCompilationOptions\(CompilationOptions options\);
* &emsp; \| &emsp; public Project WithMetadataReferences\(IEnumerable\<MetadataReference> metadataReferences\);
* &emsp; \| &emsp; public Project WithParseOptions\(ParseOptions options\);
* &emsp; \| &emsp; public Project WithProjectReferences\(IEnumerable\<ProjectReference> projectReferences\);
* &emsp; public class Microsoft\.CodeAnalysis\.ProjectDependencyGraph
* &emsp; \| &emsp; public IEnumerable\<IEnumerable\<ProjectId>> GetDependencySets\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public IImmutableSet\<ProjectId> GetProjectsThatDirectlyDependOnThisProject\(ProjectId projectId\);
* &emsp; \| &emsp; public IImmutableSet\<ProjectId> GetProjectsThatThisProjectDirectlyDependsOn\(ProjectId projectId\);
* &emsp; \| &emsp; public IImmutableSet\<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn\(ProjectId projectId\);
* &emsp; \| &emsp; public IEnumerable\<ProjectId> GetProjectsThatTransitivelyDependOnThisProject\(ProjectId projectId\);
* &emsp; \| &emsp; public IEnumerable\<ProjectId> GetTopologicallySortedProjects\(CancellationToken cancellationToken = default\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.ProjectId : IEquatable\<ProjectId>, IObjectWritable
* &emsp; \| &emsp; public Guid Id \{ get; \}
* &emsp; \| &emsp; public static ProjectId CreateFromSerialized\(Guid id, string debugName = null\);
* &emsp; \| &emsp; public static ProjectId CreateNewId\(string debugName = null\);
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public bool Equals\(ProjectId other\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public static bool operator ==\(ProjectId left, ProjectId right\);
* &emsp; \| &emsp; public static bool operator \!=\(ProjectId left, ProjectId right\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.ProjectInfo
* &emsp; \| &emsp; public IReadOnlyList\<DocumentInfo> AdditionalDocuments \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<AnalyzerReference> AnalyzerReferences \{ get; \}
* &emsp; \| &emsp; public string AssemblyName \{ get; \}
* &emsp; \| &emsp; public CompilationOptions CompilationOptions \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<DocumentInfo> Documents \{ get; \}
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public Type HostObjectType \{ get; \}
* &emsp; \| &emsp; public ProjectId Id \{ get; \}
* &emsp; \| &emsp; public bool IsSubmission \{ get; \}
* &emsp; \| &emsp; public string Language \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<MetadataReference> MetadataReferences \{ get; \}
* &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; public string OutputFilePath \{ get; \}
* &emsp; \| &emsp; public ParseOptions ParseOptions \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<ProjectReference> ProjectReferences \{ get; \}
* &emsp; \| &emsp; public VersionStamp Version \{ get; \}
* &emsp; \| &emsp; public static ProjectInfo Create\(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath = null, string outputFilePath = null, CompilationOptions compilationOptions = null, ParseOptions parseOptions = null, IEnumerable\<DocumentInfo> documents = null, IEnumerable\<ProjectReference> projectReferences = null, IEnumerable\<MetadataReference> metadataReferences = null, IEnumerable\<AnalyzerReference> analyzerReferences = null, IEnumerable\<DocumentInfo> additionalDocuments = null, bool isSubmission = false, Type hostObjectType = null\);
* &emsp; \| &emsp; public ProjectInfo WithAdditionalDocuments\(IEnumerable\<DocumentInfo> additionalDocuments\);
* &emsp; \| &emsp; public ProjectInfo WithAnalyzerReferences\(IEnumerable\<AnalyzerReference> analyzerReferences\);
* &emsp; \| &emsp; public ProjectInfo WithAssemblyName\(string assemblyName\);
* &emsp; \| &emsp; public ProjectInfo WithCompilationOptions\(CompilationOptions compilationOptions\);
* &emsp; \| &emsp; public ProjectInfo WithDocuments\(IEnumerable\<DocumentInfo> documents\);
* &emsp; \| &emsp; public ProjectInfo WithFilePath\(string filePath\);
* &emsp; \| &emsp; public ProjectInfo WithMetadataReferences\(IEnumerable\<MetadataReference> metadataReferences\);
* &emsp; \| &emsp; public ProjectInfo WithName\(string name\);
* &emsp; \| &emsp; public ProjectInfo WithOutputFilePath\(string outputFilePath\);
* &emsp; \| &emsp; public ProjectInfo WithParseOptions\(ParseOptions parseOptions\);
* &emsp; \| &emsp; public ProjectInfo WithProjectReferences\(IEnumerable\<ProjectReference> projectReferences\);
* &emsp; \| &emsp; public ProjectInfo WithVersion\(VersionStamp version\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.ProjectReference : IEquatable\<ProjectReference>
* &emsp; \| &emsp; public ProjectReference\(ProjectId projectId, ImmutableArray\<string> aliases = default, bool embedInteropTypes = false\);
* &emsp; \| &emsp; public ImmutableArray\<string> Aliases \{ get; \}
* &emsp; \| &emsp; public bool EmbedInteropTypes \{ get; \}
* &emsp; \| &emsp; public ProjectId ProjectId \{ get; \}
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public bool Equals\(ProjectReference reference\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public static bool operator ==\(ProjectReference left, ProjectReference right\);
* &emsp; \| &emsp; public static bool operator \!=\(ProjectReference left, ProjectReference right\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.ResourceDescription : IFileReference
* &emsp; \| &emsp; public ResourceDescription\(string resourceName, Func\<Stream> dataProvider, bool isPublic\);
* &emsp; \| &emsp; public ResourceDescription\(string resourceName, string fileName, Func\<Stream> dataProvider, bool isPublic\);
* &emsp; public class Microsoft\.CodeAnalysis\.RuleSet
* &emsp; \| &emsp; public RuleSet\(string filePath, ReportDiagnostic generalOption, ImmutableDictionary\<string, ReportDiagnostic> specificOptions, ImmutableArray\<RuleSetInclude> includes\);
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public ReportDiagnostic GeneralDiagnosticOption \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<RuleSetInclude> Includes \{ get; \}
* &emsp; \| &emsp; public ImmutableDictionary\<string, ReportDiagnostic> SpecificDiagnosticOptions \{ get; \}
* &emsp; \| &emsp; public static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile\(string rulesetFileFullPath, out Dictionary\<string, ReportDiagnostic> specificDiagnosticOptions\);
* &emsp; \| &emsp; public static ImmutableArray\<string> GetEffectiveIncludesFromFile\(string filePath\);
* &emsp; \| &emsp; public static RuleSet LoadEffectiveRuleSetFromFile\(string filePath\);
* &emsp; \| &emsp; public RuleSet WithEffectiveAction\(ReportDiagnostic action\);
* &emsp; public class Microsoft\.CodeAnalysis\.RuleSetInclude
* &emsp; \| &emsp; public RuleSetInclude\(string includePath, ReportDiagnostic action\);
* &emsp; \| &emsp; public ReportDiagnostic Action \{ get; \}
* &emsp; \| &emsp; public string IncludePath \{ get; \}
* &emsp; \| &emsp; public RuleSet LoadRuleSet\(RuleSet parent\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.ScriptCompilationInfo
* &emsp; \| &emsp; public Type GlobalsType \{ get; \}
* &emsp; \| &emsp; public Compilation PreviousScriptCompilation \{ get; \}
* &emsp; \| &emsp; public Type ReturnType \{ get; \}
* &emsp; \| &emsp; public ScriptCompilationInfo WithPreviousScriptCompilation\(Compilation compilation\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.CSharpScriptCompilationInfo : ScriptCompilationInfo
* &emsp; \| &emsp; \| &emsp; public CSharpCompilation PreviousScriptCompilation \{ get; \}
* &emsp; \| &emsp; \| &emsp; public CSharpScriptCompilationInfo WithPreviousScriptCompilation\(CSharpCompilation compilation\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.SemanticModel
* &emsp; \| &emsp; protected SemanticModel\(\);
* &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; protected abstract Compilation CompilationCore \{ get; \}
* &emsp; \| &emsp; public virtual bool IgnoresAccessibility \{ get; \}
* &emsp; \| &emsp; public abstract bool IsSpeculativeSemanticModel \{ get; \}
* &emsp; \| &emsp; public abstract string Language \{ get; \}
* &emsp; \| &emsp; public abstract int OriginalPositionForSpeculation \{ get; \}
* &emsp; \| &emsp; public SemanticModel ParentModel \{ get; \}
* &emsp; \| &emsp; protected abstract SemanticModel ParentModelCore \{ get; \}
* &emsp; \| &emsp; public SyntaxTree SyntaxTree \{ get; \}
* &emsp; \| &emsp; protected abstract SyntaxTree SyntaxTreeCore \{ get; \}
* &emsp; \| &emsp; protected abstract ControlFlowAnalysis AnalyzeControlFlowCore\(SyntaxNode statement\);
* &emsp; \| &emsp; protected abstract ControlFlowAnalysis AnalyzeControlFlowCore\(SyntaxNode firstStatement, SyntaxNode lastStatement\);
* &emsp; \| &emsp; protected abstract DataFlowAnalysis AnalyzeDataFlowCore\(SyntaxNode statementOrExpression\);
* &emsp; \| &emsp; protected abstract DataFlowAnalysis AnalyzeDataFlowCore\(SyntaxNode firstStatement, SyntaxNode lastStatement\);
* &emsp; \| &emsp; protected abstract IAliasSymbol GetAliasInfoCore\(SyntaxNode nameSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Optional\<object> GetConstantValue\(SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; protected abstract Optional\<object> GetConstantValueCore\(SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract ImmutableArray\<Diagnostic> GetDeclarationDiagnostics\(TextSpan? span = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; protected abstract ISymbol GetDeclaredSymbolCore\(SyntaxNode declaration, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; protected abstract ImmutableArray\<ISymbol> GetDeclaredSymbolsCore\(SyntaxNode declaration, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract ImmutableArray\<Diagnostic> GetDiagnostics\(TextSpan? span = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public ISymbol GetEnclosingSymbol\(int position, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; protected abstract ISymbol GetEnclosingSymbolCore\(int position, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; protected abstract ImmutableArray\<ISymbol> GetMemberGroupCore\(SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract ImmutableArray\<Diagnostic> GetMethodBodyDiagnostics\(TextSpan? span = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public IOperation GetOperation\(SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; protected abstract IOperation GetOperationCore\(SyntaxNode node, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public PreprocessingSymbolInfo GetPreprocessingSymbolInfo\(SyntaxNode nameSyntax\);
* &emsp; \| &emsp; protected abstract PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore\(SyntaxNode nameSyntax\);
* &emsp; \| &emsp; protected abstract IAliasSymbol GetSpeculativeAliasInfoCore\(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; protected abstract SymbolInfo GetSpeculativeSymbolInfoCore\(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; protected abstract TypeInfo GetSpeculativeTypeInfoCore\(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; protected abstract SymbolInfo GetSymbolInfoCore\(SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract ImmutableArray\<Diagnostic> GetSyntaxDiagnostics\(TextSpan? span = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; protected internal virtual SyntaxNode GetTopmostNodeForDiagnosticAnalysis\(ISymbol symbol, SyntaxNode declaringSyntax\);
* &emsp; \| &emsp; protected abstract TypeInfo GetTypeInfoCore\(SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public bool IsAccessible\(int position, ISymbol symbol\);
* &emsp; \| &emsp; protected abstract bool IsAccessibleCore\(int position, ISymbol symbol\);
* &emsp; \| &emsp; public bool IsEventUsableAsField\(int position, IEventSymbol eventSymbol\);
* &emsp; \| &emsp; protected abstract bool IsEventUsableAsFieldCore\(int position, IEventSymbol eventSymbol\);
* &emsp; \| &emsp; public ImmutableArray\<ISymbol> LookupBaseMembers\(int position, string name = null\);
* &emsp; \| &emsp; protected abstract ImmutableArray\<ISymbol> LookupBaseMembersCore\(int position, string name\);
* &emsp; \| &emsp; public ImmutableArray\<ISymbol> LookupLabels\(int position, string name = null\);
* &emsp; \| &emsp; protected abstract ImmutableArray\<ISymbol> LookupLabelsCore\(int position, string name\);
* &emsp; \| &emsp; public ImmutableArray\<ISymbol> LookupNamespacesAndTypes\(int position, INamespaceOrTypeSymbol container = null, string name = null\);
* &emsp; \| &emsp; protected abstract ImmutableArray\<ISymbol> LookupNamespacesAndTypesCore\(int position, INamespaceOrTypeSymbol container, string name\);
* &emsp; \| &emsp; public ImmutableArray\<ISymbol> LookupStaticMembers\(int position, INamespaceOrTypeSymbol container = null, string name = null\);
* &emsp; \| &emsp; protected abstract ImmutableArray\<ISymbol> LookupStaticMembersCore\(int position, INamespaceOrTypeSymbol container, string name\);
* &emsp; \| &emsp; public ImmutableArray\<ISymbol> LookupSymbols\(int position, INamespaceOrTypeSymbol container = null, string name = null, bool includeReducedExtensionMethods = false\);
* &emsp; \| &emsp; protected abstract ImmutableArray\<ISymbol> LookupSymbolsCore\(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods\);
* &emsp; public class Microsoft\.CodeAnalysis\.Solution
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public SolutionId Id \{ get; \}
* &emsp; \| &emsp; public OptionSet Options \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<ProjectId> ProjectIds \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<Project> Projects \{ get; \}
* &emsp; \| &emsp; public VersionStamp Version \{ get; \}
* &emsp; \| &emsp; public Workspace Workspace \{ get; \}
* &emsp; \| &emsp; public Solution AddAdditionalDocument\(DocumentInfo documentInfo\);
* &emsp; \| &emsp; public Solution AddAdditionalDocument\(DocumentId documentId, string name, string text, IEnumerable\<string> folders = null, string filePath = null\);
* &emsp; \| &emsp; public Solution AddAdditionalDocument\(DocumentId documentId, string name, SourceText text, IEnumerable\<string> folders = null, string filePath = null\);
* &emsp; \| &emsp; public Solution AddAnalyzerReference\(ProjectId projectId, AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; public Solution AddAnalyzerReferences\(ProjectId projectId, IEnumerable\<AnalyzerReference> analyzerReferences\);
* &emsp; \| &emsp; public Solution AddDocument\(DocumentInfo documentInfo\);
* &emsp; \| &emsp; public Solution AddDocument\(DocumentId documentId, string name, TextLoader loader, IEnumerable\<string> folders = null\);
* &emsp; \| &emsp; public Solution AddDocument\(DocumentId documentId, string name, string text, IEnumerable\<string> folders = null, string filePath = null\);
* &emsp; \| &emsp; public Solution AddDocument\(DocumentId documentId, string name, SourceText text, IEnumerable\<string> folders = null, string filePath = null, bool isGenerated = false\);
* &emsp; \| &emsp; public Solution AddDocument\(DocumentId documentId, string name, SyntaxNode syntaxRoot, IEnumerable\<string> folders = null, string filePath = null, bool isGenerated = false, PreservationMode preservationMode = PreserveValue\);
* &emsp; \| &emsp; public Solution AddMetadataReference\(ProjectId projectId, MetadataReference metadataReference\);
* &emsp; \| &emsp; public Solution AddMetadataReferences\(ProjectId projectId, IEnumerable\<MetadataReference> metadataReferences\);
* &emsp; \| &emsp; public Solution AddProject\(ProjectInfo projectInfo\);
* &emsp; \| &emsp; public Project AddProject\(string name, string assemblyName, string language\);
* &emsp; \| &emsp; public Solution AddProject\(ProjectId projectId, string name, string assemblyName, string language\);
* &emsp; \| &emsp; public Solution AddProjectReference\(ProjectId projectId, ProjectReference projectReference\);
* &emsp; \| &emsp; public Solution AddProjectReferences\(ProjectId projectId, IEnumerable\<ProjectReference> projectReferences\);
* &emsp; \| &emsp; public bool ContainsAdditionalDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public bool ContainsDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public bool ContainsProject\(ProjectId projectId\);
* &emsp; \| &emsp; public TextDocument GetAdditionalDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public SolutionChanges GetChanges\(Solution oldSolution\);
* &emsp; \| &emsp; public Document GetDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public Document GetDocument\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; public DocumentId GetDocumentId\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; public DocumentId GetDocumentId\(SyntaxTree syntaxTree, ProjectId projectId\);
* &emsp; \| &emsp; public ImmutableArray\<DocumentId> GetDocumentIdsWithFilePath\(string filePath\);
* &emsp; \| &emsp; public Solution GetIsolatedSolution\(\);
* &emsp; \| &emsp; public VersionStamp GetLatestProjectVersion\(\);
* &emsp; \| &emsp; public Project GetProject\(ProjectId projectId\);
* &emsp; \| &emsp; public Project GetProject\(IAssemblySymbol assemblySymbol, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public ProjectDependencyGraph GetProjectDependencyGraph\(\);
* &emsp; \| &emsp; public Solution RemoveAdditionalDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public Solution RemoveAnalyzerReference\(ProjectId projectId, AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; public Solution RemoveDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public Solution RemoveMetadataReference\(ProjectId projectId, MetadataReference metadataReference\);
* &emsp; \| &emsp; public Solution RemoveProject\(ProjectId projectId\);
* &emsp; \| &emsp; public Solution RemoveProjectReference\(ProjectId projectId, ProjectReference projectReference\);
* &emsp; \| &emsp; public Solution WithAdditionalDocumentText\(DocumentId documentId, SourceText text, PreservationMode mode = PreserveValue\);
* &emsp; \| &emsp; public Solution WithAdditionalDocumentText\(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode = PreserveValue\);
* &emsp; \| &emsp; public Solution WithAdditionalDocumentTextLoader\(DocumentId documentId, TextLoader loader, PreservationMode mode\);
* &emsp; \| &emsp; public Solution WithDocumentFilePath\(DocumentId documentId, string filePath\);
* &emsp; \| &emsp; public Solution WithDocumentFolders\(DocumentId documentId, IEnumerable\<string> folders\);
* &emsp; \| &emsp; public Solution WithDocumentName\(DocumentId documentId, string name\);
* &emsp; \| &emsp; public Solution WithDocumentSourceCodeKind\(DocumentId documentId, SourceCodeKind sourceCodeKind\);
* &emsp; \| &emsp; public Solution WithDocumentSyntaxRoot\(DocumentId documentId, SyntaxNode root, PreservationMode mode = PreserveValue\);
* &emsp; \| &emsp; public Solution WithDocumentText\(DocumentId documentId, SourceText text, PreservationMode mode = PreserveValue\);
* &emsp; \| &emsp; public Solution WithDocumentText\(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode = PreserveValue\);
* &emsp; \| &emsp; public Solution WithDocumentText\(IEnumerable\<DocumentId> documentIds, SourceText text, PreservationMode mode = PreserveValue\);
* &emsp; \| &emsp; public Solution WithDocumentTextLoader\(DocumentId documentId, TextLoader loader, PreservationMode mode\);
* &emsp; \| &emsp; public Solution WithProjectAnalyzerReferences\(ProjectId projectId, IEnumerable\<AnalyzerReference> analyzerReferences\);
* &emsp; \| &emsp; public Solution WithProjectAssemblyName\(ProjectId projectId, string assemblyName\);
* &emsp; \| &emsp; public Solution WithProjectCompilationOptions\(ProjectId projectId, CompilationOptions options\);
* &emsp; \| &emsp; public Solution WithProjectFilePath\(ProjectId projectId, string filePath\);
* &emsp; \| &emsp; public Solution WithProjectMetadataReferences\(ProjectId projectId, IEnumerable\<MetadataReference> metadataReferences\);
* &emsp; \| &emsp; public Solution WithProjectName\(ProjectId projectId, string name\);
* &emsp; \| &emsp; public Solution WithProjectOutputFilePath\(ProjectId projectId, string outputFilePath\);
* &emsp; \| &emsp; public Solution WithProjectParseOptions\(ProjectId projectId, ParseOptions options\);
* &emsp; \| &emsp; public Solution WithProjectReferences\(ProjectId projectId, IEnumerable\<ProjectReference> projectReferences\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.SolutionId : IEquatable\<SolutionId>, IObjectWritable
* &emsp; \| &emsp; public Guid Id \{ get; \}
* &emsp; \| &emsp; public static SolutionId CreateFromSerialized\(Guid id, string debugName = null\);
* &emsp; \| &emsp; public static SolutionId CreateNewId\(string debugName = null\);
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public bool Equals\(SolutionId other\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public static bool operator ==\(SolutionId left, SolutionId right\);
* &emsp; \| &emsp; public static bool operator \!=\(SolutionId left, SolutionId right\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.SolutionInfo
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public SolutionId Id \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<ProjectInfo> Projects \{ get; \}
* &emsp; \| &emsp; public VersionStamp Version \{ get; \}
* &emsp; \| &emsp; public static SolutionInfo Create\(SolutionId id, VersionStamp version, string filePath = null, IEnumerable\<ProjectInfo> projects = null\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.SourceReferenceResolver
* &emsp; \| &emsp; protected SourceReferenceResolver\(\);
* &emsp; \| &emsp; public override abstract bool Equals\(object other\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; public abstract string NormalizePath\(string path, string baseFilePath\);
* &emsp; \| &emsp; public abstract Stream OpenRead\(string resolvedPath\);
* &emsp; \| &emsp; public virtual SourceText ReadText\(string resolvedPath\);
* &emsp; \| &emsp; public abstract string ResolveReference\(string path, string baseFilePath\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.SourceFileResolver : SourceReferenceResolver, IEquatable\<SourceFileResolver>
* &emsp; \| &emsp; \| &emsp; public SourceFileResolver\(IEnumerable\<string> searchPaths, string baseDirectory\);
* &emsp; \| &emsp; \| &emsp; public SourceFileResolver\(ImmutableArray\<string> searchPaths, string baseDirectory\);
* &emsp; \| &emsp; \| &emsp; public SourceFileResolver\(ImmutableArray\<string> searchPaths, string baseDirectory, ImmutableArray\<KeyValuePair\<string, string>> pathMap\);
* &emsp; \| &emsp; \| &emsp; public string BaseDirectory \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static SourceFileResolver Default \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<KeyValuePair\<string, string>> PathMap \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<string> SearchPaths \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(SourceFileResolver other\);
* &emsp; \| &emsp; \| &emsp; protected virtual bool FileExists\(string resolvedPath\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override string NormalizePath\(string path, string baseFilePath\);
* &emsp; \| &emsp; \| &emsp; public override Stream OpenRead\(string resolvedPath\);
* &emsp; \| &emsp; \| &emsp; public override string ResolveReference\(string path, string baseFilePath\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.StrongNameProvider
* &emsp; \| &emsp; protected StrongNameProvider\(\);
* &emsp; \| &emsp; public override abstract bool Equals\(object other\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.DesktopStrongNameProvider : StrongNameProvider
* &emsp; \| &emsp; \| &emsp; public DesktopStrongNameProvider\(ImmutableArray\<string> keyFileSearchPaths\);
* &emsp; \| &emsp; \| &emsp; public DesktopStrongNameProvider\(ImmutableArray\<string> keyFileSearchPaths = default, string tempPath = null\);
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; public class Microsoft\.CodeAnalysis\.SymbolDisplayFormat
* &emsp; \| &emsp; public SymbolDisplayFormat\(SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle = Omitted, SymbolDisplayTypeQualificationStyle typeQualificationStyle = NameOnly, SymbolDisplayGenericsOptions genericsOptions = None, SymbolDisplayMemberOptions memberOptions = None, SymbolDisplayDelegateStyle delegateStyle = NameOnly, SymbolDisplayExtensionMethodStyle extensionMethodStyle = Default, SymbolDisplayParameterOptions parameterOptions = None, SymbolDisplayPropertyStyle propertyStyle = NameOnly, SymbolDisplayLocalOptions localOptions = None, SymbolDisplayKindOptions kindOptions = None, SymbolDisplayMiscellaneousOptions miscellaneousOptions = None\);
* &emsp; \| &emsp; public static SymbolDisplayFormat CSharpErrorMessageFormat \{ get; \}
* &emsp; \| &emsp; public static SymbolDisplayFormat CSharpShortErrorMessageFormat \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayDelegateStyle DelegateStyle \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayExtensionMethodStyle ExtensionMethodStyle \{ get; \}
* &emsp; \| &emsp; public static SymbolDisplayFormat FullyQualifiedFormat \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayGenericsOptions GenericsOptions \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayGlobalNamespaceStyle GlobalNamespaceStyle \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayKindOptions KindOptions \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayLocalOptions LocalOptions \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayMemberOptions MemberOptions \{ get; \}
* &emsp; \| &emsp; public static SymbolDisplayFormat MinimallyQualifiedFormat \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayMiscellaneousOptions MiscellaneousOptions \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayParameterOptions ParameterOptions \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayPropertyStyle PropertyStyle \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayTypeQualificationStyle TypeQualificationStyle \{ get; \}
* &emsp; \| &emsp; public static SymbolDisplayFormat VisualBasicErrorMessageFormat \{ get; \}
* &emsp; \| &emsp; public static SymbolDisplayFormat VisualBasicShortErrorMessageFormat \{ get; \}
* &emsp; \| &emsp; public SymbolDisplayFormat AddGenericsOptions\(SymbolDisplayGenericsOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat AddKindOptions\(SymbolDisplayKindOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat AddLocalOptions\(SymbolDisplayLocalOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat AddMemberOptions\(SymbolDisplayMemberOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat AddMiscellaneousOptions\(SymbolDisplayMiscellaneousOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat AddParameterOptions\(SymbolDisplayParameterOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat RemoveGenericsOptions\(SymbolDisplayGenericsOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat RemoveKindOptions\(SymbolDisplayKindOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat RemoveLocalOptions\(SymbolDisplayLocalOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat RemoveMemberOptions\(SymbolDisplayMemberOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat RemoveMiscellaneousOptions\(SymbolDisplayMiscellaneousOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat RemoveParameterOptions\(SymbolDisplayParameterOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat WithGenericsOptions\(SymbolDisplayGenericsOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat WithGlobalNamespaceStyle\(SymbolDisplayGlobalNamespaceStyle style\);
* &emsp; \| &emsp; public SymbolDisplayFormat WithKindOptions\(SymbolDisplayKindOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat WithLocalOptions\(SymbolDisplayLocalOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat WithMemberOptions\(SymbolDisplayMemberOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat WithMiscellaneousOptions\(SymbolDisplayMiscellaneousOptions options\);
* &emsp; \| &emsp; public SymbolDisplayFormat WithParameterOptions\(SymbolDisplayParameterOptions options\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.SymbolVisitor
* &emsp; \| &emsp; protected SymbolVisitor\(\);
* &emsp; \| &emsp; public virtual void DefaultVisit\(ISymbol symbol\);
* &emsp; \| &emsp; public virtual void Visit\(ISymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitAlias\(IAliasSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitArrayType\(IArrayTypeSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitAssembly\(IAssemblySymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitDiscard\(IDiscardSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitDynamicType\(IDynamicTypeSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitEvent\(IEventSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitField\(IFieldSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitLabel\(ILabelSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitLocal\(ILocalSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitMethod\(IMethodSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitModule\(IModuleSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitNamedType\(INamedTypeSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitNamespace\(INamespaceSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitParameter\(IParameterSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitPointerType\(IPointerTypeSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitProperty\(IPropertySymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitRangeVariable\(IRangeVariableSymbol symbol\);
* &emsp; \| &emsp; public virtual void VisitTypeParameter\(ITypeParameterSymbol symbol\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.SymbolVisitor\<TResult>
* &emsp; \| &emsp; protected SymbolVisitor\(\);
* &emsp; \| &emsp; public virtual TResult DefaultVisit\(ISymbol symbol\);
* &emsp; \| &emsp; public virtual TResult Visit\(ISymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitAlias\(IAliasSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitArrayType\(IArrayTypeSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitAssembly\(IAssemblySymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitDiscard\(IDiscardSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitDynamicType\(IDynamicTypeSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitEvent\(IEventSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitField\(IFieldSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitLabel\(ILabelSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitLocal\(ILocalSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitMethod\(IMethodSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitModule\(IModuleSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitNamedType\(INamedTypeSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitNamespace\(INamespaceSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitParameter\(IParameterSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitPointerType\(IPointerTypeSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitProperty\(IPropertySymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitRangeVariable\(IRangeVariableSymbol symbol\);
* &emsp; \| &emsp; public virtual TResult VisitTypeParameter\(ITypeParameterSymbol symbol\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.SyntaxAnnotation : IEquatable\<SyntaxAnnotation>, IObjectWritable
* &emsp; \| &emsp; public SyntaxAnnotation\(\);
* &emsp; \| &emsp; public SyntaxAnnotation\(string kind\);
* &emsp; \| &emsp; public SyntaxAnnotation\(string kind, string data\);
* &emsp; \| &emsp; public string Data \{ get; \}
* &emsp; \| &emsp; public static SyntaxAnnotation ElasticAnnotation \{ get; \}
* &emsp; \| &emsp; public string Kind \{ get; \}
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public bool Equals\(SyntaxAnnotation other\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public static bool operator ==\(SyntaxAnnotation left, SyntaxAnnotation right\);
* &emsp; \| &emsp; public static bool operator \!=\(SyntaxAnnotation left, SyntaxAnnotation right\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.SyntaxNode
* &emsp; \| &emsp; public bool ContainsAnnotations \{ get; \}
* &emsp; \| &emsp; public bool ContainsDiagnostics \{ get; \}
* &emsp; \| &emsp; public bool ContainsDirectives \{ get; \}
* &emsp; \| &emsp; public bool ContainsSkippedText \{ get; \}
* &emsp; \| &emsp; public TextSpan FullSpan \{ get; \}
* &emsp; \| &emsp; public bool HasLeadingTrivia \{ get; \}
* &emsp; \| &emsp; public bool HasStructuredTrivia \{ get; \}
* &emsp; \| &emsp; public bool HasTrailingTrivia \{ get; \}
* &emsp; \| &emsp; public bool IsMissing \{ get; \}
* &emsp; \| &emsp; public bool IsStructuredTrivia \{ get; \}
* &emsp; \| &emsp; protected string KindText \{ get; \}
* &emsp; \| &emsp; public abstract string Language \{ get; \}
* &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; public virtual SyntaxTrivia ParentTrivia \{ get; \}
* &emsp; \| &emsp; public int RawKind \{ get; \}
* &emsp; \| &emsp; public TextSpan Span \{ get; \}
* &emsp; \| &emsp; public int SpanStart \{ get; \}
* &emsp; \| &emsp; public SyntaxTree SyntaxTree \{ get; \}
* &emsp; \| &emsp; protected abstract SyntaxTree SyntaxTreeCore \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> Ancestors\(bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> AncestorsAndSelf\(bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> ChildNodes\(\);
* &emsp; \| &emsp; public ChildSyntaxList ChildNodesAndTokens\(\);
* &emsp; \| &emsp; public virtual SyntaxNodeOrToken ChildThatContainsPosition\(int position\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxToken> ChildTokens\(\);
* &emsp; \| &emsp; public bool Contains\(SyntaxNode node\);
* &emsp; \| &emsp; public T CopyAnnotationsTo\<T>\(T node\) where T : SyntaxNode;
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> DescendantNodes\(Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> DescendantNodes\(TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> DescendantNodesAndSelf\(Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> DescendantNodesAndSelf\(TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNodeOrToken> DescendantNodesAndTokens\(Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNodeOrToken> DescendantNodesAndTokens\(TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf\(Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf\(TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxToken> DescendantTokens\(Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxToken> DescendantTokens\(TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxTrivia> DescendantTrivia\(Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxTrivia> DescendantTrivia\(TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\);
* &emsp; \| &emsp; protected virtual bool EquivalentToCore\(SyntaxNode other\);
* &emsp; \| &emsp; public SyntaxNode FindNode\(TextSpan span, bool findInsideTrivia = false, bool getInnermostNodeForTie = false\);
* &emsp; \| &emsp; public SyntaxToken FindToken\(int position, bool findInsideTrivia = false\);
* &emsp; \| &emsp; protected virtual SyntaxToken FindTokenCore\(int position, bool findInsideTrivia\);
* &emsp; \| &emsp; protected virtual SyntaxToken FindTokenCore\(int position, Func\<SyntaxTrivia, bool> stepInto\);
* &emsp; \| &emsp; public SyntaxTrivia FindTrivia\(int position, bool findInsideTrivia = false\);
* &emsp; \| &emsp; public SyntaxTrivia FindTrivia\(int position, Func\<SyntaxTrivia, bool> stepInto\);
* &emsp; \| &emsp; protected virtual SyntaxTrivia FindTriviaCore\(int position, bool findInsideTrivia\);
* &emsp; \| &emsp; public TNode FirstAncestorOrSelf\<TNode>\(Func\<TNode, bool> predicate = null, bool ascendOutOfTrivia = true\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> GetAnnotatedNodes\(string annotationKind\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNode> GetAnnotatedNodes\(SyntaxAnnotation syntaxAnnotation\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens\(SyntaxAnnotation annotation\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens\(string annotationKind\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens\(params string\[\] annotationKinds\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxToken> GetAnnotatedTokens\(string annotationKind\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxToken> GetAnnotatedTokens\(SyntaxAnnotation syntaxAnnotation\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxTrivia> GetAnnotatedTrivia\(SyntaxAnnotation annotation\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxTrivia> GetAnnotatedTrivia\(string annotationKind\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxTrivia> GetAnnotatedTrivia\(params string\[\] annotationKinds\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(string annotationKind\);
* &emsp; \| &emsp; public IEnumerable\<SyntaxAnnotation> GetAnnotations\(IEnumerable\<string> annotationKinds\);
* &emsp; \| &emsp; public IEnumerable\<Diagnostic> GetDiagnostics\(\);
* &emsp; \| &emsp; public SyntaxToken GetFirstToken\(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false\);
* &emsp; \| &emsp; public SyntaxToken GetLastToken\(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false\);
* &emsp; \| &emsp; public SyntaxTriviaList GetLeadingTrivia\(\);
* &emsp; \| &emsp; public Location GetLocation\(\);
* &emsp; \| &emsp; protected T GetRed\<T>\(ref T field, int slot\) where T : SyntaxNode;
* &emsp; \| &emsp; protected T GetRedAtZero\<T>\(ref T field\) where T : SyntaxNode;
* &emsp; \| &emsp; public SyntaxReference GetReference\(\);
* &emsp; \| &emsp; public SourceText GetText\(Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1\);
* &emsp; \| &emsp; public SyntaxTriviaList GetTrailingTrivia\(\);
* &emsp; \| &emsp; public bool HasAnnotation\(SyntaxAnnotation annotation\);
* &emsp; \| &emsp; public bool HasAnnotations\(string annotationKind\);
* &emsp; \| &emsp; public bool HasAnnotations\(IEnumerable\<string> annotationKinds\);
* &emsp; \| &emsp; protected internal abstract SyntaxNode InsertNodesInListCore\(SyntaxNode nodeInList, IEnumerable\<SyntaxNode> nodesToInsert, bool insertBefore\);
* &emsp; \| &emsp; protected internal abstract SyntaxNode InsertTokensInListCore\(SyntaxToken originalToken, IEnumerable\<SyntaxToken> newTokens, bool insertBefore\);
* &emsp; \| &emsp; protected internal abstract SyntaxNode InsertTriviaInListCore\(SyntaxTrivia originalTrivia, IEnumerable\<SyntaxTrivia> newTrivia, bool insertBefore\);
* &emsp; \| &emsp; public bool IsEquivalentTo\(SyntaxNode other\);
* &emsp; \| &emsp; public bool IsEquivalentTo\(SyntaxNode node, bool topLevel = false\);
* &emsp; \| &emsp; protected abstract bool IsEquivalentToCore\(SyntaxNode node, bool topLevel = false\);
* &emsp; \| &emsp; public bool IsPartOfStructuredTrivia\(\);
* &emsp; \| &emsp; protected internal abstract SyntaxNode NormalizeWhitespaceCore\(string indentation, string eol, bool elasticTrivia\);
* &emsp; \| &emsp; protected internal abstract SyntaxNode RemoveNodesCore\(IEnumerable\<SyntaxNode> nodes, SyntaxRemoveOptions options\);
* &emsp; \| &emsp; protected internal abstract SyntaxNode ReplaceCore\<TNode>\(IEnumerable\<TNode> nodes = null, Func\<TNode, TNode, SyntaxNode> computeReplacementNode = null, IEnumerable\<SyntaxToken> tokens = null, Func\<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken = null, IEnumerable\<SyntaxTrivia> trivia = null, Func\<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; protected internal abstract SyntaxNode ReplaceNodeInListCore\(SyntaxNode originalNode, IEnumerable\<SyntaxNode> replacementNodes\);
* &emsp; \| &emsp; protected internal abstract SyntaxNode ReplaceTokenInListCore\(SyntaxToken originalToken, IEnumerable\<SyntaxToken> newTokens\);
* &emsp; \| &emsp; protected internal abstract SyntaxNode ReplaceTriviaInListCore\(SyntaxTrivia originalTrivia, IEnumerable\<SyntaxTrivia> newTrivia\);
* &emsp; \| &emsp; public virtual void SerializeTo\(Stream stream, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public virtual string ToFullString\(\);
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public virtual void WriteTo\(TextWriter writer\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.CSharpSyntaxNode : SyntaxNode, IMessageSerializable
* &emsp; \| &emsp; \| &emsp; public override string Language \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override SyntaxTree SyntaxTreeCore \{ get; \}
* &emsp; \| &emsp; \| &emsp; public abstract void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; public abstract TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; public static SyntaxNode DeserializeFrom\(Stream stream, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; protected override bool EquivalentToCore\(SyntaxNode other\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken FindToken\(int position, bool findInsideTrivia = false\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia FindTrivia\(int position, bool findInsideTrivia = false\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTrivia FindTrivia\(int position, Func\<SyntaxTrivia, bool> stepInto\);
* &emsp; \| &emsp; \| &emsp; public IEnumerable\<Diagnostic> GetDiagnostics\(\);
* &emsp; \| &emsp; \| &emsp; public DirectiveTriviaSyntax GetFirstDirective\(Func\<DirectiveTriviaSyntax, bool> predicate = null\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken GetFirstToken\(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false\);
* &emsp; \| &emsp; \| &emsp; public DirectiveTriviaSyntax GetLastDirective\(Func\<DirectiveTriviaSyntax, bool> predicate = null\);
* &emsp; \| &emsp; \| &emsp; public SyntaxToken GetLastToken\(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList GetLeadingTrivia\(\);
* &emsp; \| &emsp; \| &emsp; public Location GetLocation\(\);
* &emsp; \| &emsp; \| &emsp; public SyntaxTriviaList GetTrailingTrivia\(\);
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode InsertNodesInListCore\(SyntaxNode nodeInList, IEnumerable\<SyntaxNode> nodesToInsert, bool insertBefore\);
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode InsertTokensInListCore\(SyntaxToken originalToken, IEnumerable\<SyntaxToken> newTokens, bool insertBefore\);
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode InsertTriviaInListCore\(SyntaxTrivia originalTrivia, IEnumerable\<SyntaxTrivia> newTrivia, bool insertBefore\);
* &emsp; \| &emsp; \| &emsp; protected override bool IsEquivalentToCore\(SyntaxNode node, bool topLevel = false\);
* &emsp; \| &emsp; \| &emsp; public SyntaxKind Kind\(\);
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode NormalizeWhitespaceCore\(string indentation, string eol, bool elasticTrivia\);
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode RemoveNodesCore\(IEnumerable\<SyntaxNode> nodes, SyntaxRemoveOptions options\);
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode ReplaceCore\<TNode>\(IEnumerable\<TNode> nodes = null, Func\<TNode, TNode, SyntaxNode> computeReplacementNode = null, IEnumerable\<SyntaxToken> tokens = null, Func\<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken = null, IEnumerable\<SyntaxTrivia> trivia = null, Func\<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode ReplaceNodeInListCore\(SyntaxNode originalNode, IEnumerable\<SyntaxNode> replacementNodes\);
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode ReplaceTokenInListCore\(SyntaxToken originalToken, IEnumerable\<SyntaxToken> newTokens\);
* &emsp; \| &emsp; \| &emsp; protected internal override SyntaxNode ReplaceTriviaInListCore\(SyntaxTrivia originalTrivia, IEnumerable\<SyntaxTrivia> newTrivia\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AccessorDeclarationSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax AddBodyStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax WithBody\(BlockSyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AccessorListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<AccessorDeclarationSyntax> Accessors \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorListSyntax AddAccessors\(params AccessorDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorListSyntax Update\(SyntaxToken openBraceToken, SyntaxList\<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorListSyntax WithAccessors\(SyntaxList\<AccessorDeclarationSyntax> accessors\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorListSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AccessorListSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameEqualsSyntax NameEquals \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectMemberDeclaratorSyntax Update\(NameEqualsSyntax nameEquals, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectMemberDeclaratorSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectMemberDeclaratorSyntax WithNameEquals\(NameEqualsSyntax nameEquals\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ArgumentSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameColonSyntax NameColon \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken RefOrOutKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentSyntax Update\(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentSyntax WithNameColon\(NameColonSyntax nameColon\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentSyntax WithRefOrOutKeyword\(SyntaxToken refOrOutKeyword\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ArrayRankSpecifierSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public int Rank \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<ExpressionSyntax> Sizes \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayRankSpecifierSyntax AddSizes\(params ExpressionSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayRankSpecifierSyntax Update\(SyntaxToken openBracketToken, SeparatedSyntaxList\<ExpressionSyntax> sizes, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayRankSpecifierSyntax WithCloseBracketToken\(SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayRankSpecifierSyntax WithOpenBracketToken\(SyntaxToken openBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayRankSpecifierSyntax WithSizes\(SeparatedSyntaxList\<ExpressionSyntax> sizes\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ArrowExpressionClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ArrowToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrowExpressionClauseSyntax Update\(SyntaxToken arrowToken, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrowExpressionClauseSyntax WithArrowToken\(SyntaxToken arrowToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrowExpressionClauseSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AttributeArgumentListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<AttributeArgumentSyntax> Arguments \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentListSyntax AddArguments\(params AttributeArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentListSyntax Update\(SyntaxToken openParenToken, SeparatedSyntaxList\<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentListSyntax WithArguments\(SeparatedSyntaxList\<AttributeArgumentSyntax> arguments\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentListSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentListSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AttributeArgumentSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameColonSyntax NameColon \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameEqualsSyntax NameEquals \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentSyntax Update\(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentSyntax WithNameColon\(NameColonSyntax nameColon\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentSyntax WithNameEquals\(NameEqualsSyntax nameEquals\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AttributeListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<AttributeSyntax> Attributes \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeTargetSpecifierSyntax Target \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeListSyntax AddAttributes\(params AttributeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeListSyntax Update\(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList\<AttributeSyntax> attributes, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeListSyntax WithAttributes\(SeparatedSyntaxList\<AttributeSyntax> attributes\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeListSyntax WithCloseBracketToken\(SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeListSyntax WithOpenBracketToken\(SyntaxToken openBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeListSyntax WithTarget\(AttributeTargetSpecifierSyntax target\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AttributeSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeSyntax AddArgumentListArguments\(params AttributeArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeSyntax Update\(NameSyntax name, AttributeArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeSyntax WithArgumentList\(AttributeArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeSyntax WithName\(NameSyntax name\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AttributeTargetSpecifierSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeTargetSpecifierSyntax Update\(SyntaxToken identifier, SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeTargetSpecifierSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public AttributeTargetSpecifierSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseArgumentListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SeparatedSyntaxList\<ArgumentSyntax> Arguments \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ArgumentListSyntax : BaseArgumentListSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SeparatedSyntaxList\<ArgumentSyntax> Arguments \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax AddArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax Update\(SyntaxToken openParenToken, SeparatedSyntaxList\<ArgumentSyntax> arguments, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax WithArguments\(SeparatedSyntaxList\<ArgumentSyntax> arguments\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BracketedArgumentListSyntax : BaseArgumentListSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SeparatedSyntaxList\<ArgumentSyntax> Arguments \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax AddArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax Update\(SyntaxToken openBracketToken, SeparatedSyntaxList\<ArgumentSyntax> arguments, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax WithArguments\(SeparatedSyntaxList\<ArgumentSyntax> arguments\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax WithCloseBracketToken\(SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax WithOpenBracketToken\(SyntaxToken openBracketToken\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseCrefParameterListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SeparatedSyntaxList\<CrefParameterSyntax> Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SeparatedSyntaxList\<CrefParameterSyntax> Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefBracketedParameterListSyntax AddParameters\(params CrefParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefBracketedParameterListSyntax Update\(SyntaxToken openBracketToken, SeparatedSyntaxList\<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefBracketedParameterListSyntax WithCloseBracketToken\(SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefBracketedParameterListSyntax WithOpenBracketToken\(SyntaxToken openBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefBracketedParameterListSyntax WithParameters\(SeparatedSyntaxList\<CrefParameterSyntax> parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CrefParameterListSyntax : BaseCrefParameterListSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SeparatedSyntaxList\<CrefParameterSyntax> Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterListSyntax AddParameters\(params CrefParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterListSyntax Update\(SyntaxToken openParenToken, SeparatedSyntaxList\<CrefParameterSyntax> parameters, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterListSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterListSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterListSyntax WithParameters\(SeparatedSyntaxList\<CrefParameterSyntax> parameters\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<BaseTypeSyntax> Types \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public BaseListSyntax AddTypes\(params BaseTypeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public BaseListSyntax Update\(SyntaxToken colonToken, SeparatedSyntaxList\<BaseTypeSyntax> types\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public BaseListSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public BaseListSyntax WithTypes\(SeparatedSyntaxList\<BaseTypeSyntax> types\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseParameterListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SeparatedSyntaxList\<ParameterSyntax> Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BracketedParameterListSyntax : BaseParameterListSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SeparatedSyntaxList\<ParameterSyntax> Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedParameterListSyntax AddParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedParameterListSyntax Update\(SyntaxToken openBracketToken, SeparatedSyntaxList\<ParameterSyntax> parameters, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedParameterListSyntax WithCloseBracketToken\(SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedParameterListSyntax WithOpenBracketToken\(SyntaxToken openBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedParameterListSyntax WithParameters\(SeparatedSyntaxList\<ParameterSyntax> parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ParameterListSyntax : BaseParameterListSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SeparatedSyntaxList\<ParameterSyntax> Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax AddParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax Update\(SyntaxToken openParenToken, SeparatedSyntaxList\<ParameterSyntax> parameters, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax WithParameters\(SeparatedSyntaxList\<ParameterSyntax> parameters\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseTypeSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SimpleBaseTypeSyntax : BaseTypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleBaseTypeSyntax Update\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleBaseTypeSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CatchClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Block \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CatchKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchFilterClauseSyntax Filter \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchClauseSyntax AddBlockStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchClauseSyntax Update\(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchClauseSyntax WithBlock\(BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchClauseSyntax WithCatchKeyword\(SyntaxToken catchKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchClauseSyntax WithDeclaration\(CatchDeclarationSyntax declaration\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchClauseSyntax WithFilter\(CatchFilterClauseSyntax filter\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CatchDeclarationSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchDeclarationSyntax Update\(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchDeclarationSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchDeclarationSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchDeclarationSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CatchFilterClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax FilterExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken WhenKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchFilterClauseSyntax Update\(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchFilterClauseSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchFilterClauseSyntax WithFilterExpression\(ExpressionSyntax filterExpression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchFilterClauseSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CatchFilterClauseSyntax WithWhenKeyword\(SyntaxToken whenKeyword\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CompilationUnitSyntax : CSharpSyntaxNode, ICompilationUnitSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EndOfFileToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<ExternAliasDirectiveSyntax> Externs \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<MemberDeclarationSyntax> Members \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<UsingDirectiveSyntax> Usings \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax AddExterns\(params ExternAliasDirectiveSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax AddMembers\(params MemberDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax AddUsings\(params UsingDirectiveSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public IList\<LoadDirectiveTriviaSyntax> GetLoadDirectives\(\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public IList\<ReferenceDirectiveTriviaSyntax> GetReferenceDirectives\(\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax Update\(SyntaxList\<ExternAliasDirectiveSyntax> externs, SyntaxList\<UsingDirectiveSyntax> usings, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax WithEndOfFileToken\(SyntaxToken endOfFileToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax WithExterns\(SyntaxList\<ExternAliasDirectiveSyntax> externs\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax WithMembers\(SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax WithUsings\(SyntaxList\<UsingDirectiveSyntax> usings\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConstructorInitializerSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ThisOrBaseKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorInitializerSyntax AddArgumentListArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorInitializerSyntax Update\(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorInitializerSyntax WithArgumentList\(ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorInitializerSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorInitializerSyntax WithThisOrBaseKeyword\(SyntaxToken thisOrBaseKeyword\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CrefParameterSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken RefOrOutKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterSyntax Update\(SyntaxToken refOrOutKeyword, TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterSyntax WithRefOrOutKeyword\(SyntaxToken refOrOutKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CrefSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.MemberCrefSyntax : CrefSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ImplicitOrExplicitKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterListSyntax Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorMemberCrefSyntax AddParametersParameters\(params CrefParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorMemberCrefSyntax Update\(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword\(SyntaxToken implicitOrExplicitKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorMemberCrefSyntax WithOperatorKeyword\(SyntaxToken operatorKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorMemberCrefSyntax WithParameters\(CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorMemberCrefSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.IndexerMemberCrefSyntax : MemberCrefSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefBracketedParameterListSyntax Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ThisKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerMemberCrefSyntax AddParametersParameters\(params CrefParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerMemberCrefSyntax Update\(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerMemberCrefSyntax WithParameters\(CrefBracketedParameterListSyntax parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerMemberCrefSyntax WithThisKeyword\(SyntaxToken thisKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.NameMemberCrefSyntax : MemberCrefSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterListSyntax Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NameMemberCrefSyntax AddParametersParameters\(params CrefParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NameMemberCrefSyntax Update\(TypeSyntax name, CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NameMemberCrefSyntax WithName\(TypeSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NameMemberCrefSyntax WithParameters\(CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.OperatorMemberCrefSyntax : MemberCrefSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefParameterListSyntax Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorMemberCrefSyntax AddParametersParameters\(params CrefParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorMemberCrefSyntax Update\(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorMemberCrefSyntax WithOperatorKeyword\(SyntaxToken operatorKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorMemberCrefSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorMemberCrefSyntax WithParameters\(CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.QualifiedCrefSyntax : CrefSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Container \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DotToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MemberCrefSyntax Member \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QualifiedCrefSyntax Update\(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QualifiedCrefSyntax WithContainer\(TypeSyntax container\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QualifiedCrefSyntax WithDotToken\(SyntaxToken dotToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QualifiedCrefSyntax WithMember\(MemberCrefSyntax member\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeCrefSyntax : CrefSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeCrefSyntax Update\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeCrefSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ElseClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ElseKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseClauseSyntax Update\(SyntaxToken elseKeyword, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseClauseSyntax WithElseKeyword\(SyntaxToken elseKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseClauseSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.EqualsValueClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EqualsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Value \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public EqualsValueClauseSyntax Update\(SyntaxToken equalsToken, ExpressionSyntax value\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public EqualsValueClauseSyntax WithEqualsToken\(SyntaxToken equalsToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public EqualsValueClauseSyntax WithValue\(ExpressionSyntax value\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DotToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExplicitInterfaceSpecifierSyntax Update\(NameSyntax name, SyntaxToken dotToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExplicitInterfaceSpecifierSyntax WithDotToken\(SyntaxToken dotToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExplicitInterfaceSpecifierSyntax WithName\(NameSyntax name\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ExpressionSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AnonymousFunctionExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken AsyncKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract CSharpSyntaxNode Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken AsyncKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Block \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override CSharpSyntaxNode Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DelegateKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousMethodExpressionSyntax AddBlockStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousMethodExpressionSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousMethodExpressionSyntax Update\(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousMethodExpressionSyntax WithAsyncKeyword\(SyntaxToken asyncKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousMethodExpressionSyntax WithBlock\(BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousMethodExpressionSyntax WithBody\(CSharpSyntaxNode body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousMethodExpressionSyntax WithDelegateKeyword\(SyntaxToken delegateKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousMethodExpressionSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken ArrowToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken ArrowToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken AsyncKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override CSharpSyntaxNode Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedLambdaExpressionSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedLambdaExpressionSyntax Update\(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedLambdaExpressionSyntax WithArrowToken\(SyntaxToken arrowToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedLambdaExpressionSyntax WithAsyncKeyword\(SyntaxToken asyncKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedLambdaExpressionSyntax WithBody\(CSharpSyntaxNode body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedLambdaExpressionSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken ArrowToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken AsyncKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override CSharpSyntaxNode Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax Parameter \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleLambdaExpressionSyntax AddParameterAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleLambdaExpressionSyntax AddParameterModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleLambdaExpressionSyntax Update\(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleLambdaExpressionSyntax WithArrowToken\(SyntaxToken arrowToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleLambdaExpressionSyntax WithAsyncKeyword\(SyntaxToken asyncKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleLambdaExpressionSyntax WithBody\(CSharpSyntaxNode body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleLambdaExpressionSyntax WithParameter\(ParameterSyntax parameter\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<AnonymousObjectMemberDeclaratorSyntax> Initializers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken NewKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectCreationExpressionSyntax AddInitializers\(params AnonymousObjectMemberDeclaratorSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectCreationExpressionSyntax Update\(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList\<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectCreationExpressionSyntax WithInitializers\(SeparatedSyntaxList\<AnonymousObjectMemberDeclaratorSyntax> initializers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectCreationExpressionSyntax WithNewKeyword\(SyntaxToken newKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ArrayCreationExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InitializerExpressionSyntax Initializer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken NewKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayTypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayCreationExpressionSyntax AddTypeRankSpecifiers\(params ArrayRankSpecifierSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayCreationExpressionSyntax Update\(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayCreationExpressionSyntax WithInitializer\(InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayCreationExpressionSyntax WithNewKeyword\(SyntaxToken newKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayCreationExpressionSyntax WithType\(ArrayTypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AssignmentExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Left \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Right \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AssignmentExpressionSyntax Update\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AssignmentExpressionSyntax WithLeft\(ExpressionSyntax left\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AssignmentExpressionSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AssignmentExpressionSyntax WithRight\(ExpressionSyntax right\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AwaitExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken AwaitKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AwaitExpressionSyntax Update\(SyntaxToken awaitKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AwaitExpressionSyntax WithAwaitKeyword\(SyntaxToken awaitKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AwaitExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BinaryExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Left \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Right \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax Update\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax WithLeft\(ExpressionSyntax left\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BinaryExpressionSyntax WithRight\(ExpressionSyntax right\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CastExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CastExpressionSyntax Update\(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CastExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CastExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CastExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CastExpressionSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CheckedExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedExpressionSyntax Update\(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedExpressionSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConditionalAccessExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax WhenNotNull \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalAccessExpressionSyntax Update\(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalAccessExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalAccessExpressionSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalAccessExpressionSyntax WithWhenNotNull\(ExpressionSyntax whenNotNull\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConditionalExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken QuestionToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax WhenFalse \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax WhenTrue \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalExpressionSyntax Update\(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalExpressionSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalExpressionSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalExpressionSyntax WithQuestionToken\(SyntaxToken questionToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalExpressionSyntax WithWhenFalse\(ExpressionSyntax whenFalse\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConditionalExpressionSyntax WithWhenTrue\(ExpressionSyntax whenTrue\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DeclarationExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDesignationSyntax Designation \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DeclarationExpressionSyntax Update\(TypeSyntax type, VariableDesignationSyntax designation\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DeclarationExpressionSyntax WithDesignation\(VariableDesignationSyntax designation\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DeclarationExpressionSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DefaultExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefaultExpressionSyntax Update\(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefaultExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefaultExpressionSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefaultExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefaultExpressionSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ElementAccessExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElementAccessExpressionSyntax AddArgumentListArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElementAccessExpressionSyntax Update\(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElementAccessExpressionSyntax WithArgumentList\(BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElementAccessExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ElementBindingExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElementBindingExpressionSyntax AddArgumentListArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElementBindingExpressionSyntax Update\(BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElementBindingExpressionSyntax WithArgumentList\(BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Commas \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InitializerExpressionSyntax Initializer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken NewKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBracketToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitArrayCreationExpressionSyntax AddCommas\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions\(params ExpressionSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitArrayCreationExpressionSyntax Update\(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken\(SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitArrayCreationExpressionSyntax WithCommas\(SyntaxTokenList commas\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitArrayCreationExpressionSyntax WithInitializer\(InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitArrayCreationExpressionSyntax WithNewKeyword\(SyntaxToken newKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken\(SyntaxToken openBracketToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ImplicitElementAccessSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitElementAccessSyntax AddArgumentListArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitElementAccessSyntax Update\(BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ImplicitElementAccessSyntax WithArgumentList\(BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InitializerExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<ExpressionSyntax> Expressions \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InitializerExpressionSyntax AddExpressions\(params ExpressionSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InitializerExpressionSyntax Update\(SyntaxToken openBraceToken, SeparatedSyntaxList\<ExpressionSyntax> expressions, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InitializerExpressionSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InitializerExpressionSyntax WithExpressions\(SeparatedSyntaxList\<ExpressionSyntax> expressions\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InitializerExpressionSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InstanceExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseExpressionSyntax : InstanceExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Token \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BaseExpressionSyntax Update\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BaseExpressionSyntax WithToken\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ThisExpressionSyntax : InstanceExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Token \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThisExpressionSyntax Update\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThisExpressionSyntax WithToken\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InterpolatedStringExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<InterpolatedStringContentSyntax> Contents \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken StringEndToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken StringStartToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolatedStringExpressionSyntax AddContents\(params InterpolatedStringContentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolatedStringExpressionSyntax Update\(SyntaxToken stringStartToken, SyntaxList\<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolatedStringExpressionSyntax WithContents\(SyntaxList\<InterpolatedStringContentSyntax> contents\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolatedStringExpressionSyntax WithStringEndToken\(SyntaxToken stringEndToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolatedStringExpressionSyntax WithStringStartToken\(SyntaxToken stringStartToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InvocationExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InvocationExpressionSyntax AddArgumentListArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InvocationExpressionSyntax Update\(ExpressionSyntax expression, ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InvocationExpressionSyntax WithArgumentList\(ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InvocationExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.IsPatternExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken IsKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PatternSyntax Pattern \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IsPatternExpressionSyntax Update\(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IsPatternExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IsPatternExpressionSyntax WithIsKeyword\(SyntaxToken isKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IsPatternExpressionSyntax WithPattern\(PatternSyntax pattern\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LiteralExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Token \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LiteralExpressionSyntax Update\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LiteralExpressionSyntax WithToken\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.MakeRefExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MakeRefExpressionSyntax Update\(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MakeRefExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MakeRefExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MakeRefExpressionSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MakeRefExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.MemberAccessExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MemberAccessExpressionSyntax Update\(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MemberAccessExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MemberAccessExpressionSyntax WithName\(SimpleNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MemberAccessExpressionSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.MemberBindingExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MemberBindingExpressionSyntax Update\(SyntaxToken operatorToken, SimpleNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MemberBindingExpressionSyntax WithName\(SimpleNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MemberBindingExpressionSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ObjectCreationExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InitializerExpressionSyntax Initializer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken NewKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ObjectCreationExpressionSyntax AddArgumentListArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ObjectCreationExpressionSyntax Update\(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ObjectCreationExpressionSyntax WithArgumentList\(ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ObjectCreationExpressionSyntax WithInitializer\(InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ObjectCreationExpressionSyntax WithNewKeyword\(SyntaxToken newKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ObjectCreationExpressionSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.OmittedArraySizeExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OmittedArraySizeExpressionToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OmittedArraySizeExpressionSyntax Update\(SyntaxToken omittedArraySizeExpressionToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken\(SyntaxToken omittedArraySizeExpressionToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ParenthesizedExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedExpressionSyntax Update\(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.PostfixUnaryExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Operand \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PostfixUnaryExpressionSyntax Update\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PostfixUnaryExpressionSyntax WithOperand\(ExpressionSyntax operand\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PostfixUnaryExpressionSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.PrefixUnaryExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Operand \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PrefixUnaryExpressionSyntax Update\(SyntaxToken operatorToken, ExpressionSyntax operand\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PrefixUnaryExpressionSyntax WithOperand\(ExpressionSyntax operand\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PrefixUnaryExpressionSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.QueryExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryBodySyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FromClauseSyntax FromClause \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryExpressionSyntax AddBodyClauses\(params QueryClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryExpressionSyntax Update\(FromClauseSyntax fromClause, QueryBodySyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryExpressionSyntax WithBody\(QueryBodySyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryExpressionSyntax WithFromClause\(FromClauseSyntax fromClause\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.RefExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken RefKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefExpressionSyntax Update\(SyntaxToken refKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefExpressionSyntax WithRefKeyword\(SyntaxToken refKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.RefTypeExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefTypeExpressionSyntax Update\(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefTypeExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefTypeExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefTypeExpressionSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefTypeExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.RefValueExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Comma \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefValueExpressionSyntax Update\(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefValueExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefValueExpressionSyntax WithComma\(SyntaxToken comma\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefValueExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefValueExpressionSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefValueExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefValueExpressionSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SizeOfExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SizeOfExpressionSyntax Update\(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SizeOfExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SizeOfExpressionSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SizeOfExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SizeOfExpressionSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken StackAllocKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StackAllocArrayCreationExpressionSyntax Update\(SyntaxToken stackAllocKeyword, TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword\(SyntaxToken stackAllocKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StackAllocArrayCreationExpressionSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ThrowExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ThrowKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThrowExpressionSyntax Update\(SyntaxToken throwKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThrowExpressionSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThrowExpressionSyntax WithThrowKeyword\(SyntaxToken throwKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TupleExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<ArgumentSyntax> Arguments \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleExpressionSyntax AddArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleExpressionSyntax Update\(SyntaxToken openParenToken, SeparatedSyntaxList\<ArgumentSyntax> arguments, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleExpressionSyntax WithArguments\(SeparatedSyntaxList\<ArgumentSyntax> arguments\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeOfExpressionSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeOfExpressionSyntax Update\(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeOfExpressionSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeOfExpressionSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeOfExpressionSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeOfExpressionSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeSyntax : ExpressionSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public bool IsVar \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ArrayTypeSyntax : TypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax ElementType \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<ArrayRankSpecifierSyntax> RankSpecifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayTypeSyntax AddRankSpecifiers\(params ArrayRankSpecifierSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayTypeSyntax Update\(TypeSyntax elementType, SyntaxList\<ArrayRankSpecifierSyntax> rankSpecifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayTypeSyntax WithElementType\(TypeSyntax elementType\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrayTypeSyntax WithRankSpecifiers\(SyntaxList\<ArrayRankSpecifierSyntax> rankSpecifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.NameSyntax : TypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public int Arity \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.AliasQualifiedNameSyntax : NameSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IdentifierNameSyntax Alias \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AliasQualifiedNameSyntax Update\(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AliasQualifiedNameSyntax WithAlias\(IdentifierNameSyntax alias\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AliasQualifiedNameSyntax WithColonColonToken\(SyntaxToken colonColonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public AliasQualifiedNameSyntax WithName\(SimpleNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.QualifiedNameSyntax : NameSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DotToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NameSyntax Left \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SimpleNameSyntax Right \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QualifiedNameSyntax Update\(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QualifiedNameSyntax WithDotToken\(SyntaxToken dotToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QualifiedNameSyntax WithLeft\(NameSyntax left\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public QualifiedNameSyntax WithRight\(SimpleNameSyntax right\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SimpleNameSyntax : NameSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.GenericNameSyntax : SimpleNameSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public bool IsUnboundGenericName \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeArgumentListSyntax TypeArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GenericNameSyntax AddTypeArgumentListArguments\(params TypeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GenericNameSyntax Update\(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GenericNameSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GenericNameSyntax WithTypeArgumentList\(TypeArgumentListSyntax typeArgumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.IdentifierNameSyntax : SimpleNameSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IdentifierNameSyntax Update\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IdentifierNameSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.NullableTypeSyntax : TypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax ElementType \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken QuestionToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NullableTypeSyntax Update\(TypeSyntax elementType, SyntaxToken questionToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NullableTypeSyntax WithElementType\(TypeSyntax elementType\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NullableTypeSyntax WithQuestionToken\(SyntaxToken questionToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.OmittedTypeArgumentSyntax : TypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OmittedTypeArgumentToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OmittedTypeArgumentSyntax Update\(SyntaxToken omittedTypeArgumentToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken\(SyntaxToken omittedTypeArgumentToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.PointerTypeSyntax : TypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken AsteriskToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax ElementType \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PointerTypeSyntax Update\(TypeSyntax elementType, SyntaxToken asteriskToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PointerTypeSyntax WithAsteriskToken\(SyntaxToken asteriskToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PointerTypeSyntax WithElementType\(TypeSyntax elementType\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.PredefinedTypeSyntax : TypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PredefinedTypeSyntax Update\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PredefinedTypeSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.RefTypeSyntax : TypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken RefKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefTypeSyntax Update\(SyntaxToken refKeyword, TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefTypeSyntax WithRefKeyword\(SyntaxToken refKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RefTypeSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TupleTypeSyntax : TypeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TupleElementSyntax> Elements \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleTypeSyntax AddElements\(params TupleElementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleTypeSyntax Update\(SyntaxToken openParenToken, SeparatedSyntaxList\<TupleElementSyntax> elements, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleTypeSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleTypeSyntax WithElements\(SeparatedSyntaxList\<TupleElementSyntax> elements\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleTypeSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ExternAliasDirectiveSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken AliasKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ExternKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExternAliasDirectiveSyntax Update\(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExternAliasDirectiveSyntax WithAliasKeyword\(SyntaxToken aliasKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExternAliasDirectiveSyntax WithExternKeyword\(SyntaxToken externKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExternAliasDirectiveSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExternAliasDirectiveSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.FinallyClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Block \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken FinallyKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public FinallyClauseSyntax AddBlockStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public FinallyClauseSyntax Update\(SyntaxToken finallyKeyword, BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public FinallyClauseSyntax WithBlock\(BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public FinallyClauseSyntax WithFinallyKeyword\(SyntaxToken finallyKeyword\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InterpolatedStringContentSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken TextToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolatedStringTextSyntax Update\(SyntaxToken textToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolatedStringTextSyntax WithTextToken\(SyntaxToken textToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InterpolationSyntax : InterpolatedStringContentSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationAlignmentClauseSyntax AlignmentClause \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationFormatClauseSyntax FormatClause \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationSyntax Update\(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationSyntax WithAlignmentClause\(InterpolationAlignmentClauseSyntax alignmentClause\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationSyntax WithFormatClause\(InterpolationFormatClauseSyntax formatClause\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InterpolationAlignmentClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CommaToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Value \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationAlignmentClauseSyntax Update\(SyntaxToken commaToken, ExpressionSyntax value\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationAlignmentClauseSyntax WithCommaToken\(SyntaxToken commaToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationAlignmentClauseSyntax WithValue\(ExpressionSyntax value\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InterpolationFormatClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken FormatStringToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationFormatClauseSyntax Update\(SyntaxToken colonToken, SyntaxToken formatStringToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationFormatClauseSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public InterpolationFormatClauseSyntax WithFormatStringToken\(SyntaxToken formatStringToken\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.JoinIntoClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken IntoKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinIntoClauseSyntax Update\(SyntaxToken intoKeyword, SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinIntoClauseSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinIntoClauseSyntax WithIntoKeyword\(SyntaxToken intoKeyword\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.MemberDeclarationSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseFieldDeclarationSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EventKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax AddDeclarationVariables\(params VariableDeclaratorSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax WithDeclaration\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax WithEventKeyword\(SyntaxToken eventKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventFieldDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.FieldDeclarationSyntax : BaseFieldDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FieldDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FieldDeclarationSyntax AddDeclarationVariables\(params VariableDeclaratorSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FieldDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FieldDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FieldDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FieldDeclarationSyntax WithDeclaration\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FieldDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FieldDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseMethodDeclarationSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract BlockSyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BlockSyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorInitializerSyntax Initializer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax AddBodyStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax WithBody\(BlockSyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax WithInitializer\(ConstructorInitializerSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BlockSyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ImplicitOrExplicitKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax AddBodyStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithBody\(BlockSyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword\(SyntaxToken implicitOrExplicitKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithOperatorKeyword\(SyntaxToken operatorKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConversionOperatorDeclarationSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BlockSyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken TildeToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax AddBodyStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax WithBody\(BlockSyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DestructorDeclarationSyntax WithTildeToken\(SyntaxToken tildeToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.MethodDeclarationSyntax : BaseMethodDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public int Arity \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BlockSyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<TypeParameterConstraintClauseSyntax> ConstraintClauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax ReturnType \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax TypeParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax AddBodyStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax AddConstraintClauses\(params TypeParameterConstraintClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax AddTypeParameterListParameters\(params TypeParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithBody\(BlockSyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithConstraintClauses\(SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithExplicitInterfaceSpecifier\(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithReturnType\(TypeSyntax returnType\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public MethodDeclarationSyntax WithTypeParameterList\(TypeParameterListSyntax typeParameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BlockSyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OperatorToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax ReturnType \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax AddBodyStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithBody\(BlockSyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithOperatorKeyword\(SyntaxToken operatorKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithOperatorToken\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithReturnType\(TypeSyntax returnType\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OperatorDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BasePropertyDeclarationSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract AccessorListSyntax AccessorList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.EventDeclarationSyntax : BasePropertyDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override AccessorListSyntax AccessorList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EventKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax AddAccessorListAccessors\(params AccessorDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax WithAccessorList\(AccessorListSyntax accessorList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax WithEventKeyword\(SyntaxToken eventKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax WithExplicitInterfaceSpecifier\(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EventDeclarationSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override AccessorListSyntax AccessorList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Semicolon \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ThisKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax AddAccessorListAccessors\(params AccessorDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithAccessorList\(AccessorListSyntax accessorList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithExplicitInterfaceSpecifier\(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithParameterList\(BracketedParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithSemicolon\(SyntaxToken semicolon\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithThisKeyword\(SyntaxToken thisKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IndexerDeclarationSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override AccessorListSyntax AccessorList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EqualsValueClauseSyntax Initializer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Semicolon \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax AddAccessorListAccessors\(params AccessorDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithAccessorList\(AccessorListSyntax accessorList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithExplicitInterfaceSpecifier\(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithInitializer\(EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithSemicolon\(SyntaxToken semicolon\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PropertyDeclarationSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BaseTypeDeclarationSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract BaseListSyntax BaseList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.EnumDeclarationSyntax : BaseTypeDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BaseListSyntax BaseList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EnumKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<EnumMemberDeclarationSyntax> Members \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax AddBaseListTypes\(params BaseTypeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax AddMembers\(params EnumMemberDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList\<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithBaseList\(BaseListSyntax baseList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithEnumKeyword\(SyntaxToken enumKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithMembers\(SeparatedSyntaxList\<EnumMemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeDeclarationSyntax : BaseTypeDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public int Arity \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxList\<TypeParameterConstraintClauseSyntax> ConstraintClauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxList\<MemberDeclarationSyntax> Members \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract TypeParameterListSyntax TypeParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ClassDeclarationSyntax : TypeDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BaseListSyntax BaseList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<TypeParameterConstraintClauseSyntax> ConstraintClauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<MemberDeclarationSyntax> Members \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TypeParameterListSyntax TypeParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax AddBaseListTypes\(params BaseTypeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax AddConstraintClauses\(params TypeParameterConstraintClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax AddMembers\(params MemberDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax AddTypeParameterListParameters\(params TypeParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithBaseList\(BaseListSyntax baseList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithConstraintClauses\(SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithMembers\(SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassDeclarationSyntax WithTypeParameterList\(TypeParameterListSyntax typeParameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.InterfaceDeclarationSyntax : TypeDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BaseListSyntax BaseList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<TypeParameterConstraintClauseSyntax> ConstraintClauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<MemberDeclarationSyntax> Members \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TypeParameterListSyntax TypeParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax AddBaseListTypes\(params BaseTypeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax AddConstraintClauses\(params TypeParameterConstraintClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax AddMembers\(params MemberDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax AddTypeParameterListParameters\(params TypeParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithBaseList\(BaseListSyntax baseList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithConstraintClauses\(SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithMembers\(SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public InterfaceDeclarationSyntax WithTypeParameterList\(TypeParameterListSyntax typeParameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.StructDeclarationSyntax : TypeDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override BaseListSyntax BaseList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<TypeParameterConstraintClauseSyntax> ConstraintClauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxList\<MemberDeclarationSyntax> Members \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TypeParameterListSyntax TypeParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax AddBaseListTypes\(params BaseTypeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax AddConstraintClauses\(params TypeParameterConstraintClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax AddMembers\(params MemberDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax AddTypeParameterListParameters\(params TypeParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithBaseList\(BaseListSyntax baseList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithConstraintClauses\(SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithMembers\(SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StructDeclarationSyntax WithTypeParameterList\(TypeParameterListSyntax typeParameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DelegateDeclarationSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public int Arity \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<TypeParameterConstraintClauseSyntax> ConstraintClauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DelegateKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax ReturnType \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax TypeParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax AddConstraintClauses\(params TypeParameterConstraintClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax AddTypeParameterListParameters\(params TypeParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithConstraintClauses\(SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithDelegateKeyword\(SyntaxToken delegateKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithReturnType\(TypeSyntax returnType\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DelegateDeclarationSyntax WithTypeParameterList\(TypeParameterListSyntax typeParameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.EnumMemberDeclarationSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EqualsValueClauseSyntax EqualsValue \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumMemberDeclarationSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumMemberDeclarationSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumMemberDeclarationSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumMemberDeclarationSyntax WithEqualsValue\(EqualsValueClauseSyntax equalsValue\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EnumMemberDeclarationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.GlobalStatementSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GlobalStatementSyntax Update\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GlobalStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.IncompleteMemberSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IncompleteMemberSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IncompleteMemberSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IncompleteMemberSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IncompleteMemberSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IncompleteMemberSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IncompleteMemberSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.NamespaceDeclarationSyntax : MemberDeclarationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<ExternAliasDirectiveSyntax> Externs \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<MemberDeclarationSyntax> Members \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken NamespaceKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<UsingDirectiveSyntax> Usings \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax AddExterns\(params ExternAliasDirectiveSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax AddMembers\(params MemberDeclarationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax AddUsings\(params UsingDirectiveSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax Update\(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList\<ExternAliasDirectiveSyntax> externs, SyntaxList\<UsingDirectiveSyntax> usings, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax WithExterns\(SyntaxList\<ExternAliasDirectiveSyntax> externs\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax WithMembers\(SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax WithName\(NameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax WithNamespaceKeyword\(SyntaxToken namespaceKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public NamespaceDeclarationSyntax WithUsings\(SyntaxList\<UsingDirectiveSyntax> usings\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.NameColonSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public IdentifierNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameColonSyntax Update\(IdentifierNameSyntax name, SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameColonSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameColonSyntax WithName\(IdentifierNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.NameEqualsSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EqualsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public IdentifierNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameEqualsSyntax Update\(IdentifierNameSyntax name, SyntaxToken equalsToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameEqualsSyntax WithEqualsToken\(SyntaxToken equalsToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameEqualsSyntax WithName\(IdentifierNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.OrderingSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken AscendingOrDescendingKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public OrderingSyntax Update\(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public OrderingSyntax WithAscendingOrDescendingKeyword\(SyntaxToken ascendingOrDescendingKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public OrderingSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ParameterSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public EqualsValueClauseSyntax Default \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax WithDefault\(EqualsValueClauseSyntax @default\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.PatternSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConstantPatternSyntax : PatternSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstantPatternSyntax Update\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstantPatternSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DeclarationPatternSyntax : PatternSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDesignationSyntax Designation \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DeclarationPatternSyntax Update\(TypeSyntax type, VariableDesignationSyntax designation\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DeclarationPatternSyntax WithDesignation\(VariableDesignationSyntax designation\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DeclarationPatternSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.QueryBodySyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<QueryClauseSyntax> Clauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryContinuationSyntax Continuation \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SelectOrGroupClauseSyntax SelectOrGroup \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryBodySyntax AddClauses\(params QueryClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryBodySyntax Update\(SyntaxList\<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryBodySyntax WithClauses\(SyntaxList\<QueryClauseSyntax> clauses\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryBodySyntax WithContinuation\(QueryContinuationSyntax continuation\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryBodySyntax WithSelectOrGroup\(SelectOrGroupClauseSyntax selectOrGroup\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.QueryClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.FromClauseSyntax : QueryClauseSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken FromKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken InKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FromClauseSyntax Update\(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FromClauseSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FromClauseSyntax WithFromKeyword\(SyntaxToken fromKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FromClauseSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FromClauseSyntax WithInKeyword\(SyntaxToken inKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FromClauseSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.JoinClauseSyntax : QueryClauseSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EqualsKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax InExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken InKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinIntoClauseSyntax Into \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken JoinKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax LeftExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OnKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax RightExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax Update\(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithEqualsKeyword\(SyntaxToken equalsKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithInExpression\(ExpressionSyntax inExpression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithInKeyword\(SyntaxToken inKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithInto\(JoinIntoClauseSyntax into\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithJoinKeyword\(SyntaxToken joinKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithLeftExpression\(ExpressionSyntax leftExpression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithOnKeyword\(SyntaxToken onKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithRightExpression\(ExpressionSyntax rightExpression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public JoinClauseSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LetClauseSyntax : QueryClauseSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EqualsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LetKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LetClauseSyntax Update\(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LetClauseSyntax WithEqualsToken\(SyntaxToken equalsToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LetClauseSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LetClauseSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LetClauseSyntax WithLetKeyword\(SyntaxToken letKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.OrderByClauseSyntax : QueryClauseSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OrderByKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<OrderingSyntax> Orderings \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OrderByClauseSyntax AddOrderings\(params OrderingSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OrderByClauseSyntax Update\(SyntaxToken orderByKeyword, SeparatedSyntaxList\<OrderingSyntax> orderings\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OrderByClauseSyntax WithOrderByKeyword\(SyntaxToken orderByKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public OrderByClauseSyntax WithOrderings\(SeparatedSyntaxList\<OrderingSyntax> orderings\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.WhereClauseSyntax : QueryClauseSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken WhereKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhereClauseSyntax Update\(SyntaxToken whereKeyword, ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhereClauseSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhereClauseSyntax WithWhereKeyword\(SyntaxToken whereKeyword\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.QueryContinuationSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryBodySyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken IntoKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryContinuationSyntax AddBodyClauses\(params QueryClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryContinuationSyntax Update\(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryContinuationSyntax WithBody\(QueryBodySyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryContinuationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public QueryContinuationSyntax WithIntoKeyword\(SyntaxToken intoKeyword\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SelectOrGroupClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.GroupClauseSyntax : SelectOrGroupClauseSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax ByExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ByKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax GroupExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken GroupKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GroupClauseSyntax Update\(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GroupClauseSyntax WithByExpression\(ExpressionSyntax byExpression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GroupClauseSyntax WithByKeyword\(SyntaxToken byKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GroupClauseSyntax WithGroupExpression\(ExpressionSyntax groupExpression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GroupClauseSyntax WithGroupKeyword\(SyntaxToken groupKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SelectClauseSyntax : SelectOrGroupClauseSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SelectKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SelectClauseSyntax Update\(SyntaxToken selectKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SelectClauseSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SelectClauseSyntax WithSelectKeyword\(SyntaxToken selectKeyword\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.StatementSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BlockSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<StatementSyntax> Statements \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax AddStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Update\(SyntaxToken openBraceToken, SyntaxList\<StatementSyntax> statements, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax WithStatements\(SyntaxList\<StatementSyntax> statements\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BreakStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken BreakKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BreakStatementSyntax Update\(SyntaxToken breakKeyword, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BreakStatementSyntax WithBreakKeyword\(SyntaxToken breakKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BreakStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CheckedStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Block \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedStatementSyntax AddBlockStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedStatementSyntax Update\(SyntaxToken keyword, BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedStatementSyntax WithBlock\(BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CheckedStatementSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CommonForEachStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken ForEachKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken InKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ForEachStatementSyntax : CommonForEachStatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken ForEachKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken InKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax Update\(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax WithForEachKeyword\(SyntaxToken forEachKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax WithInKeyword\(SyntaxToken inKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachStatementSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ForEachVariableStatementSyntax : CommonForEachStatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken ForEachKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken InKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Variable \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachVariableStatementSyntax Update\(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachVariableStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachVariableStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachVariableStatementSyntax WithForEachKeyword\(SyntaxToken forEachKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachVariableStatementSyntax WithInKeyword\(SyntaxToken inKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachVariableStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachVariableStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForEachVariableStatementSyntax WithVariable\(ExpressionSyntax variable\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ContinueStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ContinueKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ContinueStatementSyntax Update\(SyntaxToken continueKeyword, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ContinueStatementSyntax WithContinueKeyword\(SyntaxToken continueKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ContinueStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DoStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DoKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken WhileKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DoStatementSyntax Update\(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DoStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DoStatementSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DoStatementSyntax WithDoKeyword\(SyntaxToken doKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DoStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DoStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DoStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DoStatementSyntax WithWhileKeyword\(SyntaxToken whileKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.EmptyStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EmptyStatementSyntax Update\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EmptyStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ExpressionStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public bool AllowsAnyExpression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionStatementSyntax Update\(ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.FixedStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken FixedKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FixedStatementSyntax AddDeclarationVariables\(params VariableDeclaratorSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FixedStatementSyntax Update\(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FixedStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FixedStatementSyntax WithDeclaration\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FixedStatementSyntax WithFixedKeyword\(SyntaxToken fixedKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FixedStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FixedStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ForStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken FirstSemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ForKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<ExpressionSyntax> Incrementors \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<ExpressionSyntax> Initializers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SecondSemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax AddIncrementors\(params ExpressionSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax AddInitializers\(params ExpressionSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax Update\(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList\<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList\<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithDeclaration\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithFirstSemicolonToken\(SyntaxToken firstSemicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithForKeyword\(SyntaxToken forKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithIncrementors\(SeparatedSyntaxList\<ExpressionSyntax> incrementors\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithInitializers\(SeparatedSyntaxList\<ExpressionSyntax> initializers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithSecondSemicolonToken\(SyntaxToken secondSemicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ForStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.GotoStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CaseOrDefaultKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken GotoKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GotoStatementSyntax Update\(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GotoStatementSyntax WithCaseOrDefaultKeyword\(SyntaxToken caseOrDefaultKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GotoStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GotoStatementSyntax WithGotoKeyword\(SyntaxToken gotoKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public GotoStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.IfStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseClauseSyntax Else \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken IfKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfStatementSyntax Update\(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfStatementSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfStatementSyntax WithElse\(ElseClauseSyntax @else\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfStatementSyntax WithIfKeyword\(SyntaxToken ifKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LabeledStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LabeledStatementSyntax Update\(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LabeledStatementSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LabeledStatementSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LabeledStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LocalDeclarationStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public bool IsConst \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalDeclarationStatementSyntax AddDeclarationVariables\(params VariableDeclaratorSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalDeclarationStatementSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalDeclarationStatementSyntax Update\(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalDeclarationStatementSyntax WithDeclaration\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalDeclarationStatementSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalDeclarationStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LocalFunctionStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Body \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<TypeParameterConstraintClauseSyntax> ConstraintClauses \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ArrowExpressionClauseSyntax ExpressionBody \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Modifiers \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParameterListSyntax ParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax ReturnType \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax TypeParameterList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax AddBodyStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax AddConstraintClauses\(params TypeParameterConstraintClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax AddModifiers\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax AddParameterListParameters\(params ParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax AddTypeParameterListParameters\(params TypeParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax Update\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithBody\(BlockSyntax body\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithConstraintClauses\(SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithExpressionBody\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithModifiers\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithParameterList\(ParameterListSyntax parameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithReturnType\(TypeSyntax returnType\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LocalFunctionStatementSyntax WithTypeParameterList\(TypeParameterListSyntax typeParameterList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LockStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LockKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LockStatementSyntax Update\(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LockStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LockStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LockStatementSyntax WithLockKeyword\(SyntaxToken lockKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LockStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LockStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ReturnStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ReturnKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReturnStatementSyntax Update\(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReturnStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReturnStatementSyntax WithReturnKeyword\(SyntaxToken returnKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReturnStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SwitchStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenBraceToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<SwitchSectionSyntax> Sections \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SwitchKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax AddSections\(params SwitchSectionSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax Update\(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList\<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax WithCloseBraceToken\(SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax WithOpenBraceToken\(SyntaxToken openBraceToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax WithSections\(SyntaxList\<SwitchSectionSyntax> sections\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchStatementSyntax WithSwitchKeyword\(SyntaxToken switchKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ThrowStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ThrowKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThrowStatementSyntax Update\(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThrowStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThrowStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ThrowStatementSyntax WithThrowKeyword\(SyntaxToken throwKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TryStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Block \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<CatchClauseSyntax> Catches \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public FinallyClauseSyntax Finally \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken TryKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TryStatementSyntax AddBlockStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TryStatementSyntax AddCatches\(params CatchClauseSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TryStatementSyntax Update\(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList\<CatchClauseSyntax> catches, FinallyClauseSyntax @finally\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TryStatementSyntax WithBlock\(BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TryStatementSyntax WithCatches\(SyntaxList\<CatchClauseSyntax> catches\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TryStatementSyntax WithFinally\(FinallyClauseSyntax @finally\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TryStatementSyntax WithTryKeyword\(SyntaxToken tryKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.UnsafeStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BlockSyntax Block \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken UnsafeKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UnsafeStatementSyntax AddBlockStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UnsafeStatementSyntax Update\(SyntaxToken unsafeKeyword, BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UnsafeStatementSyntax WithBlock\(BlockSyntax block\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UnsafeStatementSyntax WithUnsafeKeyword\(SyntaxToken unsafeKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.UsingStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax Declaration \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken UsingKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingStatementSyntax Update\(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingStatementSyntax WithDeclaration\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingStatementSyntax WithUsingKeyword\(SyntaxToken usingKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.WhileStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public StatementSyntax Statement \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken WhileKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhileStatementSyntax Update\(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhileStatementSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhileStatementSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhileStatementSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhileStatementSyntax WithStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhileStatementSyntax WithWhileKeyword\(SyntaxToken whileKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.YieldStatementSyntax : StatementSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Expression \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ReturnOrBreakKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken YieldKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public YieldStatementSyntax Update\(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public YieldStatementSyntax WithExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public YieldStatementSyntax WithReturnOrBreakKeyword\(SyntaxToken returnOrBreakKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public YieldStatementSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public YieldStatementSyntax WithYieldKeyword\(SyntaxToken yieldKeyword\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.StructuredTriviaSyntax : CSharpSyntaxNode, IStructuredTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxTrivia ParentTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DirectiveTriviaSyntax : StructuredTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DirectiveNameToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DirectiveTriviaSyntax GetNextDirective\(Func\<DirectiveTriviaSyntax, bool> predicate = null\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DirectiveTriviaSyntax GetPreviousDirective\(Func\<DirectiveTriviaSyntax, bool> predicate = null\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public List\<DirectiveTriviaSyntax> GetRelatedDirectives\(\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BadDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BadDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BadDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BadDirectiveTriviaSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public BadDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract bool BranchTaken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract bool ConditionValue \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool BranchTaken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool ConditionValue \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ElifKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElifDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElifDirectiveTriviaSyntax WithBranchTaken\(bool branchTaken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElifDirectiveTriviaSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElifDirectiveTriviaSyntax WithConditionValue\(bool conditionValue\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElifDirectiveTriviaSyntax WithElifKeyword\(SyntaxToken elifKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElifDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElifDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElifDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool BranchTaken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool ConditionValue \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken IfKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfDirectiveTriviaSyntax WithBranchTaken\(bool branchTaken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfDirectiveTriviaSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfDirectiveTriviaSyntax WithConditionValue\(bool conditionValue\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfDirectiveTriviaSyntax WithIfKeyword\(SyntaxToken ifKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IfDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool BranchTaken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ElseKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseDirectiveTriviaSyntax WithBranchTaken\(bool branchTaken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseDirectiveTriviaSyntax WithElseKeyword\(SyntaxToken elseKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ElseDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DefineKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefineDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefineDirectiveTriviaSyntax WithDefineKeyword\(SyntaxToken defineKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefineDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefineDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefineDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefineDirectiveTriviaSyntax WithName\(SyntaxToken name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EndIfKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndIfDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndIfDirectiveTriviaSyntax WithEndIfKeyword\(SyntaxToken endIfKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndIfDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndIfDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EndRegionKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndRegionDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndRegionDirectiveTriviaSyntax WithEndRegionKeyword\(SyntaxToken endRegionKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndRegionDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public EndRegionDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ErrorKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ErrorDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ErrorDirectiveTriviaSyntax WithErrorKeyword\(SyntaxToken errorKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ErrorDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ErrorDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LineDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken File \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Line \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LineKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LineDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LineDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LineDirectiveTriviaSyntax WithFile\(SyntaxToken file\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LineDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LineDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LineDirectiveTriviaSyntax WithLine\(SyntaxToken line\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LineDirectiveTriviaSyntax WithLineKeyword\(SyntaxToken lineKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken File \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LoadKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LoadDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LoadDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LoadDirectiveTriviaSyntax WithFile\(SyntaxToken file\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LoadDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LoadDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public LoadDirectiveTriviaSyntax WithLoadKeyword\(SyntaxToken loadKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Bytes \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ChecksumKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken File \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Guid \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken PragmaKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax WithBytes\(SyntaxToken bytes\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword\(SyntaxToken checksumKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax WithFile\(SyntaxToken file\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax WithGuid\(SyntaxToken guid\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword\(SyntaxToken pragmaKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken DisableOrRestoreKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<ExpressionSyntax> ErrorCodes \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken PragmaKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken WarningKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax AddErrorCodes\(params ExpressionSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList\<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword\(SyntaxToken disableOrRestoreKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax WithErrorCodes\(SeparatedSyntaxList\<ExpressionSyntax> errorCodes\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword\(SyntaxToken pragmaKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PragmaWarningDirectiveTriviaSyntax WithWarningKeyword\(SyntaxToken warningKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken File \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ReferenceKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReferenceDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReferenceDirectiveTriviaSyntax WithFile\(SyntaxToken file\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReferenceDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReferenceDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ReferenceDirectiveTriviaSyntax WithReferenceKeyword\(SyntaxToken referenceKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken RegionKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RegionDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RegionDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RegionDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RegionDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public RegionDirectiveTriviaSyntax WithRegionKeyword\(SyntaxToken regionKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ExclamationToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ShebangDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ShebangDirectiveTriviaSyntax WithExclamationToken\(SyntaxToken exclamationToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ShebangDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ShebangDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken UndefKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UndefDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UndefDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UndefDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UndefDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UndefDirectiveTriviaSyntax WithName\(SyntaxToken name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public UndefDirectiveTriviaSyntax WithUndefKeyword\(SyntaxToken undefKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndOfDirectiveToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken HashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override bool IsActive \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken WarningKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WarningDirectiveTriviaSyntax Update\(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WarningDirectiveTriviaSyntax WithEndOfDirectiveToken\(SyntaxToken endOfDirectiveToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WarningDirectiveTriviaSyntax WithHashToken\(SyntaxToken hashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WarningDirectiveTriviaSyntax WithIsActive\(bool isActive\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WarningDirectiveTriviaSyntax WithWarningKeyword\(SyntaxToken warningKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<XmlNodeSyntax> Content \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EndOfComment \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DocumentationCommentTriviaSyntax AddContent\(params XmlNodeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DocumentationCommentTriviaSyntax Update\(SyntaxList\<XmlNodeSyntax> content, SyntaxToken endOfComment\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DocumentationCommentTriviaSyntax WithContent\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DocumentationCommentTriviaSyntax WithEndOfComment\(SyntaxToken endOfComment\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SkippedTokensTriviaSyntax : StructuredTriviaSyntax, ISkippedTokensTriviaSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList Tokens \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SkippedTokensTriviaSyntax AddTokens\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SkippedTokensTriviaSyntax Update\(SyntaxTokenList tokens\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SkippedTokensTriviaSyntax WithTokens\(SyntaxTokenList tokens\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SwitchLabelSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CasePatternSwitchLabelSyntax : SwitchLabelSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public PatternSyntax Pattern \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public WhenClauseSyntax WhenClause \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CasePatternSwitchLabelSyntax Update\(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CasePatternSwitchLabelSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CasePatternSwitchLabelSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CasePatternSwitchLabelSyntax WithPattern\(PatternSyntax pattern\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CasePatternSwitchLabelSyntax WithWhenClause\(WhenClauseSyntax whenClause\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.CaseSwitchLabelSyntax : SwitchLabelSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Value \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CaseSwitchLabelSyntax Update\(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CaseSwitchLabelSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CaseSwitchLabelSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CaseSwitchLabelSyntax WithValue\(ExpressionSyntax value\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DefaultSwitchLabelSyntax : SwitchLabelSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken Keyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefaultSwitchLabelSyntax Update\(SyntaxToken keyword, SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefaultSwitchLabelSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DefaultSwitchLabelSyntax WithKeyword\(SyntaxToken keyword\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SwitchSectionSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<SwitchLabelSyntax> Labels \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<StatementSyntax> Statements \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchSectionSyntax AddLabels\(params SwitchLabelSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchSectionSyntax AddStatements\(params StatementSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchSectionSyntax Update\(SyntaxList\<SwitchLabelSyntax> labels, SyntaxList\<StatementSyntax> statements\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchSectionSyntax WithLabels\(SyntaxList\<SwitchLabelSyntax> labels\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SwitchSectionSyntax WithStatements\(SyntaxList\<StatementSyntax> statements\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TupleElementSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleElementSyntax Update\(TypeSyntax type, SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleElementSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TupleElementSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeArgumentListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TypeSyntax> Arguments \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken GreaterThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LessThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeArgumentListSyntax AddArguments\(params TypeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeArgumentListSyntax Update\(SyntaxToken lessThanToken, SeparatedSyntaxList\<TypeSyntax> arguments, SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeArgumentListSyntax WithArguments\(SeparatedSyntaxList\<TypeSyntax> arguments\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeArgumentListSyntax WithGreaterThanToken\(SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeArgumentListSyntax WithLessThanToken\(SyntaxToken lessThanToken\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeParameterConstraintClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TypeParameterConstraintSyntax> Constraints \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public IdentifierNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken WhereKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterConstraintClauseSyntax AddConstraints\(params TypeParameterConstraintSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterConstraintClauseSyntax Update\(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList\<TypeParameterConstraintSyntax> constraints\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterConstraintClauseSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterConstraintClauseSyntax WithConstraints\(SeparatedSyntaxList\<TypeParameterConstraintSyntax> constraints\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterConstraintClauseSyntax WithName\(IdentifierNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterConstraintClauseSyntax WithWhereKeyword\(SyntaxToken whereKeyword\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeParameterConstraintSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ClassOrStructKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassOrStructConstraintSyntax Update\(SyntaxToken classOrStructKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ClassOrStructConstraintSyntax WithClassOrStructKeyword\(SyntaxToken classOrStructKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ConstructorConstraintSyntax : TypeParameterConstraintSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken NewKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorConstraintSyntax Update\(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorConstraintSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorConstraintSyntax WithNewKeyword\(SyntaxToken newKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ConstructorConstraintSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeConstraintSyntax : TypeParameterConstraintSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeConstraintSyntax Update\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeConstraintSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeParameterListSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken GreaterThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LessThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<TypeParameterSyntax> Parameters \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax AddParameters\(params TypeParameterSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax Update\(SyntaxToken lessThanToken, SeparatedSyntaxList\<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax WithGreaterThanToken\(SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax WithLessThanToken\(SyntaxToken lessThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterListSyntax WithParameters\(SeparatedSyntaxList\<TypeParameterSyntax> parameters\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.TypeParameterSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<AttributeListSyntax> AttributeLists \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken VarianceKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterSyntax AddAttributeLists\(params AttributeListSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterSyntax Update\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterSyntax WithAttributeLists\(SyntaxList\<AttributeListSyntax> attributeLists\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeParameterSyntax WithVarianceKeyword\(SyntaxToken varianceKeyword\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.UsingDirectiveSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameEqualsSyntax Alias \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public NameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SemicolonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken StaticKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken UsingKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax Update\(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax WithAlias\(NameEqualsSyntax alias\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax WithName\(NameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax WithSemicolonToken\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax WithStaticKeyword\(SyntaxToken staticKeyword\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public UsingDirectiveSyntax WithUsingKeyword\(SyntaxToken usingKeyword\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.VariableDeclarationSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public TypeSyntax Type \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<VariableDeclaratorSyntax> Variables \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax AddVariables\(params VariableDeclaratorSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax Update\(TypeSyntax type, SeparatedSyntaxList\<VariableDeclaratorSyntax> variables\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax WithType\(TypeSyntax type\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclarationSyntax WithVariables\(SeparatedSyntaxList\<VariableDeclaratorSyntax> variables\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.VariableDeclaratorSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public BracketedArgumentListSyntax ArgumentList \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public EqualsValueClauseSyntax Initializer \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclaratorSyntax AddArgumentListArguments\(params ArgumentSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclaratorSyntax Update\(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclaratorSyntax WithArgumentList\(BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclaratorSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public VariableDeclaratorSyntax WithInitializer\(EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.VariableDesignationSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.DiscardDesignationSyntax : VariableDesignationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken UnderscoreToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DiscardDesignationSyntax Update\(SyntaxToken underscoreToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public DiscardDesignationSyntax WithUnderscoreToken\(SyntaxToken underscoreToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken CloseParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken OpenParenToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SeparatedSyntaxList\<VariableDesignationSyntax> Variables \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedVariableDesignationSyntax AddVariables\(params VariableDesignationSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedVariableDesignationSyntax Update\(SyntaxToken openParenToken, SeparatedSyntaxList\<VariableDesignationSyntax> variables, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedVariableDesignationSyntax WithCloseParenToken\(SyntaxToken closeParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedVariableDesignationSyntax WithOpenParenToken\(SyntaxToken openParenToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public ParenthesizedVariableDesignationSyntax WithVariables\(SeparatedSyntaxList\<VariableDesignationSyntax> variables\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.SingleVariableDesignationSyntax : VariableDesignationSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SingleVariableDesignationSyntax Update\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SingleVariableDesignationSyntax WithIdentifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.WhenClauseSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public ExpressionSyntax Condition \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken WhenKeyword \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public WhenClauseSyntax Update\(SyntaxToken whenKeyword, ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public WhenClauseSyntax WithCondition\(ExpressionSyntax condition\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public WhenClauseSyntax WithWhenKeyword\(SyntaxToken whenKeyword\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlAttributeSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken EndQuoteToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken EqualsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract XmlNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public abstract SyntaxToken StartQuoteToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlCrefAttributeSyntax : XmlAttributeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public CrefSyntax Cref \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndQuoteToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EqualsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override XmlNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken StartQuoteToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCrefAttributeSyntax Update\(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCrefAttributeSyntax WithCref\(CrefSyntax cref\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCrefAttributeSyntax WithEndQuoteToken\(SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCrefAttributeSyntax WithEqualsToken\(SyntaxToken equalsToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCrefAttributeSyntax WithName\(XmlNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCrefAttributeSyntax WithStartQuoteToken\(SyntaxToken startQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlNameAttributeSyntax : XmlAttributeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndQuoteToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EqualsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public IdentifierNameSyntax Identifier \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override XmlNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken StartQuoteToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameAttributeSyntax Update\(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameAttributeSyntax WithEndQuoteToken\(SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameAttributeSyntax WithEqualsToken\(SyntaxToken equalsToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameAttributeSyntax WithIdentifier\(IdentifierNameSyntax identifier\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameAttributeSyntax WithName\(XmlNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameAttributeSyntax WithStartQuoteToken\(SyntaxToken startQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlTextAttributeSyntax : XmlAttributeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EndQuoteToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken EqualsToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override XmlNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override SyntaxToken StartQuoteToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList TextTokens \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextAttributeSyntax AddTextTokens\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextAttributeSyntax Update\(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextAttributeSyntax WithEndQuoteToken\(SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextAttributeSyntax WithEqualsToken\(SyntaxToken equalsToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextAttributeSyntax WithName\(XmlNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextAttributeSyntax WithStartQuoteToken\(SyntaxToken startQuoteToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextAttributeSyntax WithTextTokens\(SyntaxTokenList textTokens\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlElementEndTagSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken GreaterThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LessThanSlashToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementEndTagSyntax Update\(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementEndTagSyntax WithGreaterThanToken\(SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementEndTagSyntax WithLessThanSlashToken\(SyntaxToken lessThanSlashToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementEndTagSyntax WithName\(XmlNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlElementStartTagSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<XmlAttributeSyntax> Attributes \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken GreaterThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LessThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementStartTagSyntax AddAttributes\(params XmlAttributeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementStartTagSyntax Update\(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList\<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementStartTagSyntax WithAttributes\(SyntaxList\<XmlAttributeSyntax> attributes\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementStartTagSyntax WithGreaterThanToken\(SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementStartTagSyntax WithLessThanToken\(SyntaxToken lessThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementStartTagSyntax WithName\(XmlNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlNameSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LocalName \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlPrefixSyntax Prefix \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameSyntax Update\(XmlPrefixSyntax prefix, SyntaxToken localName\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameSyntax WithLocalName\(SyntaxToken localName\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameSyntax WithPrefix\(XmlPrefixSyntax prefix\);
* &emsp; \| &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlNodeSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlCDataSectionSyntax : XmlNodeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EndCDataToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken StartCDataToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList TextTokens \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCDataSectionSyntax AddTextTokens\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCDataSectionSyntax Update\(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCDataSectionSyntax WithEndCDataToken\(SyntaxToken endCDataToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCDataSectionSyntax WithStartCDataToken\(SyntaxToken startCDataToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCDataSectionSyntax WithTextTokens\(SyntaxTokenList textTokens\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlCommentSyntax : XmlNodeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LessThanExclamationMinusMinusToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken MinusMinusGreaterThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList TextTokens \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCommentSyntax AddTextTokens\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCommentSyntax Update\(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCommentSyntax WithLessThanExclamationMinusMinusToken\(SyntaxToken lessThanExclamationMinusMinusToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCommentSyntax WithMinusMinusGreaterThanToken\(SyntaxToken minusMinusGreaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlCommentSyntax WithTextTokens\(SyntaxTokenList textTokens\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlElementSyntax : XmlNodeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<XmlNodeSyntax> Content \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementEndTagSyntax EndTag \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementStartTagSyntax StartTag \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementSyntax AddContent\(params XmlNodeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementSyntax AddStartTagAttributes\(params XmlAttributeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementSyntax Update\(XmlElementStartTagSyntax startTag, SyntaxList\<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementSyntax WithContent\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementSyntax WithEndTag\(XmlElementEndTagSyntax endTag\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlElementSyntax WithStartTag\(XmlElementStartTagSyntax startTag\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlEmptyElementSyntax : XmlNodeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxList\<XmlAttributeSyntax> Attributes \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken LessThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken SlashGreaterThanToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlEmptyElementSyntax AddAttributes\(params XmlAttributeSyntax\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlEmptyElementSyntax Update\(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList\<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlEmptyElementSyntax WithAttributes\(SyntaxList\<XmlAttributeSyntax> attributes\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlEmptyElementSyntax WithLessThanToken\(SyntaxToken lessThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlEmptyElementSyntax WithName\(XmlNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlEmptyElementSyntax WithSlashGreaterThanToken\(SyntaxToken slashGreaterThanToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlProcessingInstructionSyntax : XmlNodeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken EndProcessingInstructionToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlNameSyntax Name \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken StartProcessingInstructionToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList TextTokens \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlProcessingInstructionSyntax AddTextTokens\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlProcessingInstructionSyntax Update\(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken\(SyntaxToken endProcessingInstructionToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlProcessingInstructionSyntax WithName\(XmlNameSyntax name\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken\(SyntaxToken startProcessingInstructionToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlProcessingInstructionSyntax WithTextTokens\(SyntaxTokenList textTokens\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlTextSyntax : XmlNodeSyntax
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxTokenList TextTokens \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextSyntax AddTextTokens\(params SyntaxToken\[\] items\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextSyntax Update\(SyntaxTokenList textTokens\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlTextSyntax WithTextTokens\(SyntaxTokenList textTokens\);
* &emsp; \| &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CSharp\.Syntax\.XmlPrefixSyntax : CSharpSyntaxNode
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken ColonToken \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public SyntaxToken Prefix \{ get; \}
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override void Accept\(CSharpSyntaxVisitor visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public override TResult Accept\<TResult>\(CSharpSyntaxVisitor\<TResult> visitor\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlPrefixSyntax Update\(SyntaxToken prefix, SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlPrefixSyntax WithColonToken\(SyntaxToken colonToken\);
* &emsp; \| &emsp; \| &emsp; \| &emsp; public XmlPrefixSyntax WithPrefix\(SyntaxToken prefix\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.SyntaxReference
* &emsp; \| &emsp; protected SyntaxReference\(\);
* &emsp; \| &emsp; public abstract TextSpan Span \{ get; \}
* &emsp; \| &emsp; public abstract SyntaxTree SyntaxTree \{ get; \}
* &emsp; \| &emsp; public abstract SyntaxNode GetSyntax\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public virtual Task\<SyntaxNode> GetSyntaxAsync\(CancellationToken cancellationToken = default\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.SyntaxTree
* &emsp; \| &emsp; protected SyntaxTree\(\);
* &emsp; \| &emsp; public abstract Encoding Encoding \{ get; \}
* &emsp; \| &emsp; public abstract string FilePath \{ get; \}
* &emsp; \| &emsp; public abstract bool HasCompilationUnitRoot \{ get; \}
* &emsp; \| &emsp; public abstract int Length \{ get; \}
* &emsp; \| &emsp; public ParseOptions Options \{ get; \}
* &emsp; \| &emsp; protected abstract ParseOptions OptionsCore \{ get; \}
* &emsp; \| &emsp; public abstract IList\<TextSpan> GetChangedSpans\(SyntaxTree syntaxTree\);
* &emsp; \| &emsp; public abstract IList\<TextChange> GetChanges\(SyntaxTree oldTree\);
* &emsp; \| &emsp; public abstract IEnumerable\<Diagnostic> GetDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract IEnumerable\<Diagnostic> GetDiagnostics\(SyntaxNode node\);
* &emsp; \| &emsp; public abstract IEnumerable\<Diagnostic> GetDiagnostics\(SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; public abstract IEnumerable\<Diagnostic> GetDiagnostics\(SyntaxToken token\);
* &emsp; \| &emsp; public abstract IEnumerable\<Diagnostic> GetDiagnostics\(SyntaxTrivia trivia\);
* &emsp; \| &emsp; public abstract FileLinePositionSpan GetLineSpan\(TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public virtual LineVisibility GetLineVisibility\(int position, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract Location GetLocation\(TextSpan span\);
* &emsp; \| &emsp; public abstract FileLinePositionSpan GetMappedLineSpan\(TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract SyntaxReference GetReference\(SyntaxNode node\);
* &emsp; \| &emsp; public SyntaxNode GetRoot\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<SyntaxNode> GetRootAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; protected abstract Task\<SyntaxNode> GetRootAsyncCore\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; protected abstract SyntaxNode GetRootCore\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public abstract SourceText GetText\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public virtual Task\<SourceText> GetTextAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract bool HasHiddenRegions\(\);
* &emsp; \| &emsp; public abstract bool IsEquivalentTo\(SyntaxTree tree, bool topLevel = false\);
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public bool TryGetRoot\(out SyntaxNode root\);
* &emsp; \| &emsp; protected abstract bool TryGetRootCore\(out SyntaxNode root\);
* &emsp; \| &emsp; public abstract bool TryGetText\(out SourceText text\);
* &emsp; \| &emsp; public abstract SyntaxTree WithChangedText\(SourceText newText\);
* &emsp; \| &emsp; public abstract SyntaxTree WithFilePath\(string path\);
* &emsp; \| &emsp; public abstract SyntaxTree WithRootAndOptions\(SyntaxNode root, ParseOptions options\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.CSharpSyntaxTree : SyntaxTree
* &emsp; \| &emsp; \| &emsp; protected CSharpSyntaxTree\(\);
* &emsp; \| &emsp; \| &emsp; public abstract CSharpParseOptions Options \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected override ParseOptions OptionsCore \{ get; \}
* &emsp; \| &emsp; \| &emsp; protected T CloneNodeAsRoot\<T>\(T node\) where T : CSharpSyntaxNode;
* &emsp; \| &emsp; \| &emsp; public static SyntaxTree Create\(CSharpSyntaxNode root, CSharpParseOptions options = null, string path = "", Encoding encoding = null\);
* &emsp; \| &emsp; \| &emsp; public override IList\<TextSpan> GetChangedSpans\(SyntaxTree oldTree\);
* &emsp; \| &emsp; \| &emsp; public override IList\<TextChange> GetChanges\(SyntaxTree oldTree\);
* &emsp; \| &emsp; \| &emsp; public CompilationUnitSyntax GetCompilationUnitRoot\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public override IEnumerable\<Diagnostic> GetDiagnostics\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public override IEnumerable\<Diagnostic> GetDiagnostics\(SyntaxNode node\);
* &emsp; \| &emsp; \| &emsp; public override IEnumerable\<Diagnostic> GetDiagnostics\(SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; \| &emsp; public override IEnumerable\<Diagnostic> GetDiagnostics\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public override IEnumerable\<Diagnostic> GetDiagnostics\(SyntaxTrivia trivia\);
* &emsp; \| &emsp; \| &emsp; public override FileLinePositionSpan GetLineSpan\(TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public override LineVisibility GetLineVisibility\(int position, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public override Location GetLocation\(TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public override FileLinePositionSpan GetMappedLineSpan\(TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public abstract CSharpSyntaxNode GetRoot\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public virtual Task\<CSharpSyntaxNode> GetRootAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; protected override Task\<SyntaxNode> GetRootAsyncCore\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; protected override SyntaxNode GetRootCore\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public override bool HasHiddenRegions\(\);
* &emsp; \| &emsp; \| &emsp; public override bool IsEquivalentTo\(SyntaxTree tree, bool topLevel = false\);
* &emsp; \| &emsp; \| &emsp; public static SyntaxTree ParseText\(SourceText text, CSharpParseOptions options = null, string path = "", CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public static SyntaxTree ParseText\(string text, CSharpParseOptions options = null, string path = "", Encoding encoding = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public abstract bool TryGetRoot\(out CSharpSyntaxNode root\);
* &emsp; \| &emsp; \| &emsp; protected override bool TryGetRootCore\(out SyntaxNode root\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxTree WithChangedText\(SourceText newText\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.SyntaxWalker
* &emsp; \| &emsp; protected SyntaxWalker\(SyntaxWalkerDepth depth = Node\);
* &emsp; \| &emsp; protected SyntaxWalkerDepth Depth \{ get; \}
* &emsp; \| &emsp; public virtual void Visit\(SyntaxNode node\);
* &emsp; \| &emsp; protected virtual void VisitToken\(SyntaxToken token\);
* &emsp; \| &emsp; protected virtual void VisitTrivia\(SyntaxTrivia trivia\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.TextAndVersion
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public SourceText Text \{ get; \}
* &emsp; \| &emsp; public VersionStamp Version \{ get; \}
* &emsp; \| &emsp; public static TextAndVersion Create\(SourceText text, VersionStamp version, string filePath = null\);
* &emsp; public class Microsoft\.CodeAnalysis\.TextDocument
* &emsp; \| &emsp; protected TextDocument\(\);
* &emsp; \| &emsp; public string FilePath \{ get; \}
* &emsp; \| &emsp; public IReadOnlyList\<string> Folders \{ get; \}
* &emsp; \| &emsp; public DocumentId Id \{ get; \}
* &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; public Project Project \{ get; protected set; \}
* &emsp; \| &emsp; public Task\<SourceText> GetTextAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<VersionStamp> GetTextVersionAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public bool TryGetText\(out SourceText text\);
* &emsp; \| &emsp; public bool TryGetTextVersion\(out VersionStamp version\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.Document : TextDocument
* &emsp; \| &emsp; \| &emsp; public SourceCodeKind SourceCodeKind \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool SupportsSemanticModel \{ get; \}
* &emsp; \| &emsp; \| &emsp; public bool SupportsSyntaxTree \{ get; \}
* &emsp; \| &emsp; \| &emsp; public ImmutableArray\<DocumentId> GetLinkedDocumentIds\(\);
* &emsp; \| &emsp; \| &emsp; public Task\<DocumentOptionSet> GetOptionsAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public Task\<SemanticModel> GetSemanticModelAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public Task\<SyntaxNode> GetSyntaxRootAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public Task\<SyntaxTree> GetSyntaxTreeAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public Task\<VersionStamp> GetSyntaxVersionAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public Task\<IEnumerable\<TextChange>> GetTextChangesAsync\(Document oldDocument, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public bool TryGetSemanticModel\(out SemanticModel semanticModel\);
* &emsp; \| &emsp; \| &emsp; public bool TryGetSyntaxRoot\(out SyntaxNode root\);
* &emsp; \| &emsp; \| &emsp; public bool TryGetSyntaxTree\(out SyntaxTree syntaxTree\);
* &emsp; \| &emsp; \| &emsp; public bool TryGetSyntaxVersion\(out VersionStamp version\);
* &emsp; \| &emsp; \| &emsp; public Document WithFilePath\(string filePath\);
* &emsp; \| &emsp; \| &emsp; public Document WithFolders\(IEnumerable\<string> folders\);
* &emsp; \| &emsp; \| &emsp; public Document WithName\(string name\);
* &emsp; \| &emsp; \| &emsp; public Document WithSourceCodeKind\(SourceCodeKind kind\);
* &emsp; \| &emsp; \| &emsp; public Document WithSyntaxRoot\(SyntaxNode root\);
* &emsp; \| &emsp; \| &emsp; public Document WithText\(SourceText text\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.TextLoader
* &emsp; \| &emsp; protected TextLoader\(\);
* &emsp; \| &emsp; public static TextLoader From\(TextAndVersion textAndVersion\);
* &emsp; \| &emsp; public static TextLoader From\(SourceTextContainer container, VersionStamp version, string filePath = null\);
* &emsp; \| &emsp; public abstract Task\<TextAndVersion> LoadTextAndVersionAsync\(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Workspace : IDisposable
* &emsp; \| &emsp; protected Workspace\(HostServices host, string workspaceKind\);
* &emsp; \| &emsp; public event EventHandler\<DocumentActiveContextChangedEventArgs> DocumentActiveContextChanged;
* &emsp; \| &emsp; public event EventHandler\<DocumentEventArgs> DocumentClosed;
* &emsp; \| &emsp; public event EventHandler\<DocumentEventArgs> DocumentOpened;
* &emsp; \| &emsp; public event EventHandler\<WorkspaceChangeEventArgs> WorkspaceChanged;
* &emsp; \| &emsp; public event EventHandler\<WorkspaceDiagnosticEventArgs> WorkspaceFailed;
* &emsp; \| &emsp; public virtual bool CanOpenDocuments \{ get; \}
* &emsp; \| &emsp; public Solution CurrentSolution \{ get; \}
* &emsp; \| &emsp; public string Kind \{ get; \}
* &emsp; \| &emsp; public OptionSet Options \{ get; set; \}
* &emsp; \| &emsp; protected internal virtual bool PartialSemanticsEnabled \{ get; \}
* &emsp; \| &emsp; public HostWorkspaceServices Services \{ get; \}
* &emsp; \| &emsp; protected virtual Project AdjustReloadedProject\(Project oldProject, Project reloadedProject\);
* &emsp; \| &emsp; protected virtual Solution AdjustReloadedSolution\(Solution oldSolution, Solution reloadedSolution\);
* &emsp; \| &emsp; protected virtual void ApplyAdditionalDocumentAdded\(DocumentInfo info, SourceText text\);
* &emsp; \| &emsp; protected virtual void ApplyAdditionalDocumentRemoved\(DocumentId documentId\);
* &emsp; \| &emsp; protected virtual void ApplyAdditionalDocumentTextChanged\(DocumentId id, SourceText text\);
* &emsp; \| &emsp; protected virtual void ApplyAnalyzerReferenceAdded\(ProjectId projectId, AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; protected virtual void ApplyAnalyzerReferenceRemoved\(ProjectId projectId, AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; protected virtual void ApplyCompilationOptionsChanged\(ProjectId projectId, CompilationOptions options\);
* &emsp; \| &emsp; protected virtual void ApplyDocumentAdded\(DocumentInfo info, SourceText text\);
* &emsp; \| &emsp; protected virtual void ApplyDocumentInfoChanged\(DocumentId id, DocumentInfo info\);
* &emsp; \| &emsp; protected virtual void ApplyDocumentRemoved\(DocumentId documentId\);
* &emsp; \| &emsp; protected virtual void ApplyDocumentTextChanged\(DocumentId id, SourceText text\);
* &emsp; \| &emsp; protected virtual void ApplyMetadataReferenceAdded\(ProjectId projectId, MetadataReference metadataReference\);
* &emsp; \| &emsp; protected virtual void ApplyMetadataReferenceRemoved\(ProjectId projectId, MetadataReference metadataReference\);
* &emsp; \| &emsp; protected virtual void ApplyParseOptionsChanged\(ProjectId projectId, ParseOptions options\);
* &emsp; \| &emsp; protected virtual void ApplyProjectAdded\(ProjectInfo project\);
* &emsp; \| &emsp; protected virtual void ApplyProjectChanges\(ProjectChanges projectChanges\);
* &emsp; \| &emsp; protected virtual void ApplyProjectReferenceAdded\(ProjectId projectId, ProjectReference projectReference\);
* &emsp; \| &emsp; protected virtual void ApplyProjectReferenceRemoved\(ProjectId projectId, ProjectReference projectReference\);
* &emsp; \| &emsp; protected virtual void ApplyProjectRemoved\(ProjectId projectId\);
* &emsp; \| &emsp; public virtual bool CanApplyChange\(ApplyChangesKind feature\);
* &emsp; \| &emsp; protected virtual bool CanApplyParseOptionChange\(ParseOptions oldOptions, ParseOptions newOptions, Project project\);
* &emsp; \| &emsp; protected void CheckAdditionalDocumentIsInCurrentSolution\(DocumentId documentId\);
* &emsp; \| &emsp; protected void CheckAdditionalDocumentIsNotInCurrentSolution\(DocumentId documentId\);
* &emsp; \| &emsp; protected void CheckCanOpenDocuments\(\);
* &emsp; \| &emsp; protected virtual void CheckDocumentCanBeRemoved\(DocumentId documentId\);
* &emsp; \| &emsp; protected void CheckDocumentIsClosed\(DocumentId documentId\);
* &emsp; \| &emsp; protected void CheckDocumentIsInCurrentSolution\(DocumentId documentId\);
* &emsp; \| &emsp; protected void CheckDocumentIsNotInCurrentSolution\(DocumentId documentId\);
* &emsp; \| &emsp; protected void CheckDocumentIsOpen\(DocumentId documentId\);
* &emsp; \| &emsp; protected virtual void CheckProjectCanBeRemoved\(ProjectId projectId\);
* &emsp; \| &emsp; protected void CheckProjectDoesNotContainOpenDocuments\(ProjectId projectId\);
* &emsp; \| &emsp; protected void CheckProjectDoesNotHaveAnalyzerReference\(ProjectId projectId, AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; protected void CheckProjectDoesNotHaveMetadataReference\(ProjectId projectId, MetadataReference metadataReference\);
* &emsp; \| &emsp; protected void CheckProjectDoesNotHaveProjectReference\(ProjectId fromProjectId, ProjectReference projectReference\);
* &emsp; \| &emsp; protected void CheckProjectDoesNotHaveTransitiveProjectReference\(ProjectId fromProjectId, ProjectId toProjectId\);
* &emsp; \| &emsp; protected void CheckProjectHasAnalyzerReference\(ProjectId projectId, AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; protected void CheckProjectHasMetadataReference\(ProjectId projectId, MetadataReference metadataReference\);
* &emsp; \| &emsp; protected void CheckProjectHasProjectReference\(ProjectId fromProjectId, ProjectReference projectReference\);
* &emsp; \| &emsp; protected void CheckProjectIsInCurrentSolution\(ProjectId projectId\);
* &emsp; \| &emsp; protected void CheckProjectIsNotInCurrentSolution\(ProjectId projectId\);
* &emsp; \| &emsp; protected void CheckSolutionIsEmpty\(\);
* &emsp; \| &emsp; protected virtual void ClearDocumentData\(DocumentId documentId\);
* &emsp; \| &emsp; protected void ClearOpenDocument\(DocumentId documentId, bool isSolutionClosing = false\);
* &emsp; \| &emsp; protected virtual void ClearProjectData\(ProjectId projectId\);
* &emsp; \| &emsp; protected void ClearSolution\(\);
* &emsp; \| &emsp; protected virtual void ClearSolutionData\(\);
* &emsp; \| &emsp; public virtual void CloseAdditionalDocument\(DocumentId documentId\);
* &emsp; \| &emsp; public virtual void CloseDocument\(DocumentId documentId\);
* &emsp; \| &emsp; protected internal Solution CreateSolution\(SolutionId id\);
* &emsp; \| &emsp; protected internal Solution CreateSolution\(SolutionInfo solutionInfo\);
* &emsp; \| &emsp; public void Dispose\(\);
* &emsp; \| &emsp; protected virtual void Dispose\(bool finalize\);
* &emsp; \| &emsp; protected virtual string GetAdditionalDocumentName\(DocumentId documentId\);
* &emsp; \| &emsp; public virtual DocumentId GetDocumentIdInCurrentContext\(SourceTextContainer container\);
* &emsp; \| &emsp; protected virtual string GetDocumentName\(DocumentId documentId\);
* &emsp; \| &emsp; public virtual IEnumerable\<DocumentId> GetOpenDocumentIds\(ProjectId projectId = null\);
* &emsp; \| &emsp; protected virtual string GetProjectName\(ProjectId projectId\);
* &emsp; \| &emsp; public virtual IEnumerable\<DocumentId> GetRelatedDocumentIds\(SourceTextContainer container\);
* &emsp; \| &emsp; public static WorkspaceRegistration GetWorkspaceRegistration\(SourceTextContainer textContainer\);
* &emsp; \| &emsp; public virtual bool IsDocumentOpen\(DocumentId documentId\);
* &emsp; \| &emsp; protected internal void OnAdditionalDocumentAdded\(DocumentInfo documentInfo\);
* &emsp; \| &emsp; protected internal void OnAdditionalDocumentClosed\(DocumentId documentId, TextLoader reloader\);
* &emsp; \| &emsp; protected internal void OnAdditionalDocumentOpened\(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext = true\);
* &emsp; \| &emsp; protected internal void OnAdditionalDocumentRemoved\(DocumentId documentId\);
* &emsp; \| &emsp; protected internal void OnAdditionalDocumentTextChanged\(DocumentId documentId, SourceText newText, PreservationMode mode\);
* &emsp; \| &emsp; protected internal void OnAdditionalDocumentTextLoaderChanged\(DocumentId documentId, TextLoader loader\);
* &emsp; \| &emsp; protected internal void OnAnalyzerReferenceAdded\(ProjectId projectId, AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; protected internal void OnAnalyzerReferenceRemoved\(ProjectId projectId, AnalyzerReference analyzerReference\);
* &emsp; \| &emsp; protected internal void OnAssemblyNameChanged\(ProjectId projectId, string assemblyName\);
* &emsp; \| &emsp; protected internal void OnCompilationOptionsChanged\(ProjectId projectId, CompilationOptions options\);
* &emsp; \| &emsp; protected internal void OnDocumentAdded\(DocumentInfo documentInfo\);
* &emsp; \| &emsp; protected internal void OnDocumentClosed\(DocumentId documentId, TextLoader reloader, bool updateActiveContext = false\);
* &emsp; \| &emsp; protected virtual void OnDocumentClosing\(DocumentId documentId\);
* &emsp; \| &emsp; protected void OnDocumentContextUpdated\(DocumentId documentId\);
* &emsp; \| &emsp; protected internal void OnDocumentInfoChanged\(DocumentId documentId, DocumentInfo newInfo\);
* &emsp; \| &emsp; protected internal void OnDocumentOpened\(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext = true\);
* &emsp; \| &emsp; protected internal void OnDocumentReloaded\(DocumentInfo newDocumentInfo\);
* &emsp; \| &emsp; protected internal void OnDocumentRemoved\(DocumentId documentId\);
* &emsp; \| &emsp; protected internal void OnDocumentSourceCodeKindChanged\(DocumentId documentId, SourceCodeKind sourceCodeKind\);
* &emsp; \| &emsp; protected virtual void OnDocumentTextChanged\(Document document\);
* &emsp; \| &emsp; protected internal void OnDocumentTextChanged\(DocumentId documentId, SourceText newText, PreservationMode mode\);
* &emsp; \| &emsp; protected internal void OnDocumentTextLoaderChanged\(DocumentId documentId, TextLoader loader\);
* &emsp; \| &emsp; protected internal void OnMetadataReferenceAdded\(ProjectId projectId, MetadataReference metadataReference\);
* &emsp; \| &emsp; protected internal void OnMetadataReferenceRemoved\(ProjectId projectId, MetadataReference metadataReference\);
* &emsp; \| &emsp; protected internal void OnOutputFilePathChanged\(ProjectId projectId, string outputFilePath\);
* &emsp; \| &emsp; protected internal void OnParseOptionsChanged\(ProjectId projectId, ParseOptions options\);
* &emsp; \| &emsp; protected internal void OnProjectAdded\(ProjectInfo projectInfo\);
* &emsp; \| &emsp; protected internal void OnProjectNameChanged\(ProjectId projectId, string name, string filePath\);
* &emsp; \| &emsp; protected internal void OnProjectReferenceAdded\(ProjectId projectId, ProjectReference projectReference\);
* &emsp; \| &emsp; protected internal void OnProjectReferenceRemoved\(ProjectId projectId, ProjectReference projectReference\);
* &emsp; \| &emsp; protected internal virtual void OnProjectReloaded\(ProjectInfo reloadedProjectInfo\);
* &emsp; \| &emsp; protected internal virtual void OnProjectRemoved\(ProjectId projectId\);
* &emsp; \| &emsp; protected internal void OnSolutionAdded\(SolutionInfo solutionInfo\);
* &emsp; \| &emsp; protected internal void OnSolutionReloaded\(SolutionInfo reloadedSolutionInfo\);
* &emsp; \| &emsp; protected internal void OnSolutionRemoved\(\);
* &emsp; \| &emsp; protected internal virtual void OnWorkspaceFailed\(WorkspaceDiagnostic diagnostic\);
* &emsp; \| &emsp; public virtual void OpenAdditionalDocument\(DocumentId documentId, bool activate = true\);
* &emsp; \| &emsp; public virtual void OpenDocument\(DocumentId documentId, bool activate = true\);
* &emsp; \| &emsp; protected Task RaiseDocumentActiveContextChangedEventAsync\(Document document\);
* &emsp; \| &emsp; protected Task RaiseDocumentActiveContextChangedEventAsync\(SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId\);
* &emsp; \| &emsp; protected Task RaiseDocumentClosedEventAsync\(Document document\);
* &emsp; \| &emsp; protected Task RaiseDocumentOpenedEventAsync\(Document document\);
* &emsp; \| &emsp; protected Task RaiseWorkspaceChangedEventAsync\(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId = null, DocumentId documentId = null\);
* &emsp; \| &emsp; protected void RegisterText\(SourceTextContainer textContainer\);
* &emsp; \| &emsp; protected internal Task ScheduleTask\(Action action, string taskName = "Workspace\.Task"\);
* &emsp; \| &emsp; protected internal Task\<T> ScheduleTask\<T>\(Func\<T> func, string taskName = "Workspace\.Task"\);
* &emsp; \| &emsp; protected Solution SetCurrentSolution\(Solution solution\);
* &emsp; \| &emsp; public virtual bool TryApplyChanges\(Solution newSolution\);
* &emsp; \| &emsp; public static bool TryGetWorkspace\(SourceTextContainer textContainer, out Workspace workspace\);
* &emsp; \| &emsp; protected void UnregisterText\(SourceTextContainer textContainer\);
* &emsp; \| &emsp; protected void UpdateReferencesAfterAdd\(\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.AdhocWorkspace : Workspace
* &emsp; \| &emsp; \| &emsp; public AdhocWorkspace\(\);
* &emsp; \| &emsp; \| &emsp; public AdhocWorkspace\(HostServices host, string workspaceKind = "Custom"\);
* &emsp; \| &emsp; \| &emsp; public override bool CanOpenDocuments \{ get; \}
* &emsp; \| &emsp; \| &emsp; public Document AddDocument\(DocumentInfo documentInfo\);
* &emsp; \| &emsp; \| &emsp; public Document AddDocument\(ProjectId projectId, string name, SourceText text\);
* &emsp; \| &emsp; \| &emsp; public Project AddProject\(ProjectInfo projectInfo\);
* &emsp; \| &emsp; \| &emsp; public Project AddProject\(string name, string language\);
* &emsp; \| &emsp; \| &emsp; public void AddProjects\(IEnumerable\<ProjectInfo> projectInfos\);
* &emsp; \| &emsp; \| &emsp; public Solution AddSolution\(SolutionInfo solutionInfo\);
* &emsp; \| &emsp; \| &emsp; public override bool CanApplyChange\(ApplyChangesKind feature\);
* &emsp; \| &emsp; \| &emsp; public void ClearSolution\(\);
* &emsp; \| &emsp; \| &emsp; public override void CloseAdditionalDocument\(DocumentId documentId\);
* &emsp; \| &emsp; \| &emsp; public override void CloseDocument\(DocumentId documentId\);
* &emsp; \| &emsp; \| &emsp; public override void OpenAdditionalDocument\(DocumentId documentId, bool activate = true\);
* &emsp; \| &emsp; \| &emsp; public override void OpenDocument\(DocumentId documentId, bool activate = true\);
* &emsp; public class Microsoft\.CodeAnalysis\.WorkspaceDiagnostic
* &emsp; \| &emsp; public WorkspaceDiagnostic\(WorkspaceDiagnosticKind kind, string message\);
* &emsp; \| &emsp; public WorkspaceDiagnosticKind Kind \{ get; \}
* &emsp; \| &emsp; public string Message \{ get; \}
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.DocumentDiagnostic : WorkspaceDiagnostic
* &emsp; \| &emsp; \| &emsp; public DocumentDiagnostic\(WorkspaceDiagnosticKind kind, string message, DocumentId documentId\);
* &emsp; \| &emsp; \| &emsp; public DocumentId DocumentId \{ get; \}
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.ProjectDiagnostic : WorkspaceDiagnostic
* &emsp; \| &emsp; \| &emsp; public ProjectDiagnostic\(WorkspaceDiagnosticKind kind, string message, ProjectId projectId\);
* &emsp; \| &emsp; \| &emsp; public ProjectId ProjectId \{ get; \}
* &emsp; public sealed class Microsoft\.CodeAnalysis\.WorkspaceRegistration
* &emsp; \| &emsp; public event EventHandler WorkspaceChanged;
* &emsp; \| &emsp; public Workspace Workspace \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.XmlReferenceResolver
* &emsp; \| &emsp; protected XmlReferenceResolver\(\);
* &emsp; \| &emsp; public override abstract bool Equals\(object other\);
* &emsp; \| &emsp; public override abstract int GetHashCode\(\);
* &emsp; \| &emsp; public abstract Stream OpenRead\(string resolvedPath\);
* &emsp; \| &emsp; public abstract string ResolveReference\(string path, string baseFilePath\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.XmlFileResolver : XmlReferenceResolver
* &emsp; \| &emsp; \| &emsp; public XmlFileResolver\(string baseDirectory\);
* &emsp; \| &emsp; \| &emsp; public string BaseDirectory \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static XmlFileResolver Default \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; protected virtual bool FileExists\(string resolvedPath\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; \| &emsp; public override Stream OpenRead\(string resolvedPath\);
* &emsp; \| &emsp; \| &emsp; public override string ResolveReference\(string path, string baseFilePath\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.CSharpSyntaxVisitor
* &emsp; \| &emsp; protected CSharpSyntaxVisitor\(\);
* &emsp; \| &emsp; public virtual void DefaultVisit\(SyntaxNode node\);
* &emsp; \| &emsp; public virtual void Visit\(SyntaxNode node\);
* &emsp; \| &emsp; public virtual void VisitAccessorDeclaration\(AccessorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAccessorList\(AccessorListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAliasQualifiedName\(AliasQualifiedNameSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAnonymousMethodExpression\(AnonymousMethodExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAnonymousObjectCreationExpression\(AnonymousObjectCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAnonymousObjectMemberDeclarator\(AnonymousObjectMemberDeclaratorSyntax node\);
* &emsp; \| &emsp; public virtual void VisitArgument\(ArgumentSyntax node\);
* &emsp; \| &emsp; public virtual void VisitArgumentList\(ArgumentListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitArrayCreationExpression\(ArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitArrayRankSpecifier\(ArrayRankSpecifierSyntax node\);
* &emsp; \| &emsp; public virtual void VisitArrayType\(ArrayTypeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitArrowExpressionClause\(ArrowExpressionClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAssignmentExpression\(AssignmentExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAttribute\(AttributeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAttributeArgument\(AttributeArgumentSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAttributeArgumentList\(AttributeArgumentListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAttributeList\(AttributeListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAttributeTargetSpecifier\(AttributeTargetSpecifierSyntax node\);
* &emsp; \| &emsp; public virtual void VisitAwaitExpression\(AwaitExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitBadDirectiveTrivia\(BadDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitBaseExpression\(BaseExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitBaseList\(BaseListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitBinaryExpression\(BinaryExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitBlock\(BlockSyntax node\);
* &emsp; \| &emsp; public virtual void VisitBracketedArgumentList\(BracketedArgumentListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitBracketedParameterList\(BracketedParameterListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitBreakStatement\(BreakStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCasePatternSwitchLabel\(CasePatternSwitchLabelSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCaseSwitchLabel\(CaseSwitchLabelSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCastExpression\(CastExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCatchClause\(CatchClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCatchDeclaration\(CatchDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCatchFilterClause\(CatchFilterClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCheckedExpression\(CheckedExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCheckedStatement\(CheckedStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitClassDeclaration\(ClassDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitClassOrStructConstraint\(ClassOrStructConstraintSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCompilationUnit\(CompilationUnitSyntax node\);
* &emsp; \| &emsp; public virtual void VisitConditionalAccessExpression\(ConditionalAccessExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitConditionalExpression\(ConditionalExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitConstantPattern\(ConstantPatternSyntax node\);
* &emsp; \| &emsp; public virtual void VisitConstructorConstraint\(ConstructorConstraintSyntax node\);
* &emsp; \| &emsp; public virtual void VisitConstructorDeclaration\(ConstructorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitConstructorInitializer\(ConstructorInitializerSyntax node\);
* &emsp; \| &emsp; public virtual void VisitContinueStatement\(ContinueStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitConversionOperatorDeclaration\(ConversionOperatorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitConversionOperatorMemberCref\(ConversionOperatorMemberCrefSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCrefBracketedParameterList\(CrefBracketedParameterListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCrefParameter\(CrefParameterSyntax node\);
* &emsp; \| &emsp; public virtual void VisitCrefParameterList\(CrefParameterListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDeclarationExpression\(DeclarationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDeclarationPattern\(DeclarationPatternSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDefaultExpression\(DefaultExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDefaultSwitchLabel\(DefaultSwitchLabelSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDefineDirectiveTrivia\(DefineDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDelegateDeclaration\(DelegateDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDestructorDeclaration\(DestructorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDiscardDesignation\(DiscardDesignationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDoStatement\(DoStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitDocumentationCommentTrivia\(DocumentationCommentTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitElementAccessExpression\(ElementAccessExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitElementBindingExpression\(ElementBindingExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitElifDirectiveTrivia\(ElifDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitElseClause\(ElseClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitElseDirectiveTrivia\(ElseDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitEmptyStatement\(EmptyStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitEndIfDirectiveTrivia\(EndIfDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitEndRegionDirectiveTrivia\(EndRegionDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitEnumDeclaration\(EnumDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitEnumMemberDeclaration\(EnumMemberDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitEqualsValueClause\(EqualsValueClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitErrorDirectiveTrivia\(ErrorDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitEventDeclaration\(EventDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitEventFieldDeclaration\(EventFieldDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitExplicitInterfaceSpecifier\(ExplicitInterfaceSpecifierSyntax node\);
* &emsp; \| &emsp; public virtual void VisitExpressionStatement\(ExpressionStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitExternAliasDirective\(ExternAliasDirectiveSyntax node\);
* &emsp; \| &emsp; public virtual void VisitFieldDeclaration\(FieldDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitFinallyClause\(FinallyClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitFixedStatement\(FixedStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitForEachStatement\(ForEachStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitForEachVariableStatement\(ForEachVariableStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitForStatement\(ForStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitFromClause\(FromClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitGenericName\(GenericNameSyntax node\);
* &emsp; \| &emsp; public virtual void VisitGlobalStatement\(GlobalStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitGotoStatement\(GotoStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitGroupClause\(GroupClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitIdentifierName\(IdentifierNameSyntax node\);
* &emsp; \| &emsp; public virtual void VisitIfDirectiveTrivia\(IfDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitIfStatement\(IfStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitImplicitArrayCreationExpression\(ImplicitArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitImplicitElementAccess\(ImplicitElementAccessSyntax node\);
* &emsp; \| &emsp; public virtual void VisitIncompleteMember\(IncompleteMemberSyntax node\);
* &emsp; \| &emsp; public virtual void VisitIndexerDeclaration\(IndexerDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitIndexerMemberCref\(IndexerMemberCrefSyntax node\);
* &emsp; \| &emsp; public virtual void VisitInitializerExpression\(InitializerExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitInterfaceDeclaration\(InterfaceDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitInterpolatedStringExpression\(InterpolatedStringExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitInterpolatedStringText\(InterpolatedStringTextSyntax node\);
* &emsp; \| &emsp; public virtual void VisitInterpolation\(InterpolationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitInterpolationAlignmentClause\(InterpolationAlignmentClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitInterpolationFormatClause\(InterpolationFormatClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitInvocationExpression\(InvocationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitIsPatternExpression\(IsPatternExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitJoinClause\(JoinClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitJoinIntoClause\(JoinIntoClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitLabeledStatement\(LabeledStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitLetClause\(LetClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitLineDirectiveTrivia\(LineDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitLiteralExpression\(LiteralExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitLoadDirectiveTrivia\(LoadDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitLocalDeclarationStatement\(LocalDeclarationStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitLocalFunctionStatement\(LocalFunctionStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitLockStatement\(LockStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitMakeRefExpression\(MakeRefExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitMemberAccessExpression\(MemberAccessExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitMemberBindingExpression\(MemberBindingExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitMethodDeclaration\(MethodDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitNameColon\(NameColonSyntax node\);
* &emsp; \| &emsp; public virtual void VisitNameEquals\(NameEqualsSyntax node\);
* &emsp; \| &emsp; public virtual void VisitNameMemberCref\(NameMemberCrefSyntax node\);
* &emsp; \| &emsp; public virtual void VisitNamespaceDeclaration\(NamespaceDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitNullableType\(NullableTypeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitObjectCreationExpression\(ObjectCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitOmittedArraySizeExpression\(OmittedArraySizeExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitOmittedTypeArgument\(OmittedTypeArgumentSyntax node\);
* &emsp; \| &emsp; public virtual void VisitOperatorDeclaration\(OperatorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitOperatorMemberCref\(OperatorMemberCrefSyntax node\);
* &emsp; \| &emsp; public virtual void VisitOrderByClause\(OrderByClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitOrdering\(OrderingSyntax node\);
* &emsp; \| &emsp; public virtual void VisitParameter\(ParameterSyntax node\);
* &emsp; \| &emsp; public virtual void VisitParameterList\(ParameterListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitParenthesizedExpression\(ParenthesizedExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitParenthesizedLambdaExpression\(ParenthesizedLambdaExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitParenthesizedVariableDesignation\(ParenthesizedVariableDesignationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitPointerType\(PointerTypeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitPostfixUnaryExpression\(PostfixUnaryExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitPragmaChecksumDirectiveTrivia\(PragmaChecksumDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitPragmaWarningDirectiveTrivia\(PragmaWarningDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitPredefinedType\(PredefinedTypeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitPrefixUnaryExpression\(PrefixUnaryExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitPropertyDeclaration\(PropertyDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitQualifiedCref\(QualifiedCrefSyntax node\);
* &emsp; \| &emsp; public virtual void VisitQualifiedName\(QualifiedNameSyntax node\);
* &emsp; \| &emsp; public virtual void VisitQueryBody\(QueryBodySyntax node\);
* &emsp; \| &emsp; public virtual void VisitQueryContinuation\(QueryContinuationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitQueryExpression\(QueryExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitRefExpression\(RefExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitRefType\(RefTypeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitRefTypeExpression\(RefTypeExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitRefValueExpression\(RefValueExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitReferenceDirectiveTrivia\(ReferenceDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitRegionDirectiveTrivia\(RegionDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitReturnStatement\(ReturnStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitSelectClause\(SelectClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitShebangDirectiveTrivia\(ShebangDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitSimpleBaseType\(SimpleBaseTypeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitSimpleLambdaExpression\(SimpleLambdaExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitSingleVariableDesignation\(SingleVariableDesignationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitSizeOfExpression\(SizeOfExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitSkippedTokensTrivia\(SkippedTokensTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitStackAllocArrayCreationExpression\(StackAllocArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitStructDeclaration\(StructDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitSwitchSection\(SwitchSectionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitSwitchStatement\(SwitchStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitThisExpression\(ThisExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitThrowExpression\(ThrowExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitThrowStatement\(ThrowStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTryStatement\(TryStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTupleElement\(TupleElementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTupleExpression\(TupleExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTupleType\(TupleTypeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTypeArgumentList\(TypeArgumentListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTypeConstraint\(TypeConstraintSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTypeCref\(TypeCrefSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTypeOfExpression\(TypeOfExpressionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTypeParameter\(TypeParameterSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTypeParameterConstraintClause\(TypeParameterConstraintClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitTypeParameterList\(TypeParameterListSyntax node\);
* &emsp; \| &emsp; public virtual void VisitUndefDirectiveTrivia\(UndefDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitUnsafeStatement\(UnsafeStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitUsingDirective\(UsingDirectiveSyntax node\);
* &emsp; \| &emsp; public virtual void VisitUsingStatement\(UsingStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitVariableDeclaration\(VariableDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual void VisitVariableDeclarator\(VariableDeclaratorSyntax node\);
* &emsp; \| &emsp; public virtual void VisitWarningDirectiveTrivia\(WarningDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual void VisitWhenClause\(WhenClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitWhereClause\(WhereClauseSyntax node\);
* &emsp; \| &emsp; public virtual void VisitWhileStatement\(WhileStatementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlCDataSection\(XmlCDataSectionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlComment\(XmlCommentSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlCrefAttribute\(XmlCrefAttributeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlElement\(XmlElementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlElementEndTag\(XmlElementEndTagSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlElementStartTag\(XmlElementStartTagSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlEmptyElement\(XmlEmptyElementSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlName\(XmlNameSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlNameAttribute\(XmlNameAttributeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlPrefix\(XmlPrefixSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlProcessingInstruction\(XmlProcessingInstructionSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlText\(XmlTextSyntax node\);
* &emsp; \| &emsp; public virtual void VisitXmlTextAttribute\(XmlTextAttributeSyntax node\);
* &emsp; \| &emsp; public virtual void VisitYieldStatement\(YieldStatementSyntax node\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.CSharpSyntaxWalker : CSharpSyntaxVisitor
* &emsp; \| &emsp; \| &emsp; protected CSharpSyntaxWalker\(SyntaxWalkerDepth depth = Node\);
* &emsp; \| &emsp; \| &emsp; protected SyntaxWalkerDepth Depth \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override void DefaultVisit\(SyntaxNode node\);
* &emsp; \| &emsp; \| &emsp; public override void Visit\(SyntaxNode node\);
* &emsp; \| &emsp; \| &emsp; public virtual void VisitLeadingTrivia\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public virtual void VisitToken\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public virtual void VisitTrailingTrivia\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public virtual void VisitTrivia\(SyntaxTrivia trivia\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.CSharpSyntaxVisitor\<TResult>
* &emsp; \| &emsp; protected CSharpSyntaxVisitor\(\);
* &emsp; \| &emsp; public virtual TResult DefaultVisit\(SyntaxNode node\);
* &emsp; \| &emsp; public virtual TResult Visit\(SyntaxNode node\);
* &emsp; \| &emsp; public virtual TResult VisitAccessorDeclaration\(AccessorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAccessorList\(AccessorListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAliasQualifiedName\(AliasQualifiedNameSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAnonymousMethodExpression\(AnonymousMethodExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAnonymousObjectCreationExpression\(AnonymousObjectCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAnonymousObjectMemberDeclarator\(AnonymousObjectMemberDeclaratorSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitArgument\(ArgumentSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitArgumentList\(ArgumentListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitArrayCreationExpression\(ArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitArrayRankSpecifier\(ArrayRankSpecifierSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitArrayType\(ArrayTypeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitArrowExpressionClause\(ArrowExpressionClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAssignmentExpression\(AssignmentExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAttribute\(AttributeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAttributeArgument\(AttributeArgumentSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAttributeArgumentList\(AttributeArgumentListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAttributeList\(AttributeListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAttributeTargetSpecifier\(AttributeTargetSpecifierSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitAwaitExpression\(AwaitExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitBadDirectiveTrivia\(BadDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitBaseExpression\(BaseExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitBaseList\(BaseListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitBinaryExpression\(BinaryExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitBlock\(BlockSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitBracketedArgumentList\(BracketedArgumentListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitBracketedParameterList\(BracketedParameterListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitBreakStatement\(BreakStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCasePatternSwitchLabel\(CasePatternSwitchLabelSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCaseSwitchLabel\(CaseSwitchLabelSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCastExpression\(CastExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCatchClause\(CatchClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCatchDeclaration\(CatchDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCatchFilterClause\(CatchFilterClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCheckedExpression\(CheckedExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCheckedStatement\(CheckedStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitClassDeclaration\(ClassDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitClassOrStructConstraint\(ClassOrStructConstraintSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCompilationUnit\(CompilationUnitSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitConditionalAccessExpression\(ConditionalAccessExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitConditionalExpression\(ConditionalExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitConstantPattern\(ConstantPatternSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitConstructorConstraint\(ConstructorConstraintSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitConstructorDeclaration\(ConstructorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitConstructorInitializer\(ConstructorInitializerSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitContinueStatement\(ContinueStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitConversionOperatorDeclaration\(ConversionOperatorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitConversionOperatorMemberCref\(ConversionOperatorMemberCrefSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCrefBracketedParameterList\(CrefBracketedParameterListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCrefParameter\(CrefParameterSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitCrefParameterList\(CrefParameterListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDeclarationExpression\(DeclarationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDeclarationPattern\(DeclarationPatternSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDefaultExpression\(DefaultExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDefaultSwitchLabel\(DefaultSwitchLabelSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDefineDirectiveTrivia\(DefineDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDelegateDeclaration\(DelegateDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDestructorDeclaration\(DestructorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDiscardDesignation\(DiscardDesignationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDoStatement\(DoStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitDocumentationCommentTrivia\(DocumentationCommentTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitElementAccessExpression\(ElementAccessExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitElementBindingExpression\(ElementBindingExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitElifDirectiveTrivia\(ElifDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitElseClause\(ElseClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitElseDirectiveTrivia\(ElseDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitEmptyStatement\(EmptyStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitEndIfDirectiveTrivia\(EndIfDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitEndRegionDirectiveTrivia\(EndRegionDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitEnumDeclaration\(EnumDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitEnumMemberDeclaration\(EnumMemberDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitEqualsValueClause\(EqualsValueClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitErrorDirectiveTrivia\(ErrorDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitEventDeclaration\(EventDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitEventFieldDeclaration\(EventFieldDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitExplicitInterfaceSpecifier\(ExplicitInterfaceSpecifierSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitExpressionStatement\(ExpressionStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitExternAliasDirective\(ExternAliasDirectiveSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitFieldDeclaration\(FieldDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitFinallyClause\(FinallyClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitFixedStatement\(FixedStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitForEachStatement\(ForEachStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitForEachVariableStatement\(ForEachVariableStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitForStatement\(ForStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitFromClause\(FromClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitGenericName\(GenericNameSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitGlobalStatement\(GlobalStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitGotoStatement\(GotoStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitGroupClause\(GroupClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitIdentifierName\(IdentifierNameSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitIfDirectiveTrivia\(IfDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitIfStatement\(IfStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitImplicitArrayCreationExpression\(ImplicitArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitImplicitElementAccess\(ImplicitElementAccessSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitIncompleteMember\(IncompleteMemberSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitIndexerDeclaration\(IndexerDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitIndexerMemberCref\(IndexerMemberCrefSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitInitializerExpression\(InitializerExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitInterfaceDeclaration\(InterfaceDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitInterpolatedStringExpression\(InterpolatedStringExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitInterpolatedStringText\(InterpolatedStringTextSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitInterpolation\(InterpolationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitInterpolationAlignmentClause\(InterpolationAlignmentClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitInterpolationFormatClause\(InterpolationFormatClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitInvocationExpression\(InvocationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitIsPatternExpression\(IsPatternExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitJoinClause\(JoinClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitJoinIntoClause\(JoinIntoClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitLabeledStatement\(LabeledStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitLetClause\(LetClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitLineDirectiveTrivia\(LineDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitLiteralExpression\(LiteralExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitLoadDirectiveTrivia\(LoadDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitLocalDeclarationStatement\(LocalDeclarationStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitLocalFunctionStatement\(LocalFunctionStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitLockStatement\(LockStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitMakeRefExpression\(MakeRefExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitMemberAccessExpression\(MemberAccessExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitMemberBindingExpression\(MemberBindingExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitMethodDeclaration\(MethodDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitNameColon\(NameColonSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitNameEquals\(NameEqualsSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitNameMemberCref\(NameMemberCrefSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitNamespaceDeclaration\(NamespaceDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitNullableType\(NullableTypeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitObjectCreationExpression\(ObjectCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitOmittedArraySizeExpression\(OmittedArraySizeExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitOmittedTypeArgument\(OmittedTypeArgumentSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitOperatorDeclaration\(OperatorDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitOperatorMemberCref\(OperatorMemberCrefSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitOrderByClause\(OrderByClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitOrdering\(OrderingSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitParameter\(ParameterSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitParameterList\(ParameterListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitParenthesizedExpression\(ParenthesizedExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitParenthesizedLambdaExpression\(ParenthesizedLambdaExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitParenthesizedVariableDesignation\(ParenthesizedVariableDesignationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitPointerType\(PointerTypeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitPostfixUnaryExpression\(PostfixUnaryExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitPragmaChecksumDirectiveTrivia\(PragmaChecksumDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitPragmaWarningDirectiveTrivia\(PragmaWarningDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitPredefinedType\(PredefinedTypeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitPrefixUnaryExpression\(PrefixUnaryExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitPropertyDeclaration\(PropertyDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitQualifiedCref\(QualifiedCrefSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitQualifiedName\(QualifiedNameSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitQueryBody\(QueryBodySyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitQueryContinuation\(QueryContinuationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitQueryExpression\(QueryExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitRefExpression\(RefExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitRefType\(RefTypeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitRefTypeExpression\(RefTypeExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitRefValueExpression\(RefValueExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitReferenceDirectiveTrivia\(ReferenceDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitRegionDirectiveTrivia\(RegionDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitReturnStatement\(ReturnStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitSelectClause\(SelectClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitShebangDirectiveTrivia\(ShebangDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitSimpleBaseType\(SimpleBaseTypeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitSimpleLambdaExpression\(SimpleLambdaExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitSingleVariableDesignation\(SingleVariableDesignationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitSizeOfExpression\(SizeOfExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitSkippedTokensTrivia\(SkippedTokensTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitStackAllocArrayCreationExpression\(StackAllocArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitStructDeclaration\(StructDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitSwitchSection\(SwitchSectionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitSwitchStatement\(SwitchStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitThisExpression\(ThisExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitThrowExpression\(ThrowExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitThrowStatement\(ThrowStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTryStatement\(TryStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTupleElement\(TupleElementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTupleExpression\(TupleExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTupleType\(TupleTypeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTypeArgumentList\(TypeArgumentListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTypeConstraint\(TypeConstraintSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTypeCref\(TypeCrefSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTypeOfExpression\(TypeOfExpressionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTypeParameter\(TypeParameterSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTypeParameterConstraintClause\(TypeParameterConstraintClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitTypeParameterList\(TypeParameterListSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitUndefDirectiveTrivia\(UndefDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitUnsafeStatement\(UnsafeStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitUsingDirective\(UsingDirectiveSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitUsingStatement\(UsingStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitVariableDeclaration\(VariableDeclarationSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitVariableDeclarator\(VariableDeclaratorSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitWarningDirectiveTrivia\(WarningDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitWhenClause\(WhenClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitWhereClause\(WhereClauseSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitWhileStatement\(WhileStatementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlCDataSection\(XmlCDataSectionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlComment\(XmlCommentSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlCrefAttribute\(XmlCrefAttributeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlElement\(XmlElementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlElementEndTag\(XmlElementEndTagSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlElementStartTag\(XmlElementStartTagSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlEmptyElement\(XmlEmptyElementSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlName\(XmlNameSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlNameAttribute\(XmlNameAttributeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlPrefix\(XmlPrefixSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlProcessingInstruction\(XmlProcessingInstructionSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlText\(XmlTextSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitXmlTextAttribute\(XmlTextAttributeSyntax node\);
* &emsp; \| &emsp; public virtual TResult VisitYieldStatement\(YieldStatementSyntax node\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CSharp\.CSharpSyntaxRewriter : CSharpSyntaxVisitor\<SyntaxNode>
* &emsp; \| &emsp; \| &emsp; public CSharpSyntaxRewriter\(bool visitIntoStructuredTrivia = false\);
* &emsp; \| &emsp; \| &emsp; public virtual bool VisitIntoStructuredTrivia \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode Visit\(SyntaxNode node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAccessorDeclaration\(AccessorDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAccessorList\(AccessorListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAliasQualifiedName\(AliasQualifiedNameSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAnonymousMethodExpression\(AnonymousMethodExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAnonymousObjectCreationExpression\(AnonymousObjectCreationExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAnonymousObjectMemberDeclarator\(AnonymousObjectMemberDeclaratorSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitArgument\(ArgumentSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitArgumentList\(ArgumentListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitArrayCreationExpression\(ArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitArrayRankSpecifier\(ArrayRankSpecifierSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitArrayType\(ArrayTypeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitArrowExpressionClause\(ArrowExpressionClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAssignmentExpression\(AssignmentExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAttribute\(AttributeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAttributeArgument\(AttributeArgumentSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAttributeArgumentList\(AttributeArgumentListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAttributeList\(AttributeListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAttributeTargetSpecifier\(AttributeTargetSpecifierSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitAwaitExpression\(AwaitExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitBadDirectiveTrivia\(BadDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitBaseExpression\(BaseExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitBaseList\(BaseListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitBinaryExpression\(BinaryExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitBlock\(BlockSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitBracketedArgumentList\(BracketedArgumentListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitBracketedParameterList\(BracketedParameterListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitBreakStatement\(BreakStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCasePatternSwitchLabel\(CasePatternSwitchLabelSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCaseSwitchLabel\(CaseSwitchLabelSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCastExpression\(CastExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCatchClause\(CatchClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCatchDeclaration\(CatchDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCatchFilterClause\(CatchFilterClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCheckedExpression\(CheckedExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCheckedStatement\(CheckedStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitClassDeclaration\(ClassDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitClassOrStructConstraint\(ClassOrStructConstraintSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCompilationUnit\(CompilationUnitSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitConditionalAccessExpression\(ConditionalAccessExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitConditionalExpression\(ConditionalExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitConstantPattern\(ConstantPatternSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitConstructorConstraint\(ConstructorConstraintSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitConstructorDeclaration\(ConstructorDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitConstructorInitializer\(ConstructorInitializerSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitContinueStatement\(ContinueStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitConversionOperatorDeclaration\(ConversionOperatorDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitConversionOperatorMemberCref\(ConversionOperatorMemberCrefSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCrefBracketedParameterList\(CrefBracketedParameterListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCrefParameter\(CrefParameterSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitCrefParameterList\(CrefParameterListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDeclarationExpression\(DeclarationExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDeclarationPattern\(DeclarationPatternSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDefaultExpression\(DefaultExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDefaultSwitchLabel\(DefaultSwitchLabelSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDefineDirectiveTrivia\(DefineDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDelegateDeclaration\(DelegateDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDestructorDeclaration\(DestructorDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDiscardDesignation\(DiscardDesignationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDoStatement\(DoStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitDocumentationCommentTrivia\(DocumentationCommentTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitElementAccessExpression\(ElementAccessExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitElementBindingExpression\(ElementBindingExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitElifDirectiveTrivia\(ElifDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitElseClause\(ElseClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitElseDirectiveTrivia\(ElseDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitEmptyStatement\(EmptyStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitEndIfDirectiveTrivia\(EndIfDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitEndRegionDirectiveTrivia\(EndRegionDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitEnumDeclaration\(EnumDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitEnumMemberDeclaration\(EnumMemberDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitEqualsValueClause\(EqualsValueClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitErrorDirectiveTrivia\(ErrorDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitEventDeclaration\(EventDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitEventFieldDeclaration\(EventFieldDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitExplicitInterfaceSpecifier\(ExplicitInterfaceSpecifierSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitExpressionStatement\(ExpressionStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitExternAliasDirective\(ExternAliasDirectiveSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitFieldDeclaration\(FieldDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitFinallyClause\(FinallyClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitFixedStatement\(FixedStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitForEachStatement\(ForEachStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitForEachVariableStatement\(ForEachVariableStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitForStatement\(ForStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitFromClause\(FromClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitGenericName\(GenericNameSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitGlobalStatement\(GlobalStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitGotoStatement\(GotoStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitGroupClause\(GroupClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitIdentifierName\(IdentifierNameSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitIfDirectiveTrivia\(IfDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitIfStatement\(IfStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitImplicitArrayCreationExpression\(ImplicitArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitImplicitElementAccess\(ImplicitElementAccessSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitIncompleteMember\(IncompleteMemberSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitIndexerDeclaration\(IndexerDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitIndexerMemberCref\(IndexerMemberCrefSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitInitializerExpression\(InitializerExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitInterfaceDeclaration\(InterfaceDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitInterpolatedStringExpression\(InterpolatedStringExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitInterpolatedStringText\(InterpolatedStringTextSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitInterpolation\(InterpolationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitInterpolationAlignmentClause\(InterpolationAlignmentClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitInterpolationFormatClause\(InterpolationFormatClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitInvocationExpression\(InvocationExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitIsPatternExpression\(IsPatternExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitJoinClause\(JoinClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitJoinIntoClause\(JoinIntoClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitLabeledStatement\(LabeledStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitLetClause\(LetClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitLineDirectiveTrivia\(LineDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public virtual SyntaxTokenList VisitList\(SyntaxTokenList list\);
* &emsp; \| &emsp; \| &emsp; public virtual SyntaxTriviaList VisitList\(SyntaxTriviaList list\);
* &emsp; \| &emsp; \| &emsp; public virtual SyntaxList\<TNode> VisitList\<TNode>\(SyntaxList\<TNode> list\) where TNode : SyntaxNode;
* &emsp; \| &emsp; \| &emsp; public virtual SeparatedSyntaxList\<TNode> VisitList\<TNode>\(SeparatedSyntaxList\<TNode> list\) where TNode : SyntaxNode;
* &emsp; \| &emsp; \| &emsp; public virtual SyntaxTrivia VisitListElement\(SyntaxTrivia element\);
* &emsp; \| &emsp; \| &emsp; public virtual TNode VisitListElement\<TNode>\(TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; \| &emsp; public virtual SyntaxToken VisitListSeparator\(SyntaxToken separator\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitLiteralExpression\(LiteralExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitLoadDirectiveTrivia\(LoadDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitLocalDeclarationStatement\(LocalDeclarationStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitLocalFunctionStatement\(LocalFunctionStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitLockStatement\(LockStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitMakeRefExpression\(MakeRefExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitMemberAccessExpression\(MemberAccessExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitMemberBindingExpression\(MemberBindingExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitMethodDeclaration\(MethodDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitNameColon\(NameColonSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitNameEquals\(NameEqualsSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitNameMemberCref\(NameMemberCrefSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitNamespaceDeclaration\(NamespaceDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitNullableType\(NullableTypeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitObjectCreationExpression\(ObjectCreationExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitOmittedArraySizeExpression\(OmittedArraySizeExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitOmittedTypeArgument\(OmittedTypeArgumentSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitOperatorDeclaration\(OperatorDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitOperatorMemberCref\(OperatorMemberCrefSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitOrderByClause\(OrderByClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitOrdering\(OrderingSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitParameter\(ParameterSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitParameterList\(ParameterListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitParenthesizedExpression\(ParenthesizedExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitParenthesizedLambdaExpression\(ParenthesizedLambdaExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitParenthesizedVariableDesignation\(ParenthesizedVariableDesignationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitPointerType\(PointerTypeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitPostfixUnaryExpression\(PostfixUnaryExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitPragmaChecksumDirectiveTrivia\(PragmaChecksumDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitPragmaWarningDirectiveTrivia\(PragmaWarningDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitPredefinedType\(PredefinedTypeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitPrefixUnaryExpression\(PrefixUnaryExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitPropertyDeclaration\(PropertyDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitQualifiedCref\(QualifiedCrefSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitQualifiedName\(QualifiedNameSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitQueryBody\(QueryBodySyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitQueryContinuation\(QueryContinuationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitQueryExpression\(QueryExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitRefExpression\(RefExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitRefType\(RefTypeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitRefTypeExpression\(RefTypeExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitRefValueExpression\(RefValueExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitReferenceDirectiveTrivia\(ReferenceDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitRegionDirectiveTrivia\(RegionDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitReturnStatement\(ReturnStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitSelectClause\(SelectClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitShebangDirectiveTrivia\(ShebangDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitSimpleBaseType\(SimpleBaseTypeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitSimpleLambdaExpression\(SimpleLambdaExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitSingleVariableDesignation\(SingleVariableDesignationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitSizeOfExpression\(SizeOfExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitSkippedTokensTrivia\(SkippedTokensTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitStackAllocArrayCreationExpression\(StackAllocArrayCreationExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitStructDeclaration\(StructDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitSwitchSection\(SwitchSectionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitSwitchStatement\(SwitchStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitThisExpression\(ThisExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitThrowExpression\(ThrowExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitThrowStatement\(ThrowStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public virtual SyntaxToken VisitToken\(SyntaxToken token\);
* &emsp; \| &emsp; \| &emsp; public virtual SyntaxTrivia VisitTrivia\(SyntaxTrivia trivia\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTryStatement\(TryStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTupleElement\(TupleElementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTupleExpression\(TupleExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTupleType\(TupleTypeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTypeArgumentList\(TypeArgumentListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTypeConstraint\(TypeConstraintSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTypeCref\(TypeCrefSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTypeOfExpression\(TypeOfExpressionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTypeParameter\(TypeParameterSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTypeParameterConstraintClause\(TypeParameterConstraintClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitTypeParameterList\(TypeParameterListSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitUndefDirectiveTrivia\(UndefDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitUnsafeStatement\(UnsafeStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitUsingDirective\(UsingDirectiveSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitUsingStatement\(UsingStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitVariableDeclaration\(VariableDeclarationSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitVariableDeclarator\(VariableDeclaratorSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitWarningDirectiveTrivia\(WarningDirectiveTriviaSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitWhenClause\(WhenClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitWhereClause\(WhereClauseSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitWhileStatement\(WhileStatementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlCDataSection\(XmlCDataSectionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlComment\(XmlCommentSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlCrefAttribute\(XmlCrefAttributeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlElement\(XmlElementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlElementEndTag\(XmlElementEndTagSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlElementStartTag\(XmlElementStartTagSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlEmptyElement\(XmlEmptyElementSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlName\(XmlNameSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlNameAttribute\(XmlNameAttributeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlPrefix\(XmlPrefixSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlProcessingInstruction\(XmlProcessingInstructionSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlText\(XmlTextSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitXmlTextAttribute\(XmlTextAttributeSyntax node\);
* &emsp; \| &emsp; \| &emsp; public override SyntaxNode VisitYieldStatement\(YieldStatementSyntax node\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CodeActions\.CodeAction
* &emsp; \| &emsp; protected CodeAction\(\);
* &emsp; \| &emsp; public virtual string EquivalenceKey \{ get; \}
* &emsp; \| &emsp; public virtual ImmutableArray\<string> Tags \{ get; \}
* &emsp; \| &emsp; public abstract string Title \{ get; \}
* &emsp; \| &emsp; protected virtual Task\<IEnumerable\<CodeActionOperation>> ComputeOperationsAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; protected virtual Task\<IEnumerable\<CodeActionOperation>> ComputePreviewOperationsAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public static CodeAction Create\(string title, Func\<CancellationToken, Task\<Document>> createChangedDocument, string equivalenceKey = null\);
* &emsp; \| &emsp; public static CodeAction Create\(string title, Func\<CancellationToken, Task\<Solution>> createChangedSolution, string equivalenceKey = null\);
* &emsp; \| &emsp; protected virtual Task\<Document> GetChangedDocumentAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; protected virtual Task\<Solution> GetChangedSolutionAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<CodeActionOperation>> GetOperationsAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<CodeActionOperation>> GetPreviewOperationsAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; protected Task\<ImmutableArray\<CodeActionOperation>> PostProcessAsync\(IEnumerable\<CodeActionOperation> operations, CancellationToken cancellationToken\);
* &emsp; \| &emsp; protected Task\<Solution> PostProcessChangesAsync\(Solution changedSolution, CancellationToken cancellationToken\);
* &emsp; \| &emsp; protected virtual Task\<Document> PostProcessChangesAsync\(Document document, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CodeActions\.CodeActionWithOptions : CodeAction
* &emsp; \| &emsp; \| &emsp; protected CodeActionWithOptions\(\);
* &emsp; \| &emsp; \| &emsp; protected override Task\<IEnumerable\<CodeActionOperation>> ComputeOperationsAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; protected abstract Task\<IEnumerable\<CodeActionOperation>> ComputeOperationsAsync\(object options, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public Task\<IEnumerable\<CodeActionOperation>> GetOperationsAsync\(object options, CancellationToken cancellationToken\);
* &emsp; \| &emsp; \| &emsp; public abstract object GetOptions\(CancellationToken cancellationToken\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CodeActions\.CodeActionOperation
* &emsp; \| &emsp; protected CodeActionOperation\(\);
* &emsp; \| &emsp; public virtual string Title \{ get; \}
* &emsp; \| &emsp; public virtual void Apply\(Workspace workspace, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CodeActions\.ApplyChangesOperation : CodeActionOperation
* &emsp; \| &emsp; \| &emsp; public ApplyChangesOperation\(Solution changedSolution\);
* &emsp; \| &emsp; \| &emsp; public Solution ChangedSolution \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override void Apply\(Workspace workspace, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.CodeActions\.OpenDocumentOperation : CodeActionOperation
* &emsp; \| &emsp; \| &emsp; public OpenDocumentOperation\(DocumentId documentId, bool activateIfAlreadyOpen = false\);
* &emsp; \| &emsp; \| &emsp; public DocumentId DocumentId \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override void Apply\(Workspace workspace, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.CodeActions\.PreviewOperation : CodeActionOperation
* &emsp; \| &emsp; \| &emsp; protected PreviewOperation\(\);
* &emsp; \| &emsp; \| &emsp; public abstract Task\<object> GetPreviewAsync\(CancellationToken cancellationToken\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CodeFixes\.CodeFixProvider
* &emsp; \| &emsp; protected CodeFixProvider\(\);
* &emsp; \| &emsp; public abstract ImmutableArray\<string> FixableDiagnosticIds \{ get; \}
* &emsp; \| &emsp; public virtual FixAllProvider GetFixAllProvider\(\);
* &emsp; \| &emsp; public abstract Task RegisterCodeFixesAsync\(CodeFixContext context\);
* &emsp; public class Microsoft\.CodeAnalysis\.CodeFixes\.FixAllContext
* &emsp; \| &emsp; public FixAllContext\(Document document, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable\<string> diagnosticIds, FixAllContext\.DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public FixAllContext\(Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable\<string> diagnosticIds, FixAllContext\.DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; public string CodeActionEquivalenceKey \{ get; \}
* &emsp; \| &emsp; public CodeFixProvider CodeFixProvider \{ get; \}
* &emsp; \| &emsp; public ImmutableHashSet\<string> DiagnosticIds \{ get; \}
* &emsp; \| &emsp; public Document Document \{ get; \}
* &emsp; \| &emsp; public Project Project \{ get; \}
* &emsp; \| &emsp; public FixAllScope Scope \{ get; \}
* &emsp; \| &emsp; public Solution Solution \{ get; \}
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAllDiagnosticsAsync\(Project project\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetDocumentDiagnosticsAsync\(Document document\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetProjectDiagnosticsAsync\(Project project\);
* &emsp; \| &emsp; public FixAllContext WithCancellationToken\(CancellationToken cancellationToken\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CodeFixes\.FixAllContext\.DiagnosticProvider
* &emsp; \| &emsp; protected DiagnosticProvider\(\);
* &emsp; \| &emsp; public abstract Task\<IEnumerable\<Diagnostic>> GetAllDiagnosticsAsync\(Project project, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public abstract Task\<IEnumerable\<Diagnostic>> GetDocumentDiagnosticsAsync\(Document document, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public abstract Task\<IEnumerable\<Diagnostic>> GetProjectDiagnosticsAsync\(Project project, CancellationToken cancellationToken\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CodeFixes\.FixAllProvider
* &emsp; \| &emsp; protected FixAllProvider\(\);
* &emsp; \| &emsp; public abstract Task\<CodeAction> GetFixAsync\(FixAllContext fixAllContext\);
* &emsp; \| &emsp; public virtual IEnumerable\<string> GetSupportedFixAllDiagnosticIds\(CodeFixProvider originalCodeFixProvider\);
* &emsp; \| &emsp; public virtual IEnumerable\<FixAllScope> GetSupportedFixAllScopes\(\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.CodeRefactorings\.CodeRefactoringProvider
* &emsp; \| &emsp; protected CodeRefactoringProvider\(\);
* &emsp; \| &emsp; public abstract Task ComputeRefactoringsAsync\(CodeRefactoringContext context\);
* &emsp; public class Microsoft\.CodeAnalysis\.CodeStyle\.CodeStyleOption\<T> : IEquatable\<CodeStyleOption\<T>>, ICodeStyleOption
* &emsp; \| &emsp; public CodeStyleOption\(T value, NotificationOption notification\);
* &emsp; \| &emsp; public static CodeStyleOption\<T> Default \{ get; \}
* &emsp; \| &emsp; public NotificationOption Notification \{ get; set; \}
* &emsp; \| &emsp; public T Value \{ get; set; \}
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public bool Equals\(CodeStyleOption\<T> other\);
* &emsp; \| &emsp; public static CodeStyleOption\<T> FromXElement\(XElement element\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public XElement ToXElement\(\);
* &emsp; public class Microsoft\.CodeAnalysis\.CodeStyle\.CodeStyleOptions
* &emsp; \| &emsp; public static readonly PerLanguageOption\<CodeStyleOption\<bool>> PreferIntrinsicPredefinedTypeKeywordInDeclaration;
* &emsp; \| &emsp; public static readonly PerLanguageOption\<CodeStyleOption\<bool>> PreferIntrinsicPredefinedTypeKeywordInMemberAccess;
* &emsp; \| &emsp; public static readonly PerLanguageOption\<CodeStyleOption\<bool>> QualifyEventAccess;
* &emsp; \| &emsp; public static readonly PerLanguageOption\<CodeStyleOption\<bool>> QualifyFieldAccess;
* &emsp; \| &emsp; public static readonly PerLanguageOption\<CodeStyleOption\<bool>> QualifyMethodAccess;
* &emsp; \| &emsp; public static readonly PerLanguageOption\<CodeStyleOption\<bool>> QualifyPropertyAccess;
* &emsp; \| &emsp; public CodeStyleOptions\(\);
* &emsp; public class Microsoft\.CodeAnalysis\.CodeStyle\.NotificationOption
* &emsp; \| &emsp; public static readonly NotificationOption Error;
* &emsp; \| &emsp; public static readonly NotificationOption None;
* &emsp; \| &emsp; public static readonly NotificationOption Suggestion;
* &emsp; \| &emsp; public static readonly NotificationOption Warning;
* &emsp; \| &emsp; public string Name \{ get; set; \}
* &emsp; \| &emsp; public DiagnosticSeverity Value \{ get; set; \}
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Diagnostics\.AnalysisContext
* &emsp; \| &emsp; protected AnalysisContext\(\);
* &emsp; \| &emsp; public virtual void ConfigureGeneratedCodeAnalysis\(GeneratedCodeAnalysisFlags analysisMode\);
* &emsp; \| &emsp; public virtual void EnableConcurrentExecution\(\);
* &emsp; \| &emsp; public abstract void RegisterCodeBlockAction\(Action\<CodeBlockAnalysisContext> action\);
* &emsp; \| &emsp; public abstract void RegisterCodeBlockStartAction\<TLanguageKindEnum>\(Action\<CodeBlockStartAnalysisContext\<TLanguageKindEnum>> action\) where TLanguageKindEnum : struct;
* &emsp; \| &emsp; public abstract void RegisterCompilationAction\(Action\<CompilationAnalysisContext> action\);
* &emsp; \| &emsp; public abstract void RegisterCompilationStartAction\(Action\<CompilationStartAnalysisContext> action\);
* &emsp; \| &emsp; public void RegisterOperationAction\(Action\<OperationAnalysisContext> action, params OperationKind\[\] operationKinds\);
* &emsp; \| &emsp; public virtual void RegisterOperationAction\(Action\<OperationAnalysisContext> action, ImmutableArray\<OperationKind> operationKinds\);
* &emsp; \| &emsp; public virtual void RegisterOperationBlockAction\(Action\<OperationBlockAnalysisContext> action\);
* &emsp; \| &emsp; public virtual void RegisterOperationBlockStartAction\(Action\<OperationBlockStartAnalysisContext> action\);
* &emsp; \| &emsp; public abstract void RegisterSemanticModelAction\(Action\<SemanticModelAnalysisContext> action\);
* &emsp; \| &emsp; public void RegisterSymbolAction\(Action\<SymbolAnalysisContext> action, params SymbolKind\[\] symbolKinds\);
* &emsp; \| &emsp; public abstract void RegisterSymbolAction\(Action\<SymbolAnalysisContext> action, ImmutableArray\<SymbolKind> symbolKinds\);
* &emsp; \| &emsp; public void RegisterSyntaxNodeAction\<TLanguageKindEnum>\(Action\<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum\[\] syntaxKinds\) where TLanguageKindEnum : struct;
* &emsp; \| &emsp; public abstract void RegisterSyntaxNodeAction\<TLanguageKindEnum>\(Action\<SyntaxNodeAnalysisContext> action, ImmutableArray\<TLanguageKindEnum> syntaxKinds\) where TLanguageKindEnum : struct;
* &emsp; \| &emsp; public abstract void RegisterSyntaxTreeAction\(Action\<SyntaxTreeAnalysisContext> action\);
* &emsp; \| &emsp; public bool TryGetValue\<TValue>\(SourceText text, SourceTextValueProvider\<TValue> valueProvider, out TValue value\);
* &emsp; public class Microsoft\.CodeAnalysis\.Diagnostics\.AnalysisResult
* &emsp; \| &emsp; public ImmutableDictionary\<DiagnosticAnalyzer, AnalyzerTelemetryInfo> AnalyzerTelemetryInfo \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<DiagnosticAnalyzer> Analyzers \{ get; \}
* &emsp; \| &emsp; public ImmutableDictionary\<DiagnosticAnalyzer, ImmutableArray\<Diagnostic>> CompilationDiagnostics \{ get; \}
* &emsp; \| &emsp; public ImmutableDictionary\<SyntaxTree, ImmutableDictionary\<DiagnosticAnalyzer, ImmutableArray\<Diagnostic>>> SemanticDiagnostics \{ get; \}
* &emsp; \| &emsp; public ImmutableDictionary\<SyntaxTree, ImmutableDictionary\<DiagnosticAnalyzer, ImmutableArray\<Diagnostic>>> SyntaxDiagnostics \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<Diagnostic> GetAllDiagnostics\(\);
* &emsp; \| &emsp; public ImmutableArray\<Diagnostic> GetAllDiagnostics\(DiagnosticAnalyzer analyzer\);
* &emsp; public class Microsoft\.CodeAnalysis\.Diagnostics\.AnalyzerOptions
* &emsp; \| &emsp; public AnalyzerOptions\(ImmutableArray\<AdditionalText> additionalFiles\);
* &emsp; \| &emsp; public ImmutableArray\<AdditionalText> AdditionalFiles \{ get; \}
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public AnalyzerOptions WithAdditionalFiles\(ImmutableArray\<AdditionalText> additionalFiles\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Diagnostics\.AnalyzerReference
* &emsp; \| &emsp; protected AnalyzerReference\(\);
* &emsp; \| &emsp; public virtual string Display \{ get; \}
* &emsp; \| &emsp; public abstract string FullPath \{ get; \}
* &emsp; \| &emsp; public abstract object Id \{ get; \}
* &emsp; \| &emsp; public abstract ImmutableArray\<DiagnosticAnalyzer> GetAnalyzers\(string language\);
* &emsp; \| &emsp; public abstract ImmutableArray\<DiagnosticAnalyzer> GetAnalyzersForAllLanguages\(\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.AnalyzerFileReference : AnalyzerReference, IEquatable\<AnalyzerReference>
* &emsp; \| &emsp; \| &emsp; public AnalyzerFileReference\(string fullPath, IAnalyzerAssemblyLoader assemblyLoader\);
* &emsp; \| &emsp; \| &emsp; public event EventHandler\<AnalyzerLoadFailureEventArgs> AnalyzerLoadFailed;
* &emsp; \| &emsp; \| &emsp; public override string Display \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override string FullPath \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override object Id \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; \| &emsp; public bool Equals\(AnalyzerReference other\);
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<DiagnosticAnalyzer> GetAnalyzers\(string language\);
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<DiagnosticAnalyzer> GetAnalyzersForAllLanguages\(\);
* &emsp; \| &emsp; \| &emsp; public Assembly GetAssembly\(\);
* &emsp; \| &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.AnalyzerImageReference : AnalyzerReference
* &emsp; \| &emsp; \| &emsp; public AnalyzerImageReference\(ImmutableArray\<DiagnosticAnalyzer> analyzers, string fullPath = null, string display = null\);
* &emsp; \| &emsp; \| &emsp; public override string Display \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override string FullPath \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override object Id \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<DiagnosticAnalyzer> GetAnalyzers\(string language\);
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<DiagnosticAnalyzer> GetAnalyzersForAllLanguages\(\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.UnresolvedAnalyzerReference : AnalyzerReference
* &emsp; \| &emsp; \| &emsp; public UnresolvedAnalyzerReference\(string unresolvedPath\);
* &emsp; \| &emsp; \| &emsp; public override string Display \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override string FullPath \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override object Id \{ get; \}
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<DiagnosticAnalyzer> GetAnalyzers\(string language\);
* &emsp; \| &emsp; \| &emsp; public override ImmutableArray\<DiagnosticAnalyzer> GetAnalyzersForAllLanguages\(\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Diagnostics\.CodeBlockStartAnalysisContext\<TLanguageKindEnum> where TLanguageKindEnum : struct
* &emsp; \| &emsp; protected CodeBlockStartAnalysisContext\(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; public SyntaxNode CodeBlock \{ get; \}
* &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; public ISymbol OwningSymbol \{ get; \}
* &emsp; \| &emsp; public SemanticModel SemanticModel \{ get; \}
* &emsp; \| &emsp; public abstract void RegisterCodeBlockEndAction\(Action\<CodeBlockAnalysisContext> action\);
* &emsp; \| &emsp; public void RegisterSyntaxNodeAction\(Action\<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum\[\] syntaxKinds\);
* &emsp; \| &emsp; public abstract void RegisterSyntaxNodeAction\(Action\<SyntaxNodeAnalysisContext> action, ImmutableArray\<TLanguageKindEnum> syntaxKinds\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Diagnostics\.CompilationStartAnalysisContext
* &emsp; \| &emsp; protected CompilationStartAnalysisContext\(Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; public abstract void RegisterCodeBlockAction\(Action\<CodeBlockAnalysisContext> action\);
* &emsp; \| &emsp; public abstract void RegisterCodeBlockStartAction\<TLanguageKindEnum>\(Action\<CodeBlockStartAnalysisContext\<TLanguageKindEnum>> action\) where TLanguageKindEnum : struct;
* &emsp; \| &emsp; public abstract void RegisterCompilationEndAction\(Action\<CompilationAnalysisContext> action\);
* &emsp; \| &emsp; public void RegisterOperationAction\(Action\<OperationAnalysisContext> action, params OperationKind\[\] operationKinds\);
* &emsp; \| &emsp; public virtual void RegisterOperationAction\(Action\<OperationAnalysisContext> action, ImmutableArray\<OperationKind> operationKinds\);
* &emsp; \| &emsp; public virtual void RegisterOperationBlockAction\(Action\<OperationBlockAnalysisContext> action\);
* &emsp; \| &emsp; public virtual void RegisterOperationBlockStartAction\(Action\<OperationBlockStartAnalysisContext> action\);
* &emsp; \| &emsp; public abstract void RegisterSemanticModelAction\(Action\<SemanticModelAnalysisContext> action\);
* &emsp; \| &emsp; public void RegisterSymbolAction\(Action\<SymbolAnalysisContext> action, params SymbolKind\[\] symbolKinds\);
* &emsp; \| &emsp; public abstract void RegisterSymbolAction\(Action\<SymbolAnalysisContext> action, ImmutableArray\<SymbolKind> symbolKinds\);
* &emsp; \| &emsp; public void RegisterSyntaxNodeAction\<TLanguageKindEnum>\(Action\<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum\[\] syntaxKinds\) where TLanguageKindEnum : struct;
* &emsp; \| &emsp; public abstract void RegisterSyntaxNodeAction\<TLanguageKindEnum>\(Action\<SyntaxNodeAnalysisContext> action, ImmutableArray\<TLanguageKindEnum> syntaxKinds\) where TLanguageKindEnum : struct;
* &emsp; \| &emsp; public abstract void RegisterSyntaxTreeAction\(Action\<SyntaxTreeAnalysisContext> action\);
* &emsp; \| &emsp; public bool TryGetValue\<TValue>\(SourceText text, SourceTextValueProvider\<TValue> valueProvider, out TValue value\);
* &emsp; \| &emsp; public bool TryGetValue\<TValue>\(SyntaxTree tree, SyntaxTreeValueProvider\<TValue> valueProvider, out TValue value\);
* &emsp; public class Microsoft\.CodeAnalysis\.Diagnostics\.CompilationWithAnalyzers
* &emsp; \| &emsp; public CompilationWithAnalyzers\(Compilation compilation, ImmutableArray\<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions\);
* &emsp; \| &emsp; public CompilationWithAnalyzers\(Compilation compilation, ImmutableArray\<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public CompilationWithAnalyzersOptions AnalysisOptions \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<DiagnosticAnalyzer> Analyzers \{ get; \}
* &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; public static void ClearAnalyzerState\(ImmutableArray\<DiagnosticAnalyzer> analyzers\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAllDiagnosticsAsync\(\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAllDiagnosticsAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<AnalysisResult> GetAnalysisResultAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<AnalysisResult> GetAnalysisResultAsync\(ImmutableArray\<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync\(ImmutableArray\<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerDiagnosticsAsync\(\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerDiagnosticsAsync\(CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerDiagnosticsAsync\(ImmutableArray\<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync\(SemanticModel model, TextSpan? filterSpan, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync\(SemanticModel model, TextSpan? filterSpan, ImmutableArray\<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync\(SyntaxTree tree, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<ImmutableArray\<Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync\(SyntaxTree tree, ImmutableArray\<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public Task\<AnalyzerTelemetryInfo> GetAnalyzerTelemetryInfoAsync\(DiagnosticAnalyzer analyzer, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public static IEnumerable\<Diagnostic> GetEffectiveDiagnostics\(IEnumerable\<Diagnostic> diagnostics, Compilation compilation\);
* &emsp; \| &emsp; public static IEnumerable\<Diagnostic> GetEffectiveDiagnostics\(ImmutableArray\<Diagnostic> diagnostics, Compilation compilation\);
* &emsp; \| &emsp; public static bool IsDiagnosticAnalyzerSuppressed\(DiagnosticAnalyzer analyzer, CompilationOptions options, Action\<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException = null\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.CompilationWithAnalyzersOptions
* &emsp; \| &emsp; public CompilationWithAnalyzersOptions\(AnalyzerOptions options, Action\<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime\);
* &emsp; \| &emsp; public CompilationWithAnalyzersOptions\(AnalyzerOptions options, Action\<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics\);
* &emsp; \| &emsp; public CompilationWithAnalyzersOptions\(AnalyzerOptions options, Action\<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics, Func\<Exception, bool> analyzerExceptionFilter\);
* &emsp; \| &emsp; public Func\<Exception, bool> AnalyzerExceptionFilter \{ get; \}
* &emsp; \| &emsp; public bool ConcurrentAnalysis \{ get; \}
* &emsp; \| &emsp; public bool LogAnalyzerExecutionTime \{ get; \}
* &emsp; \| &emsp; public Action\<Exception, DiagnosticAnalyzer, Diagnostic> OnAnalyzerException \{ get; \}
* &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; public bool ReportSuppressedDiagnostics \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Diagnostics\.DiagnosticAnalyzer
* &emsp; \| &emsp; protected DiagnosticAnalyzer\(\);
* &emsp; \| &emsp; public abstract ImmutableArray\<DiagnosticDescriptor> SupportedDiagnostics \{ get; \}
* &emsp; \| &emsp; public override sealed bool Equals\(object obj\);
* &emsp; \| &emsp; public override sealed int GetHashCode\(\);
* &emsp; \| &emsp; public abstract void Initialize\(AnalysisContext context\);
* &emsp; \| &emsp; public override sealed string ToString\(\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Diagnostics\.OperationBlockStartAnalysisContext
* &emsp; \| &emsp; protected OperationBlockStartAnalysisContext\(ImmutableArray\<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken\);
* &emsp; \| &emsp; public CancellationToken CancellationToken \{ get; \}
* &emsp; \| &emsp; public Compilation Compilation \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<IOperation> OperationBlocks \{ get; \}
* &emsp; \| &emsp; public AnalyzerOptions Options \{ get; \}
* &emsp; \| &emsp; public ISymbol OwningSymbol \{ get; \}
* &emsp; \| &emsp; public void RegisterOperationAction\(Action\<OperationAnalysisContext> action, params OperationKind\[\] operationKinds\);
* &emsp; \| &emsp; public abstract void RegisterOperationAction\(Action\<OperationAnalysisContext> action, ImmutableArray\<OperationKind> operationKinds\);
* &emsp; \| &emsp; public abstract void RegisterOperationBlockEndAction\(Action\<OperationBlockAnalysisContext> action\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.SourceTextValueProvider\<TValue>
* &emsp; \| &emsp; public SourceTextValueProvider\(Func\<SourceText, TValue> computeValue, IEqualityComparer\<SourceText> sourceTextComparer = null\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.SuppressionInfo
* &emsp; \| &emsp; public AttributeData Attribute \{ get; \}
* &emsp; \| &emsp; public string Id \{ get; \}
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.SyntaxTreeValueProvider\<TValue>
* &emsp; \| &emsp; public SyntaxTreeValueProvider\(Func\<SyntaxTree, TValue> computeValue, IEqualityComparer\<SyntaxTree> syntaxTreeComparer = null\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Diagnostics\.Telemetry\.AnalyzerTelemetryInfo
* &emsp; \| &emsp; public AnalyzerTelemetryInfo\(\);
* &emsp; \| &emsp; public int CodeBlockActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int CodeBlockEndActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int CodeBlockStartActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int CompilationActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int CompilationEndActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int CompilationStartActionsCount \{ get; set; \}
* &emsp; \| &emsp; public TimeSpan ExecutionTime \{ get; set; \}
* &emsp; \| &emsp; public int OperationActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int OperationBlockActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int OperationBlockEndActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int OperationBlockStartActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int SemanticModelActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int SymbolActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int SyntaxNodeActionsCount \{ get; set; \}
* &emsp; \| &emsp; public int SyntaxTreeActionsCount \{ get; set; \}
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Differencing\.EditScript\<TNode>
* &emsp; \| &emsp; public ImmutableArray\<Edit\<TNode>> Edits \{ get; \}
* &emsp; \| &emsp; public Match\<TNode> Match \{ get; \}
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Differencing\.Match\<TNode>
* &emsp; \| &emsp; public TreeComparer\<TNode> Comparer \{ get; \}
* &emsp; \| &emsp; public IReadOnlyDictionary\<TNode, TNode> Matches \{ get; \}
* &emsp; \| &emsp; public TNode NewRoot \{ get; \}
* &emsp; \| &emsp; public TNode OldRoot \{ get; \}
* &emsp; \| &emsp; public IReadOnlyDictionary\<TNode, TNode> ReverseMatches \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<Edit\<TNode>> GetSequenceEdits\(IEnumerable\<TNode> oldNodes, IEnumerable\<TNode> newNodes\);
* &emsp; \| &emsp; public EditScript\<TNode> GetTreeEdits\(\);
* &emsp; \| &emsp; public bool TryGetNewNode\(TNode oldNode, out TNode newNode\);
* &emsp; \| &emsp; public bool TryGetOldNode\(TNode newNode, out TNode oldNode\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Differencing\.TreeComparer\<TNode>
* &emsp; \| &emsp; protected TreeComparer\(\);
* &emsp; \| &emsp; protected internal abstract int LabelCount \{ get; \}
* &emsp; \| &emsp; public EditScript\<TNode> ComputeEditScript\(TNode oldRoot, TNode newRoot\);
* &emsp; \| &emsp; public Match\<TNode> ComputeMatch\(TNode oldRoot, TNode newRoot, IEnumerable\<KeyValuePair\<TNode, TNode>> knownMatches = null\);
* &emsp; \| &emsp; protected internal abstract IEnumerable\<TNode> GetChildren\(TNode node\);
* &emsp; \| &emsp; protected internal abstract IEnumerable\<TNode> GetDescendants\(TNode node\);
* &emsp; \| &emsp; public abstract double GetDistance\(TNode oldNode, TNode newNode\);
* &emsp; \| &emsp; protected internal abstract int GetLabel\(TNode node\);
* &emsp; \| &emsp; protected internal abstract TextSpan GetSpan\(TNode node\);
* &emsp; \| &emsp; protected internal abstract int TiedToAncestor\(int label\);
* &emsp; \| &emsp; protected internal abstract bool TreesEqual\(TNode oldNode, TNode newNode\);
* &emsp; \| &emsp; protected internal abstract bool TryGetParent\(TNode node, out TNode parent\);
* &emsp; \| &emsp; public abstract bool ValuesEqual\(TNode oldNode, TNode newNode\);
* &emsp; public class Microsoft\.CodeAnalysis\.Editing\.SolutionEditor
* &emsp; \| &emsp; public SolutionEditor\(Solution solution\);
* &emsp; \| &emsp; public Solution OriginalSolution \{ get; \}
* &emsp; \| &emsp; public Solution GetChangedSolution\(\);
* &emsp; \| &emsp; public Task\<DocumentEditor> GetDocumentEditorAsync\(DocumentId id, CancellationToken cancellationToken = default\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Editing\.SymbolEditor
* &emsp; \| &emsp; public Solution ChangedSolution \{ get; \}
* &emsp; \| &emsp; public Solution OriginalSolution \{ get; \}
* &emsp; \| &emsp; public static SymbolEditor Create\(Document document\);
* &emsp; \| &emsp; public static SymbolEditor Create\(Solution solution\);
* &emsp; \| &emsp; public Task\<ISymbol> EditAllDeclarationsAsync\(ISymbol symbol, SymbolEditor\.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<ISymbol> EditAllDeclarationsAsync\(ISymbol symbol, SymbolEditor\.DeclarationEditAction editAction, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<ISymbol> EditOneDeclarationAsync\(ISymbol symbol, SymbolEditor\.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<ISymbol> EditOneDeclarationAsync\(ISymbol symbol, SymbolEditor\.DeclarationEditAction editAction, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<ISymbol> EditOneDeclarationAsync\(ISymbol symbol, Location location, SymbolEditor\.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<ISymbol> EditOneDeclarationAsync\(ISymbol symbol, Location location, SymbolEditor\.DeclarationEditAction editAction, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<ISymbol> EditOneDeclarationAsync\(ISymbol symbol, ISymbol member, SymbolEditor\.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<ISymbol> EditOneDeclarationAsync\(ISymbol symbol, ISymbol member, SymbolEditor\.DeclarationEditAction editAction, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public IEnumerable\<Document> GetChangedDocuments\(\);
* &emsp; \| &emsp; public Task\<IReadOnlyList\<SyntaxNode>> GetCurrentDeclarationsAsync\(ISymbol symbol, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public Task\<ISymbol> GetCurrentSymbolAsync\(ISymbol symbol, CancellationToken cancellationToken = default\);
* &emsp; public class Microsoft\.CodeAnalysis\.Editing\.SyntaxEditor
* &emsp; \| &emsp; public SyntaxEditor\(SyntaxNode root, Workspace workspace\);
* &emsp; \| &emsp; public SyntaxGenerator Generator \{ get; \}
* &emsp; \| &emsp; public SyntaxNode OriginalRoot \{ get; \}
* &emsp; \| &emsp; public SyntaxNode GetChangedRoot\(\);
* &emsp; \| &emsp; public void InsertAfter\(SyntaxNode node, SyntaxNode newNode\);
* &emsp; \| &emsp; public void InsertAfter\(SyntaxNode node, IEnumerable\<SyntaxNode> newNodes\);
* &emsp; \| &emsp; public void InsertBefore\(SyntaxNode node, SyntaxNode newNode\);
* &emsp; \| &emsp; public void InsertBefore\(SyntaxNode node, IEnumerable\<SyntaxNode> newNodes\);
* &emsp; \| &emsp; public void RemoveNode\(SyntaxNode node\);
* &emsp; \| &emsp; public void RemoveNode\(SyntaxNode node, SyntaxRemoveOptions options\);
* &emsp; \| &emsp; public void ReplaceNode\(SyntaxNode node, Func\<SyntaxNode, SyntaxGenerator, SyntaxNode> computeReplacement\);
* &emsp; \| &emsp; public void ReplaceNode\(SyntaxNode node, SyntaxNode newNode\);
* &emsp; \| &emsp; public void TrackNode\(SyntaxNode node\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.Editing\.DocumentEditor : SyntaxEditor
* &emsp; \| &emsp; \| &emsp; public Document OriginalDocument \{ get; \}
* &emsp; \| &emsp; \| &emsp; public SemanticModel SemanticModel \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static Task\<DocumentEditor> CreateAsync\(Document document, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; \| &emsp; public Document GetChangedDocument\(\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Editing\.SyntaxGenerator : ILanguageService
* &emsp; \| &emsp; public static SyntaxRemoveOptions DefaultRemoveOptions;
* &emsp; \| &emsp; protected SyntaxGenerator\(\);
* &emsp; \| &emsp; public SyntaxNode AddAccessors\(SyntaxNode declaration, IEnumerable\<SyntaxNode> accessors\);
* &emsp; \| &emsp; public SyntaxNode AddAttributeArguments\(SyntaxNode attributeDeclaration, IEnumerable\<SyntaxNode> attributeArguments\);
* &emsp; \| &emsp; public SyntaxNode AddAttributes\(SyntaxNode declaration, IEnumerable\<SyntaxNode> attributes\);
* &emsp; \| &emsp; public SyntaxNode AddAttributes\(SyntaxNode declaration, params SyntaxNode\[\] attributes\);
* &emsp; \| &emsp; public abstract SyntaxNode AddBaseType\(SyntaxNode declaration, SyntaxNode baseType\);
* &emsp; \| &emsp; public abstract SyntaxNode AddEventHandler\(SyntaxNode @event, SyntaxNode handler\);
* &emsp; \| &emsp; public abstract SyntaxNode AddExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode AddInterfaceType\(SyntaxNode declaration, SyntaxNode interfaceType\);
* &emsp; \| &emsp; public SyntaxNode AddMembers\(SyntaxNode declaration, IEnumerable\<SyntaxNode> members\);
* &emsp; \| &emsp; public SyntaxNode AddMembers\(SyntaxNode declaration, params SyntaxNode\[\] members\);
* &emsp; \| &emsp; public SyntaxNode AddNamespaceImports\(SyntaxNode declaration, IEnumerable\<SyntaxNode> imports\);
* &emsp; \| &emsp; public SyntaxNode AddNamespaceImports\(SyntaxNode declaration, params SyntaxNode\[\] imports\);
* &emsp; \| &emsp; public SyntaxNode AddParameters\(SyntaxNode declaration, IEnumerable\<SyntaxNode> parameters\);
* &emsp; \| &emsp; public SyntaxNode AddReturnAttributes\(SyntaxNode declaration, IEnumerable\<SyntaxNode> attributes\);
* &emsp; \| &emsp; public SyntaxNode AddReturnAttributes\(SyntaxNode declaration, params SyntaxNode\[\] attributes\);
* &emsp; \| &emsp; public SyntaxNode AddSwitchSections\(SyntaxNode switchStatement, IEnumerable\<SyntaxNode> switchSections\);
* &emsp; \| &emsp; public SyntaxNode Argument\(SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode Argument\(RefKind refKind, SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode Argument\(string name, RefKind refKind, SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode ArrayCreationExpression\(SyntaxNode elementType, IEnumerable\<SyntaxNode> elements\);
* &emsp; \| &emsp; public abstract SyntaxNode ArrayCreationExpression\(SyntaxNode elementType, SyntaxNode size\);
* &emsp; \| &emsp; public abstract SyntaxNode ArrayTypeExpression\(SyntaxNode type\);
* &emsp; \| &emsp; public SyntaxNode AsPrivateInterfaceImplementation\(SyntaxNode declaration, SyntaxNode interfaceType\);
* &emsp; \| &emsp; public abstract SyntaxNode AsPrivateInterfaceImplementation\(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName\);
* &emsp; \| &emsp; public SyntaxNode AsPublicInterfaceImplementation\(SyntaxNode declaration, SyntaxNode interfaceType\);
* &emsp; \| &emsp; public abstract SyntaxNode AsPublicInterfaceImplementation\(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName\);
* &emsp; \| &emsp; public abstract SyntaxNode AssignmentStatement\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public SyntaxNode Attribute\(AttributeData attribute\);
* &emsp; \| &emsp; public abstract SyntaxNode Attribute\(SyntaxNode name, IEnumerable\<SyntaxNode> attributeArguments = null\);
* &emsp; \| &emsp; public SyntaxNode Attribute\(string name, IEnumerable\<SyntaxNode> attributeArguments = null\);
* &emsp; \| &emsp; public SyntaxNode Attribute\(string name, params SyntaxNode\[\] attributeArguments\);
* &emsp; \| &emsp; public SyntaxNode AttributeArgument\(SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode AttributeArgument\(string name, SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode AwaitExpression\(SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode BaseExpression\(\);
* &emsp; \| &emsp; public abstract SyntaxNode BitwiseAndExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode BitwiseNotExpression\(SyntaxNode operand\);
* &emsp; \| &emsp; public abstract SyntaxNode BitwiseOrExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode CastExpression\(SyntaxNode type, SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode CastExpression\(ITypeSymbol type, SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode CatchClause\(SyntaxNode type, string identifier, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public SyntaxNode CatchClause\(ITypeSymbol type, string identifier, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode ClassDeclaration\(string name, IEnumerable\<string> typeParameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, SyntaxNode baseType = null, IEnumerable\<SyntaxNode> interfaceTypes = null, IEnumerable\<SyntaxNode> members = null\);
* &emsp; \| &emsp; public abstract TNode ClearTrivia\<TNode>\(TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public abstract SyntaxNode CoalesceExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode CompilationUnit\(IEnumerable\<SyntaxNode> declarations\);
* &emsp; \| &emsp; public SyntaxNode CompilationUnit\(params SyntaxNode\[\] declarations\);
* &emsp; \| &emsp; public abstract SyntaxNode ConditionalExpression\(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse\);
* &emsp; \| &emsp; public SyntaxNode ConstructorDeclaration\(IMethodSymbol constructorMethod, IEnumerable\<SyntaxNode> baseConstructorArguments = null, IEnumerable\<SyntaxNode> statements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode ConstructorDeclaration\(string containingTypeName = null, IEnumerable\<SyntaxNode> parameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable\<SyntaxNode> baseConstructorArguments = null, IEnumerable\<SyntaxNode> statements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode ConvertExpression\(SyntaxNode type, SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode ConvertExpression\(ITypeSymbol type, SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode CustomEventDeclaration\(IEventSymbol symbol, IEnumerable\<SyntaxNode> addAccessorStatements = null, IEnumerable\<SyntaxNode> removeAccessorStatements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode CustomEventDeclaration\(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable\<SyntaxNode> parameters = null, IEnumerable\<SyntaxNode> addAccessorStatements = null, IEnumerable\<SyntaxNode> removeAccessorStatements = null\);
* &emsp; \| &emsp; public SyntaxNode Declaration\(ISymbol symbol\);
* &emsp; \| &emsp; public abstract SyntaxNode DefaultExpression\(SyntaxNode type\);
* &emsp; \| &emsp; public abstract SyntaxNode DefaultExpression\(ITypeSymbol type\);
* &emsp; \| &emsp; public abstract SyntaxNode DefaultSwitchSection\(IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode DelegateDeclaration\(string name, IEnumerable\<SyntaxNode> parameters = null, IEnumerable\<string> typeParameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default\);
* &emsp; \| &emsp; public abstract SyntaxNode DivideExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public SyntaxNode DottedName\(string dottedName\);
* &emsp; \| &emsp; public abstract SyntaxNode ElementAccessExpression\(SyntaxNode expression, IEnumerable\<SyntaxNode> arguments\);
* &emsp; \| &emsp; public SyntaxNode ElementAccessExpression\(SyntaxNode expression, params SyntaxNode\[\] arguments\);
* &emsp; \| &emsp; public abstract SyntaxNode EnumDeclaration\(string name, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable\<SyntaxNode> members = null\);
* &emsp; \| &emsp; public abstract SyntaxNode EnumMember\(string name, SyntaxNode expression = null\);
* &emsp; \| &emsp; public SyntaxNode EventDeclaration\(IEventSymbol symbol\);
* &emsp; \| &emsp; public abstract SyntaxNode EventDeclaration\(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default\);
* &emsp; \| &emsp; public abstract SyntaxNode ExitSwitchStatement\(\);
* &emsp; \| &emsp; public abstract SyntaxNode ExpressionStatement\(SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode FalseLiteralExpression\(\);
* &emsp; \| &emsp; public SyntaxNode FieldDeclaration\(IFieldSymbol field\);
* &emsp; \| &emsp; public SyntaxNode FieldDeclaration\(IFieldSymbol field, SyntaxNode initializer\);
* &emsp; \| &emsp; public abstract SyntaxNode FieldDeclaration\(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, SyntaxNode initializer = null\);
* &emsp; \| &emsp; public abstract SyntaxNode GenericName\(string identifier, IEnumerable\<SyntaxNode> typeArguments\);
* &emsp; \| &emsp; public SyntaxNode GenericName\(string identifier, IEnumerable\<ITypeSymbol> typeArguments\);
* &emsp; \| &emsp; public SyntaxNode GenericName\(string identifier, params SyntaxNode\[\] typeArguments\);
* &emsp; \| &emsp; public SyntaxNode GenericName\(string identifier, params ITypeSymbol\[\] typeArguments\);
* &emsp; \| &emsp; public abstract Accessibility GetAccessibility\(SyntaxNode declaration\);
* &emsp; \| &emsp; public SyntaxNode GetAccessor\(SyntaxNode declaration, DeclarationKind kind\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetAccessors\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetAttributeArguments\(SyntaxNode attributeDeclaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetAttributes\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetBaseAndInterfaceTypes\(SyntaxNode declaration\);
* &emsp; \| &emsp; public SyntaxNode GetDeclaration\(SyntaxNode node\);
* &emsp; \| &emsp; public SyntaxNode GetDeclaration\(SyntaxNode node, DeclarationKind kind\);
* &emsp; \| &emsp; public abstract DeclarationKind GetDeclarationKind\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract SyntaxNode GetExpression\(SyntaxNode declaration\);
* &emsp; \| &emsp; public static SyntaxGenerator GetGenerator\(Document document\);
* &emsp; \| &emsp; public static SyntaxGenerator GetGenerator\(Project project\);
* &emsp; \| &emsp; public static SyntaxGenerator GetGenerator\(Workspace workspace, string language\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetGetAccessorStatements\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetMembers\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract DeclarationModifiers GetModifiers\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract string GetName\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetNamespaceImports\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetParameters\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetReturnAttributes\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetSetAccessorStatements\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetStatements\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract IReadOnlyList\<SyntaxNode> GetSwitchSections\(SyntaxNode switchStatement\);
* &emsp; \| &emsp; public abstract SyntaxNode GetType\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract SyntaxNode GreaterThanExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode GreaterThanOrEqualExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode IdentifierName\(string identifier\);
* &emsp; \| &emsp; public SyntaxNode IfStatement\(SyntaxNode condition, IEnumerable\<SyntaxNode> trueStatements, SyntaxNode falseStatement\);
* &emsp; \| &emsp; public abstract SyntaxNode IfStatement\(SyntaxNode condition, IEnumerable\<SyntaxNode> trueStatements, IEnumerable\<SyntaxNode> falseStatements = null\);
* &emsp; \| &emsp; protected int IndexOf\<T>\(IReadOnlyList\<T> list, T element\);
* &emsp; \| &emsp; public SyntaxNode IndexerDeclaration\(IPropertySymbol indexer, IEnumerable\<SyntaxNode> getAccessorStatements = null, IEnumerable\<SyntaxNode> setAccessorStatements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode IndexerDeclaration\(IEnumerable\<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable\<SyntaxNode> getAccessorStatements = null, IEnumerable\<SyntaxNode> setAccessorStatements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode InsertAccessors\(SyntaxNode declaration, int index, IEnumerable\<SyntaxNode> accessors\);
* &emsp; \| &emsp; public abstract SyntaxNode InsertAttributeArguments\(SyntaxNode attributeDeclaration, int index, IEnumerable\<SyntaxNode> attributeArguments\);
* &emsp; \| &emsp; public abstract SyntaxNode InsertAttributes\(SyntaxNode declaration, int index, IEnumerable\<SyntaxNode> attributes\);
* &emsp; \| &emsp; public SyntaxNode InsertAttributes\(SyntaxNode declaration, int index, params SyntaxNode\[\] attributes\);
* &emsp; \| &emsp; public abstract SyntaxNode InsertMembers\(SyntaxNode declaration, int index, IEnumerable\<SyntaxNode> members\);
* &emsp; \| &emsp; public SyntaxNode InsertMembers\(SyntaxNode declaration, int index, params SyntaxNode\[\] members\);
* &emsp; \| &emsp; public abstract SyntaxNode InsertNamespaceImports\(SyntaxNode declaration, int index, IEnumerable\<SyntaxNode> imports\);
* &emsp; \| &emsp; public SyntaxNode InsertNamespaceImports\(SyntaxNode declaration, int index, params SyntaxNode\[\] imports\);
* &emsp; \| &emsp; public virtual SyntaxNode InsertNodesAfter\(SyntaxNode root, SyntaxNode node, IEnumerable\<SyntaxNode> newDeclarations\);
* &emsp; \| &emsp; public virtual SyntaxNode InsertNodesBefore\(SyntaxNode root, SyntaxNode node, IEnumerable\<SyntaxNode> newDeclarations\);
* &emsp; \| &emsp; public abstract SyntaxNode InsertParameters\(SyntaxNode declaration, int index, IEnumerable\<SyntaxNode> parameters\);
* &emsp; \| &emsp; public abstract SyntaxNode InsertReturnAttributes\(SyntaxNode declaration, int index, IEnumerable\<SyntaxNode> attributes\);
* &emsp; \| &emsp; public SyntaxNode InsertReturnAttributes\(SyntaxNode declaration, int index, params SyntaxNode\[\] attributes\);
* &emsp; \| &emsp; public abstract SyntaxNode InsertSwitchSections\(SyntaxNode switchStatement, int index, IEnumerable\<SyntaxNode> switchSections\);
* &emsp; \| &emsp; public abstract SyntaxNode InterfaceDeclaration\(string name, IEnumerable\<string> typeParameters = null, Accessibility accessibility = NotApplicable, IEnumerable\<SyntaxNode> interfaceTypes = null, IEnumerable\<SyntaxNode> members = null\);
* &emsp; \| &emsp; public abstract SyntaxNode InvocationExpression\(SyntaxNode expression, IEnumerable\<SyntaxNode> arguments\);
* &emsp; \| &emsp; public SyntaxNode InvocationExpression\(SyntaxNode expression, params SyntaxNode\[\] arguments\);
* &emsp; \| &emsp; public abstract SyntaxNode IsTypeExpression\(SyntaxNode expression, SyntaxNode type\);
* &emsp; \| &emsp; public SyntaxNode IsTypeExpression\(SyntaxNode expression, ITypeSymbol type\);
* &emsp; \| &emsp; public abstract SyntaxNode LambdaParameter\(string identifier, SyntaxNode type = null\);
* &emsp; \| &emsp; public SyntaxNode LambdaParameter\(string identifier, ITypeSymbol type\);
* &emsp; \| &emsp; public abstract SyntaxNode LessThanExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode LessThanOrEqualExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode LiteralExpression\(object value\);
* &emsp; \| &emsp; public SyntaxNode LocalDeclarationStatement\(string name, SyntaxNode initializer\);
* &emsp; \| &emsp; public abstract SyntaxNode LocalDeclarationStatement\(SyntaxNode type, string identifier, SyntaxNode initializer = null, bool isConst = false\);
* &emsp; \| &emsp; public SyntaxNode LocalDeclarationStatement\(ITypeSymbol type, string name, SyntaxNode initializer = null, bool isConst = false\);
* &emsp; \| &emsp; public abstract SyntaxNode LockStatement\(SyntaxNode expression, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode LogicalAndExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode LogicalNotExpression\(SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode LogicalOrExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public virtual SyntaxNode MemberAccessExpression\(SyntaxNode expression, SyntaxNode memberName\);
* &emsp; \| &emsp; public SyntaxNode MemberAccessExpression\(SyntaxNode expression, string memberName\);
* &emsp; \| &emsp; public SyntaxNode MethodDeclaration\(IMethodSymbol method, IEnumerable\<SyntaxNode> statements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode MethodDeclaration\(string name, IEnumerable\<SyntaxNode> parameters = null, IEnumerable\<string> typeParameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable\<SyntaxNode> statements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode ModuloExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode MultiplyExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode NameOfExpression\(SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode NamespaceDeclaration\(SyntaxNode name, IEnumerable\<SyntaxNode> declarations\);
* &emsp; \| &emsp; public SyntaxNode NamespaceDeclaration\(SyntaxNode name, params SyntaxNode\[\] declarations\);
* &emsp; \| &emsp; public SyntaxNode NamespaceDeclaration\(string name, IEnumerable\<SyntaxNode> declarations\);
* &emsp; \| &emsp; public SyntaxNode NamespaceDeclaration\(string name, params SyntaxNode\[\] declarations\);
* &emsp; \| &emsp; public abstract SyntaxNode NamespaceImportDeclaration\(SyntaxNode name\);
* &emsp; \| &emsp; public SyntaxNode NamespaceImportDeclaration\(string name\);
* &emsp; \| &emsp; public abstract SyntaxNode NegateExpression\(SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode NullLiteralExpression\(\);
* &emsp; \| &emsp; public abstract SyntaxNode NullableTypeExpression\(SyntaxNode type\);
* &emsp; \| &emsp; public abstract SyntaxNode ObjectCreationExpression\(SyntaxNode namedType, IEnumerable\<SyntaxNode> arguments\);
* &emsp; \| &emsp; public SyntaxNode ObjectCreationExpression\(ITypeSymbol type, IEnumerable\<SyntaxNode> arguments\);
* &emsp; \| &emsp; public SyntaxNode ObjectCreationExpression\(SyntaxNode type, params SyntaxNode\[\] arguments\);
* &emsp; \| &emsp; public SyntaxNode ObjectCreationExpression\(ITypeSymbol type, params SyntaxNode\[\] arguments\);
* &emsp; \| &emsp; public SyntaxNode OperatorDeclaration\(IMethodSymbol method, IEnumerable\<SyntaxNode> statements = null\);
* &emsp; \| &emsp; public virtual SyntaxNode OperatorDeclaration\(OperatorKind kind, IEnumerable\<SyntaxNode> parameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable\<SyntaxNode> statements = null\);
* &emsp; \| &emsp; public SyntaxNode ParameterDeclaration\(IParameterSymbol symbol, SyntaxNode initializer = null\);
* &emsp; \| &emsp; public abstract SyntaxNode ParameterDeclaration\(string name, SyntaxNode type = null, SyntaxNode initializer = null, RefKind refKind = None\);
* &emsp; \| &emsp; protected static SyntaxNode PreserveTrivia\<TNode>\(TNode node, Func\<TNode, SyntaxNode> nodeChanger\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public SyntaxNode PropertyDeclaration\(IPropertySymbol property, IEnumerable\<SyntaxNode> getAccessorStatements = null, IEnumerable\<SyntaxNode> setAccessorStatements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode PropertyDeclaration\(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable\<SyntaxNode> getAccessorStatements = null, IEnumerable\<SyntaxNode> setAccessorStatements = null\);
* &emsp; \| &emsp; public abstract SyntaxNode QualifiedName\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode ReferenceEqualsExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode ReferenceNotEqualsExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public SyntaxNode RemoveAllAttributes\(SyntaxNode declaration\);
* &emsp; \| &emsp; public abstract SyntaxNode RemoveEventHandler\(SyntaxNode @event, SyntaxNode handler\);
* &emsp; \| &emsp; public virtual SyntaxNode RemoveNode\(SyntaxNode root, SyntaxNode node\);
* &emsp; \| &emsp; public virtual SyntaxNode RemoveNode\(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options\);
* &emsp; \| &emsp; public SyntaxNode RemoveNodes\(SyntaxNode root, IEnumerable\<SyntaxNode> declarations\);
* &emsp; \| &emsp; protected static SeparatedSyntaxList\<TNode> RemoveRange\<TNode>\(SeparatedSyntaxList\<TNode> list, int offset, int count\) where TNode : SyntaxNode;
* &emsp; \| &emsp; protected static SyntaxList\<TNode> RemoveRange\<TNode>\(SyntaxList\<TNode> list, int offset, int count\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public virtual SyntaxNode ReplaceNode\(SyntaxNode root, SyntaxNode node, SyntaxNode newDeclaration\);
* &emsp; \| &emsp; protected static SyntaxNode ReplaceRange\(SyntaxNode root, SyntaxNode node, IEnumerable\<SyntaxNode> replacements\);
* &emsp; \| &emsp; protected static SyntaxNode ReplaceWithTrivia\(SyntaxNode root, SyntaxNode original, SyntaxNode replacement\);
* &emsp; \| &emsp; protected static SyntaxNode ReplaceWithTrivia\(SyntaxNode root, SyntaxToken original, SyntaxToken replacement\);
* &emsp; \| &emsp; protected static SyntaxNode ReplaceWithTrivia\<TNode>\(SyntaxNode root, TNode original, Func\<TNode, SyntaxNode> replacer\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public abstract SyntaxNode ReturnStatement\(SyntaxNode expression = null\);
* &emsp; \| &emsp; public abstract SyntaxNode StructDeclaration\(string name, IEnumerable\<string> typeParameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable\<SyntaxNode> interfaceTypes = null, IEnumerable\<SyntaxNode> members = null\);
* &emsp; \| &emsp; public abstract SyntaxNode SubtractExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public SyntaxNode SwitchSection\(SyntaxNode caseExpression, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode SwitchSection\(IEnumerable\<SyntaxNode> caseExpressions, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode SwitchStatement\(SyntaxNode expression, IEnumerable\<SyntaxNode> sections\);
* &emsp; \| &emsp; public SyntaxNode SwitchStatement\(SyntaxNode expression, params SyntaxNode\[\] sections\);
* &emsp; \| &emsp; public abstract SyntaxNode ThisExpression\(\);
* &emsp; \| &emsp; public abstract SyntaxNode ThrowExpression\(SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode ThrowStatement\(SyntaxNode expression = null\);
* &emsp; \| &emsp; public SyntaxNode TrueLiteralExpression\(\);
* &emsp; \| &emsp; public abstract SyntaxNode TryCastExpression\(SyntaxNode expression, SyntaxNode type\);
* &emsp; \| &emsp; public SyntaxNode TryCastExpression\(SyntaxNode expression, ITypeSymbol type\);
* &emsp; \| &emsp; public SyntaxNode TryCatchStatement\(IEnumerable\<SyntaxNode> tryStatements, params SyntaxNode\[\] catchClauses\);
* &emsp; \| &emsp; public abstract SyntaxNode TryCatchStatement\(IEnumerable\<SyntaxNode> tryStatements, IEnumerable\<SyntaxNode> catchClauses, IEnumerable\<SyntaxNode> finallyStatements = null\);
* &emsp; \| &emsp; public SyntaxNode TryFinallyStatement\(IEnumerable\<SyntaxNode> tryStatements, IEnumerable\<SyntaxNode> finallyStatements\);
* &emsp; \| &emsp; public abstract SyntaxNode TypeExpression\(SpecialType specialType\);
* &emsp; \| &emsp; public abstract SyntaxNode TypeExpression\(ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public SyntaxNode TypeExpression\(ITypeSymbol typeSymbol, bool addImport\);
* &emsp; \| &emsp; public abstract SyntaxNode TypeOfExpression\(SyntaxNode type\);
* &emsp; \| &emsp; public abstract SyntaxNode TypedConstantExpression\(TypedConstant value\);
* &emsp; \| &emsp; public abstract SyntaxNode UsingStatement\(SyntaxNode expression, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public SyntaxNode UsingStatement\(string name, SyntaxNode expression, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode UsingStatement\(SyntaxNode type, string name, SyntaxNode expression, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode ValueEqualsExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public abstract SyntaxNode ValueNotEqualsExpression\(SyntaxNode left, SyntaxNode right\);
* &emsp; \| &emsp; public SyntaxNode ValueReturningLambdaExpression\(SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode ValueReturningLambdaExpression\(IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode ValueReturningLambdaExpression\(IEnumerable\<SyntaxNode> lambdaParameters, SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode ValueReturningLambdaExpression\(IEnumerable\<SyntaxNode> lambdaParameters, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public SyntaxNode ValueReturningLambdaExpression\(string parameterName, SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode ValueReturningLambdaExpression\(string parameterName, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public SyntaxNode VoidReturningLambdaExpression\(SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode VoidReturningLambdaExpression\(IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode VoidReturningLambdaExpression\(IEnumerable\<SyntaxNode> lambdaParameters, SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode VoidReturningLambdaExpression\(IEnumerable\<SyntaxNode> lambdaParameters, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public SyntaxNode VoidReturningLambdaExpression\(string parameterName, SyntaxNode expression\);
* &emsp; \| &emsp; public SyntaxNode VoidReturningLambdaExpression\(string parameterName, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode WhileStatement\(SyntaxNode condition, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode WithAccessibility\(SyntaxNode declaration, Accessibility accessibility\);
* &emsp; \| &emsp; public abstract SyntaxNode WithExpression\(SyntaxNode declaration, SyntaxNode expression\);
* &emsp; \| &emsp; public abstract SyntaxNode WithGetAccessorStatements\(SyntaxNode declaration, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode WithModifiers\(SyntaxNode declaration, DeclarationModifiers modifiers\);
* &emsp; \| &emsp; public abstract SyntaxNode WithName\(SyntaxNode declaration, string name\);
* &emsp; \| &emsp; public abstract SyntaxNode WithSetAccessorStatements\(SyntaxNode declaration, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode WithStatements\(SyntaxNode declaration, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public abstract SyntaxNode WithType\(SyntaxNode declaration, SyntaxNode type\);
* &emsp; \| &emsp; public abstract SyntaxNode WithTypeArguments\(SyntaxNode expression, IEnumerable\<SyntaxNode> typeArguments\);
* &emsp; \| &emsp; public SyntaxNode WithTypeArguments\(SyntaxNode expression, params SyntaxNode\[\] typeArguments\);
* &emsp; \| &emsp; public SyntaxNode WithTypeConstraint\(SyntaxNode declaration, string typeParameterName, params SyntaxNode\[\] types\);
* &emsp; \| &emsp; public abstract SyntaxNode WithTypeConstraint\(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable\<SyntaxNode> types = null\);
* &emsp; \| &emsp; public SyntaxNode WithTypeConstraint\(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, params SyntaxNode\[\] types\);
* &emsp; \| &emsp; public abstract SyntaxNode WithTypeParameters\(SyntaxNode declaration, IEnumerable\<string> typeParameters\);
* &emsp; \| &emsp; public SyntaxNode WithTypeParameters\(SyntaxNode declaration, params string\[\] typeParameters\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Emit\.EmitBaseline
* &emsp; \| &emsp; public ModuleMetadata OriginalMetadata \{ get; \}
* &emsp; \| &emsp; public static EmitBaseline CreateInitialBaseline\(ModuleMetadata module, Func\<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider\);
* &emsp; public sealed class Microsoft\.CodeAnalysis\.Emit\.EmitOptions : IEquatable\<EmitOptions>
* &emsp; \| &emsp; public EmitOptions\(bool metadataOnly, DebugInformationFormat debugInformationFormat, string pdbFilePath, string outputNameOverride, int fileAlignment, ulong baseAddress, bool highEntropyVirtualAddressSpace, SubsystemVersion subsystemVersion, string runtimeMetadataVersion, bool tolerateErrors, bool includePrivateMembers\);
* &emsp; \| &emsp; public EmitOptions\(bool metadataOnly = false, DebugInformationFormat debugInformationFormat = \(DebugInformationFormat\)0, string pdbFilePath = null, string outputNameOverride = null, int fileAlignment = 0, ulong baseAddress = 0, bool highEntropyVirtualAddressSpace = false, SubsystemVersion subsystemVersion = default, string runtimeMetadataVersion = null, bool tolerateErrors = false, bool includePrivateMembers = true, ImmutableArray\<InstrumentationKind> instrumentationKinds = default\);
* &emsp; \| &emsp; public ulong BaseAddress \{ get; \}
* &emsp; \| &emsp; public DebugInformationFormat DebugInformationFormat \{ get; \}
* &emsp; \| &emsp; public bool EmitMetadataOnly \{ get; \}
* &emsp; \| &emsp; public int FileAlignment \{ get; \}
* &emsp; \| &emsp; public bool HighEntropyVirtualAddressSpace \{ get; \}
* &emsp; \| &emsp; public bool IncludePrivateMembers \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<InstrumentationKind> InstrumentationKinds \{ get; \}
* &emsp; \| &emsp; public string OutputNameOverride \{ get; \}
* &emsp; \| &emsp; public string PdbFilePath \{ get; \}
* &emsp; \| &emsp; public string RuntimeMetadataVersion \{ get; \}
* &emsp; \| &emsp; public SubsystemVersion SubsystemVersion \{ get; \}
* &emsp; \| &emsp; public bool TolerateErrors \{ get; \}
* &emsp; \| &emsp; public override bool Equals\(object obj\);
* &emsp; \| &emsp; public bool Equals\(EmitOptions other\);
* &emsp; \| &emsp; public override int GetHashCode\(\);
* &emsp; \| &emsp; public EmitOptions WithBaseAddress\(ulong value\);
* &emsp; \| &emsp; public EmitOptions WithDebugInformationFormat\(DebugInformationFormat format\);
* &emsp; \| &emsp; public EmitOptions WithEmitMetadataOnly\(bool value\);
* &emsp; \| &emsp; public EmitOptions WithFileAlignment\(int value\);
* &emsp; \| &emsp; public EmitOptions WithHighEntropyVirtualAddressSpace\(bool value\);
* &emsp; \| &emsp; public EmitOptions WithIncludePrivateMembers\(bool value\);
* &emsp; \| &emsp; public EmitOptions WithInstrumentationKinds\(ImmutableArray\<InstrumentationKind> instrumentationKinds\);
* &emsp; \| &emsp; public EmitOptions WithOutputNameOverride\(string outputName\);
* &emsp; \| &emsp; public EmitOptions WithPdbFilePath\(string path\);
* &emsp; \| &emsp; public EmitOptions WithRuntimeMetadataVersion\(string version\);
* &emsp; \| &emsp; public EmitOptions WithSubsystemVersion\(SubsystemVersion subsystemVersion\);
* &emsp; \| &emsp; public EmitOptions WithTolerateErrors\(bool value\);
* &emsp; \| &emsp; public static bool operator ==\(EmitOptions left, EmitOptions right\);
* &emsp; \| &emsp; public static bool operator \!=\(EmitOptions left, EmitOptions right\);
* &emsp; public class Microsoft\.CodeAnalysis\.Emit\.EmitResult
* &emsp; \| &emsp; public ImmutableArray\<Diagnostic> Diagnostics \{ get; \}
* &emsp; \| &emsp; public bool Success \{ get; \}
* &emsp; \| &emsp; protected virtual string GetDebuggerDisplay\(\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.Emit\.EmitDifferenceResult : EmitResult
* &emsp; \| &emsp; \| &emsp; public EmitBaseline Baseline \{ get; \}
* &emsp; public class Microsoft\.CodeAnalysis\.FindSymbols\.ReferencedSymbol
* &emsp; \| &emsp; public ISymbol Definition \{ get; \}
* &emsp; \| &emsp; public IEnumerable\<ReferenceLocation> Locations \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Host\.HostLanguageServices
* &emsp; \| &emsp; protected HostLanguageServices\(\);
* &emsp; \| &emsp; public abstract string Language \{ get; \}
* &emsp; \| &emsp; public abstract HostWorkspaceServices WorkspaceServices \{ get; \}
* &emsp; \| &emsp; public TLanguageService GetRequiredService\<TLanguageService>\(\) where TLanguageService : ILanguageService;
* &emsp; \| &emsp; public abstract TLanguageService GetService\<TLanguageService>\(\) where TLanguageService : ILanguageService;
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Host\.HostServices
* &emsp; \| &emsp; protected HostServices\(\);
* &emsp; \| &emsp; protected internal abstract HostWorkspaceServices CreateWorkspaceServices\(Workspace workspace\);
* &emsp; \| &emsp; public class Microsoft\.CodeAnalysis\.Host\.Mef\.MefHostServices : HostServices, IMefHostExportProvider
* &emsp; \| &emsp; \| &emsp; public MefHostServices\(CompositionContext compositionContext\);
* &emsp; \| &emsp; \| &emsp; public static ImmutableArray\<Assembly> DefaultAssemblies \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static MefHostServices DefaultHost \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static MefHostServices Create\(IEnumerable\<Assembly> assemblies\);
* &emsp; \| &emsp; \| &emsp; public static MefHostServices Create\(CompositionContext compositionContext\);
* &emsp; \| &emsp; \| &emsp; protected internal override HostWorkspaceServices CreateWorkspaceServices\(Workspace workspace\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Host\.HostWorkspaceServices
* &emsp; \| &emsp; protected HostWorkspaceServices\(\);
* &emsp; \| &emsp; public abstract HostServices HostServices \{ get; \}
* &emsp; \| &emsp; public virtual IPersistentStorageService PersistentStorage \{ get; \}
* &emsp; \| &emsp; public virtual IEnumerable\<string> SupportedLanguages \{ get; \}
* &emsp; \| &emsp; public virtual ITemporaryStorageService TemporaryStorage \{ get; \}
* &emsp; \| &emsp; public abstract Workspace Workspace \{ get; \}
* &emsp; \| &emsp; public abstract IEnumerable\<TLanguageService> FindLanguageServices\<TLanguageService>\(HostWorkspaceServices\.MetadataFilter filter\);
* &emsp; \| &emsp; public virtual HostLanguageServices GetLanguageServices\(string languageName\);
* &emsp; \| &emsp; public TWorkspaceService GetRequiredService\<TWorkspaceService>\(\) where TWorkspaceService : IWorkspaceService;
* &emsp; \| &emsp; public abstract TWorkspaceService GetService\<TWorkspaceService>\(\) where TWorkspaceService : IWorkspaceService;
* &emsp; \| &emsp; public virtual bool IsSupported\(string languageName\);
* &emsp; public class Microsoft\.CodeAnalysis\.Options\.Option\<T> : IOption
* &emsp; \| &emsp; public Option\(string feature, string name\);
* &emsp; \| &emsp; public Option\(string feature, string name, T defaultValue\);
* &emsp; \| &emsp; public Option\(string feature, string name, T defaultValue, params OptionStorageLocation\[\] storageLocations\);
* &emsp; \| &emsp; public T DefaultValue \{ get; \}
* &emsp; \| &emsp; public string Feature \{ get; \}
* &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<OptionStorageLocation> StorageLocations \{ get; \}
* &emsp; \| &emsp; public Type Type \{ get; \}
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public static implicit operator OptionKey\(Option\<T> option\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Options\.OptionSet
* &emsp; \| &emsp; protected OptionSet\(\);
* &emsp; \| &emsp; public abstract object GetOption\(OptionKey optionKey\);
* &emsp; \| &emsp; public T GetOption\<T>\(Option\<T> option\);
* &emsp; \| &emsp; public T GetOption\<T>\(PerLanguageOption\<T> option, string language\);
* &emsp; \| &emsp; public abstract OptionSet WithChangedOption\(OptionKey optionAndLanguage, object value\);
* &emsp; \| &emsp; public OptionSet WithChangedOption\<T>\(Option\<T> option, T value\);
* &emsp; \| &emsp; public OptionSet WithChangedOption\<T>\(PerLanguageOption\<T> option, string language, T value\);
* &emsp; \| &emsp; public sealed class Microsoft\.CodeAnalysis\.Options\.DocumentOptionSet : OptionSet
* &emsp; \| &emsp; \| &emsp; public override object GetOption\(OptionKey optionKey\);
* &emsp; \| &emsp; \| &emsp; public T GetOption\<T>\(PerLanguageOption\<T> option\);
* &emsp; \| &emsp; \| &emsp; public override OptionSet WithChangedOption\(OptionKey optionAndLanguage, object value\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Options\.OptionStorageLocation
* &emsp; \| &emsp; protected OptionStorageLocation\(\);
* &emsp; public class Microsoft\.CodeAnalysis\.Options\.PerLanguageOption\<T> : IOption
* &emsp; \| &emsp; public PerLanguageOption\(string feature, string name, T defaultValue\);
* &emsp; \| &emsp; public PerLanguageOption\(string feature, string name, T defaultValue, params OptionStorageLocation\[\] storageLocations\);
* &emsp; \| &emsp; public T DefaultValue \{ get; \}
* &emsp; \| &emsp; public string Feature \{ get; \}
* &emsp; \| &emsp; public string Name \{ get; \}
* &emsp; \| &emsp; public ImmutableArray\<OptionStorageLocation> StorageLocations \{ get; \}
* &emsp; \| &emsp; public Type Type \{ get; \}
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Semantics\.OperationVisitor
* &emsp; \| &emsp; protected OperationVisitor\(\);
* &emsp; \| &emsp; public virtual void DefaultVisit\(IOperation operation\);
* &emsp; \| &emsp; public virtual void Visit\(IOperation operation\);
* &emsp; \| &emsp; public virtual void VisitAddressOfExpression\(IAddressOfExpression operation\);
* &emsp; \| &emsp; public virtual void VisitArgument\(IArgument operation\);
* &emsp; \| &emsp; public virtual void VisitArrayCreationExpression\(IArrayCreationExpression operation\);
* &emsp; \| &emsp; public virtual void VisitArrayElementReferenceExpression\(IArrayElementReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitArrayInitializer\(IArrayInitializer operation\);
* &emsp; \| &emsp; public virtual void VisitAssignmentExpression\(IAssignmentExpression operation\);
* &emsp; \| &emsp; public virtual void VisitAwaitExpression\(IAwaitExpression operation\);
* &emsp; \| &emsp; public virtual void VisitBinaryOperatorExpression\(IBinaryOperatorExpression operation\);
* &emsp; \| &emsp; public virtual void VisitBlockStatement\(IBlockStatement operation\);
* &emsp; \| &emsp; public virtual void VisitBranchStatement\(IBranchStatement operation\);
* &emsp; \| &emsp; public virtual void VisitCatchClause\(ICatchClause operation\);
* &emsp; \| &emsp; public virtual void VisitCompoundAssignmentExpression\(ICompoundAssignmentExpression operation\);
* &emsp; \| &emsp; public virtual void VisitConditionalAccessExpression\(IConditionalAccessExpression operation\);
* &emsp; \| &emsp; public virtual void VisitConditionalAccessInstanceExpression\(IConditionalAccessInstanceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitConditionalChoiceExpression\(IConditionalChoiceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitConversionExpression\(IConversionExpression operation\);
* &emsp; \| &emsp; public virtual void VisitDefaultValueExpression\(IDefaultValueExpression operation\);
* &emsp; \| &emsp; public virtual void VisitEmptyStatement\(IEmptyStatement operation\);
* &emsp; \| &emsp; public virtual void VisitEndStatement\(IEndStatement operation\);
* &emsp; \| &emsp; public virtual void VisitEventAssignmentExpression\(IEventAssignmentExpression operation\);
* &emsp; \| &emsp; public virtual void VisitEventReferenceExpression\(IEventReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitExpressionStatement\(IExpressionStatement operation\);
* &emsp; \| &emsp; public virtual void VisitFieldInitializer\(IFieldInitializer operation\);
* &emsp; \| &emsp; public virtual void VisitFieldReferenceExpression\(IFieldReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitFixedStatement\(IFixedStatement operation\);
* &emsp; \| &emsp; public virtual void VisitForEachLoopStatement\(IForEachLoopStatement operation\);
* &emsp; \| &emsp; public virtual void VisitForLoopStatement\(IForLoopStatement operation\);
* &emsp; \| &emsp; public virtual void VisitIfStatement\(IIfStatement operation\);
* &emsp; \| &emsp; public virtual void VisitIncrementExpression\(IIncrementExpression operation\);
* &emsp; \| &emsp; public virtual void VisitIndexedPropertyReferenceExpression\(IIndexedPropertyReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitInstanceReferenceExpression\(IInstanceReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitInvalidExpression\(IInvalidExpression operation\);
* &emsp; \| &emsp; public virtual void VisitInvalidStatement\(IInvalidStatement operation\);
* &emsp; \| &emsp; public virtual void VisitInvocationExpression\(IInvocationExpression operation\);
* &emsp; \| &emsp; public virtual void VisitIsTypeExpression\(IIsTypeExpression operation\);
* &emsp; \| &emsp; public virtual void VisitLabelStatement\(ILabelStatement operation\);
* &emsp; \| &emsp; public virtual void VisitLambdaExpression\(ILambdaExpression operation\);
* &emsp; \| &emsp; public virtual void VisitLateBoundMemberReferenceExpression\(ILateBoundMemberReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitLiteralExpression\(ILiteralExpression operation\);
* &emsp; \| &emsp; public virtual void VisitLocalReferenceExpression\(ILocalReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitLockStatement\(ILockStatement operation\);
* &emsp; \| &emsp; public virtual void VisitMethodBindingExpression\(IMethodBindingExpression operation\);
* &emsp; \| &emsp; public virtual void VisitNullCoalescingExpression\(INullCoalescingExpression operation\);
* &emsp; \| &emsp; public virtual void VisitObjectCreationExpression\(IObjectCreationExpression operation\);
* &emsp; \| &emsp; public virtual void VisitOmittedArgumentExpression\(IOmittedArgumentExpression operation\);
* &emsp; \| &emsp; public virtual void VisitParameterInitializer\(IParameterInitializer operation\);
* &emsp; \| &emsp; public virtual void VisitParameterReferenceExpression\(IParameterReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitParenthesizedExpression\(IParenthesizedExpression operation\);
* &emsp; \| &emsp; public virtual void VisitPlaceholderExpression\(IPlaceholderExpression operation\);
* &emsp; \| &emsp; public virtual void VisitPointerIndirectionReferenceExpression\(IPointerIndirectionReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitPropertyInitializer\(IPropertyInitializer operation\);
* &emsp; \| &emsp; public virtual void VisitPropertyReferenceExpression\(IPropertyReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitRangeCaseClause\(IRangeCaseClause operation\);
* &emsp; \| &emsp; public virtual void VisitRelationalCaseClause\(IRelationalCaseClause operation\);
* &emsp; \| &emsp; public virtual void VisitReturnStatement\(IReturnStatement operation\);
* &emsp; \| &emsp; public virtual void VisitSingleValueCaseClause\(ISingleValueCaseClause operation\);
* &emsp; \| &emsp; public virtual void VisitSizeOfExpression\(ISizeOfExpression operation\);
* &emsp; \| &emsp; public virtual void VisitStopStatement\(IStopStatement operation\);
* &emsp; \| &emsp; public virtual void VisitSwitchCase\(ISwitchCase operation\);
* &emsp; \| &emsp; public virtual void VisitSwitchStatement\(ISwitchStatement operation\);
* &emsp; \| &emsp; public virtual void VisitSyntheticLocalReferenceExpression\(ISyntheticLocalReferenceExpression operation\);
* &emsp; \| &emsp; public virtual void VisitThrowStatement\(IThrowStatement operation\);
* &emsp; \| &emsp; public virtual void VisitTryStatement\(ITryStatement operation\);
* &emsp; \| &emsp; public virtual void VisitTypeOfExpression\(ITypeOfExpression operation\);
* &emsp; \| &emsp; public virtual void VisitTypeParameterObjectCreationExpression\(ITypeParameterObjectCreationExpression operation\);
* &emsp; \| &emsp; public virtual void VisitUnaryOperatorExpression\(IUnaryOperatorExpression operation\);
* &emsp; \| &emsp; public virtual void VisitUnboundLambdaExpression\(IUnboundLambdaExpression operation\);
* &emsp; \| &emsp; public virtual void VisitUsingStatement\(IUsingStatement operation\);
* &emsp; \| &emsp; public virtual void VisitVariableDeclaration\(IVariableDeclaration operation\);
* &emsp; \| &emsp; public virtual void VisitVariableDeclarationStatement\(IVariableDeclarationStatement operation\);
* &emsp; \| &emsp; public virtual void VisitWhileUntilLoopStatement\(IWhileUntilLoopStatement operation\);
* &emsp; \| &emsp; public virtual void VisitWithStatement\(IWithStatement operation\);
* &emsp; \| &emsp; public virtual void VisitYieldBreakStatement\(IReturnStatement operation\);
* &emsp; \| &emsp; public abstract class Microsoft\.CodeAnalysis\.Semantics\.OperationWalker : OperationVisitor
* &emsp; \| &emsp; \| &emsp; protected OperationWalker\(\);
* &emsp; \| &emsp; \| &emsp; public override void Visit\(IOperation operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitAddressOfExpression\(IAddressOfExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitArgument\(IArgument operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitArrayCreationExpression\(IArrayCreationExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitArrayElementReferenceExpression\(IArrayElementReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitArrayInitializer\(IArrayInitializer operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitAssignmentExpression\(IAssignmentExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitAwaitExpression\(IAwaitExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitBinaryOperatorExpression\(IBinaryOperatorExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitBlockStatement\(IBlockStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitBranchStatement\(IBranchStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitCatchClause\(ICatchClause operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitCompoundAssignmentExpression\(ICompoundAssignmentExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitConditionalAccessExpression\(IConditionalAccessExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitConditionalAccessInstanceExpression\(IConditionalAccessInstanceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitConditionalChoiceExpression\(IConditionalChoiceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitConversionExpression\(IConversionExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitDefaultValueExpression\(IDefaultValueExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitEmptyStatement\(IEmptyStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitEndStatement\(IEndStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitEventAssignmentExpression\(IEventAssignmentExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitEventReferenceExpression\(IEventReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitExpressionStatement\(IExpressionStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitFieldInitializer\(IFieldInitializer operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitFieldReferenceExpression\(IFieldReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitFixedStatement\(IFixedStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitForEachLoopStatement\(IForEachLoopStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitForLoopStatement\(IForLoopStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitIfStatement\(IIfStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitIncrementExpression\(IIncrementExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitIndexedPropertyReferenceExpression\(IIndexedPropertyReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitInstanceReferenceExpression\(IInstanceReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitInvalidExpression\(IInvalidExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitInvalidStatement\(IInvalidStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitInvocationExpression\(IInvocationExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitIsTypeExpression\(IIsTypeExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitLabelStatement\(ILabelStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitLambdaExpression\(ILambdaExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitLateBoundMemberReferenceExpression\(ILateBoundMemberReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitLiteralExpression\(ILiteralExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitLocalReferenceExpression\(ILocalReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitLockStatement\(ILockStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitMethodBindingExpression\(IMethodBindingExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitNullCoalescingExpression\(INullCoalescingExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitObjectCreationExpression\(IObjectCreationExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitOmittedArgumentExpression\(IOmittedArgumentExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitParameterInitializer\(IParameterInitializer operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitParameterReferenceExpression\(IParameterReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitParenthesizedExpression\(IParenthesizedExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitPlaceholderExpression\(IPlaceholderExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitPointerIndirectionReferenceExpression\(IPointerIndirectionReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitPropertyInitializer\(IPropertyInitializer operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitPropertyReferenceExpression\(IPropertyReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitRangeCaseClause\(IRangeCaseClause operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitRelationalCaseClause\(IRelationalCaseClause operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitReturnStatement\(IReturnStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitSingleValueCaseClause\(ISingleValueCaseClause operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitSizeOfExpression\(ISizeOfExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitStopStatement\(IStopStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitSwitchCase\(ISwitchCase operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitSwitchStatement\(ISwitchStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitSyntheticLocalReferenceExpression\(ISyntheticLocalReferenceExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitThrowStatement\(IThrowStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitTryStatement\(ITryStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitTypeOfExpression\(ITypeOfExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitTypeParameterObjectCreationExpression\(ITypeParameterObjectCreationExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitUnaryOperatorExpression\(IUnaryOperatorExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitUnboundLambdaExpression\(IUnboundLambdaExpression operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitUsingStatement\(IUsingStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitVariableDeclaration\(IVariableDeclaration operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitVariableDeclarationStatement\(IVariableDeclarationStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitWhileUntilLoopStatement\(IWhileUntilLoopStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitWithStatement\(IWithStatement operation\);
* &emsp; \| &emsp; \| &emsp; public override void VisitYieldBreakStatement\(IReturnStatement operation\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Semantics\.OperationVisitor\<TArgument, TResult>
* &emsp; \| &emsp; protected OperationVisitor\(\);
* &emsp; \| &emsp; public virtual TResult DefaultVisit\(IOperation operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult Visit\(IOperation operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitAddressOfExpression\(IAddressOfExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitArgument\(IArgument operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitArrayCreationExpression\(IArrayCreationExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitArrayElementReferenceExpression\(IArrayElementReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitArrayInitializer\(IArrayInitializer operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitAssignmentExpression\(IAssignmentExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitAwaitExpression\(IAwaitExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitBinaryOperatorExpression\(IBinaryOperatorExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitBlockStatement\(IBlockStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitBranchStatement\(IBranchStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitCatchClause\(ICatchClause operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitCompoundAssignmentExpression\(ICompoundAssignmentExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitConditionalAccessExpression\(IConditionalAccessExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitConditionalAccessInstanceExpression\(IConditionalAccessInstanceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitConditionalChoiceExpression\(IConditionalChoiceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitConversionExpression\(IConversionExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitDefaultValueExpression\(IDefaultValueExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitEmptyStatement\(IEmptyStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitEndStatement\(IEndStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitEventAssignmentExpression\(IEventAssignmentExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitEventReferenceExpression\(IEventReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitExpressionStatement\(IExpressionStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitFieldInitializer\(IFieldInitializer operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitFieldReferenceExpression\(IFieldReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitFixedStatement\(IFixedStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitForEachLoopStatement\(IForEachLoopStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitForLoopStatement\(IForLoopStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitIfStatement\(IIfStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitIncrementExpression\(IIncrementExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitIndexedPropertyReferenceExpression\(IIndexedPropertyReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitInstanceReferenceExpression\(IInstanceReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitInvalidExpression\(IInvalidExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitInvalidStatement\(IInvalidStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitInvocationExpression\(IInvocationExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitIsTypeExpression\(IIsTypeExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitLabelStatement\(ILabelStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitLambdaExpression\(ILambdaExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitLateBoundMemberReferenceExpression\(ILateBoundMemberReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitLiteralExpression\(ILiteralExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitLocalReferenceExpression\(ILocalReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitLockStatement\(ILockStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitMethodBindingExpression\(IMethodBindingExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitNullCoalescingExpression\(INullCoalescingExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitObjectCreationExpression\(IObjectCreationExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitOmittedArgumentExpression\(IOmittedArgumentExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitParameterInitializer\(IParameterInitializer operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitParameterReferenceExpression\(IParameterReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitParenthesizedExpression\(IParenthesizedExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitPlaceholderExpression\(IPlaceholderExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitPointerIndirectionReferenceExpression\(IPointerIndirectionReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitPropertyInitializer\(IPropertyInitializer operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitPropertyReferenceExpression\(IPropertyReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitRangeCaseClause\(IRangeCaseClause operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitRelationalCaseClause\(IRelationalCaseClause operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitReturnStatement\(IReturnStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitSingleValueCaseClause\(ISingleValueCaseClause operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitSizeOfExpression\(ISizeOfExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitStopStatement\(IStopStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitSwitchCase\(ISwitchCase operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitSwitchStatement\(ISwitchStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitSyntheticLocalReferenceExpression\(ISyntheticLocalReferenceExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitThrowStatement\(IThrowStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitTryStatement\(ITryStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitTypeOfExpression\(ITypeOfExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitTypeParameterObjectCreationExpression\(ITypeParameterObjectCreationExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitUnaryOperatorExpression\(IUnaryOperatorExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitUnboundLambdaExpression\(IUnboundLambdaExpression operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitUsingStatement\(IUsingStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitVariableDeclaration\(IVariableDeclaration operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitVariableDeclarationStatement\(IVariableDeclarationStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitWhileUntilLoopStatement\(IWhileUntilLoopStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitWithStatement\(IWithStatement operation, TArgument argument\);
* &emsp; \| &emsp; public virtual TResult VisitYieldBreakStatement\(IReturnStatement operation, TArgument argument\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Text\.SourceText
* &emsp; \| &emsp; protected SourceText\(ImmutableArray\<byte> checksum = default, SourceHashAlgorithm checksumAlgorithm = Sha1, SourceTextContainer container = null\);
* &emsp; \| &emsp; public bool CanBeEmbedded \{ get; \}
* &emsp; \| &emsp; public SourceHashAlgorithm ChecksumAlgorithm \{ get; \}
* &emsp; \| &emsp; public virtual SourceTextContainer Container \{ get; \}
* &emsp; \| &emsp; public abstract Encoding Encoding \{ get; \}
* &emsp; \| &emsp; public abstract int Length \{ get; \}
* &emsp; \| &emsp; public TextLineCollection Lines \{ get; \}
* &emsp; \| &emsp; public abstract char this\[int position\] \{ get; \}
* &emsp; \| &emsp; public bool ContentEquals\(SourceText other\);
* &emsp; \| &emsp; protected virtual bool ContentEqualsImpl\(SourceText other\);
* &emsp; \| &emsp; public abstract void CopyTo\(int sourceIndex, char\[\] destination, int destinationIndex, int count\);
* &emsp; \| &emsp; public static SourceText From\(string text, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1\);
* &emsp; \| &emsp; public static SourceText From\(TextReader reader, int length, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1\);
* &emsp; \| &emsp; public static SourceText From\(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected\);
* &emsp; \| &emsp; public static SourceText From\(byte\[\] buffer, int length, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected\);
* &emsp; \| &emsp; public static SourceText From\(Stream stream, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false\);
* &emsp; \| &emsp; public static SourceText From\(byte\[\] buffer, int length, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false\);
* &emsp; \| &emsp; public virtual IReadOnlyList\<TextChangeRange> GetChangeRanges\(SourceText oldText\);
* &emsp; \| &emsp; public ImmutableArray\<byte> GetChecksum\(\);
* &emsp; \| &emsp; protected virtual TextLineCollection GetLinesCore\(\);
* &emsp; \| &emsp; public virtual SourceText GetSubText\(TextSpan span\);
* &emsp; \| &emsp; public SourceText GetSubText\(int start\);
* &emsp; \| &emsp; public virtual IReadOnlyList\<TextChange> GetTextChanges\(SourceText oldText\);
* &emsp; \| &emsp; public SourceText Replace\(TextSpan span, string newText\);
* &emsp; \| &emsp; public SourceText Replace\(int start, int length, string newText\);
* &emsp; \| &emsp; public override string ToString\(\);
* &emsp; \| &emsp; public virtual string ToString\(TextSpan span\);
* &emsp; \| &emsp; public virtual SourceText WithChanges\(IEnumerable\<TextChange> changes\);
* &emsp; \| &emsp; public SourceText WithChanges\(params TextChange\[\] changes\);
* &emsp; \| &emsp; public void Write\(TextWriter textWriter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public virtual void Write\(TextWriter writer, TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Text\.SourceTextContainer
* &emsp; \| &emsp; protected SourceTextContainer\(\);
* &emsp; \| &emsp; public abstract event EventHandler\<TextChangeEventArgs> TextChanged;
* &emsp; \| &emsp; public abstract SourceText CurrentText \{ get; \}
* &emsp; public abstract class Microsoft\.CodeAnalysis\.Text\.TextLineCollection : IEnumerable\<TextLine>, IReadOnlyCollection\<TextLine>, IReadOnlyList\<TextLine>
* &emsp; \| &emsp; protected TextLineCollection\(\);
* &emsp; \| &emsp; public abstract int Count \{ get; \}
* &emsp; \| &emsp; public abstract TextLine this\[int index\] \{ get; \}
* &emsp; \| &emsp; public TextLineCollection\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; public virtual TextLine GetLineFromPosition\(int position\);
* &emsp; \| &emsp; public virtual LinePosition GetLinePosition\(int position\);
* &emsp; \| &emsp; public LinePositionSpan GetLinePositionSpan\(TextSpan span\);
* &emsp; \| &emsp; public int GetPosition\(LinePosition position\);
* &emsp; \| &emsp; public TextSpan GetTextSpan\(LinePositionSpan span\);
* &emsp; \| &emsp; public abstract int IndexOf\(int position\);
* &emsp; public abstract class Roslynator\.NameGenerator
* &emsp; \| &emsp; protected NameGenerator\(\);
* &emsp; \| &emsp; public static NameGenerator Default \{ get; \}
* &emsp; \| &emsp; public static string CreateName\(ITypeSymbol typeSymbol, bool firstCharToLower = false\);
* &emsp; \| &emsp; public string EnsureUniqueEnumMemberName\(string baseName, INamedTypeSymbol enumType, bool isCaseSensitive = true\);
* &emsp; \| &emsp; public string EnsureUniqueLocalName\(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public string EnsureUniqueMemberName\(string baseName, INamedTypeSymbol typeSymbol, bool isCaseSensitive = true\);
* &emsp; \| &emsp; public string EnsureUniqueMemberName\(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public abstract string EnsureUniqueName\(string baseName, IEnumerable\<string> reservedNames, bool isCaseSensitive = true\);
* &emsp; \| &emsp; public abstract string EnsureUniqueName\(string baseName, ImmutableArray\<ISymbol> symbols, bool isCaseSensitive = true\);
* &emsp; \| &emsp; public string EnsureUniqueName\(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true\);
* &emsp; \| &emsp; public static bool IsUniqueName\(string name, IEnumerable\<string> reservedNames, bool isCaseSensitive = true\);
* &emsp; \| &emsp; public static bool IsUniqueName\(string name, ImmutableArray\<ISymbol> symbols, bool isCaseSensitive = true\);
* &emsp; public class Roslynator\.SeparatedSyntaxListSelection\<TNode> : ISelection\<TNode> where TNode : SyntaxNode
* &emsp; \| &emsp; protected SeparatedSyntaxListSelection\(SeparatedSyntaxList\<TNode> list, TextSpan span, int firstIndex, int lastIndex\);
* &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; public int FirstIndex \{ get; \}
* &emsp; \| &emsp; public int LastIndex \{ get; \}
* &emsp; \| &emsp; public TextSpan OriginalSpan \{ get; \}
* &emsp; \| &emsp; public SeparatedSyntaxList\<TNode> UnderlyingList \{ get; \}
* &emsp; \| &emsp; public TNode this\[int index\] \{ get; \}
* &emsp; \| &emsp; public static SeparatedSyntaxListSelection\<TNode> Create\(SeparatedSyntaxList\<TNode> list, TextSpan span\);
* &emsp; \| &emsp; public TNode First\(\);
* &emsp; \| &emsp; public SeparatedSyntaxListSelection\<TNode>\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; public TNode Last\(\);
* &emsp; \| &emsp; public static bool TryCreate\(SeparatedSyntaxList\<TNode> list, TextSpan span, out SeparatedSyntaxListSelection\<TNode> selection\);
* &emsp; public class Roslynator\.SyntaxListSelection\<TNode> : ISelection\<TNode> where TNode : SyntaxNode
* &emsp; \| &emsp; protected SyntaxListSelection\(SyntaxList\<TNode> list, TextSpan span, int firstIndex, int lastIndex\);
* &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; public int FirstIndex \{ get; \}
* &emsp; \| &emsp; public int LastIndex \{ get; \}
* &emsp; \| &emsp; public TextSpan OriginalSpan \{ get; \}
* &emsp; \| &emsp; public SyntaxList\<TNode> UnderlyingList \{ get; \}
* &emsp; \| &emsp; public TNode this\[int index\] \{ get; \}
* &emsp; \| &emsp; public static SyntaxListSelection\<TNode> Create\(SyntaxList\<TNode> list, TextSpan span\);
* &emsp; \| &emsp; public TNode First\(\);
* &emsp; \| &emsp; public SyntaxListSelection\<TNode>\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; public TNode Last\(\);
* &emsp; \| &emsp; public static bool TryCreate\(SyntaxList\<TNode> list, TextSpan span, out SyntaxListSelection\<TNode> selection\);
* &emsp; \| &emsp; public sealed class Roslynator\.CSharp\.MemberDeclarationListSelection : SyntaxListSelection\<MemberDeclarationSyntax>
* &emsp; \| &emsp; \| &emsp; public SyntaxNode Parent \{ get; \}
* &emsp; \| &emsp; \| &emsp; public static MemberDeclarationListSelection Create\(CompilationUnitSyntax compilationUnit, TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public static MemberDeclarationListSelection Create\(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public static MemberDeclarationListSelection Create\(TypeDeclarationSyntax typeDeclaration, TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public static bool TryCreate\(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers\);
* &emsp; \| &emsp; \| &emsp; public static bool TryCreate\(TypeDeclarationSyntax typeDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers\);
* &emsp; \| &emsp; public sealed class Roslynator\.CSharp\.StatementListSelection : SyntaxListSelection\<StatementSyntax>
* &emsp; \| &emsp; \| &emsp; public static StatementListSelection Create\(BlockSyntax block, TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public static StatementListSelection Create\(SwitchSectionSyntax switchSection, TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public static StatementListSelection Create\(in StatementListInfo statementsInfo, TextSpan span\);
* &emsp; \| &emsp; \| &emsp; public static bool TryCreate\(BlockSyntax block, TextSpan span, out StatementListSelection selectedStatements\);
* &emsp; \| &emsp; \| &emsp; public static bool TryCreate\(SwitchSectionSyntax switchSection, TextSpan span, out StatementListSelection selectedStatements\);
* &emsp; public abstract class Roslynator\.CSharp\.ModifierList\<TNode> where TNode : SyntaxNode
* &emsp; \| &emsp; public static ModifierList\<TNode> Instance \{ get; \}
* &emsp; \| &emsp; public TNode Insert\(TNode node, SyntaxKind kind, IComparer\<SyntaxKind> comparer = null\);
* &emsp; \| &emsp; public TNode Insert\(TNode node, SyntaxToken modifier, IComparer\<SyntaxToken> comparer = null\);
* &emsp; \| &emsp; public TNode Remove\(TNode node, SyntaxKind kind\);
* &emsp; \| &emsp; public TNode Remove\(TNode node, SyntaxToken modifier\);
* &emsp; \| &emsp; public TNode RemoveAll\(TNode node\);
* &emsp; \| &emsp; public TNode RemoveAll\(TNode node, Func\<SyntaxToken, bool> predicate\);
* &emsp; \| &emsp; public TNode RemoveAt\(TNode node, int index\);
* &emsp; public class Roslynator\.Text\.TextLineCollectionSelection : ISelection\<TextLine>
* &emsp; \| &emsp; protected TextLineCollectionSelection\(TextLineCollection lines, TextSpan span, int firstIndex, int lastIndex\);
* &emsp; \| &emsp; public int Count \{ get; \}
* &emsp; \| &emsp; public int FirstIndex \{ get; \}
* &emsp; \| &emsp; public int LastIndex \{ get; \}
* &emsp; \| &emsp; public TextSpan OriginalSpan \{ get; \}
* &emsp; \| &emsp; public TextLineCollection UnderlyingLines \{ get; \}
* &emsp; \| &emsp; public TextLine this\[int index\] \{ get; \}
* &emsp; \| &emsp; public static TextLineCollectionSelection Create\(TextLineCollection lines, TextSpan span\);
* &emsp; \| &emsp; public TextLine First\(\);
* &emsp; \| &emsp; public TextLineCollectionSelection\.Enumerator GetEnumerator\(\);
* &emsp; \| &emsp; public TextLine Last\(\);
* &emsp; \| &emsp; public static bool TryCreate\(TextLineCollection lines, TextSpan span, out TextLineCollectionSelection selectedLines\);
* &emsp; public static class Microsoft\.CodeAnalysis\.AnnotationExtensions
* &emsp; \| &emsp; public static TNode WithAdditionalAnnotations\<TNode>\(this TNode node, params SyntaxAnnotation\[\] annotations\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode WithAdditionalAnnotations\<TNode>\(this TNode node, IEnumerable\<SyntaxAnnotation> annotations\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode WithoutAnnotations\<TNode>\(this TNode node, string annotationKind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode WithoutAnnotations\<TNode>\(this TNode node, params SyntaxAnnotation\[\] annotations\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode WithoutAnnotations\<TNode>\(this TNode node, IEnumerable\<SyntaxAnnotation> annotations\) where TNode : SyntaxNode;
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharpExtensions
* &emsp; \| &emsp; public static bool Any\(this SyntaxTriviaList list, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool Any\(this SyntaxTokenList list, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool Any\<TNode>\(this SyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool Any\<TNode>\(this SeparatedSyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static int IndexOf\(this SyntaxTriviaList list, SyntaxKind kind\);
* &emsp; \| &emsp; public static int IndexOf\(this SyntaxTokenList list, SyntaxKind kind\);
* &emsp; \| &emsp; public static int IndexOf\<TNode>\(this SyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static int IndexOf\<TNode>\(this SeparatedSyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxNode node, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxToken token, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxTrivia trivia, SyntaxKind kind\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CaseInsensitiveComparison
* &emsp; \| &emsp; public static StringComparer Comparer \{ get; \}
* &emsp; \| &emsp; public static int Compare\(string left, string right\);
* &emsp; \| &emsp; public static bool EndsWith\(string value, string possibleEnd\);
* &emsp; \| &emsp; public static bool Equals\(string left, string right\);
* &emsp; \| &emsp; public static int GetHashCode\(string value\);
* &emsp; \| &emsp; public static bool StartsWith\(string value, string possibleStart\);
* &emsp; \| &emsp; public static void ToLower\(StringBuilder builder\);
* &emsp; \| &emsp; public static char ToLower\(char c\);
* &emsp; \| &emsp; public static string ToLower\(string value\);
* &emsp; public static class Microsoft\.CodeAnalysis\.DocumentationCommentId
* &emsp; \| &emsp; public static string CreateDeclarationId\(ISymbol symbol\);
* &emsp; \| &emsp; public static string CreateReferenceId\(ISymbol symbol\);
* &emsp; \| &emsp; public static ISymbol GetFirstSymbolForDeclarationId\(string id, Compilation compilation\);
* &emsp; \| &emsp; public static ISymbol GetFirstSymbolForReferenceId\(string id, Compilation compilation\);
* &emsp; \| &emsp; public static ImmutableArray\<ISymbol> GetSymbolsForDeclarationId\(string id, Compilation compilation\);
* &emsp; \| &emsp; public static ImmutableArray\<ISymbol> GetSymbolsForReferenceId\(string id, Compilation compilation\);
* &emsp; public static class Microsoft\.CodeAnalysis\.FileSystemExtensions
* &emsp; \| &emsp; public static EmitResult Emit\(this Compilation compilation, string outputPath, string pdbPath = null, string xmlDocPath = null, string win32ResourcesPath = null, IEnumerable\<ResourceDescription> manifestResources = null, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.ISymbolExtensions
* &emsp; \| &emsp; public static IMethodSymbol GetConstructedReducedFrom\(this IMethodSymbol method\);
* &emsp; public static class Microsoft\.CodeAnalysis\.LanguageNames
* &emsp; \| &emsp; public const string CSharp = "C\#";
* &emsp; \| &emsp; public const string FSharp = "F\#";
* &emsp; \| &emsp; public const string VisualBasic = "Visual Basic";
* &emsp; public static class Microsoft\.CodeAnalysis\.ModelExtensions
* &emsp; \| &emsp; public static ControlFlowAnalysis AnalyzeControlFlow\(this SemanticModel semanticModel, SyntaxNode statement\);
* &emsp; \| &emsp; public static ControlFlowAnalysis AnalyzeControlFlow\(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement\);
* &emsp; \| &emsp; public static DataFlowAnalysis AnalyzeDataFlow\(this SemanticModel semanticModel, SyntaxNode statementOrExpression\);
* &emsp; \| &emsp; public static DataFlowAnalysis AnalyzeDataFlow\(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement\);
* &emsp; \| &emsp; public static IAliasSymbol GetAliasInfo\(this SemanticModel semanticModel, SyntaxNode nameSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetDeclaredSymbol\(this SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ImmutableArray\<ISymbol> GetMemberGroup\(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IAliasSymbol GetSpeculativeAliasInfo\(this SemanticModel semanticModel, int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; public static SymbolInfo GetSpeculativeSymbolInfo\(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; public static TypeInfo GetSpeculativeTypeInfo\(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; public static SymbolInfo GetSymbolInfo\(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static TypeInfo GetTypeInfo\(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.SymbolDisplayExtensions
* &emsp; \| &emsp; public static string ToDisplayString\(this ImmutableArray\<SymbolDisplayPart> parts\);
* &emsp; public static class Microsoft\.CodeAnalysis\.SyntaxNodeExtensions
* &emsp; \| &emsp; public static TNode GetCurrentNode\<TNode>\(this SyntaxNode root, TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static IEnumerable\<TNode> GetCurrentNodes\<TNode>\(this SyntaxNode root, TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static IEnumerable\<TNode> GetCurrentNodes\<TNode>\(this SyntaxNode root, IEnumerable\<TNode> nodes\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TRoot InsertNodesAfter\<TRoot>\(this TRoot root, SyntaxNode nodeInList, IEnumerable\<SyntaxNode> newNodes\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot InsertNodesBefore\<TRoot>\(this TRoot root, SyntaxNode nodeInList, IEnumerable\<SyntaxNode> newNodes\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot InsertTokensAfter\<TRoot>\(this TRoot root, SyntaxToken tokenInList, IEnumerable\<SyntaxToken> newTokens\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot InsertTokensBefore\<TRoot>\(this TRoot root, SyntaxToken tokenInList, IEnumerable\<SyntaxToken> newTokens\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot InsertTriviaAfter\<TRoot>\(this TRoot root, SyntaxTrivia trivia, IEnumerable\<SyntaxTrivia> newTrivia\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot InsertTriviaBefore\<TRoot>\(this TRoot root, SyntaxTrivia trivia, IEnumerable\<SyntaxTrivia> newTrivia\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TNode NormalizeWhitespace\<TNode>\(this TNode node, string indentation, bool elasticTrivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode NormalizeWhitespace\<TNode>\(this TNode node, string indentation = "    ", string eol = "\\r\\n", bool elasticTrivia = false\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TRoot RemoveNode\<TRoot>\(this TRoot root, SyntaxNode node, SyntaxRemoveOptions options\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot RemoveNodes\<TRoot>\(this TRoot root, IEnumerable\<SyntaxNode> nodes, SyntaxRemoveOptions options\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceNode\<TRoot>\(this TRoot root, SyntaxNode oldNode, SyntaxNode newNode\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceNode\<TRoot>\(this TRoot root, SyntaxNode oldNode, IEnumerable\<SyntaxNode> newNodes\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceNodes\<TRoot, TNode>\(this TRoot root, IEnumerable\<TNode> nodes, Func\<TNode, TNode, SyntaxNode> computeReplacementNode\) where TRoot : SyntaxNode where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceSyntax\<TRoot>\(this TRoot root, IEnumerable\<SyntaxNode> nodes, Func\<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, IEnumerable\<SyntaxToken> tokens, Func\<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable\<SyntaxTrivia> trivia, Func\<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceToken\<TRoot>\(this TRoot root, SyntaxToken oldToken, SyntaxToken newToken\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceToken\<TRoot>\(this TRoot root, SyntaxToken tokenInList, IEnumerable\<SyntaxToken> newTokens\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceTokens\<TRoot>\(this TRoot root, IEnumerable\<SyntaxToken> tokens, Func\<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceTrivia\<TRoot>\(this TRoot root, SyntaxTrivia oldTrivia, IEnumerable\<SyntaxTrivia> newTrivia\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceTrivia\<TRoot>\(this TRoot root, IEnumerable\<SyntaxTrivia> trivia, Func\<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot ReplaceTrivia\<TRoot>\(this TRoot root, SyntaxTrivia trivia, SyntaxTrivia newTrivia\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot TrackNodes\<TRoot>\(this TRoot root, IEnumerable\<SyntaxNode> nodes\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TRoot TrackNodes\<TRoot>\(this TRoot root, params SyntaxNode\[\] nodes\) where TRoot : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithLeadingTrivia\<TSyntax>\(this TSyntax node, SyntaxTriviaList trivia\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithLeadingTrivia\<TSyntax>\(this TSyntax node, IEnumerable\<SyntaxTrivia> trivia\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithLeadingTrivia\<TSyntax>\(this TSyntax node, params SyntaxTrivia\[\] trivia\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithTrailingTrivia\<TSyntax>\(this TSyntax node, SyntaxTriviaList trivia\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithTrailingTrivia\<TSyntax>\(this TSyntax node, IEnumerable\<SyntaxTrivia> trivia\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithTrailingTrivia\<TSyntax>\(this TSyntax node, params SyntaxTrivia\[\] trivia\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithTriviaFrom\<TSyntax>\(this TSyntax syntax, SyntaxNode node\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithoutLeadingTrivia\<TSyntax>\(this TSyntax node\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static TSyntax WithoutTrailingTrivia\<TSyntax>\(this TSyntax node\) where TSyntax : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxToken WithoutTrivia\(this SyntaxToken token\);
* &emsp; \| &emsp; public static TSyntax WithoutTrivia\<TSyntax>\(this TSyntax syntax\) where TSyntax : SyntaxNode;
* &emsp; public static class Microsoft\.CodeAnalysis\.WellKnownDiagnosticTags
* &emsp; \| &emsp; public const string AnalyzerException = "AnalyzerException";
* &emsp; \| &emsp; public const string Build = "Build";
* &emsp; \| &emsp; public const string Compiler = "Compiler";
* &emsp; \| &emsp; public const string EditAndContinue = "EditAndContinue";
* &emsp; \| &emsp; public const string NotConfigurable = "NotConfigurable";
* &emsp; \| &emsp; public const string Telemetry = "Telemetry";
* &emsp; \| &emsp; public const string Unnecessary = "Unnecessary";
* &emsp; public static class Microsoft\.CodeAnalysis\.WellKnownMemberNames
* &emsp; \| &emsp; public const string AdditionOperatorName = "op\_Addition";
* &emsp; \| &emsp; public const string BitwiseAndOperatorName = "op\_BitwiseAnd";
* &emsp; \| &emsp; public const string BitwiseOrOperatorName = "op\_BitwiseOr";
* &emsp; \| &emsp; public const string CollectionInitializerAddMethodName = "Add";
* &emsp; \| &emsp; public const string ConcatenateOperatorName = "op\_Concatenate";
* &emsp; \| &emsp; public const string CurrentPropertyName = "Current";
* &emsp; \| &emsp; public const string DecrementOperatorName = "op\_Decrement";
* &emsp; \| &emsp; public const string DefaultScriptClassName = "Script";
* &emsp; \| &emsp; public const string DelegateBeginInvokeName = "BeginInvoke";
* &emsp; \| &emsp; public const string DelegateEndInvokeName = "EndInvoke";
* &emsp; \| &emsp; public const string DelegateInvokeName = "Invoke";
* &emsp; \| &emsp; public const string DestructorName = "Finalize";
* &emsp; \| &emsp; public const string DivisionOperatorName = "op\_Division";
* &emsp; \| &emsp; public const string EntryPointMethodName = "Main";
* &emsp; \| &emsp; public const string EnumBackingFieldName = "value\_\_";
* &emsp; \| &emsp; public const string EqualityOperatorName = "op\_Equality";
* &emsp; \| &emsp; public const string ExclusiveOrOperatorName = "op\_ExclusiveOr";
* &emsp; \| &emsp; public const string ExplicitConversionName = "op\_Explicit";
* &emsp; \| &emsp; public const string ExponentOperatorName = "op\_Exponent";
* &emsp; \| &emsp; public const string FalseOperatorName = "op\_False";
* &emsp; \| &emsp; public const string GetAwaiter = "GetAwaiter";
* &emsp; \| &emsp; public const string GetEnumeratorMethodName = "GetEnumerator";
* &emsp; \| &emsp; public const string GetResult = "GetResult";
* &emsp; \| &emsp; public const string GreaterThanOperatorName = "op\_GreaterThan";
* &emsp; \| &emsp; public const string GreaterThanOrEqualOperatorName = "op\_GreaterThanOrEqual";
* &emsp; \| &emsp; public const string ImplicitConversionName = "op\_Implicit";
* &emsp; \| &emsp; public const string IncrementOperatorName = "op\_Increment";
* &emsp; \| &emsp; public const string Indexer = "this\[\]";
* &emsp; \| &emsp; public const string InequalityOperatorName = "op\_Inequality";
* &emsp; \| &emsp; public const string InstanceConstructorName = "\.ctor";
* &emsp; \| &emsp; public const string IntegerDivisionOperatorName = "op\_IntegerDivision";
* &emsp; \| &emsp; public const string IsCompleted = "IsCompleted";
* &emsp; \| &emsp; public const string LeftShiftOperatorName = "op\_LeftShift";
* &emsp; \| &emsp; public const string LessThanOperatorName = "op\_LessThan";
* &emsp; \| &emsp; public const string LessThanOrEqualOperatorName = "op\_LessThanOrEqual";
* &emsp; \| &emsp; public const string LikeOperatorName = "op\_Like";
* &emsp; \| &emsp; public const string LogicalAndOperatorName = "op\_LogicalAnd";
* &emsp; \| &emsp; public const string LogicalNotOperatorName = "op\_LogicalNot";
* &emsp; \| &emsp; public const string LogicalOrOperatorName = "op\_LogicalOr";
* &emsp; \| &emsp; public const string ModulusOperatorName = "op\_Modulus";
* &emsp; \| &emsp; public const string MoveNextMethodName = "MoveNext";
* &emsp; \| &emsp; public const string MultiplyOperatorName = "op\_Multiply";
* &emsp; \| &emsp; public const string ObjectEquals = "Equals";
* &emsp; \| &emsp; public const string ObjectGetHashCode = "GetHashCode";
* &emsp; \| &emsp; public const string ObjectToString = "ToString";
* &emsp; \| &emsp; public const string OnCompleted = "OnCompleted";
* &emsp; \| &emsp; public const string OnesComplementOperatorName = "op\_OnesComplement";
* &emsp; \| &emsp; public const string RightShiftOperatorName = "op\_RightShift";
* &emsp; \| &emsp; public const string StaticConstructorName = "\.cctor";
* &emsp; \| &emsp; public const string SubtractionOperatorName = "op\_Subtraction";
* &emsp; \| &emsp; public const string TrueOperatorName = "op\_True";
* &emsp; \| &emsp; public const string UnaryNegationOperatorName = "op\_UnaryNegation";
* &emsp; \| &emsp; public const string UnaryPlusOperatorName = "op\_UnaryPlus";
* &emsp; \| &emsp; public const string UnsignedLeftShiftOperatorName = "op\_UnsignedLeftShift";
* &emsp; \| &emsp; public const string UnsignedRightShiftOperatorName = "op\_UnsignedRightShift";
* &emsp; \| &emsp; public const string ValuePropertyName = "Value";
* &emsp; public static class Microsoft\.CodeAnalysis\.WorkspaceKind
* &emsp; \| &emsp; public const string Debugger = "Debugger";
* &emsp; \| &emsp; public const string Host = "Host";
* &emsp; \| &emsp; public const string Interactive = "Interactive";
* &emsp; \| &emsp; public const string MetadataAsSource = "MetadataAsSource";
* &emsp; \| &emsp; public const string MiscellaneousFiles = "MiscellaneousFiles";
* &emsp; \| &emsp; public const string Preview = "Preview";
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.CSharpExtensions
* &emsp; \| &emsp; public static ControlFlowAnalysis AnalyzeControlFlow\(this SemanticModel semanticModel, StatementSyntax statement\);
* &emsp; \| &emsp; public static ControlFlowAnalysis AnalyzeControlFlow\(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement\);
* &emsp; \| &emsp; public static DataFlowAnalysis AnalyzeDataFlow\(this SemanticModel semanticModel, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static DataFlowAnalysis AnalyzeDataFlow\(this SemanticModel semanticModel, StatementSyntax statement\);
* &emsp; \| &emsp; public static DataFlowAnalysis AnalyzeDataFlow\(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement\);
* &emsp; \| &emsp; public static Conversion ClassifyConversion\(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination\);
* &emsp; \| &emsp; public static Conversion ClassifyConversion\(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false\);
* &emsp; \| &emsp; public static Conversion ClassifyConversion\(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false\);
* &emsp; \| &emsp; public static IAliasSymbol GetAliasInfo\(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static AwaitExpressionInfo GetAwaitExpressionInfo\(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression\);
* &emsp; \| &emsp; public static SymbolInfo GetCollectionInitializerSymbolInfo\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static CompilationUnitSyntax GetCompilationUnitRoot\(this SyntaxTree tree, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Optional\<object> GetConstantValue\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Conversion GetConversion\(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ILocalSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetDeclaredSymbol\(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static INamespaceSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static INamedTypeSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static INamedTypeSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IFieldSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IMethodSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetDeclaredSymbol\(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IPropertySymbol GetDeclaredSymbol\(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IPropertySymbol GetDeclaredSymbol\(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IEventSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IMethodSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetDeclaredSymbol\(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetDeclaredSymbol\(this SemanticModel semanticModel, TupleElementSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ILabelSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ILabelSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IAliasSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IAliasSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IParameterSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IPropertySymbol GetDeclaredSymbol\(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static INamedTypeSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static INamedTypeSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, TupleExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetDeclaredSymbol\(this SemanticModel semanticModel, ArgumentSyntax declaratorSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetDeclaredSymbol\(this SemanticModel semanticModel, SingleVariableDesignationSyntax designationSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ILocalSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IRangeVariableSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IRangeVariableSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IRangeVariableSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ITypeParameterSymbol GetDeclaredSymbol\(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static DirectiveTriviaSyntax GetFirstDirective\(this SyntaxNode node, Func\<DirectiveTriviaSyntax, bool> predicate = null\);
* &emsp; \| &emsp; public static ForEachStatementInfo GetForEachStatementInfo\(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement\);
* &emsp; \| &emsp; public static ForEachStatementInfo GetForEachStatementInfo\(this SemanticModel semanticModel, CommonForEachStatementSyntax forEachStatement\);
* &emsp; \| &emsp; public static ImmutableArray\<IPropertySymbol> GetIndexerGroup\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static DirectiveTriviaSyntax GetLastDirective\(this SyntaxNode node, Func\<DirectiveTriviaSyntax, bool> predicate = null\);
* &emsp; \| &emsp; public static ImmutableArray\<ISymbol> GetMemberGroup\(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ImmutableArray\<ISymbol> GetMemberGroup\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ImmutableArray\<ISymbol> GetMemberGroup\(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static QueryClauseInfo GetQueryClauseInfo\(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IAliasSymbol GetSpeculativeAliasInfo\(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; public static Conversion GetSpeculativeConversion\(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; public static SymbolInfo GetSpeculativeSymbolInfo\(this SemanticModel semanticModel, int position, AttributeSyntax attribute\);
* &emsp; \| &emsp; public static SymbolInfo GetSpeculativeSymbolInfo\(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer\);
* &emsp; \| &emsp; public static SymbolInfo GetSpeculativeSymbolInfo\(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; public static SymbolInfo GetSpeculativeSymbolInfo\(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; public static TypeInfo GetSpeculativeTypeInfo\(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption\);
* &emsp; \| &emsp; public static SymbolInfo GetSymbolInfo\(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SymbolInfo GetSymbolInfo\(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SymbolInfo GetSymbolInfo\(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SymbolInfo GetSymbolInfo\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SymbolInfo GetSymbolInfo\(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SymbolInfo GetSymbolInfo\(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static TypeInfo GetTypeInfo\(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static TypeInfo GetTypeInfo\(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static TypeInfo GetTypeInfo\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static TypeInfo GetTypeInfo\(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SyntaxTokenList Insert\(this SyntaxTokenList list, int index, params SyntaxToken\[\] items\);
* &emsp; \| &emsp; public static bool IsContextualKeyword\(this SyntaxToken token\);
* &emsp; \| &emsp; public static bool IsKeyword\(this SyntaxToken token\);
* &emsp; \| &emsp; public static bool IsReservedKeyword\(this SyntaxToken token\);
* &emsp; \| &emsp; public static bool IsVerbatimIdentifier\(this SyntaxToken token\);
* &emsp; \| &emsp; public static bool IsVerbatimStringLiteral\(this SyntaxToken token\);
* &emsp; \| &emsp; public static SyntaxKind Kind\(this SyntaxNode node\);
* &emsp; \| &emsp; public static SyntaxKind Kind\(this SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; public static SyntaxKind Kind\(this SyntaxToken token\);
* &emsp; \| &emsp; public static SyntaxKind Kind\(this SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static SyntaxToken ReplaceTrivia\(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia\);
* &emsp; \| &emsp; public static SyntaxToken ReplaceTrivia\(this SyntaxToken token, IEnumerable\<SyntaxTrivia> trivia, Func\<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModel\(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModel\(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModel\(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModel\(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModel\(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModel\(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModel\(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = BindAsExpression\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModelForMethodBody\(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel\);
* &emsp; \| &emsp; public static bool TryGetSpeculativeSemanticModelForMethodBody\(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel\);
* &emsp; \| &emsp; public static VarianceKind VarianceKindFromToken\(this SyntaxToken node\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.CSharpFileSystemExtensions
* &emsp; \| &emsp; public static EmitResult Emit\(this CSharpCompilation compilation, string outputPath, string pdbPath = null, string xmlDocumentationPath = null, string win32ResourcesPath = null, IEnumerable\<ResourceDescription> manifestResources = null, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.LanguageVersionFacts
* &emsp; \| &emsp; public static LanguageVersion MapSpecifiedToEffectiveVersion\(this LanguageVersion version\);
* &emsp; \| &emsp; public static string ToDisplayString\(this LanguageVersion version\);
* &emsp; \| &emsp; public static bool TryParse\(this string version, out LanguageVersion result\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.SymbolDisplay
* &emsp; \| &emsp; public static string FormatLiteral\(char c, bool quote\);
* &emsp; \| &emsp; public static string FormatLiteral\(string value, bool quote\);
* &emsp; \| &emsp; public static string FormatPrimitive\(object obj, bool quoteStrings, bool useHexadecimalNumbers\);
* &emsp; \| &emsp; public static ImmutableArray\<SymbolDisplayPart> ToDisplayParts\(ISymbol symbol, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; public static string ToDisplayString\(ISymbol symbol, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; public static ImmutableArray\<SymbolDisplayPart> ToMinimalDisplayParts\(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; public static string ToMinimalDisplayString\(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.SyntaxExtensions
* &emsp; \| &emsp; public static SyntaxTriviaList NormalizeWhitespace\(this SyntaxTriviaList list, string indentation, bool elasticTrivia\);
* &emsp; \| &emsp; public static SyntaxToken NormalizeWhitespace\(this SyntaxToken token, string indentation, bool elasticTrivia\);
* &emsp; \| &emsp; public static SyntaxTriviaList NormalizeWhitespace\(this SyntaxTriviaList list, string indentation = "    ", string eol = "\\r\\n", bool elasticTrivia = false\);
* &emsp; \| &emsp; public static SyntaxToken NormalizeWhitespace\(this SyntaxToken token, string indentation = "    ", string eol = "\\r\\n", bool elasticTrivia = false\);
* &emsp; \| &emsp; public static SyntaxTriviaList ToSyntaxTriviaList\(this IEnumerable\<SyntaxTrivia> sequence\);
* &emsp; \| &emsp; public static IndexerDeclarationSyntax Update\(this IndexerDeclarationSyntax syntax, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static OperatorDeclarationSyntax Update\(this OperatorDeclarationSyntax syntax, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax block, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static MethodDeclarationSyntax Update\(this MethodDeclarationSyntax syntax, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax block, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static SimpleNameSyntax WithIdentifier\(this SimpleNameSyntax simpleName, SyntaxToken identifier\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.SyntaxFactory
* &emsp; \| &emsp; public static SyntaxTrivia CarriageReturn \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia CarriageReturnLineFeed \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia ElasticCarriageReturn \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia ElasticCarriageReturnLineFeed \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia ElasticLineFeed \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia ElasticMarker \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia ElasticSpace \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia ElasticTab \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia LineFeed \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia Space \{ get; \}
* &emsp; \| &emsp; public static SyntaxTrivia Tab \{ get; \}
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AccessorDeclaration\(SyntaxKind kind\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AccessorDeclaration\(SyntaxKind kind, BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AccessorDeclaration\(SyntaxKind kind, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AccessorDeclaration\(SyntaxKind kind, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AccessorDeclaration\(SyntaxKind kind, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AccessorDeclaration\(SyntaxKind kind, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AccessorDeclaration\(SyntaxKind kind, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AccessorDeclaration\(SyntaxKind kind, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static AccessorListSyntax AccessorList\(SyntaxList\<AccessorDeclarationSyntax> accessors = default\);
* &emsp; \| &emsp; public static AccessorListSyntax AccessorList\(SyntaxToken openBraceToken, SyntaxList\<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static AliasQualifiedNameSyntax AliasQualifiedName\(IdentifierNameSyntax alias, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static AliasQualifiedNameSyntax AliasQualifiedName\(string alias, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static AliasQualifiedNameSyntax AliasQualifiedName\(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static AnonymousMethodExpressionSyntax AnonymousMethodExpression\(\);
* &emsp; \| &emsp; public static AnonymousMethodExpressionSyntax AnonymousMethodExpression\(CSharpSyntaxNode body\);
* &emsp; \| &emsp; public static AnonymousMethodExpressionSyntax AnonymousMethodExpression\(ParameterListSyntax parameterList, CSharpSyntaxNode body\);
* &emsp; \| &emsp; public static AnonymousMethodExpressionSyntax AnonymousMethodExpression\(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body\);
* &emsp; \| &emsp; public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression\(SeparatedSyntaxList\<AnonymousObjectMemberDeclaratorSyntax> initializers = default\);
* &emsp; \| &emsp; public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression\(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList\<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator\(NameEqualsSyntax nameEquals, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static bool AreEquivalent\(SyntaxTokenList oldList, SyntaxTokenList newList\);
* &emsp; \| &emsp; public static bool AreEquivalent\(SyntaxToken oldToken, SyntaxToken newToken\);
* &emsp; \| &emsp; public static bool AreEquivalent\(SyntaxNode oldNode, SyntaxNode newNode, Func\<SyntaxKind, bool> ignoreChildNode = null\);
* &emsp; \| &emsp; public static bool AreEquivalent\(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel\);
* &emsp; \| &emsp; public static bool AreEquivalent\(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel\);
* &emsp; \| &emsp; public static bool AreEquivalent\<TNode>\(SyntaxList\<TNode> oldList, SyntaxList\<TNode> newList, Func\<SyntaxKind, bool> ignoreChildNode = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool AreEquivalent\<TNode>\(SeparatedSyntaxList\<TNode> oldList, SeparatedSyntaxList\<TNode> newList, Func\<SyntaxKind, bool> ignoreChildNode = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool AreEquivalent\<TNode>\(SyntaxList\<TNode> oldList, SyntaxList\<TNode> newList, bool topLevel\) where TNode : CSharpSyntaxNode;
* &emsp; \| &emsp; public static bool AreEquivalent\<TNode>\(SeparatedSyntaxList\<TNode> oldList, SeparatedSyntaxList\<TNode> newList, bool topLevel\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static ArgumentSyntax Argument\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ArgumentSyntax Argument\(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ArgumentListSyntax ArgumentList\(SeparatedSyntaxList\<ArgumentSyntax> arguments = default\);
* &emsp; \| &emsp; public static ArgumentListSyntax ArgumentList\(SyntaxToken openParenToken, SeparatedSyntaxList\<ArgumentSyntax> arguments, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static ArrayCreationExpressionSyntax ArrayCreationExpression\(ArrayTypeSyntax type\);
* &emsp; \| &emsp; public static ArrayCreationExpressionSyntax ArrayCreationExpression\(ArrayTypeSyntax type, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; public static ArrayCreationExpressionSyntax ArrayCreationExpression\(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; public static ArrayRankSpecifierSyntax ArrayRankSpecifier\(SeparatedSyntaxList\<ExpressionSyntax> sizes = default\);
* &emsp; \| &emsp; public static ArrayRankSpecifierSyntax ArrayRankSpecifier\(SyntaxToken openBracketToken, SeparatedSyntaxList\<ExpressionSyntax> sizes, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; public static ArrayTypeSyntax ArrayType\(TypeSyntax elementType\);
* &emsp; \| &emsp; public static ArrayTypeSyntax ArrayType\(TypeSyntax elementType, SyntaxList\<ArrayRankSpecifierSyntax> rankSpecifiers\);
* &emsp; \| &emsp; public static ArrowExpressionClauseSyntax ArrowExpressionClause\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ArrowExpressionClauseSyntax ArrowExpressionClause\(SyntaxToken arrowToken, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax AssignmentExpression\(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax AssignmentExpression\(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AttributeSyntax Attribute\(NameSyntax name\);
* &emsp; \| &emsp; public static AttributeSyntax Attribute\(NameSyntax name, AttributeArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static AttributeArgumentSyntax AttributeArgument\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static AttributeArgumentSyntax AttributeArgument\(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static AttributeArgumentListSyntax AttributeArgumentList\(SeparatedSyntaxList\<AttributeArgumentSyntax> arguments = default\);
* &emsp; \| &emsp; public static AttributeArgumentListSyntax AttributeArgumentList\(SyntaxToken openParenToken, SeparatedSyntaxList\<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static AttributeListSyntax AttributeList\(SeparatedSyntaxList\<AttributeSyntax> attributes = default\);
* &emsp; \| &emsp; public static AttributeListSyntax AttributeList\(AttributeTargetSpecifierSyntax target, SeparatedSyntaxList\<AttributeSyntax> attributes\);
* &emsp; \| &emsp; public static AttributeListSyntax AttributeList\(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList\<AttributeSyntax> attributes, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier\(SyntaxToken identifier, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static AwaitExpressionSyntax AwaitExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static AwaitExpressionSyntax AwaitExpression\(SyntaxToken awaitKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static BadDirectiveTriviaSyntax BadDirectiveTrivia\(SyntaxToken identifier, bool isActive\);
* &emsp; \| &emsp; public static BadDirectiveTriviaSyntax BadDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static SyntaxToken BadToken\(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static BaseExpressionSyntax BaseExpression\(\);
* &emsp; \| &emsp; public static BaseExpressionSyntax BaseExpression\(SyntaxToken token\);
* &emsp; \| &emsp; public static BaseListSyntax BaseList\(SeparatedSyntaxList\<BaseTypeSyntax> types = default\);
* &emsp; \| &emsp; public static BaseListSyntax BaseList\(SyntaxToken colonToken, SeparatedSyntaxList\<BaseTypeSyntax> types\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax BinaryExpression\(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax BinaryExpression\(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BlockSyntax Block\(params StatementSyntax\[\] statements\);
* &emsp; \| &emsp; public static BlockSyntax Block\(IEnumerable\<StatementSyntax> statements\);
* &emsp; \| &emsp; public static BlockSyntax Block\(SyntaxList\<StatementSyntax> statements = default\);
* &emsp; \| &emsp; public static BlockSyntax Block\(SyntaxToken openBraceToken, SyntaxList\<StatementSyntax> statements, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static BracketedArgumentListSyntax BracketedArgumentList\(SeparatedSyntaxList\<ArgumentSyntax> arguments = default\);
* &emsp; \| &emsp; public static BracketedArgumentListSyntax BracketedArgumentList\(SyntaxToken openBracketToken, SeparatedSyntaxList\<ArgumentSyntax> arguments, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; public static BracketedParameterListSyntax BracketedParameterList\(SeparatedSyntaxList\<ParameterSyntax> parameters = default\);
* &emsp; \| &emsp; public static BracketedParameterListSyntax BracketedParameterList\(SyntaxToken openBracketToken, SeparatedSyntaxList\<ParameterSyntax> parameters, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; public static BreakStatementSyntax BreakStatement\(\);
* &emsp; \| &emsp; public static BreakStatementSyntax BreakStatement\(SyntaxToken breakKeyword, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel\(PatternSyntax pattern, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel\(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel\(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static CaseSwitchLabelSyntax CaseSwitchLabel\(ExpressionSyntax value\);
* &emsp; \| &emsp; public static CaseSwitchLabelSyntax CaseSwitchLabel\(ExpressionSyntax value, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static CaseSwitchLabelSyntax CaseSwitchLabel\(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static CastExpressionSyntax CastExpression\(TypeSyntax type, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static CastExpressionSyntax CastExpression\(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static CatchClauseSyntax CatchClause\(\);
* &emsp; \| &emsp; public static CatchClauseSyntax CatchClause\(CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block\);
* &emsp; \| &emsp; public static CatchClauseSyntax CatchClause\(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block\);
* &emsp; \| &emsp; public static CatchDeclarationSyntax CatchDeclaration\(TypeSyntax type\);
* &emsp; \| &emsp; public static CatchDeclarationSyntax CatchDeclaration\(TypeSyntax type, SyntaxToken identifier\);
* &emsp; \| &emsp; public static CatchDeclarationSyntax CatchDeclaration\(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static CatchFilterClauseSyntax CatchFilterClause\(ExpressionSyntax filterExpression\);
* &emsp; \| &emsp; public static CatchFilterClauseSyntax CatchFilterClause\(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static CheckedExpressionSyntax CheckedExpression\(SyntaxKind kind, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static CheckedExpressionSyntax CheckedExpression\(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static CheckedStatementSyntax CheckedStatement\(SyntaxKind kind, BlockSyntax block = null\);
* &emsp; \| &emsp; public static CheckedStatementSyntax CheckedStatement\(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax ClassDeclaration\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax ClassDeclaration\(string identifier\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax ClassDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax ClassDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ClassOrStructConstraintSyntax ClassOrStructConstraint\(SyntaxKind kind\);
* &emsp; \| &emsp; public static ClassOrStructConstraintSyntax ClassOrStructConstraint\(SyntaxKind kind, SyntaxToken classOrStructKeyword\);
* &emsp; \| &emsp; public static SyntaxTrivia Comment\(string text\);
* &emsp; \| &emsp; public static CompilationUnitSyntax CompilationUnit\(\);
* &emsp; \| &emsp; public static CompilationUnitSyntax CompilationUnit\(SyntaxList\<ExternAliasDirectiveSyntax> externs, SyntaxList\<UsingDirectiveSyntax> usings, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static CompilationUnitSyntax CompilationUnit\(SyntaxList\<ExternAliasDirectiveSyntax> externs, SyntaxList\<UsingDirectiveSyntax> usings, SyntaxList\<AttributeListSyntax> attributeLists, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken\);
* &emsp; \| &emsp; public static ConditionalAccessExpressionSyntax ConditionalAccessExpression\(ExpressionSyntax expression, ExpressionSyntax whenNotNull\);
* &emsp; \| &emsp; public static ConditionalAccessExpressionSyntax ConditionalAccessExpression\(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull\);
* &emsp; \| &emsp; public static ConditionalExpressionSyntax ConditionalExpression\(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse\);
* &emsp; \| &emsp; public static ConditionalExpressionSyntax ConditionalExpression\(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse\);
* &emsp; \| &emsp; public static ConstantPatternSyntax ConstantPattern\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ConstructorConstraintSyntax ConstructorConstraint\(\);
* &emsp; \| &emsp; public static ConstructorConstraintSyntax ConstructorConstraint\(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(string identifier\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ConstructorInitializerSyntax ConstructorInitializer\(SyntaxKind kind, ArgumentListSyntax argumentList = null\);
* &emsp; \| &emsp; public static ConstructorInitializerSyntax ConstructorInitializer\(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static ContinueStatementSyntax ContinueStatement\(\);
* &emsp; \| &emsp; public static ContinueStatementSyntax ContinueStatement\(SyntaxToken continueKeyword, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration\(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type\);
* &emsp; \| &emsp; public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref\(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type\);
* &emsp; \| &emsp; public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref\(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref\(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; public static CrefBracketedParameterListSyntax CrefBracketedParameterList\(SeparatedSyntaxList\<CrefParameterSyntax> parameters = default\);
* &emsp; \| &emsp; public static CrefBracketedParameterListSyntax CrefBracketedParameterList\(SyntaxToken openBracketToken, SeparatedSyntaxList\<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken\);
* &emsp; \| &emsp; public static CrefParameterSyntax CrefParameter\(TypeSyntax type\);
* &emsp; \| &emsp; public static CrefParameterSyntax CrefParameter\(SyntaxToken refOrOutKeyword, TypeSyntax type\);
* &emsp; \| &emsp; public static CrefParameterListSyntax CrefParameterList\(SeparatedSyntaxList\<CrefParameterSyntax> parameters = default\);
* &emsp; \| &emsp; public static CrefParameterListSyntax CrefParameterList\(SyntaxToken openParenToken, SeparatedSyntaxList\<CrefParameterSyntax> parameters, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static DeclarationExpressionSyntax DeclarationExpression\(TypeSyntax type, VariableDesignationSyntax designation\);
* &emsp; \| &emsp; public static DeclarationPatternSyntax DeclarationPattern\(TypeSyntax type, VariableDesignationSyntax designation\);
* &emsp; \| &emsp; public static DefaultExpressionSyntax DefaultExpression\(TypeSyntax type\);
* &emsp; \| &emsp; public static DefaultExpressionSyntax DefaultExpression\(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static DefaultSwitchLabelSyntax DefaultSwitchLabel\(\);
* &emsp; \| &emsp; public static DefaultSwitchLabelSyntax DefaultSwitchLabel\(SyntaxToken colonToken\);
* &emsp; \| &emsp; public static DefaultSwitchLabelSyntax DefaultSwitchLabel\(SyntaxToken keyword, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia\(SyntaxToken name, bool isActive\);
* &emsp; \| &emsp; public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia\(string name, bool isActive\);
* &emsp; \| &emsp; public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static DelegateDeclarationSyntax DelegateDeclaration\(TypeSyntax returnType, SyntaxToken identifier\);
* &emsp; \| &emsp; public static DelegateDeclarationSyntax DelegateDeclaration\(TypeSyntax returnType, string identifier\);
* &emsp; \| &emsp; public static DelegateDeclarationSyntax DelegateDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses\);
* &emsp; \| &emsp; public static DelegateDeclarationSyntax DelegateDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static DestructorDeclarationSyntax DestructorDeclaration\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static DestructorDeclarationSyntax DestructorDeclaration\(string identifier\);
* &emsp; \| &emsp; public static DestructorDeclarationSyntax DestructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body\);
* &emsp; \| &emsp; public static DestructorDeclarationSyntax DestructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static DestructorDeclarationSyntax DestructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static DestructorDeclarationSyntax DestructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static DestructorDeclarationSyntax DestructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static DestructorDeclarationSyntax DestructorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static SyntaxTrivia DisabledText\(string text\);
* &emsp; \| &emsp; public static DiscardDesignationSyntax DiscardDesignation\(\);
* &emsp; \| &emsp; public static DiscardDesignationSyntax DiscardDesignation\(SyntaxToken underscoreToken\);
* &emsp; \| &emsp; public static DoStatementSyntax DoStatement\(StatementSyntax statement, ExpressionSyntax condition\);
* &emsp; \| &emsp; public static DoStatementSyntax DoStatement\(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static DocumentationCommentTriviaSyntax DocumentationComment\(params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static SyntaxTrivia DocumentationCommentExterior\(string text\);
* &emsp; \| &emsp; public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia\(SyntaxKind kind, SyntaxList\<XmlNodeSyntax> content = default\);
* &emsp; \| &emsp; public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia\(SyntaxKind kind, SyntaxList\<XmlNodeSyntax> content, SyntaxToken endOfComment\);
* &emsp; \| &emsp; public static SyntaxTrivia ElasticEndOfLine\(string text\);
* &emsp; \| &emsp; public static SyntaxTrivia ElasticWhitespace\(string text\);
* &emsp; \| &emsp; public static ElementAccessExpressionSyntax ElementAccessExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ElementAccessExpressionSyntax ElementAccessExpression\(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static ElementBindingExpressionSyntax ElementBindingExpression\(\);
* &emsp; \| &emsp; public static ElementBindingExpressionSyntax ElementBindingExpression\(BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia\(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue\);
* &emsp; \| &emsp; public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue\);
* &emsp; \| &emsp; public static ElseClauseSyntax ElseClause\(StatementSyntax statement\);
* &emsp; \| &emsp; public static ElseClauseSyntax ElseClause\(SyntaxToken elseKeyword, StatementSyntax statement\);
* &emsp; \| &emsp; public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia\(bool isActive, bool branchTaken\);
* &emsp; \| &emsp; public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken\);
* &emsp; \| &emsp; public static EmptyStatementSyntax EmptyStatement\(\);
* &emsp; \| &emsp; public static EmptyStatementSyntax EmptyStatement\(SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia\(bool isActive\);
* &emsp; \| &emsp; public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static SyntaxTrivia EndOfLine\(string text\);
* &emsp; \| &emsp; public static SyntaxTrivia EndOfLine\(string text, bool elastic\);
* &emsp; \| &emsp; public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia\(bool isActive\);
* &emsp; \| &emsp; public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static EnumDeclarationSyntax EnumDeclaration\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static EnumDeclarationSyntax EnumDeclaration\(string identifier\);
* &emsp; \| &emsp; public static EnumDeclarationSyntax EnumDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, BaseListSyntax baseList, SeparatedSyntaxList\<EnumMemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static EnumDeclarationSyntax EnumDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList\<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static EnumMemberDeclarationSyntax EnumMemberDeclaration\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static EnumMemberDeclarationSyntax EnumMemberDeclaration\(string identifier\);
* &emsp; \| &emsp; public static EnumMemberDeclarationSyntax EnumMemberDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue\);
* &emsp; \| &emsp; public static EqualsValueClauseSyntax EqualsValueClause\(ExpressionSyntax value\);
* &emsp; \| &emsp; public static EqualsValueClauseSyntax EqualsValueClause\(SyntaxToken equalsToken, ExpressionSyntax value\);
* &emsp; \| &emsp; public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia\(bool isActive\);
* &emsp; \| &emsp; public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static EventDeclarationSyntax EventDeclaration\(TypeSyntax type, SyntaxToken identifier\);
* &emsp; \| &emsp; public static EventDeclarationSyntax EventDeclaration\(TypeSyntax type, string identifier\);
* &emsp; \| &emsp; public static EventDeclarationSyntax EventDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static EventDeclarationSyntax EventDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static EventFieldDeclarationSyntax EventFieldDeclaration\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static EventFieldDeclarationSyntax EventFieldDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static EventFieldDeclarationSyntax EventFieldDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier\(NameSyntax name\);
* &emsp; \| &emsp; public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier\(NameSyntax name, SyntaxToken dotToken\);
* &emsp; \| &emsp; public static ExpressionStatementSyntax ExpressionStatement\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ExpressionStatementSyntax ExpressionStatement\(ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static ExternAliasDirectiveSyntax ExternAliasDirective\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static ExternAliasDirectiveSyntax ExternAliasDirective\(string identifier\);
* &emsp; \| &emsp; public static ExternAliasDirectiveSyntax ExternAliasDirective\(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static FieldDeclarationSyntax FieldDeclaration\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static FieldDeclarationSyntax FieldDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static FieldDeclarationSyntax FieldDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static FinallyClauseSyntax FinallyClause\(BlockSyntax block = null\);
* &emsp; \| &emsp; public static FinallyClauseSyntax FinallyClause\(SyntaxToken finallyKeyword, BlockSyntax block\);
* &emsp; \| &emsp; public static FixedStatementSyntax FixedStatement\(VariableDeclarationSyntax declaration, StatementSyntax statement\);
* &emsp; \| &emsp; public static FixedStatementSyntax FixedStatement\(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; public static ForEachStatementSyntax ForEachStatement\(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression, StatementSyntax statement\);
* &emsp; \| &emsp; public static ForEachStatementSyntax ForEachStatement\(TypeSyntax type, string identifier, ExpressionSyntax expression, StatementSyntax statement\);
* &emsp; \| &emsp; public static ForEachStatementSyntax ForEachStatement\(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; public static ForEachVariableStatementSyntax ForEachVariableStatement\(ExpressionSyntax variable, ExpressionSyntax expression, StatementSyntax statement\);
* &emsp; \| &emsp; public static ForEachVariableStatementSyntax ForEachVariableStatement\(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; public static ForStatementSyntax ForStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; public static ForStatementSyntax ForStatement\(VariableDeclarationSyntax declaration, SeparatedSyntaxList\<ExpressionSyntax> initializers, ExpressionSyntax condition, SeparatedSyntaxList\<ExpressionSyntax> incrementors, StatementSyntax statement\);
* &emsp; \| &emsp; public static ForStatementSyntax ForStatement\(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList\<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList\<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; public static FromClauseSyntax FromClause\(SyntaxToken identifier, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static FromClauseSyntax FromClause\(string identifier, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static FromClauseSyntax FromClause\(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static FromClauseSyntax FromClause\(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static GenericNameSyntax GenericName\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static GenericNameSyntax GenericName\(string identifier\);
* &emsp; \| &emsp; public static GenericNameSyntax GenericName\(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList\);
* &emsp; \| &emsp; public static ExpressionSyntax GetNonGenericExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ExpressionSyntax GetStandaloneExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static GlobalStatementSyntax GlobalStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; public static GotoStatementSyntax GotoStatement\(SyntaxKind kind, ExpressionSyntax expression = null\);
* &emsp; \| &emsp; public static GotoStatementSyntax GotoStatement\(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static GotoStatementSyntax GotoStatement\(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static GroupClauseSyntax GroupClause\(ExpressionSyntax groupExpression, ExpressionSyntax byExpression\);
* &emsp; \| &emsp; public static GroupClauseSyntax GroupClause\(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression\);
* &emsp; \| &emsp; public static SyntaxToken Identifier\(string text\);
* &emsp; \| &emsp; public static SyntaxToken Identifier\(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Identifier\(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static IdentifierNameSyntax IdentifierName\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static IdentifierNameSyntax IdentifierName\(string name\);
* &emsp; \| &emsp; public static IfDirectiveTriviaSyntax IfDirectiveTrivia\(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue\);
* &emsp; \| &emsp; public static IfDirectiveTriviaSyntax IfDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue\);
* &emsp; \| &emsp; public static IfStatementSyntax IfStatement\(ExpressionSyntax condition, StatementSyntax statement\);
* &emsp; \| &emsp; public static IfStatementSyntax IfStatement\(ExpressionSyntax condition, StatementSyntax statement, ElseClauseSyntax @else\);
* &emsp; \| &emsp; public static IfStatementSyntax IfStatement\(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else\);
* &emsp; \| &emsp; public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression\(InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression\(SyntaxTokenList commas, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression\(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; public static ImplicitElementAccessSyntax ImplicitElementAccess\(\);
* &emsp; \| &emsp; public static ImplicitElementAccessSyntax ImplicitElementAccess\(BracketedArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static IncompleteMemberSyntax IncompleteMember\(TypeSyntax type = null\);
* &emsp; \| &emsp; public static IncompleteMemberSyntax IncompleteMember\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type\);
* &emsp; \| &emsp; public static IndexerDeclarationSyntax IndexerDeclaration\(TypeSyntax type\);
* &emsp; \| &emsp; public static IndexerDeclarationSyntax IndexerDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static IndexerDeclarationSyntax IndexerDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static IndexerDeclarationSyntax IndexerDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static IndexerMemberCrefSyntax IndexerMemberCref\(CrefBracketedParameterListSyntax parameters = null\);
* &emsp; \| &emsp; public static IndexerMemberCrefSyntax IndexerMemberCref\(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax InitializerExpression\(SyntaxKind kind, SeparatedSyntaxList\<ExpressionSyntax> expressions = default\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax InitializerExpression\(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList\<ExpressionSyntax> expressions, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax InterfaceDeclaration\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax InterfaceDeclaration\(string identifier\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax InterfaceDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax InterfaceDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static InterpolatedStringExpressionSyntax InterpolatedStringExpression\(SyntaxToken stringStartToken\);
* &emsp; \| &emsp; public static InterpolatedStringExpressionSyntax InterpolatedStringExpression\(SyntaxToken stringStartToken, SyntaxList\<InterpolatedStringContentSyntax> contents\);
* &emsp; \| &emsp; public static InterpolatedStringExpressionSyntax InterpolatedStringExpression\(SyntaxToken stringStartToken, SyntaxList\<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken\);
* &emsp; \| &emsp; public static InterpolatedStringTextSyntax InterpolatedStringText\(\);
* &emsp; \| &emsp; public static InterpolatedStringTextSyntax InterpolatedStringText\(SyntaxToken textToken\);
* &emsp; \| &emsp; public static InterpolationSyntax Interpolation\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static InterpolationSyntax Interpolation\(ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause\);
* &emsp; \| &emsp; public static InterpolationSyntax Interpolation\(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause\(SyntaxToken commaToken, ExpressionSyntax value\);
* &emsp; \| &emsp; public static InterpolationFormatClauseSyntax InterpolationFormatClause\(SyntaxToken colonToken\);
* &emsp; \| &emsp; public static InterpolationFormatClauseSyntax InterpolationFormatClause\(SyntaxToken colonToken, SyntaxToken formatStringToken\);
* &emsp; \| &emsp; public static InvocationExpressionSyntax InvocationExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static InvocationExpressionSyntax InvocationExpression\(ExpressionSyntax expression, ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static bool IsCompleteSubmission\(SyntaxTree tree\);
* &emsp; \| &emsp; public static IsPatternExpressionSyntax IsPatternExpression\(ExpressionSyntax expression, PatternSyntax pattern\);
* &emsp; \| &emsp; public static IsPatternExpressionSyntax IsPatternExpression\(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern\);
* &emsp; \| &emsp; public static JoinClauseSyntax JoinClause\(SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression\);
* &emsp; \| &emsp; public static JoinClauseSyntax JoinClause\(string identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression\);
* &emsp; \| &emsp; public static JoinClauseSyntax JoinClause\(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into\);
* &emsp; \| &emsp; public static JoinClauseSyntax JoinClause\(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into\);
* &emsp; \| &emsp; public static JoinIntoClauseSyntax JoinIntoClause\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static JoinIntoClauseSyntax JoinIntoClause\(string identifier\);
* &emsp; \| &emsp; public static JoinIntoClauseSyntax JoinIntoClause\(SyntaxToken intoKeyword, SyntaxToken identifier\);
* &emsp; \| &emsp; public static LabeledStatementSyntax LabeledStatement\(SyntaxToken identifier, StatementSyntax statement\);
* &emsp; \| &emsp; public static LabeledStatementSyntax LabeledStatement\(string identifier, StatementSyntax statement\);
* &emsp; \| &emsp; public static LabeledStatementSyntax LabeledStatement\(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement\);
* &emsp; \| &emsp; public static LetClauseSyntax LetClause\(SyntaxToken identifier, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static LetClauseSyntax LetClause\(string identifier, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static LetClauseSyntax LetClause\(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static LineDirectiveTriviaSyntax LineDirectiveTrivia\(SyntaxToken line, bool isActive\);
* &emsp; \| &emsp; public static LineDirectiveTriviaSyntax LineDirectiveTrivia\(SyntaxToken line, SyntaxToken file, bool isActive\);
* &emsp; \| &emsp; public static LineDirectiveTriviaSyntax LineDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static SyntaxList\<TNode> List\<TNode>\(\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxList\<TNode> List\<TNode>\(IEnumerable\<TNode> nodes\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxToken Literal\(int value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(uint value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(long value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(ulong value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(float value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(double value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(decimal value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(char value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, int value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, uint value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, long value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, ulong value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, float value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, double value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, decimal value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, string value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(string text, char value\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Literal\(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax LiteralExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax LiteralExpression\(SyntaxKind kind, SyntaxToken token\);
* &emsp; \| &emsp; public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia\(SyntaxToken file, bool isActive\);
* &emsp; \| &emsp; public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static LocalDeclarationStatementSyntax LocalDeclarationStatement\(VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static LocalDeclarationStatementSyntax LocalDeclarationStatement\(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static LocalDeclarationStatementSyntax LocalDeclarationStatement\(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static LocalFunctionStatementSyntax LocalFunctionStatement\(TypeSyntax returnType, SyntaxToken identifier\);
* &emsp; \| &emsp; public static LocalFunctionStatementSyntax LocalFunctionStatement\(TypeSyntax returnType, string identifier\);
* &emsp; \| &emsp; public static LocalFunctionStatementSyntax LocalFunctionStatement\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static LocalFunctionStatementSyntax LocalFunctionStatement\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static LockStatementSyntax LockStatement\(ExpressionSyntax expression, StatementSyntax statement\);
* &emsp; \| &emsp; public static LockStatementSyntax LockStatement\(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; public static MakeRefExpressionSyntax MakeRefExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static MakeRefExpressionSyntax MakeRefExpression\(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static MemberAccessExpressionSyntax MemberAccessExpression\(SyntaxKind kind, ExpressionSyntax expression, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static MemberAccessExpressionSyntax MemberAccessExpression\(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static MemberBindingExpressionSyntax MemberBindingExpression\(SimpleNameSyntax name\);
* &emsp; \| &emsp; public static MemberBindingExpressionSyntax MemberBindingExpression\(SyntaxToken operatorToken, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static MethodDeclarationSyntax MethodDeclaration\(TypeSyntax returnType, SyntaxToken identifier\);
* &emsp; \| &emsp; public static MethodDeclarationSyntax MethodDeclaration\(TypeSyntax returnType, string identifier\);
* &emsp; \| &emsp; public static MethodDeclarationSyntax MethodDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static MethodDeclarationSyntax MethodDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static MethodDeclarationSyntax MethodDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static SyntaxToken MissingToken\(SyntaxKind kind\);
* &emsp; \| &emsp; public static SyntaxToken MissingToken\(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static NameColonSyntax NameColon\(IdentifierNameSyntax name\);
* &emsp; \| &emsp; public static NameColonSyntax NameColon\(string name\);
* &emsp; \| &emsp; public static NameColonSyntax NameColon\(IdentifierNameSyntax name, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static NameEqualsSyntax NameEquals\(IdentifierNameSyntax name\);
* &emsp; \| &emsp; public static NameEqualsSyntax NameEquals\(string name\);
* &emsp; \| &emsp; public static NameEqualsSyntax NameEquals\(IdentifierNameSyntax name, SyntaxToken equalsToken\);
* &emsp; \| &emsp; public static NameMemberCrefSyntax NameMemberCref\(TypeSyntax name\);
* &emsp; \| &emsp; public static NameMemberCrefSyntax NameMemberCref\(TypeSyntax name, CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; public static NamespaceDeclarationSyntax NamespaceDeclaration\(NameSyntax name\);
* &emsp; \| &emsp; public static NamespaceDeclarationSyntax NamespaceDeclaration\(NameSyntax name, SyntaxList\<ExternAliasDirectiveSyntax> externs, SyntaxList\<UsingDirectiveSyntax> usings, SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static NamespaceDeclarationSyntax NamespaceDeclaration\(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList\<ExternAliasDirectiveSyntax> externs, SyntaxList\<UsingDirectiveSyntax> usings, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static SyntaxNodeOrTokenList NodeOrTokenList\(\);
* &emsp; \| &emsp; public static SyntaxNodeOrTokenList NodeOrTokenList\(IEnumerable\<SyntaxNodeOrToken> nodesAndTokens\);
* &emsp; \| &emsp; public static SyntaxNodeOrTokenList NodeOrTokenList\(params SyntaxNodeOrToken\[\] nodesAndTokens\);
* &emsp; \| &emsp; public static NullableTypeSyntax NullableType\(TypeSyntax elementType\);
* &emsp; \| &emsp; public static NullableTypeSyntax NullableType\(TypeSyntax elementType, SyntaxToken questionToken\);
* &emsp; \| &emsp; public static ObjectCreationExpressionSyntax ObjectCreationExpression\(TypeSyntax type\);
* &emsp; \| &emsp; public static ObjectCreationExpressionSyntax ObjectCreationExpression\(TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; public static ObjectCreationExpressionSyntax ObjectCreationExpression\(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer\);
* &emsp; \| &emsp; public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression\(\);
* &emsp; \| &emsp; public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression\(SyntaxToken omittedArraySizeExpressionToken\);
* &emsp; \| &emsp; public static OmittedTypeArgumentSyntax OmittedTypeArgument\(\);
* &emsp; \| &emsp; public static OmittedTypeArgumentSyntax OmittedTypeArgument\(SyntaxToken omittedTypeArgumentToken\);
* &emsp; \| &emsp; public static OperatorDeclarationSyntax OperatorDeclaration\(TypeSyntax returnType, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static OperatorDeclarationSyntax OperatorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static OperatorDeclarationSyntax OperatorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static OperatorDeclarationSyntax OperatorDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static OperatorMemberCrefSyntax OperatorMemberCref\(SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static OperatorMemberCrefSyntax OperatorMemberCref\(SyntaxToken operatorToken, CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; public static OperatorMemberCrefSyntax OperatorMemberCref\(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters\);
* &emsp; \| &emsp; public static OrderByClauseSyntax OrderByClause\(SeparatedSyntaxList\<OrderingSyntax> orderings = default\);
* &emsp; \| &emsp; public static OrderByClauseSyntax OrderByClause\(SyntaxToken orderByKeyword, SeparatedSyntaxList\<OrderingSyntax> orderings\);
* &emsp; \| &emsp; public static OrderingSyntax Ordering\(SyntaxKind kind, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static OrderingSyntax Ordering\(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword\);
* &emsp; \| &emsp; public static ParameterSyntax Parameter\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static ParameterSyntax Parameter\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default\);
* &emsp; \| &emsp; public static ParameterListSyntax ParameterList\(SeparatedSyntaxList\<ParameterSyntax> parameters = default\);
* &emsp; \| &emsp; public static ParameterListSyntax ParameterList\(SyntaxToken openParenToken, SeparatedSyntaxList\<ParameterSyntax> parameters, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static ParenthesizedExpressionSyntax ParenthesizedExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ParenthesizedExpressionSyntax ParenthesizedExpression\(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression\(CSharpSyntaxNode body\);
* &emsp; \| &emsp; public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression\(ParameterListSyntax parameterList, CSharpSyntaxNode body\);
* &emsp; \| &emsp; public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression\(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body\);
* &emsp; \| &emsp; public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation\(SeparatedSyntaxList\<VariableDesignationSyntax> variables = default\);
* &emsp; \| &emsp; public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation\(SyntaxToken openParenToken, SeparatedSyntaxList\<VariableDesignationSyntax> variables, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static ArgumentListSyntax ParseArgumentList\(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true\);
* &emsp; \| &emsp; public static AttributeArgumentListSyntax ParseAttributeArgumentList\(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true\);
* &emsp; \| &emsp; public static BracketedArgumentListSyntax ParseBracketedArgumentList\(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true\);
* &emsp; \| &emsp; public static BracketedParameterListSyntax ParseBracketedParameterList\(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true\);
* &emsp; \| &emsp; public static CompilationUnitSyntax ParseCompilationUnit\(string text, int offset = 0, CSharpParseOptions options = null\);
* &emsp; \| &emsp; public static ExpressionSyntax ParseExpression\(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true\);
* &emsp; \| &emsp; public static SyntaxTriviaList ParseLeadingTrivia\(string text, int offset = 0\);
* &emsp; \| &emsp; public static NameSyntax ParseName\(string text, int offset = 0, bool consumeFullText = true\);
* &emsp; \| &emsp; public static ParameterListSyntax ParseParameterList\(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true\);
* &emsp; \| &emsp; public static StatementSyntax ParseStatement\(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true\);
* &emsp; \| &emsp; public static SyntaxTree ParseSyntaxTree\(SourceText text, ParseOptions options = null, string path = "", CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SyntaxTree ParseSyntaxTree\(string text, ParseOptions options = null, string path = "", Encoding encoding = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SyntaxToken ParseToken\(string text, int offset = 0\);
* &emsp; \| &emsp; public static IEnumerable\<SyntaxToken> ParseTokens\(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null\);
* &emsp; \| &emsp; public static SyntaxTriviaList ParseTrailingTrivia\(string text, int offset = 0\);
* &emsp; \| &emsp; public static TypeSyntax ParseTypeName\(string text, int offset = 0, bool consumeFullText = true\);
* &emsp; \| &emsp; public static PointerTypeSyntax PointerType\(TypeSyntax elementType\);
* &emsp; \| &emsp; public static PointerTypeSyntax PointerType\(TypeSyntax elementType, SyntaxToken asteriskToken\);
* &emsp; \| &emsp; public static PostfixUnaryExpressionSyntax PostfixUnaryExpression\(SyntaxKind kind, ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PostfixUnaryExpressionSyntax PostfixUnaryExpression\(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia\(SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, bool isActive\);
* &emsp; \| &emsp; public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia\(SyntaxToken disableOrRestoreKeyword, bool isActive\);
* &emsp; \| &emsp; public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia\(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList\<ExpressionSyntax> errorCodes, bool isActive\);
* &emsp; \| &emsp; public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList\<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedType\(SyntaxToken keyword\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax PrefixUnaryExpression\(SyntaxKind kind, ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax PrefixUnaryExpression\(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand\);
* &emsp; \| &emsp; public static SyntaxTrivia PreprocessingMessage\(string text\);
* &emsp; \| &emsp; public static PropertyDeclarationSyntax PropertyDeclaration\(TypeSyntax type, SyntaxToken identifier\);
* &emsp; \| &emsp; public static PropertyDeclarationSyntax PropertyDeclaration\(TypeSyntax type, string identifier\);
* &emsp; \| &emsp; public static PropertyDeclarationSyntax PropertyDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static PropertyDeclarationSyntax PropertyDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static PropertyDeclarationSyntax PropertyDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static QualifiedCrefSyntax QualifiedCref\(TypeSyntax container, MemberCrefSyntax member\);
* &emsp; \| &emsp; public static QualifiedCrefSyntax QualifiedCref\(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member\);
* &emsp; \| &emsp; public static QualifiedNameSyntax QualifiedName\(NameSyntax left, SimpleNameSyntax right\);
* &emsp; \| &emsp; public static QualifiedNameSyntax QualifiedName\(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right\);
* &emsp; \| &emsp; public static QueryBodySyntax QueryBody\(SelectOrGroupClauseSyntax selectOrGroup\);
* &emsp; \| &emsp; public static QueryBodySyntax QueryBody\(SyntaxList\<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation\);
* &emsp; \| &emsp; public static QueryContinuationSyntax QueryContinuation\(SyntaxToken identifier, QueryBodySyntax body\);
* &emsp; \| &emsp; public static QueryContinuationSyntax QueryContinuation\(string identifier, QueryBodySyntax body\);
* &emsp; \| &emsp; public static QueryContinuationSyntax QueryContinuation\(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body\);
* &emsp; \| &emsp; public static QueryExpressionSyntax QueryExpression\(FromClauseSyntax fromClause, QueryBodySyntax body\);
* &emsp; \| &emsp; public static RefExpressionSyntax RefExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static RefExpressionSyntax RefExpression\(SyntaxToken refKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static RefTypeSyntax RefType\(TypeSyntax type\);
* &emsp; \| &emsp; public static RefTypeSyntax RefType\(SyntaxToken refKeyword, TypeSyntax type\);
* &emsp; \| &emsp; public static RefTypeExpressionSyntax RefTypeExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static RefTypeExpressionSyntax RefTypeExpression\(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static RefValueExpressionSyntax RefValueExpression\(ExpressionSyntax expression, TypeSyntax type\);
* &emsp; \| &emsp; public static RefValueExpressionSyntax RefValueExpression\(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia\(SyntaxToken file, bool isActive\);
* &emsp; \| &emsp; public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia\(bool isActive\);
* &emsp; \| &emsp; public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static ReturnStatementSyntax ReturnStatement\(ExpressionSyntax expression = null\);
* &emsp; \| &emsp; public static ReturnStatementSyntax ReturnStatement\(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static SelectClauseSyntax SelectClause\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static SelectClauseSyntax SelectClause\(SyntaxToken selectKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> SeparatedList\<TNode>\(\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> SeparatedList\<TNode>\(IEnumerable\<TNode> nodes\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> SeparatedList\<TNode>\(IEnumerable\<SyntaxNodeOrToken> nodesAndTokens\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> SeparatedList\<TNode>\(SyntaxNodeOrTokenList nodesAndTokens\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> SeparatedList\<TNode>\(IEnumerable\<TNode> nodes, IEnumerable\<SyntaxToken> separators\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia\(bool isActive\);
* &emsp; \| &emsp; public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static SimpleBaseTypeSyntax SimpleBaseType\(TypeSyntax type\);
* &emsp; \| &emsp; public static SimpleLambdaExpressionSyntax SimpleLambdaExpression\(ParameterSyntax parameter, CSharpSyntaxNode body\);
* &emsp; \| &emsp; public static SimpleLambdaExpressionSyntax SimpleLambdaExpression\(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body\);
* &emsp; \| &emsp; public static SingleVariableDesignationSyntax SingleVariableDesignation\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static SyntaxList\<TNode> SingletonList\<TNode>\(TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> SingletonSeparatedList\<TNode>\(TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SizeOfExpressionSyntax SizeOfExpression\(TypeSyntax type\);
* &emsp; \| &emsp; public static SizeOfExpressionSyntax SizeOfExpression\(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static SkippedTokensTriviaSyntax SkippedTokensTrivia\(\);
* &emsp; \| &emsp; public static SkippedTokensTriviaSyntax SkippedTokensTrivia\(SyntaxTokenList tokens\);
* &emsp; \| &emsp; public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression\(TypeSyntax type\);
* &emsp; \| &emsp; public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression\(SyntaxToken stackAllocKeyword, TypeSyntax type\);
* &emsp; \| &emsp; public static StructDeclarationSyntax StructDeclaration\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static StructDeclarationSyntax StructDeclaration\(string identifier\);
* &emsp; \| &emsp; public static StructDeclarationSyntax StructDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static StructDeclarationSyntax StructDeclaration\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static SwitchSectionSyntax SwitchSection\(\);
* &emsp; \| &emsp; public static SwitchSectionSyntax SwitchSection\(SyntaxList\<SwitchLabelSyntax> labels, SyntaxList\<StatementSyntax> statements\);
* &emsp; \| &emsp; public static SwitchStatementSyntax SwitchStatement\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static SwitchStatementSyntax SwitchStatement\(ExpressionSyntax expression, SyntaxList\<SwitchSectionSyntax> sections\);
* &emsp; \| &emsp; public static SwitchStatementSyntax SwitchStatement\(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList\<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static SyntaxTree SyntaxTree\(SyntaxNode root, ParseOptions options = null, string path = "", Encoding encoding = null\);
* &emsp; \| &emsp; public static SyntaxTrivia SyntaxTrivia\(SyntaxKind kind, string text\);
* &emsp; \| &emsp; public static ThisExpressionSyntax ThisExpression\(\);
* &emsp; \| &emsp; public static ThisExpressionSyntax ThisExpression\(SyntaxToken token\);
* &emsp; \| &emsp; public static ThrowExpressionSyntax ThrowExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ThrowExpressionSyntax ThrowExpression\(SyntaxToken throwKeyword, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ThrowStatementSyntax ThrowStatement\(ExpressionSyntax expression = null\);
* &emsp; \| &emsp; public static ThrowStatementSyntax ThrowStatement\(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static SyntaxToken Token\(SyntaxKind kind\);
* &emsp; \| &emsp; public static SyntaxToken Token\(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken Token\(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxTokenList TokenList\(\);
* &emsp; \| &emsp; public static SyntaxTokenList TokenList\(SyntaxToken token\);
* &emsp; \| &emsp; public static SyntaxTokenList TokenList\(params SyntaxToken\[\] tokens\);
* &emsp; \| &emsp; public static SyntaxTokenList TokenList\(IEnumerable\<SyntaxToken> tokens\);
* &emsp; \| &emsp; public static SyntaxTrivia Trivia\(StructuredTriviaSyntax node\);
* &emsp; \| &emsp; public static SyntaxTriviaList TriviaList\(\);
* &emsp; \| &emsp; public static SyntaxTriviaList TriviaList\(SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static SyntaxTriviaList TriviaList\(params SyntaxTrivia\[\] trivias\);
* &emsp; \| &emsp; public static SyntaxTriviaList TriviaList\(IEnumerable\<SyntaxTrivia> trivias\);
* &emsp; \| &emsp; public static TryStatementSyntax TryStatement\(SyntaxList\<CatchClauseSyntax> catches = default\);
* &emsp; \| &emsp; public static TryStatementSyntax TryStatement\(BlockSyntax block, SyntaxList\<CatchClauseSyntax> catches, FinallyClauseSyntax @finally\);
* &emsp; \| &emsp; public static TryStatementSyntax TryStatement\(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList\<CatchClauseSyntax> catches, FinallyClauseSyntax @finally\);
* &emsp; \| &emsp; public static TupleElementSyntax TupleElement\(TypeSyntax type\);
* &emsp; \| &emsp; public static TupleElementSyntax TupleElement\(TypeSyntax type, SyntaxToken identifier\);
* &emsp; \| &emsp; public static TupleExpressionSyntax TupleExpression\(SeparatedSyntaxList\<ArgumentSyntax> arguments = default\);
* &emsp; \| &emsp; public static TupleExpressionSyntax TupleExpression\(SyntaxToken openParenToken, SeparatedSyntaxList\<ArgumentSyntax> arguments, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static TupleTypeSyntax TupleType\(SeparatedSyntaxList\<TupleElementSyntax> elements = default\);
* &emsp; \| &emsp; public static TupleTypeSyntax TupleType\(SyntaxToken openParenToken, SeparatedSyntaxList\<TupleElementSyntax> elements, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static TypeArgumentListSyntax TypeArgumentList\(SeparatedSyntaxList\<TypeSyntax> arguments = default\);
* &emsp; \| &emsp; public static TypeArgumentListSyntax TypeArgumentList\(SyntaxToken lessThanToken, SeparatedSyntaxList\<TypeSyntax> arguments, SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; public static TypeConstraintSyntax TypeConstraint\(TypeSyntax type\);
* &emsp; \| &emsp; public static TypeCrefSyntax TypeCref\(TypeSyntax type\);
* &emsp; \| &emsp; public static TypeDeclarationSyntax TypeDeclaration\(SyntaxKind kind, SyntaxToken identifier\);
* &emsp; \| &emsp; public static TypeDeclarationSyntax TypeDeclaration\(SyntaxKind kind, string identifier\);
* &emsp; \| &emsp; public static TypeDeclarationSyntax TypeDeclaration\(SyntaxKind kind, SyntaxList\<AttributeListSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList\<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList\<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static TypeOfExpressionSyntax TypeOfExpression\(TypeSyntax type\);
* &emsp; \| &emsp; public static TypeOfExpressionSyntax TypeOfExpression\(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static TypeParameterSyntax TypeParameter\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static TypeParameterSyntax TypeParameter\(string identifier\);
* &emsp; \| &emsp; public static TypeParameterSyntax TypeParameter\(SyntaxList\<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier\);
* &emsp; \| &emsp; public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause\(IdentifierNameSyntax name\);
* &emsp; \| &emsp; public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause\(string name\);
* &emsp; \| &emsp; public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause\(IdentifierNameSyntax name, SeparatedSyntaxList\<TypeParameterConstraintSyntax> constraints\);
* &emsp; \| &emsp; public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause\(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList\<TypeParameterConstraintSyntax> constraints\);
* &emsp; \| &emsp; public static TypeParameterListSyntax TypeParameterList\(SeparatedSyntaxList\<TypeParameterSyntax> parameters = default\);
* &emsp; \| &emsp; public static TypeParameterListSyntax TypeParameterList\(SyntaxToken lessThanToken, SeparatedSyntaxList\<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia\(SyntaxToken name, bool isActive\);
* &emsp; \| &emsp; public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia\(string name, bool isActive\);
* &emsp; \| &emsp; public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static UnsafeStatementSyntax UnsafeStatement\(BlockSyntax block = null\);
* &emsp; \| &emsp; public static UnsafeStatementSyntax UnsafeStatement\(SyntaxToken unsafeKeyword, BlockSyntax block\);
* &emsp; \| &emsp; public static UsingDirectiveSyntax UsingDirective\(NameSyntax name\);
* &emsp; \| &emsp; public static UsingDirectiveSyntax UsingDirective\(NameEqualsSyntax alias, NameSyntax name\);
* &emsp; \| &emsp; public static UsingDirectiveSyntax UsingDirective\(SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name\);
* &emsp; \| &emsp; public static UsingDirectiveSyntax UsingDirective\(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static UsingStatementSyntax UsingStatement\(StatementSyntax statement\);
* &emsp; \| &emsp; public static UsingStatementSyntax UsingStatement\(VariableDeclarationSyntax declaration, ExpressionSyntax expression, StatementSyntax statement\);
* &emsp; \| &emsp; public static UsingStatementSyntax UsingStatement\(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; public static VariableDeclarationSyntax VariableDeclaration\(TypeSyntax type\);
* &emsp; \| &emsp; public static VariableDeclarationSyntax VariableDeclaration\(TypeSyntax type, SeparatedSyntaxList\<VariableDeclaratorSyntax> variables\);
* &emsp; \| &emsp; public static VariableDeclaratorSyntax VariableDeclarator\(SyntaxToken identifier\);
* &emsp; \| &emsp; public static VariableDeclaratorSyntax VariableDeclarator\(string identifier\);
* &emsp; \| &emsp; public static VariableDeclaratorSyntax VariableDeclarator\(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static SyntaxToken VerbatimIdentifier\(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia\(bool isActive\);
* &emsp; \| &emsp; public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia\(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive\);
* &emsp; \| &emsp; public static WhenClauseSyntax WhenClause\(ExpressionSyntax condition\);
* &emsp; \| &emsp; public static WhenClauseSyntax WhenClause\(SyntaxToken whenKeyword, ExpressionSyntax condition\);
* &emsp; \| &emsp; public static WhereClauseSyntax WhereClause\(ExpressionSyntax condition\);
* &emsp; \| &emsp; public static WhereClauseSyntax WhereClause\(SyntaxToken whereKeyword, ExpressionSyntax condition\);
* &emsp; \| &emsp; public static WhileStatementSyntax WhileStatement\(ExpressionSyntax condition, StatementSyntax statement\);
* &emsp; \| &emsp; public static WhileStatementSyntax WhileStatement\(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement\);
* &emsp; \| &emsp; public static SyntaxTrivia Whitespace\(string text\);
* &emsp; \| &emsp; public static SyntaxTrivia Whitespace\(string text, bool elastic\);
* &emsp; \| &emsp; public static XmlCDataSectionSyntax XmlCDataSection\(SyntaxTokenList textTokens = default\);
* &emsp; \| &emsp; public static XmlCDataSectionSyntax XmlCDataSection\(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken\);
* &emsp; \| &emsp; public static XmlCommentSyntax XmlComment\(SyntaxTokenList textTokens = default\);
* &emsp; \| &emsp; public static XmlCommentSyntax XmlComment\(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken\);
* &emsp; \| &emsp; public static XmlCrefAttributeSyntax XmlCrefAttribute\(CrefSyntax cref\);
* &emsp; \| &emsp; public static XmlCrefAttributeSyntax XmlCrefAttribute\(CrefSyntax cref, SyntaxKind quoteKind\);
* &emsp; \| &emsp; public static XmlCrefAttributeSyntax XmlCrefAttribute\(XmlNameSyntax name, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; public static XmlCrefAttributeSyntax XmlCrefAttribute\(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlElement\(string localName, SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlElement\(XmlNameSyntax name, SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlElement\(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlElement\(XmlElementStartTagSyntax startTag, SyntaxList\<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag\);
* &emsp; \| &emsp; public static XmlElementEndTagSyntax XmlElementEndTag\(XmlNameSyntax name\);
* &emsp; \| &emsp; public static XmlElementEndTagSyntax XmlElementEndTag\(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; public static XmlElementStartTagSyntax XmlElementStartTag\(XmlNameSyntax name\);
* &emsp; \| &emsp; public static XmlElementStartTagSyntax XmlElementStartTag\(XmlNameSyntax name, SyntaxList\<XmlAttributeSyntax> attributes\);
* &emsp; \| &emsp; public static XmlElementStartTagSyntax XmlElementStartTag\(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList\<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlEmptyElement\(string localName\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlEmptyElement\(XmlNameSyntax name\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlEmptyElement\(XmlNameSyntax name, SyntaxList\<XmlAttributeSyntax> attributes\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlEmptyElement\(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList\<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken\);
* &emsp; \| &emsp; public static SyntaxToken XmlEntity\(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlExampleElement\(params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlExampleElement\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlExceptionElement\(CrefSyntax cref, params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlExceptionElement\(CrefSyntax cref, SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlMultiLineElement\(string localName, SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlMultiLineElement\(XmlNameSyntax name, SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlNameSyntax XmlName\(SyntaxToken localName\);
* &emsp; \| &emsp; public static XmlNameSyntax XmlName\(string localName\);
* &emsp; \| &emsp; public static XmlNameSyntax XmlName\(XmlPrefixSyntax prefix, SyntaxToken localName\);
* &emsp; \| &emsp; public static XmlNameAttributeSyntax XmlNameAttribute\(string parameterName\);
* &emsp; \| &emsp; public static XmlNameAttributeSyntax XmlNameAttribute\(XmlNameSyntax name, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; public static XmlNameAttributeSyntax XmlNameAttribute\(XmlNameSyntax name, SyntaxToken startQuoteToken, string identifier, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; public static XmlNameAttributeSyntax XmlNameAttribute\(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; public static XmlTextSyntax XmlNewLine\(string text\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlNullKeywordElement\(\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlParaElement\(params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlParaElement\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlParamElement\(string parameterName, params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlParamElement\(string parameterName, SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlParamRefElement\(string parameterName\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlPermissionElement\(CrefSyntax cref, params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlPermissionElement\(CrefSyntax cref, SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlPlaceholderElement\(params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlPlaceholderElement\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlPrefixSyntax XmlPrefix\(SyntaxToken prefix\);
* &emsp; \| &emsp; public static XmlPrefixSyntax XmlPrefix\(string prefix\);
* &emsp; \| &emsp; public static XmlPrefixSyntax XmlPrefix\(SyntaxToken prefix, SyntaxToken colonToken\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlPreliminaryElement\(\);
* &emsp; \| &emsp; public static XmlProcessingInstructionSyntax XmlProcessingInstruction\(XmlNameSyntax name\);
* &emsp; \| &emsp; public static XmlProcessingInstructionSyntax XmlProcessingInstruction\(XmlNameSyntax name, SyntaxTokenList textTokens\);
* &emsp; \| &emsp; public static XmlProcessingInstructionSyntax XmlProcessingInstruction\(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlRemarksElement\(params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlRemarksElement\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlReturnsElement\(params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlReturnsElement\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlSeeAlsoElement\(CrefSyntax cref\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlSeeAlsoElement\(Uri linkAddress, SyntaxList\<XmlNodeSyntax> linkText\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlSeeElement\(CrefSyntax cref\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlSummaryElement\(params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlSummaryElement\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static XmlTextSyntax XmlText\(\);
* &emsp; \| &emsp; public static XmlTextSyntax XmlText\(params SyntaxToken\[\] textTokens\);
* &emsp; \| &emsp; public static XmlTextSyntax XmlText\(SyntaxTokenList textTokens\);
* &emsp; \| &emsp; public static XmlTextSyntax XmlText\(string value\);
* &emsp; \| &emsp; public static XmlTextAttributeSyntax XmlTextAttribute\(string name, params SyntaxToken\[\] textTokens\);
* &emsp; \| &emsp; public static XmlTextAttributeSyntax XmlTextAttribute\(string name, string value\);
* &emsp; \| &emsp; public static XmlTextAttributeSyntax XmlTextAttribute\(string name, SyntaxKind quoteKind, SyntaxTokenList textTokens\);
* &emsp; \| &emsp; public static XmlTextAttributeSyntax XmlTextAttribute\(XmlNameSyntax name, SyntaxKind quoteKind, SyntaxTokenList textTokens\);
* &emsp; \| &emsp; public static XmlTextAttributeSyntax XmlTextAttribute\(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; public static XmlTextAttributeSyntax XmlTextAttribute\(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; public static XmlTextAttributeSyntax XmlTextAttribute\(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken\);
* &emsp; \| &emsp; public static SyntaxToken XmlTextLiteral\(string value\);
* &emsp; \| &emsp; public static SyntaxToken XmlTextLiteral\(string text, string value\);
* &emsp; \| &emsp; public static SyntaxToken XmlTextLiteral\(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static SyntaxToken XmlTextNewLine\(string text\);
* &emsp; \| &emsp; public static SyntaxToken XmlTextNewLine\(string text, bool continueXmlDocumentationComment\);
* &emsp; \| &emsp; public static SyntaxToken XmlTextNewLine\(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlThreadSafetyElement\(\);
* &emsp; \| &emsp; public static XmlEmptyElementSyntax XmlThreadSafetyElement\(bool isStatic, bool isInstance\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlValueElement\(params XmlNodeSyntax\[\] content\);
* &emsp; \| &emsp; public static XmlElementSyntax XmlValueElement\(SyntaxList\<XmlNodeSyntax> content\);
* &emsp; \| &emsp; public static YieldStatementSyntax YieldStatement\(SyntaxKind kind, ExpressionSyntax expression = null\);
* &emsp; \| &emsp; public static YieldStatementSyntax YieldStatement\(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.SyntaxFacts
* &emsp; \| &emsp; public static IEqualityComparer\<SyntaxKind> EqualityComparer \{ get; \}
* &emsp; \| &emsp; public static SyntaxKind GetAccessorDeclarationKind\(SyntaxKind keyword\);
* &emsp; \| &emsp; public static SyntaxKind GetAssignmentExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static SyntaxKind GetBaseTypeDeclarationKind\(SyntaxKind kind\);
* &emsp; \| &emsp; public static SyntaxKind GetBinaryExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static SyntaxKind GetCheckStatement\(SyntaxKind keyword\);
* &emsp; \| &emsp; public static SyntaxKind GetContextualKeywordKind\(string text\);
* &emsp; \| &emsp; public static IEnumerable\<SyntaxKind> GetContextualKeywordKinds\(\);
* &emsp; \| &emsp; public static SyntaxKind GetInstanceExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static SyntaxKind GetKeywordKind\(string text\);
* &emsp; \| &emsp; public static IEnumerable\<SyntaxKind> GetKeywordKinds\(\);
* &emsp; \| &emsp; public static SyntaxKind GetLiteralExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static SyntaxKind GetOperatorKind\(string operatorMetadataName\);
* &emsp; \| &emsp; public static SyntaxKind GetPostfixUnaryExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static SyntaxKind GetPrefixUnaryExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static SyntaxKind GetPreprocessorKeywordKind\(string text\);
* &emsp; \| &emsp; public static IEnumerable\<SyntaxKind> GetPreprocessorKeywordKinds\(\);
* &emsp; \| &emsp; public static SyntaxKind GetPrimaryFunction\(SyntaxKind keyword\);
* &emsp; \| &emsp; public static IEnumerable\<SyntaxKind> GetPunctuationKinds\(\);
* &emsp; \| &emsp; public static IEnumerable\<SyntaxKind> GetReservedKeywordKinds\(\);
* &emsp; \| &emsp; public static SyntaxKind GetSwitchLabelKind\(SyntaxKind keyword\);
* &emsp; \| &emsp; public static string GetText\(Accessibility accessibility\);
* &emsp; \| &emsp; public static string GetText\(SyntaxKind kind\);
* &emsp; \| &emsp; public static SyntaxKind GetTypeDeclarationKind\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsAccessibilityModifier\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsAccessorDeclaration\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsAccessorDeclarationKeyword\(SyntaxKind keyword\);
* &emsp; \| &emsp; public static bool IsAliasQualifier\(SyntaxNode node\);
* &emsp; \| &emsp; public static bool IsAnyOverloadableOperator\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsAnyToken\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsAnyUnaryExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsAssignmentExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsAssignmentExpressionOperatorToken\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsAttributeName\(SyntaxNode node\);
* &emsp; \| &emsp; public static bool IsAttributeTargetSpecifier\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsBinaryExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsBinaryExpressionOperatorToken\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsContextualKeyword\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsDocumentationCommentTrivia\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsFixedStatementExpression\(SyntaxNode node\);
* &emsp; \| &emsp; public static bool IsGlobalMemberDeclaration\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsIdentifierPartCharacter\(char ch\);
* &emsp; \| &emsp; public static bool IsIdentifierStartCharacter\(char ch\);
* &emsp; \| &emsp; public static bool IsInNamespaceOrTypeContext\(ExpressionSyntax node\);
* &emsp; \| &emsp; public static bool IsInTypeOnlyContext\(ExpressionSyntax node\);
* &emsp; \| &emsp; public static bool IsIndexed\(ExpressionSyntax node\);
* &emsp; \| &emsp; public static bool IsInstanceExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsInvoked\(ExpressionSyntax node\);
* &emsp; \| &emsp; public static bool IsKeywordKind\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsLambdaBody\(SyntaxNode node\);
* &emsp; \| &emsp; public static bool IsLanguagePunctuation\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsLiteralExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsName\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsNamedArgumentName\(SyntaxNode node\);
* &emsp; \| &emsp; public static bool IsNamespaceAliasQualifier\(ExpressionSyntax node\);
* &emsp; \| &emsp; public static bool IsNamespaceMemberDeclaration\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsNewLine\(char ch\);
* &emsp; \| &emsp; public static bool IsOverloadableBinaryOperator\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsOverloadableUnaryOperator\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsPostfixUnaryExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsPostfixUnaryExpressionToken\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsPredefinedType\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsPrefixUnaryExpression\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsPrefixUnaryExpressionOperatorToken\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsPreprocessorDirective\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsPreprocessorKeyword\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsPreprocessorPunctuation\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsPrimaryFunction\(SyntaxKind keyword\);
* &emsp; \| &emsp; public static bool IsPunctuation\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsPunctuationOrKeyword\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsQueryContextualKeyword\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsReservedKeyword\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsReservedTupleElementName\(string elementName\);
* &emsp; \| &emsp; public static bool IsTrivia\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsTypeDeclaration\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsTypeParameterVarianceKeyword\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsTypeSyntax\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsUnaryOperatorDeclarationToken\(SyntaxKind token\);
* &emsp; \| &emsp; public static bool IsValidIdentifier\(string name\);
* &emsp; \| &emsp; public static bool IsWhitespace\(char ch\);
* &emsp; \| &emsp; public static string TryGetInferredMemberName\(this SyntaxNode syntax\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.TypedConstantExtensions
* &emsp; \| &emsp; public static string ToCSharpString\(this TypedConstant constant\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CSharp\.Formatting\.CSharpFormattingOptions
* &emsp; \| &emsp; public static Option\<bool> IndentBlock \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> IndentBraces \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> IndentSwitchCaseSection \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> IndentSwitchSection \{ get; \}
* &emsp; \| &emsp; public static Option\<LabelPositionOptions> LabelPositioning \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLineForCatch \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLineForClausesInQuery \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLineForElse \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLineForFinally \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLineForMembersInAnonymousTypes \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLineForMembersInObjectInit \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInAccessors \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInAnonymousMethods \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInAnonymousTypes \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInControlBlocks \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInLambdaExpressionBody \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInMethods \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInObjectCollectionArrayInitializers \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInProperties \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> NewLinesForBracesInTypes \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceAfterCast \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceAfterColonInBaseTypeDeclaration \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceAfterComma \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceAfterControlFlowStatementKeyword \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceAfterDot \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceAfterMethodCallName \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceAfterSemicolonsInForStatement \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceBeforeColonInBaseTypeDeclaration \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceBeforeComma \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceBeforeDot \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceBeforeOpenSquareBracket \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceBeforeSemicolonsInForStatement \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceBetweenEmptyMethodCallParentheses \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceBetweenEmptyMethodDeclarationParentheses \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceBetweenEmptySquareBrackets \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceWithinCastParentheses \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceWithinExpressionParentheses \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceWithinMethodCallParentheses \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceWithinMethodDeclarationParenthesis \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceWithinOtherParentheses \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpaceWithinSquareBrackets \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpacesIgnoreAroundVariableDeclaration \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> SpacingAfterMethodDeclarationName \{ get; \}
* &emsp; \| &emsp; public static Option\<BinaryOperatorSpacingOptions> SpacingAroundBinaryOperator \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> WrappingKeepStatementsOnSingleLine \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> WrappingPreserveSingleLine \{ get; \}
* &emsp; public static class Microsoft\.CodeAnalysis\.Classification\.ClassificationTypeNames
* &emsp; \| &emsp; public const string ClassName = "class name";
* &emsp; \| &emsp; public const string Comment = "comment";
* &emsp; \| &emsp; public const string DelegateName = "delegate name";
* &emsp; \| &emsp; public const string EnumName = "enum name";
* &emsp; \| &emsp; public const string ExcludedCode = "excluded code";
* &emsp; \| &emsp; public const string Identifier = "identifier";
* &emsp; \| &emsp; public const string InterfaceName = "interface name";
* &emsp; \| &emsp; public const string Keyword = "keyword";
* &emsp; \| &emsp; public const string ModuleName = "module name";
* &emsp; \| &emsp; public const string NumericLiteral = "number";
* &emsp; \| &emsp; public const string Operator = "operator";
* &emsp; \| &emsp; public const string PreprocessorKeyword = "preprocessor keyword";
* &emsp; \| &emsp; public const string PreprocessorText = "preprocessor text";
* &emsp; \| &emsp; public const string Punctuation = "punctuation";
* &emsp; \| &emsp; public const string StringLiteral = "string";
* &emsp; \| &emsp; public const string StructName = "struct name";
* &emsp; \| &emsp; public const string Text = "text";
* &emsp; \| &emsp; public const string TypeParameterName = "type parameter name";
* &emsp; \| &emsp; public const string VerbatimStringLiteral = "string \- verbatim";
* &emsp; \| &emsp; public const string WhiteSpace = "whitespace";
* &emsp; \| &emsp; public const string XmlDocCommentAttributeName = "xml doc comment \- attribute name";
* &emsp; \| &emsp; public const string XmlDocCommentAttributeQuotes = "xml doc comment \- attribute quotes";
* &emsp; \| &emsp; public const string XmlDocCommentAttributeValue = "xml doc comment \- attribute value";
* &emsp; \| &emsp; public const string XmlDocCommentCDataSection = "xml doc comment \- cdata section";
* &emsp; \| &emsp; public const string XmlDocCommentComment = "xml doc comment \- comment";
* &emsp; \| &emsp; public const string XmlDocCommentDelimiter = "xml doc comment \- delimiter";
* &emsp; \| &emsp; public const string XmlDocCommentEntityReference = "xml doc comment \- entity reference";
* &emsp; \| &emsp; public const string XmlDocCommentName = "xml doc comment \- name";
* &emsp; \| &emsp; public const string XmlDocCommentProcessingInstruction = "xml doc comment \- processing instruction";
* &emsp; \| &emsp; public const string XmlDocCommentText = "xml doc comment \- text";
* &emsp; \| &emsp; public const string XmlLiteralAttributeName = "xml literal \- attribute name";
* &emsp; \| &emsp; public const string XmlLiteralAttributeQuotes = "xml literal \- attribute quotes";
* &emsp; \| &emsp; public const string XmlLiteralAttributeValue = "xml literal \- attribute value";
* &emsp; \| &emsp; public const string XmlLiteralCDataSection = "xml literal \- cdata section";
* &emsp; \| &emsp; public const string XmlLiteralComment = "xml literal \- comment";
* &emsp; \| &emsp; public const string XmlLiteralDelimiter = "xml literal \- delimiter";
* &emsp; \| &emsp; public const string XmlLiteralEmbeddedExpression = "xml literal \- embedded expression";
* &emsp; \| &emsp; public const string XmlLiteralEntityReference = "xml literal \- entity reference";
* &emsp; \| &emsp; public const string XmlLiteralName = "xml literal \- name";
* &emsp; \| &emsp; public const string XmlLiteralProcessingInstruction = "xml literal \- processing instruction";
* &emsp; \| &emsp; public const string XmlLiteralText = "xml literal \- text";
* &emsp; public static class Microsoft\.CodeAnalysis\.Classification\.Classifier
* &emsp; \| &emsp; public static IEnumerable\<ClassifiedSpan> GetClassifiedSpans\(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ClassifiedSpan>> GetClassifiedSpansAsync\(Document document, TextSpan textSpan, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CodeActions\.ConflictAnnotation
* &emsp; \| &emsp; public const string Kind = "CodeAction\_Conflict";
* &emsp; \| &emsp; public static SyntaxAnnotation Create\(string description\);
* &emsp; \| &emsp; public static string GetDescription\(SyntaxAnnotation annotation\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CodeActions\.RenameAnnotation
* &emsp; \| &emsp; public const string Kind = "CodeAction\_Rename";
* &emsp; \| &emsp; public static SyntaxAnnotation Create\(\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CodeActions\.WarningAnnotation
* &emsp; \| &emsp; public const string Kind = "CodeAction\_Warning";
* &emsp; \| &emsp; public static SyntaxAnnotation Create\(string description\);
* &emsp; \| &emsp; public static string GetDescription\(SyntaxAnnotation annotation\);
* &emsp; public static class Microsoft\.CodeAnalysis\.CodeFixes\.WellKnownFixAllProviders
* &emsp; \| &emsp; public static FixAllProvider BatchFixer \{ get; \}
* &emsp; public static class Microsoft\.CodeAnalysis\.Diagnostics\.DiagnosticAnalyzerExtensions
* &emsp; \| &emsp; public static CompilationWithAnalyzers WithAnalyzers\(this Compilation compilation, ImmutableArray\<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions\);
* &emsp; \| &emsp; public static CompilationWithAnalyzers WithAnalyzers\(this Compilation compilation, ImmutableArray\<DiagnosticAnalyzer> analyzers, AnalyzerOptions options = null, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Editing\.ImportAdder
* &emsp; \| &emsp; public static Task\<Document> AddImportsAsync\(Document document, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> AddImportsAsync\(Document document, SyntaxAnnotation annotation, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> AddImportsAsync\(Document document, TextSpan span, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> AddImportsAsync\(Document document, IEnumerable\<TextSpan> spans, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Editing\.SymbolEditorExtensions
* &emsp; \| &emsp; public static Task\<SyntaxNode> GetBaseOrInterfaceDeclarationReferenceAsync\(this SymbolEditor editor, ISymbol symbol, ITypeSymbol baseOrInterfaceType, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<ISymbol> SetBaseTypeAsync\(this SymbolEditor editor, INamedTypeSymbol symbol, Func\<SyntaxGenerator, SyntaxNode> getNewBaseType, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<ISymbol> SetBaseTypeAsync\(this SymbolEditor editor, INamedTypeSymbol symbol, ITypeSymbol newBaseType, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Editing\.SyntaxEditorExtensions
* &emsp; \| &emsp; public static void AddAttribute\(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute\);
* &emsp; \| &emsp; public static void AddAttributeArgument\(this SyntaxEditor editor, SyntaxNode attributeDeclaration, SyntaxNode attributeArgument\);
* &emsp; \| &emsp; public static void AddBaseType\(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode baseType\);
* &emsp; \| &emsp; public static void AddInterfaceType\(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode interfaceType\);
* &emsp; \| &emsp; public static void AddMember\(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode member\);
* &emsp; \| &emsp; public static void AddParameter\(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode parameter\);
* &emsp; \| &emsp; public static void AddReturnAttribute\(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute\);
* &emsp; \| &emsp; public static void InsertMembers\(this SyntaxEditor editor, SyntaxNode declaration, int index, IEnumerable\<SyntaxNode> members\);
* &emsp; \| &emsp; public static void SetAccessibility\(this SyntaxEditor editor, SyntaxNode declaration, Accessibility accessibility\);
* &emsp; \| &emsp; public static void SetExpression\(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode expression\);
* &emsp; \| &emsp; public static void SetGetAccessorStatements\(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public static void SetModifiers\(this SyntaxEditor editor, SyntaxNode declaration, DeclarationModifiers modifiers\);
* &emsp; \| &emsp; public static void SetName\(this SyntaxEditor editor, SyntaxNode declaration, string name\);
* &emsp; \| &emsp; public static void SetSetAccessorStatements\(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public static void SetStatements\(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable\<SyntaxNode> statements\);
* &emsp; \| &emsp; public static void SetType\(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode type\);
* &emsp; \| &emsp; public static void SetTypeConstraint\(this SyntaxEditor editor, SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kind, IEnumerable\<SyntaxNode> types\);
* &emsp; \| &emsp; public static void SetTypeParameters\(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable\<string> typeParameters\);
* &emsp; public static class Microsoft\.CodeAnalysis\.FindSymbols\.SymbolFinder
* &emsp; \| &emsp; public static Task\<IEnumerable\<SymbolCallerInfo>> FindCallersAsync\(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<SymbolCallerInfo>> FindCallersAsync\(ISymbol symbol, Solution solution, IImmutableSet\<Document> documents, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindDeclarationsAsync\(Project project, string name, bool ignoreCase, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindDeclarationsAsync\(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<INamedTypeSymbol>> FindDerivedClassesAsync\(INamedTypeSymbol type, Solution solution, IImmutableSet\<Project> projects = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindImplementationsAsync\(ISymbol symbol, Solution solution, IImmutableSet\<Project> projects = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindImplementedInterfaceMembersAsync\(ISymbol symbol, Solution solution, IImmutableSet\<Project> projects = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindOverridesAsync\(ISymbol symbol, Solution solution, IImmutableSet\<Project> projects = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ReferencedSymbol>> FindReferencesAsync\(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ReferencedSymbol>> FindReferencesAsync\(ISymbol symbol, Solution solution, IImmutableSet\<Document> documents, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ReferencedSymbol>> FindReferencesAsync\(ISymbol symbol, Solution solution, IFindReferencesProgress progress, IImmutableSet\<Document> documents, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IEnumerable\<TSymbol> FindSimilarSymbols\<TSymbol>\(TSymbol symbol, Compilation compilation, CancellationToken cancellationToken = default\) where TSymbol : ISymbol;
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindSourceDeclarationsAsync\(Project project, Func\<string, bool> predicate, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindSourceDeclarationsAsync\(Solution solution, Func\<string, bool> predicate, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindSourceDeclarationsAsync\(Project project, string name, bool ignoreCase, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindSourceDeclarationsAsync\(Project project, Func\<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindSourceDeclarationsAsync\(Solution solution, string name, bool ignoreCase, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindSourceDeclarationsAsync\(Solution solution, Func\<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindSourceDeclarationsAsync\(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> FindSourceDeclarationsAsync\(Solution solution, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<ISymbol> FindSourceDefinitionAsync\(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol FindSymbolAtPosition\(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<ISymbol> FindSymbolAtPositionAsync\(Document document, int position, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<ISymbol> FindSymbolAtPositionAsync\(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Formatting\.Formatter
* &emsp; \| &emsp; public static SyntaxAnnotation Annotation \{ get; \}
* &emsp; \| &emsp; public static SyntaxNode Format\(SyntaxNode node, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SyntaxNode Format\(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SyntaxNode Format\(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static SyntaxNode Format\(SyntaxNode node, IEnumerable\<TextSpan> spans, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> FormatAsync\(Document document, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> FormatAsync\(Document document, SyntaxAnnotation annotation, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> FormatAsync\(Document document, TextSpan span, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> FormatAsync\(Document document, IEnumerable\<TextSpan> spans, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IList\<TextChange> GetFormattedTextChanges\(SyntaxNode node, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IList\<TextChange> GetFormattedTextChanges\(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IList\<TextChange> GetFormattedTextChanges\(SyntaxNode node, IEnumerable\<TextSpan> spans, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Formatting\.FormattingOptions
* &emsp; \| &emsp; public static PerLanguageOption\<int> IndentationSize \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<string> NewLine \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<FormattingOptions\.IndentStyle> SmartIndent \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<int> TabSize \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> UseTabs \{ get; \}
* &emsp; public static class Microsoft\.CodeAnalysis\.Host\.Mef\.ServiceLayer
* &emsp; \| &emsp; public const string Default = "Default";
* &emsp; \| &emsp; public const string Desktop = "Desktop";
* &emsp; \| &emsp; public const string Editor = "Editor";
* &emsp; \| &emsp; public const string Host = "Host";
* &emsp; public static class Microsoft\.CodeAnalysis\.Recommendations\.RecommendationOptions
* &emsp; \| &emsp; public static PerLanguageOption\<bool> FilterOutOfScopeLocals \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> HideAdvancedMembers \{ get; \}
* &emsp; public static class Microsoft\.CodeAnalysis\.Recommendations\.Recommender
* &emsp; \| &emsp; public static IEnumerable\<ISymbol> GetRecommendedSymbolsAtPosition\(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<IEnumerable\<ISymbol>> GetRecommendedSymbolsAtPositionAsync\(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Rename\.RenameOptions
* &emsp; \| &emsp; public static Option\<bool> PreviewChanges \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> RenameInComments \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> RenameInStrings \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> RenameOverloads \{ get; \}
* &emsp; public static class Microsoft\.CodeAnalysis\.Rename\.Renamer
* &emsp; \| &emsp; public static Task\<Solution> RenameSymbolAsync\(Solution solution, ISymbol symbol, string newName, OptionSet optionSet, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Semantics\.OperationExtensions
* &emsp; \| &emsp; public static IEnumerable\<IOperation> Descendants\(this IOperation operation\);
* &emsp; \| &emsp; public static IEnumerable\<IOperation> DescendantsAndSelf\(this IOperation operation\);
* &emsp; \| &emsp; public static ImmutableArray\<ILocalSymbol> GetDeclaredVariables\(this IVariableDeclarationStatement declarationStatement\);
* &emsp; \| &emsp; public static IOperation GetRootOperation\(this ISymbol symbol, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Semantics\.UnaryAndBinaryOperationExtensions
* &emsp; \| &emsp; public static BinaryOperandsKind GetBinaryOperandsKind\(this IBinaryOperatorExpression binary\);
* &emsp; \| &emsp; public static BinaryOperandsKind GetBinaryOperandsKind\(this ICompoundAssignmentExpression compoundAssignment\);
* &emsp; \| &emsp; public static BinaryOperandsKind GetBinaryOperandsKind\(BinaryOperationKind kind\);
* &emsp; \| &emsp; public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind\(this IBinaryOperatorExpression binary\);
* &emsp; \| &emsp; public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind\(this ICompoundAssignmentExpression compoundAssignment\);
* &emsp; \| &emsp; public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind\(BinaryOperationKind kind\);
* &emsp; \| &emsp; public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind\(this IIncrementExpression increment\);
* &emsp; \| &emsp; public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind\(UnaryOperationKind kind\);
* &emsp; \| &emsp; public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind\(this IUnaryOperatorExpression unary\);
* &emsp; \| &emsp; public static UnaryOperandKind GetUnaryOperandKind\(this IIncrementExpression increment\);
* &emsp; \| &emsp; public static UnaryOperandKind GetUnaryOperandKind\(UnaryOperationKind kind\);
* &emsp; \| &emsp; public static UnaryOperandKind GetUnaryOperandKind\(this IUnaryOperatorExpression unary\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Simplification\.SimplificationOptions
* &emsp; \| &emsp; public static Option\<bool> AllowSimplificationToBaseType \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> AllowSimplificationToGenericType \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> PreferAliasToQualification \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> PreferImplicitTypeInLocalDeclaration \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> PreferImplicitTypeInference \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> PreferIntrinsicPredefinedTypeKeywordInDeclaration \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> PreferIntrinsicPredefinedTypeKeywordInMemberAccess \{ get; \}
* &emsp; \| &emsp; public static Option\<bool> PreferOmittingModuleNamesInQualification \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> QualifyEventAccess \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> QualifyFieldAccess \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> QualifyMemberAccessWithThisOrMe \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> QualifyMethodAccess \{ get; \}
* &emsp; \| &emsp; public static PerLanguageOption\<bool> QualifyPropertyAccess \{ get; \}
* &emsp; public static class Microsoft\.CodeAnalysis\.Simplification\.Simplifier
* &emsp; \| &emsp; public static SyntaxAnnotation Annotation \{ get; \}
* &emsp; \| &emsp; public static SyntaxAnnotation SpecialTypeAnnotation \{ get; \}
* &emsp; \| &emsp; public static SyntaxToken Expand\(SyntaxToken token, SemanticModel semanticModel, Workspace workspace, Func\<SyntaxNode, bool> expandInsideNode = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static TNode Expand\<TNode>\(TNode node, SemanticModel semanticModel, Workspace workspace, Func\<SyntaxNode, bool> expandInsideNode = null, bool expandParameter = false, CancellationToken cancellationToken = default\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static Task\<SyntaxToken> ExpandAsync\(SyntaxToken token, Document document, Func\<SyntaxNode, bool> expandInsideNode = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<TNode> ExpandAsync\<TNode>\(TNode node, Document document, Func\<SyntaxNode, bool> expandInsideNode = null, bool expandParameter = false, CancellationToken cancellationToken = default\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static Task\<Document> ReduceAsync\(Document document, OptionSet optionSet = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> ReduceAsync\(Document document, SyntaxAnnotation annotation, OptionSet optionSet = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> ReduceAsync\(Document document, TextSpan span, OptionSet optionSet = null, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> ReduceAsync\(Document document, IEnumerable\<TextSpan> spans, OptionSet optionSet = null, CancellationToken cancellationToken = default\);
* &emsp; public static class Microsoft\.CodeAnalysis\.Tags\.WellKnownTags
* &emsp; \| &emsp; public const string Assembly = "Assembly";
* &emsp; \| &emsp; public const string Class = "Class";
* &emsp; \| &emsp; public const string Constant = "Constant";
* &emsp; \| &emsp; public const string Delegate = "Delegate";
* &emsp; \| &emsp; public const string Enum = "Enum";
* &emsp; \| &emsp; public const string EnumMember = "EnumMember";
* &emsp; \| &emsp; public const string Error = "Error";
* &emsp; \| &emsp; public const string Event = "Event";
* &emsp; \| &emsp; public const string ExtensionMethod = "ExtensionMethod";
* &emsp; \| &emsp; public const string Field = "Field";
* &emsp; \| &emsp; public const string File = "File";
* &emsp; \| &emsp; public const string Folder = "Folder";
* &emsp; \| &emsp; public const string Interface = "Interface";
* &emsp; \| &emsp; public const string Internal = "Internal";
* &emsp; \| &emsp; public const string Intrinsic = "Intrinsic";
* &emsp; \| &emsp; public const string Keyword = "Keyword";
* &emsp; \| &emsp; public const string Label = "Label";
* &emsp; \| &emsp; public const string Local = "Local";
* &emsp; \| &emsp; public const string Method = "Method";
* &emsp; \| &emsp; public const string Module = "Module";
* &emsp; \| &emsp; public const string Namespace = "Namespace";
* &emsp; \| &emsp; public const string Operator = "Operator";
* &emsp; \| &emsp; public const string Parameter = "Parameter";
* &emsp; \| &emsp; public const string Private = "Private";
* &emsp; \| &emsp; public const string Project = "Project";
* &emsp; \| &emsp; public const string Property = "Property";
* &emsp; \| &emsp; public const string Protected = "Protected";
* &emsp; \| &emsp; public const string Public = "Public";
* &emsp; \| &emsp; public const string RangeVariable = "RangeVariable";
* &emsp; \| &emsp; public const string Reference = "Reference";
* &emsp; \| &emsp; public const string Snippet = "Snippet";
* &emsp; \| &emsp; public const string Structure = "Structure";
* &emsp; \| &emsp; public const string TypeParameter = "TypeParameter";
* &emsp; \| &emsp; public const string Warning = "Warning";
* &emsp; public static class Roslynator\.DiagnosticsExtensions
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable\<Location> additionalLocations, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable\<Location> additionalLocations, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable\<Location> additionalLocations, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary\<string, string> properties, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary\<string, string> properties, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary\<string, string> properties, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable\<Location> additionalLocations, ImmutableDictionary\<string, string> properties, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable\<Location> additionalLocations, ImmutableDictionary\<string, string> properties, params object\[\] messageArgs\);
* &emsp; \| &emsp; public static void ReportDiagnostic\(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable\<Location> additionalLocations, ImmutableDictionary\<string, string> properties, params object\[\] messageArgs\);
* &emsp; public static class Roslynator\.EnumExtensions
* &emsp; \| &emsp; public static bool Is\(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2\);
* &emsp; \| &emsp; public static bool Is\(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2\);
* &emsp; \| &emsp; public static bool Is\(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2\);
* &emsp; \| &emsp; public static bool Is\(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2\);
* &emsp; \| &emsp; public static bool Is\(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3\);
* &emsp; \| &emsp; public static bool Is\(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3\);
* &emsp; \| &emsp; public static bool Is\(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3\);
* &emsp; \| &emsp; public static bool Is\(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3\);
* &emsp; \| &emsp; public static bool Is\(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4\);
* &emsp; \| &emsp; public static bool Is\(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4\);
* &emsp; \| &emsp; public static bool Is\(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4\);
* &emsp; \| &emsp; public static bool Is\(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4\);
* &emsp; \| &emsp; public static bool Is\(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4, Accessibility accessibility5\);
* &emsp; \| &emsp; public static bool Is\(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4, MethodKind methodKind5\);
* &emsp; \| &emsp; public static bool Is\(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4, SpecialType specialType5\);
* &emsp; \| &emsp; public static bool Is\(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4, TypeKind typeKind5\);
* &emsp; \| &emsp; public static bool IsMoreRestrictiveThan\(this Accessibility accessibility, Accessibility other\);
* &emsp; public static class Roslynator\.FileLinePositionSpanExtensions
* &emsp; \| &emsp; public static int EndLine\(this FileLinePositionSpan fileLinePositionSpan\);
* &emsp; \| &emsp; public static bool IsMultiLine\(this FileLinePositionSpan fileLinePositionSpan\);
* &emsp; \| &emsp; public static bool IsSingleLine\(this FileLinePositionSpan fileLinePositionSpan\);
* &emsp; \| &emsp; public static int StartLine\(this FileLinePositionSpan fileLinePositionSpan\);
* &emsp; public static class Roslynator\.SemanticModelExtensions
* &emsp; \| &emsp; public static INamedTypeSymbol GetEnclosingNamedType\(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static TSymbol GetEnclosingSymbol\<TSymbol>\(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default\) where TSymbol : ISymbol;
* &emsp; \| &emsp; public static ISymbol GetSymbol\(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static INamedTypeSymbol GetTypeByMetadataName\(this SemanticModel semanticModel, string fullyQualifiedMetadataName\);
* &emsp; \| &emsp; public static ITypeSymbol GetTypeSymbol\(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default\);
* &emsp; public static class Roslynator\.SymbolExtensions
* &emsp; \| &emsp; public static IEnumerable\<INamedTypeSymbol> BaseTypes\(this ITypeSymbol type\);
* &emsp; \| &emsp; public static IEnumerable\<ITypeSymbol> BaseTypesAndSelf\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static bool EqualsOrInheritsFrom\(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false\);
* &emsp; \| &emsp; public static bool EqualsOrInheritsFrom\(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false\);
* &emsp; \| &emsp; public static TSymbol FindMember\<TSymbol>\(this ITypeSymbol typeSymbol, Func\<TSymbol, bool> predicate = null\) where TSymbol : ISymbol;
* &emsp; \| &emsp; public static TSymbol FindMember\<TSymbol>\(this ITypeSymbol typeSymbol, string name, Func\<TSymbol, bool> predicate = null\) where TSymbol : ISymbol;
* &emsp; \| &emsp; public static TSymbol FindMember\<TSymbol>\(this INamedTypeSymbol typeSymbol, Func\<TSymbol, bool> predicate, bool includeBaseTypes = false\) where TSymbol : ISymbol;
* &emsp; \| &emsp; public static TSymbol FindMember\<TSymbol>\(this INamedTypeSymbol typeSymbol, string name, Func\<TSymbol, bool> predicate = null, bool includeBaseTypes = false\) where TSymbol : ISymbol;
* &emsp; \| &emsp; public static INamedTypeSymbol FindTypeMember\(this INamedTypeSymbol typeSymbol, Func\<INamedTypeSymbol, bool> predicate, bool includeBaseTypes = false\);
* &emsp; \| &emsp; public static INamedTypeSymbol FindTypeMember\(this INamedTypeSymbol typeSymbol, string name, Func\<INamedTypeSymbol, bool> predicate = null, bool includeBaseTypes = false\);
* &emsp; \| &emsp; public static INamedTypeSymbol FindTypeMember\(this INamedTypeSymbol typeSymbol, string name, int arity, Func\<INamedTypeSymbol, bool> predicate = null, bool includeBaseTypes = false\);
* &emsp; \| &emsp; public static AttributeData GetAttribute\(this ISymbol symbol, INamedTypeSymbol attributeClass\);
* &emsp; \| &emsp; public static AttributeData GetAttribute\(this ISymbol symbol, in MetadataName attributeName\);
* &emsp; \| &emsp; public static bool HasAttribute\(this ISymbol symbol, INamedTypeSymbol attributeClass\);
* &emsp; \| &emsp; public static bool HasAttribute\(this ISymbol symbol, in MetadataName attributeName\);
* &emsp; \| &emsp; public static bool HasAttribute\(this ITypeSymbol typeSymbol, INamedTypeSymbol attributeClass, bool includeBaseTypes\);
* &emsp; \| &emsp; public static bool HasAttribute\(this ITypeSymbol typeSymbol, in MetadataName attributeName, bool includeBaseTypes\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, bool value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, char value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, sbyte value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, byte value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, short value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, ushort value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, int value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, uint value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, long value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, ulong value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, decimal value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, float value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, double value\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this IFieldSymbol fieldSymbol, string value\);
* &emsp; \| &emsp; public static bool HasMetadataName\(this ISymbol symbol, in MetadataName metadataName\);
* &emsp; \| &emsp; public static bool Implements\(this ITypeSymbol typeSymbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false\);
* &emsp; \| &emsp; public static bool Implements\(this ITypeSymbol typeSymbol, SpecialType interfaceType, bool allInterfaces = false\);
* &emsp; \| &emsp; public static bool Implements\(this ITypeSymbol typeSymbol, in MetadataName interfaceName, bool allInterfaces = false\);
* &emsp; \| &emsp; public static bool ImplementsAny\(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, bool allInterfaces = false\);
* &emsp; \| &emsp; public static bool ImplementsAny\(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, SpecialType interfaceType3, bool allInterfaces = false\);
* &emsp; \| &emsp; public static bool ImplementsInterfaceMember\(this ISymbol symbol, bool allInterfaces = false\);
* &emsp; \| &emsp; public static bool ImplementsInterfaceMember\(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false\);
* &emsp; \| &emsp; public static bool ImplementsInterfaceMember\<TSymbol>\(this ISymbol symbol, bool allInterfaces = false\) where TSymbol : ISymbol;
* &emsp; \| &emsp; public static bool ImplementsInterfaceMember\<TSymbol>\(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false\) where TSymbol : ISymbol;
* &emsp; \| &emsp; public static bool InheritsFrom\(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false\);
* &emsp; \| &emsp; public static bool InheritsFrom\(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false\);
* &emsp; \| &emsp; public static bool IsAsyncMethod\(this ISymbol symbol\);
* &emsp; \| &emsp; public static bool IsErrorType\(this ISymbol symbol\);
* &emsp; \| &emsp; public static bool IsIEnumerableOfT\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static bool IsIEnumerableOrIEnumerableOfT\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static bool IsKind\(this ISymbol symbol, SymbolKind kind\);
* &emsp; \| &emsp; public static bool IsKind\(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2\);
* &emsp; \| &emsp; public static bool IsKind\(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3\);
* &emsp; \| &emsp; public static bool IsKind\(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4\);
* &emsp; \| &emsp; public static bool IsKind\(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4, SymbolKind kind5\);
* &emsp; \| &emsp; public static bool IsNullableOf\(this INamedTypeSymbol namedTypeSymbol, SpecialType specialType\);
* &emsp; \| &emsp; public static bool IsNullableOf\(this INamedTypeSymbol namedTypeSymbol, ITypeSymbol typeArgument\);
* &emsp; \| &emsp; public static bool IsNullableOf\(this ITypeSymbol typeSymbol, SpecialType specialType\);
* &emsp; \| &emsp; public static bool IsNullableOf\(this ITypeSymbol typeSymbol, ITypeSymbol typeArgument\);
* &emsp; \| &emsp; public static bool IsNullableType\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static bool IsObject\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static bool IsOrdinaryExtensionMethod\(this IMethodSymbol methodSymbol\);
* &emsp; \| &emsp; public static bool IsParameterArrayOf\(this IParameterSymbol parameterSymbol, SpecialType elementType\);
* &emsp; \| &emsp; public static bool IsParameterArrayOf\(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2\);
* &emsp; \| &emsp; public static bool IsParameterArrayOf\(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2, SpecialType elementType3\);
* &emsp; \| &emsp; public static bool IsPubliclyVisible\(this ISymbol symbol\);
* &emsp; \| &emsp; public static bool IsReducedExtensionMethod\(this IMethodSymbol methodSymbol\);
* &emsp; \| &emsp; public static bool IsRefOrOut\(this IParameterSymbol parameterSymbol\);
* &emsp; \| &emsp; public static bool IsReferenceTypeOrNullableType\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static bool IsString\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static bool IsVoid\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static IMethodSymbol ReducedFromOrSelf\(this IMethodSymbol methodSymbol\);
* &emsp; \| &emsp; public static bool SupportsExplicitDeclaration\(this ITypeSymbol typeSymbol\);
* &emsp; public static class Roslynator\.SyntaxExtensions
* &emsp; \| &emsp; public static bool All\(this SyntaxTokenList list, Func\<SyntaxToken, bool> predicate\);
* &emsp; \| &emsp; public static bool All\(this SyntaxTriviaList list, Func\<SyntaxTrivia, bool> predicate\);
* &emsp; \| &emsp; public static bool All\<TNode>\(this SeparatedSyntaxList\<TNode> list, Func\<TNode, bool> predicate\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool All\<TNode>\(this SyntaxList\<TNode> list, Func\<TNode, bool> predicate\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool Any\(this SyntaxTokenList list, Func\<SyntaxToken, bool> predicate\);
* &emsp; \| &emsp; public static bool Any\(this SyntaxTriviaList list, Func\<SyntaxTrivia, bool> predicate\);
* &emsp; \| &emsp; public static bool Any\<TNode>\(this SeparatedSyntaxList\<TNode> list, Func\<TNode, bool> predicate\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool Any\<TNode>\(this SyntaxList\<TNode> list, Func\<TNode, bool> predicate\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxToken AppendToLeadingTrivia\(this SyntaxToken token, IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; public static SyntaxToken AppendToLeadingTrivia\(this SyntaxToken token, SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static TNode AppendToLeadingTrivia\<TNode>\(this TNode node, IEnumerable\<SyntaxTrivia> trivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode AppendToLeadingTrivia\<TNode>\(this TNode node, SyntaxTrivia trivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxToken AppendToTrailingTrivia\(this SyntaxToken token, IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; public static SyntaxToken AppendToTrailingTrivia\(this SyntaxToken token, SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static TNode AppendToTrailingTrivia\<TNode>\(this TNode node, IEnumerable\<SyntaxTrivia> trivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode AppendToTrailingTrivia\<TNode>\(this TNode node, SyntaxTrivia trivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool Contains\(this SyntaxTokenList tokens, SyntaxToken token\);
* &emsp; \| &emsp; public static bool Contains\<TNode>\(this SeparatedSyntaxList\<TNode> list, TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool Contains\<TNode>\(this SyntaxList\<TNode> list, TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool ContainsDirectives\(this SyntaxNode node, TextSpan span\);
* &emsp; \| &emsp; public static IEnumerable\<SyntaxTrivia> DescendantTrivia\<TNode>\(this SyntaxList\<TNode> list, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static IEnumerable\<SyntaxTrivia> DescendantTrivia\<TNode>\(this SyntaxList\<TNode> list, TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode FirstAncestor\<TNode>\(this SyntaxNode node, Func\<TNode, bool> predicate = null, bool ascendOutOfTrivia = true\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode FirstDescendant\<TNode>\(this SyntaxNode node, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode FirstDescendant\<TNode>\(this SyntaxNode node, TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode FirstDescendantOrSelf\<TNode>\(this SyntaxNode node, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode FirstDescendantOrSelf\<TNode>\(this SyntaxNode node, TextSpan span, Func\<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxTriviaList GetLeadingAndTrailingTrivia\(this SyntaxNode node\);
* &emsp; \| &emsp; public static SyntaxToken GetTrailingSeparator\<TNode>\(this SeparatedSyntaxList\<TNode> list\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool HasTrailingSeparator\<TNode>\(this SeparatedSyntaxList\<TNode> list\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static int IndexOf\(this SyntaxTokenList tokens, Func\<SyntaxToken, bool> predicate\);
* &emsp; \| &emsp; public static int IndexOf\(this SyntaxTriviaList triviaList, Func\<SyntaxTrivia, bool> predicate\);
* &emsp; \| &emsp; public static bool IsFirst\<TNode>\(this SeparatedSyntaxList\<TNode> list, TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool IsFirst\<TNode>\(this SyntaxList\<TNode> list, TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool IsLast\<TNode>\(this SeparatedSyntaxList\<TNode> list, TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool IsLast\<TNode>\(this SyntaxList\<TNode> list, TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxTriviaList LeadingAndTrailingTrivia\(this SyntaxToken token\);
* &emsp; \| &emsp; public static SyntaxToken PrependToLeadingTrivia\(this SyntaxToken token, IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; public static SyntaxToken PrependToLeadingTrivia\(this SyntaxToken token, SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static TNode PrependToLeadingTrivia\<TNode>\(this TNode node, IEnumerable\<SyntaxTrivia> trivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode PrependToLeadingTrivia\<TNode>\(this TNode node, SyntaxTrivia trivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxToken PrependToTrailingTrivia\(this SyntaxToken token, IEnumerable\<SyntaxTrivia> trivia\);
* &emsp; \| &emsp; public static SyntaxToken PrependToTrailingTrivia\(this SyntaxToken token, SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static TNode PrependToTrailingTrivia\<TNode>\(this TNode node, IEnumerable\<SyntaxTrivia> trivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode PrependToTrailingTrivia\<TNode>\(this TNode node, SyntaxTrivia trivia\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxTokenList ReplaceAt\(this SyntaxTokenList tokenList, int index, SyntaxToken newToken\);
* &emsp; \| &emsp; public static SyntaxTriviaList ReplaceAt\(this SyntaxTriviaList triviaList, int index, SyntaxTrivia newTrivia\);
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> ReplaceAt\<TNode>\(this SeparatedSyntaxList\<TNode> list, int index, TNode newNode\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxList\<TNode> ReplaceAt\<TNode>\(this SyntaxList\<TNode> list, int index, TNode newNode\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool SpanContainsDirectives\(this SyntaxNode node\);
* &emsp; \| &emsp; public static bool TryGetContainingList\(this SyntaxTrivia trivia, out SyntaxTriviaList triviaList, bool allowLeading = true, bool allowTrailing = true\);
* &emsp; \| &emsp; public static SyntaxToken WithTriviaFrom\(this SyntaxToken token, SyntaxNode node\);
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> WithTriviaFrom\<TNode>\(this SeparatedSyntaxList\<TNode> list, SyntaxNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxList\<TNode> WithTriviaFrom\<TNode>\(this SyntaxList\<TNode> list, SyntaxNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode WithTriviaFrom\<TNode>\(this TNode node, SyntaxToken token\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxNodeOrToken WithoutLeadingTrivia\(this SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; public static SyntaxToken WithoutLeadingTrivia\(this SyntaxToken token\);
* &emsp; \| &emsp; public static SyntaxNodeOrToken WithoutTrailingTrivia\(this SyntaxNodeOrToken nodeOrToken\);
* &emsp; \| &emsp; public static SyntaxToken WithoutTrailingTrivia\(this SyntaxToken token\);
* &emsp; \| &emsp; public static SyntaxNodeOrToken WithoutTrivia\(this SyntaxNodeOrToken nodeOrToken\);
* &emsp; public static class Roslynator\.SyntaxTreeExtensions
* &emsp; \| &emsp; public static int GetEndLine\(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static int GetStartLine\(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static bool IsMultiLineSpan\(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static bool IsSingleLineSpan\(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; public static class Roslynator\.WorkspaceExtensions
* &emsp; \| &emsp; public static Task\<Document> InsertNodeAfterAsync\(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> InsertNodeBeforeAsync\(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> InsertNodesAfterAsync\(this Document document, SyntaxNode nodeInList, IEnumerable\<SyntaxNode> newNodes, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> InsertNodesBeforeAsync\(this Document document, SyntaxNode nodeInList, IEnumerable\<SyntaxNode> newNodes, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> RemoveNodeAsync\(this Document document, SyntaxNode node, SyntaxRemoveOptions options, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> RemoveNodesAsync\(this Document document, IEnumerable\<SyntaxNode> nodes, SyntaxRemoveOptions options, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> ReplaceNodeAsync\(this Document document, SyntaxNode oldNode, SyntaxNode newNode, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> ReplaceNodeAsync\(this Document document, SyntaxNode oldNode, IEnumerable\<SyntaxNode> newNodes, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Solution> ReplaceNodeAsync\<TNode>\(this Solution solution, TNode oldNode, TNode newNode, CancellationToken cancellationToken = default\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static Task\<Document> ReplaceNodesAsync\<TNode>\(this Document document, IEnumerable\<TNode> nodes, Func\<TNode, TNode, SyntaxNode> computeReplacementNode, CancellationToken cancellationToken = default\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static Task\<Solution> ReplaceNodesAsync\<TNode>\(this Solution solution, IEnumerable\<TNode> nodes, Func\<TNode, TNode, SyntaxNode> computeReplacementNodes, CancellationToken cancellationToken = default\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static Task\<Document> ReplaceTokenAsync\(this Document document, SyntaxToken oldToken, SyntaxToken newToken, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> ReplaceTokenAsync\(this Document document, SyntaxToken oldToken, IEnumerable\<SyntaxToken> newTokens, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> ReplaceTriviaAsync\(this Document document, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> ReplaceTriviaAsync\(this Document document, SyntaxTrivia oldTrivia, IEnumerable\<SyntaxTrivia> newTrivia, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> WithTextChangeAsync\(this Document document, TextChange textChange, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> WithTextChangesAsync\(this Document document, TextChange\[\] textChanges, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> WithTextChangesAsync\(this Document document, IEnumerable\<TextChange> textChanges, CancellationToken cancellationToken = default\);
* &emsp; public static class Roslynator\.CSharp\.CSharpExtensions
* &emsp; \| &emsp; public static IParameterSymbol DetermineParameter\(this SemanticModel semanticModel, ArgumentSyntax argument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IParameterSymbol DetermineParameter\(this SemanticModel semanticModel, AttributeArgumentSyntax attributeArgument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ExtensionMethodSymbolInfo GetExtensionMethodInfo\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static IMethodSymbol GetMethodSymbol\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ExtensionMethodSymbolInfo GetReducedExtensionMethodInfo\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetSymbol\(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetSymbol\(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetSymbol\(this SemanticModel semanticModel, CrefSyntax cref, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetSymbol\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetSymbol\(this SemanticModel semanticModel, OrderingSyntax ordering, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ISymbol GetSymbol\(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ITypeSymbol GetTypeSymbol\(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ITypeSymbol GetTypeSymbol\(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ITypeSymbol GetTypeSymbol\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ITypeSymbol GetTypeSymbol\(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static bool HasConstantValue\(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static bool IsDefaultValue\(this SemanticModel semanticModel, ITypeSymbol typeSymbol, ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; public static class Roslynator\.CSharp\.CSharpFactory
* &emsp; \| &emsp; public static AccessorListSyntax AccessorList\(AccessorDeclarationSyntax accessor\);
* &emsp; \| &emsp; public static AccessorListSyntax AccessorList\(params AccessorDeclarationSyntax\[\] accessors\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AddAccessorDeclaration\(BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AddAccessorDeclaration\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AddAccessorDeclaration\(SyntaxTokenList modifiers, BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AddAccessorDeclaration\(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax AddAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax AddAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax AddExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax AddExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax AddressOfExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax AddressOfExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax AndAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax AndAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static ArgumentSyntax Argument\(NameColonSyntax nameColon, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ArgumentListSyntax ArgumentList\(ArgumentSyntax argument\);
* &emsp; \| &emsp; public static ArgumentListSyntax ArgumentList\(params ArgumentSyntax\[\] arguments\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax ArrayInitializerExpression\(SeparatedSyntaxList\<ExpressionSyntax> expressions = default\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax ArrayInitializerExpression\(SyntaxToken openBraceToken, SeparatedSyntaxList\<ExpressionSyntax> expressions, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax AsExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax AsExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AttributeSyntax Attribute\(NameSyntax name, AttributeArgumentSyntax argument\);
* &emsp; \| &emsp; public static AttributeArgumentSyntax AttributeArgument\(NameColonSyntax nameColon, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static AttributeArgumentSyntax AttributeArgument\(NameEqualsSyntax nameEquals, ExpressionSyntax expression\);
* &emsp; \| &emsp; public static AttributeArgumentListSyntax AttributeArgumentList\(AttributeArgumentSyntax attributeArgument\);
* &emsp; \| &emsp; public static AttributeArgumentListSyntax AttributeArgumentList\(params AttributeArgumentSyntax\[\] attributeArguments\);
* &emsp; \| &emsp; public static AttributeListSyntax AttributeList\(AttributeSyntax attribute\);
* &emsp; \| &emsp; public static AttributeListSyntax AttributeList\(params AttributeSyntax\[\] attributes\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AutoGetAccessorDeclaration\(SyntaxTokenList modifiers = default\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax AutoSetAccessorDeclaration\(SyntaxTokenList modifiers = default\);
* &emsp; \| &emsp; public static ConstructorInitializerSyntax BaseConstructorInitializer\(ArgumentListSyntax argumentList = null\);
* &emsp; \| &emsp; public static ConstructorInitializerSyntax BaseConstructorInitializer\(SyntaxToken semicolonToken, ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static BaseListSyntax BaseList\(BaseTypeSyntax type\);
* &emsp; \| &emsp; public static BaseListSyntax BaseList\(params BaseTypeSyntax\[\] types\);
* &emsp; \| &emsp; public static BaseListSyntax BaseList\(SyntaxToken colonToken, BaseTypeSyntax baseType\);
* &emsp; \| &emsp; public static BaseListSyntax BaseList\(SyntaxToken colonToken, params BaseTypeSyntax\[\] types\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax BitwiseAndExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax BitwiseAndExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax BitwiseNotExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax BitwiseNotExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax BitwiseOrExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax BitwiseOrExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BlockSyntax Block\(StatementSyntax statement\);
* &emsp; \| &emsp; public static BlockSyntax Block\(SyntaxToken openBrace, StatementSyntax statement, SyntaxToken closeBrace\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax BooleanLiteralExpression\(bool value\);
* &emsp; \| &emsp; public static BracketedArgumentListSyntax BracketedArgumentList\(ArgumentSyntax argument\);
* &emsp; \| &emsp; public static BracketedArgumentListSyntax BracketedArgumentList\(params ArgumentSyntax\[\] arguments\);
* &emsp; \| &emsp; public static BracketedParameterListSyntax BracketedParameterList\(ParameterSyntax parameter\);
* &emsp; \| &emsp; public static BracketedParameterListSyntax BracketedParameterList\(params ParameterSyntax\[\] parameters\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax CharacterLiteralExpression\(char value\);
* &emsp; \| &emsp; public static CheckedExpressionSyntax CheckedExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static CheckedExpressionSyntax CheckedExpression\(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static ClassOrStructConstraintSyntax ClassConstraint\(\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax ClassDeclaration\(SyntaxTokenList modifiers, string identifier, SyntaxList\<MemberDeclarationSyntax> members = default\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax ClassDeclaration\(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList\<MemberDeclarationSyntax> members = default\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax CoalesceExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax CoalesceExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax CollectionInitializerExpression\(SeparatedSyntaxList\<ExpressionSyntax> expressions = default\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax CollectionInitializerExpression\(SyntaxToken openBraceToken, SeparatedSyntaxList\<ExpressionSyntax> expressions, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static CompilationUnitSyntax CompilationUnit\(MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static CompilationUnitSyntax CompilationUnit\(SyntaxList\<UsingDirectiveSyntax> usings, MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static CompilationUnitSyntax CompilationUnit\(SyntaxList\<UsingDirectiveSyntax> usings, SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax ComplexElementInitializerExpression\(SeparatedSyntaxList\<ExpressionSyntax> expressions = default\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax ComplexElementInitializerExpression\(SyntaxToken openBraceToken, SeparatedSyntaxList\<ExpressionSyntax> expressions, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body\);
* &emsp; \| &emsp; public static ConstructorDeclarationSyntax ConstructorDeclaration\(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax DefaultLiteralExpression\(\);
* &emsp; \| &emsp; public static SwitchSectionSyntax DefaultSwitchSection\(StatementSyntax statement\);
* &emsp; \| &emsp; public static SwitchSectionSyntax DefaultSwitchSection\(SyntaxList\<StatementSyntax> statements\);
* &emsp; \| &emsp; public static DelegateDeclarationSyntax DelegateDeclaration\(SyntaxTokenList modifiers, TypeSyntax returnType, string identifier, ParameterListSyntax parameterList\);
* &emsp; \| &emsp; public static DelegateDeclarationSyntax DelegateDeclaration\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax DivideAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax DivideAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax DivideExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax DivideExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static SyntaxTrivia EmptyWhitespace\(\);
* &emsp; \| &emsp; public static EnumDeclarationSyntax EnumDeclaration\(SyntaxTokenList modifiers, SyntaxToken identifier, SeparatedSyntaxList\<EnumMemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static EnumMemberDeclarationSyntax EnumMemberDeclaration\(SyntaxToken identifier, ExpressionSyntax value\);
* &emsp; \| &emsp; public static EnumMemberDeclarationSyntax EnumMemberDeclaration\(SyntaxToken identifier, EqualsValueClauseSyntax value\);
* &emsp; \| &emsp; public static EnumMemberDeclarationSyntax EnumMemberDeclaration\(string name, ExpressionSyntax value\);
* &emsp; \| &emsp; public static EnumMemberDeclarationSyntax EnumMemberDeclaration\(string name, EqualsValueClauseSyntax value\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax EqualsExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax EqualsExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static EventDeclarationSyntax EventDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, string identifier, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static EventDeclarationSyntax EventDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static EventFieldDeclarationSyntax EventFieldDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, string identifier\);
* &emsp; \| &emsp; public static EventFieldDeclarationSyntax EventFieldDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax ExclusiveOrExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax ExclusiveOrExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body\);
* &emsp; \| &emsp; public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax FalseLiteralExpression\(\);
* &emsp; \| &emsp; public static FieldDeclarationSyntax FieldDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static FieldDeclarationSyntax FieldDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static FieldDeclarationSyntax FieldDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, string identifier, ExpressionSyntax value = null\);
* &emsp; \| &emsp; public static FieldDeclarationSyntax FieldDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null\);
* &emsp; \| &emsp; public static GenericNameSyntax GenericName\(string identifier, TypeSyntax typeArgument\);
* &emsp; \| &emsp; public static GenericNameSyntax GenericName\(SyntaxToken identifier, TypeSyntax typeArgument\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax GetAccessorDeclaration\(BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax GetAccessorDeclaration\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax GetAccessorDeclaration\(SyntaxTokenList modifiers, BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax GetAccessorDeclaration\(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax GreaterThanExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax GreaterThanExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax GreaterThanOrEqualExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax GreaterThanOrEqualExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body\);
* &emsp; \| &emsp; public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static IndexerDeclarationSyntax IndexerDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static IndexerDeclarationSyntax IndexerDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax InterfaceDeclaration\(SyntaxTokenList modifiers, string identifier, SyntaxList\<MemberDeclarationSyntax> members = default\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax InterfaceDeclaration\(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList\<MemberDeclarationSyntax> members = default\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax IsExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax IsExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax LeftShiftAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax LeftShiftAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LeftShiftExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LeftShiftExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LessThanExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LessThanExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LessThanOrEqualExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LessThanOrEqualExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax LiteralExpression\(object value\);
* &emsp; \| &emsp; public static LocalDeclarationStatementSyntax LocalDeclarationStatement\(TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static LocalDeclarationStatementSyntax LocalDeclarationStatement\(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static LocalDeclarationStatementSyntax LocalDeclarationStatement\(TypeSyntax type, string identifier, ExpressionSyntax value = null\);
* &emsp; \| &emsp; public static LocalDeclarationStatementSyntax LocalDeclarationStatement\(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null\);
* &emsp; \| &emsp; public static LocalFunctionStatementSyntax LocalFunctionStatement\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body\);
* &emsp; \| &emsp; public static LocalFunctionStatementSyntax LocalFunctionStatement\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LogicalAndExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LogicalAndExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax LogicalNotExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax LogicalNotExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LogicalOrExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax LogicalOrExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static MethodDeclarationSyntax MethodDeclaration\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body\);
* &emsp; \| &emsp; public static MethodDeclarationSyntax MethodDeclaration\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax ModuloAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax ModuloAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax ModuloExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax ModuloExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax MultiplyAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax MultiplyAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax MultiplyExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax MultiplyExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static InvocationExpressionSyntax NameOfExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static InvocationExpressionSyntax NameOfExpression\(string identifier\);
* &emsp; \| &emsp; public static NamespaceDeclarationSyntax NamespaceDeclaration\(NameSyntax name, MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static NamespaceDeclarationSyntax NamespaceDeclaration\(NameSyntax name, SyntaxList\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static SyntaxTrivia NewLine\(\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax NotEqualsExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax NotEqualsExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NullLiteralExpression\(\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NumericLiteralExpression\(int value\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NumericLiteralExpression\(uint value\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NumericLiteralExpression\(sbyte value\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NumericLiteralExpression\(decimal value\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NumericLiteralExpression\(double value\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NumericLiteralExpression\(float value\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NumericLiteralExpression\(long value\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax NumericLiteralExpression\(ulong value\);
* &emsp; \| &emsp; public static ObjectCreationExpressionSyntax ObjectCreationExpression\(TypeSyntax type, ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax ObjectInitializerExpression\(SeparatedSyntaxList\<ExpressionSyntax> expressions = default\);
* &emsp; \| &emsp; public static InitializerExpressionSyntax ObjectInitializerExpression\(SyntaxToken openBraceToken, SeparatedSyntaxList\<ExpressionSyntax> expressions, SyntaxToken closeBraceToken\);
* &emsp; \| &emsp; public static OperatorDeclarationSyntax OperatorDeclaration\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body\);
* &emsp; \| &emsp; public static OperatorDeclarationSyntax OperatorDeclaration\(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax OrAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax OrAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static ParameterSyntax Parameter\(TypeSyntax type, string identifier, ExpressionSyntax @default = null\);
* &emsp; \| &emsp; public static ParameterSyntax Parameter\(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax @default = null\);
* &emsp; \| &emsp; public static ParameterSyntax Parameter\(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default\);
* &emsp; \| &emsp; public static ParameterListSyntax ParameterList\(ParameterSyntax parameter\);
* &emsp; \| &emsp; public static ParameterListSyntax ParameterList\(params ParameterSyntax\[\] parameters\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax PointerIndirectionExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax PointerIndirectionExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static PostfixUnaryExpressionSyntax PostDecrementExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PostfixUnaryExpressionSyntax PostDecrementExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static PostfixUnaryExpressionSyntax PostIncrementExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PostfixUnaryExpressionSyntax PostIncrementExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax PreDecrementExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax PreDecrementExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax PreIncrementExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax PreIncrementExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedBoolType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedByteType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedCharType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedDecimalType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedDoubleType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedFloatType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedIntType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedLongType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedObjectType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedSByteType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedShortType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedStringType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedUIntType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedULongType\(\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax PredefinedUShortType\(\);
* &emsp; \| &emsp; public static PropertyDeclarationSyntax PropertyDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static PropertyDeclarationSyntax PropertyDeclaration\(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList, ExpressionSyntax value = null\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax RemoveAccessorDeclaration\(BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax RemoveAccessorDeclaration\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax RemoveAccessorDeclaration\(SyntaxTokenList modifiers, BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax RemoveAccessorDeclaration\(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax RightShiftAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax RightShiftAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax RightShiftExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax RightShiftExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax SetAccessorDeclaration\(BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax SetAccessorDeclaration\(ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax SetAccessorDeclaration\(SyntaxTokenList modifiers, BlockSyntax body\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax SetAccessorDeclaration\(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax SimpleAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax SimpleAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static ExpressionStatementSyntax SimpleAssignmentStatement\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static ExpressionStatementSyntax SimpleAssignmentStatement\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static MemberAccessExpressionSyntax SimpleMemberAccessExpression\(ExpressionSyntax expression, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static MemberAccessExpressionSyntax SimpleMemberAccessExpression\(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static InvocationExpressionSyntax SimpleMemberInvocationExpression\(ExpressionSyntax expression, SimpleNameSyntax name\);
* &emsp; \| &emsp; public static InvocationExpressionSyntax SimpleMemberInvocationExpression\(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentSyntax argument\);
* &emsp; \| &emsp; public static InvocationExpressionSyntax SimpleMemberInvocationExpression\(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax StringLiteralExpression\(string value\);
* &emsp; \| &emsp; public static ClassOrStructConstraintSyntax StructConstraint\(\);
* &emsp; \| &emsp; public static StructDeclarationSyntax StructDeclaration\(SyntaxTokenList modifiers, string identifier, SyntaxList\<MemberDeclarationSyntax> members = default\);
* &emsp; \| &emsp; public static StructDeclarationSyntax StructDeclaration\(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList\<MemberDeclarationSyntax> members = default\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax SubtractAssignmentExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static AssignmentExpressionSyntax SubtractAssignmentExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax SubtractExpression\(ExpressionSyntax left, ExpressionSyntax right\);
* &emsp; \| &emsp; public static BinaryExpressionSyntax SubtractExpression\(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right\);
* &emsp; \| &emsp; public static SwitchSectionSyntax SwitchSection\(SwitchLabelSyntax switchLabel, StatementSyntax statement\);
* &emsp; \| &emsp; public static SwitchSectionSyntax SwitchSection\(SwitchLabelSyntax switchLabel, SyntaxList\<StatementSyntax> statements\);
* &emsp; \| &emsp; public static SwitchSectionSyntax SwitchSection\(SyntaxList\<SwitchLabelSyntax> switchLabels, StatementSyntax statement\);
* &emsp; \| &emsp; public static ConstructorInitializerSyntax ThisConstructorInitializer\(ArgumentListSyntax argumentList = null\);
* &emsp; \| &emsp; public static ConstructorInitializerSyntax ThisConstructorInitializer\(SyntaxToken semicolonToken, ArgumentListSyntax argumentList\);
* &emsp; \| &emsp; public static SyntaxTokenList TokenList\(Accessibility accessibility\);
* &emsp; \| &emsp; public static SyntaxTokenList TokenList\(SyntaxKind kind\);
* &emsp; \| &emsp; public static SyntaxTokenList TokenList\(SyntaxKind kind1, SyntaxKind kind2\);
* &emsp; \| &emsp; public static SyntaxTokenList TokenList\(SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3\);
* &emsp; \| &emsp; public static LiteralExpressionSyntax TrueLiteralExpression\(\);
* &emsp; \| &emsp; public static TryStatementSyntax TryStatement\(BlockSyntax block, CatchClauseSyntax @catch, FinallyClauseSyntax @finally = null\);
* &emsp; \| &emsp; public static TypeArgumentListSyntax TypeArgumentList\(TypeSyntax argument\);
* &emsp; \| &emsp; public static TypeArgumentListSyntax TypeArgumentList\(params TypeSyntax\[\] arguments\);
* &emsp; \| &emsp; public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause\(IdentifierNameSyntax identifierName, TypeParameterConstraintSyntax typeParameterConstraint\);
* &emsp; \| &emsp; public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause\(string name, TypeParameterConstraintSyntax typeParameterConstraint\);
* &emsp; \| &emsp; public static TypeParameterListSyntax TypeParameterList\(TypeParameterSyntax parameter\);
* &emsp; \| &emsp; public static TypeParameterListSyntax TypeParameterList\(params TypeParameterSyntax\[\] parameters\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax UnaryMinusExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax UnaryMinusExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax UnaryPlusExpression\(ExpressionSyntax operand\);
* &emsp; \| &emsp; public static PrefixUnaryExpressionSyntax UnaryPlusExpression\(ExpressionSyntax operand, SyntaxToken operatorToken\);
* &emsp; \| &emsp; public static CheckedExpressionSyntax UncheckedExpression\(ExpressionSyntax expression\);
* &emsp; \| &emsp; public static CheckedExpressionSyntax UncheckedExpression\(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken\);
* &emsp; \| &emsp; public static UsingDirectiveSyntax UsingStaticDirective\(NameSyntax name\);
* &emsp; \| &emsp; public static UsingDirectiveSyntax UsingStaticDirective\(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameSyntax name, SyntaxToken semicolonToken\);
* &emsp; \| &emsp; public static IdentifierNameSyntax VarType\(\);
* &emsp; \| &emsp; public static VariableDeclarationSyntax VariableDeclaration\(TypeSyntax type, VariableDeclaratorSyntax variable\);
* &emsp; \| &emsp; public static VariableDeclarationSyntax VariableDeclaration\(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static VariableDeclarationSyntax VariableDeclaration\(TypeSyntax type, string identifier, ExpressionSyntax value = null\);
* &emsp; \| &emsp; public static VariableDeclarationSyntax VariableDeclaration\(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null\);
* &emsp; \| &emsp; public static VariableDeclaratorSyntax VariableDeclarator\(string identifier, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static VariableDeclaratorSyntax VariableDeclarator\(SyntaxToken identifier, EqualsValueClauseSyntax initializer\);
* &emsp; \| &emsp; public static PredefinedTypeSyntax VoidType\(\);
* &emsp; \| &emsp; public static YieldStatementSyntax YieldBreakStatement\(\);
* &emsp; \| &emsp; public static YieldStatementSyntax YieldReturnStatement\(ExpressionSyntax expression\);
* &emsp; public static class Roslynator\.CSharp\.CSharpFacts
* &emsp; \| &emsp; public static bool CanBeEmbeddedStatement\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool CanHaveEmbeddedStatement\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool CanHaveExpressionBody\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool CanHaveMembers\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool CanHaveModifiers\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool CanHaveStatements\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsAnonymousFunctionExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsBooleanExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsBooleanLiteralExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsCommentTrivia\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsCompoundAssignmentExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsConstraint\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsFunction\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsIfElseDirective\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsIncrementOrDecrementExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsIterationStatement\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsJumpStatement\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsLambdaExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsLiteralExpression\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsPredefinedType\(SpecialType specialType\);
* &emsp; \| &emsp; public static bool IsSimpleType\(SpecialType specialType\);
* &emsp; \| &emsp; public static bool IsSwitchLabel\(SyntaxKind kind\);
* &emsp; \| &emsp; public static bool SupportsPrefixOrPostfixUnaryOperator\(SpecialType specialType\);
* &emsp; public static class Roslynator\.CSharp\.EnumExtensions
* &emsp; \| &emsp; public static bool Is\(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2\);
* &emsp; \| &emsp; public static bool Is\(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3\);
* &emsp; \| &emsp; public static bool Is\(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4\);
* &emsp; \| &emsp; public static bool Is\(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5\);
* &emsp; \| &emsp; public static bool Is\(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6\);
* &emsp; public static class Roslynator\.CSharp\.ModifierList
* &emsp; \| &emsp; public static int GetInsertIndex\(SyntaxTokenList tokens, SyntaxKind kind, IComparer\<SyntaxKind> comparer = null\);
* &emsp; \| &emsp; public static int GetInsertIndex\(SyntaxTokenList tokens, SyntaxToken token, IComparer\<SyntaxToken> comparer = null\);
* &emsp; \| &emsp; public static SyntaxTokenList Insert\(SyntaxTokenList modifiers, SyntaxKind kind, IComparer\<SyntaxKind> comparer = null\);
* &emsp; \| &emsp; public static SyntaxTokenList Insert\(SyntaxTokenList modifiers, SyntaxToken modifier, IComparer\<SyntaxToken> comparer = null\);
* &emsp; \| &emsp; public static TNode Insert\<TNode>\(TNode node, SyntaxKind kind, IComparer\<SyntaxKind> comparer = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode Insert\<TNode>\(TNode node, SyntaxToken modifier, IComparer\<SyntaxToken> comparer = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode Remove\<TNode>\(TNode node, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode Remove\<TNode>\(TNode node, SyntaxToken modifier\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode RemoveAll\<TNode>\(TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode RemoveAll\<TNode>\(TNode node, Func\<SyntaxToken, bool> predicate\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode RemoveAt\<TNode>\(TNode node, int index\) where TNode : SyntaxNode;
* &emsp; public static class Roslynator\.CSharp\.Modifiers
* &emsp; \| &emsp; public static SyntaxTokenList Const\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_Abstract\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_Const\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_Override\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_Partial\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_Static\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_Static\_Partial\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_Static\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Internal\_Virtual\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Partial\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Private\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Private\_Const\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Private\_Partial\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Private\_Protected\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Private\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Private\_Static\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Private\_Static\_Partial\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Private\_Static\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\_Abstract\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\_Const\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\_Internal\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\_Override\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\_Static\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\_Static\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Protected\_Virtual\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_Abstract\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_Const\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_Override\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_Partial\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_Static\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_Static\_Partial\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_Static\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Public\_Virtual\(\);
* &emsp; \| &emsp; public static SyntaxTokenList ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Ref\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Static\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Static\_ReadOnly\(\);
* &emsp; \| &emsp; public static SyntaxTokenList Virtual\(\);
* &emsp; public static class Roslynator\.CSharp\.SymbolExtensions
* &emsp; \| &emsp; public static bool SupportsConstantValue\(this ITypeSymbol typeSymbol\);
* &emsp; \| &emsp; public static TypeSyntax ToMinimalTypeSyntax\(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; public static TypeSyntax ToMinimalTypeSyntax\(this INamespaceSymbol namespaceSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; public static TypeSyntax ToMinimalTypeSyntax\(this ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; public static TypeSyntax ToTypeSyntax\(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; public static TypeSyntax ToTypeSyntax\(this INamespaceSymbol namespaceSymbol, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; public static TypeSyntax ToTypeSyntax\(this ITypeSymbol typeSymbol, SymbolDisplayFormat format = null\);
* &emsp; public static class Roslynator\.CSharp\.SyntaxAccessibility
* &emsp; \| &emsp; public static Accessibility GetAccessibility\(SyntaxNode declaration\);
* &emsp; \| &emsp; public static Accessibility GetDefaultAccessibility\(SyntaxNode declaration\);
* &emsp; \| &emsp; public static Accessibility GetDefaultExplicitAccessibility\(SyntaxNode declaration\);
* &emsp; \| &emsp; public static Accessibility GetExplicitAccessibility\(SyntaxNode declaration\);
* &emsp; \| &emsp; public static Accessibility GetExplicitAccessibility\(SyntaxTokenList modifiers\);
* &emsp; \| &emsp; public static bool IsPubliclyVisible\(MemberDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static bool IsValidAccessibility\(SyntaxNode node, Accessibility accessibility, bool ignoreOverride = false\);
* &emsp; \| &emsp; public static TNode WithExplicitAccessibility\<TNode>\(TNode node, Accessibility newAccessibility, IComparer\<SyntaxKind> comparer = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode WithoutExplicitAccessibility\<TNode>\(TNode node\) where TNode : SyntaxNode;
* &emsp; public static class Roslynator\.CSharp\.SyntaxExtensions
* &emsp; \| &emsp; public static SyntaxList\<StatementSyntax> Add\(this SyntaxList\<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax AddAttributeLists\(this ClassDeclarationSyntax classDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax\[\] attributeLists\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax AddAttributeLists\(this InterfaceDeclarationSyntax interfaceDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax\[\] attributeLists\);
* &emsp; \| &emsp; public static StructDeclarationSyntax AddAttributeLists\(this StructDeclarationSyntax structDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax\[\] attributeLists\);
* &emsp; \| &emsp; public static CompilationUnitSyntax AddUsings\(this CompilationUnitSyntax compilationUnit, bool keepSingleLineCommentsOnTop, params UsingDirectiveSyntax\[\] usings\);
* &emsp; \| &emsp; public static IfStatementCascade AsCascade\(this IfStatementSyntax ifStatement\);
* &emsp; \| &emsp; public static ExpressionChain AsChain\(this BinaryExpressionSyntax binaryExpression, TextSpan? span = null\);
* &emsp; \| &emsp; public static CSharpSyntaxNode BodyOrExpressionBody\(this AccessorDeclarationSyntax accessorDeclaration\);
* &emsp; \| &emsp; public static CSharpSyntaxNode BodyOrExpressionBody\(this ConstructorDeclarationSyntax constructorDeclaration\);
* &emsp; \| &emsp; public static CSharpSyntaxNode BodyOrExpressionBody\(this ConversionOperatorDeclarationSyntax conversionOperatorDeclaration\);
* &emsp; \| &emsp; public static CSharpSyntaxNode BodyOrExpressionBody\(this DestructorDeclarationSyntax destructorDeclaration\);
* &emsp; \| &emsp; public static CSharpSyntaxNode BodyOrExpressionBody\(this LocalFunctionStatementSyntax localFunctionStatement\);
* &emsp; \| &emsp; public static CSharpSyntaxNode BodyOrExpressionBody\(this MethodDeclarationSyntax methodDeclaration\);
* &emsp; \| &emsp; public static CSharpSyntaxNode BodyOrExpressionBody\(this OperatorDeclarationSyntax operatorDeclaration\);
* &emsp; \| &emsp; public static TextSpan BracesSpan\(this ClassDeclarationSyntax classDeclaration\);
* &emsp; \| &emsp; public static TextSpan BracesSpan\(this EnumDeclarationSyntax enumDeclaration\);
* &emsp; \| &emsp; public static TextSpan BracesSpan\(this InterfaceDeclarationSyntax interfaceDeclaration\);
* &emsp; \| &emsp; public static TextSpan BracesSpan\(this NamespaceDeclarationSyntax namespaceDeclaration\);
* &emsp; \| &emsp; public static TextSpan BracesSpan\(this StructDeclarationSyntax structDeclaration\);
* &emsp; \| &emsp; public static bool Contains\(this SyntaxTokenList tokenList, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool Contains\(this SyntaxTriviaList triviaList, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool Contains\<TNode>\(this SeparatedSyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool Contains\<TNode>\(this SyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool ContainsAny\(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2\);
* &emsp; \| &emsp; public static bool ContainsAny\(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3\);
* &emsp; \| &emsp; public static bool ContainsAny\(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4\);
* &emsp; \| &emsp; public static bool ContainsAny\(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5\);
* &emsp; \| &emsp; public static bool ContainsDefaultLabel\(this SwitchSectionSyntax switchSection\);
* &emsp; \| &emsp; public static bool ContainsYield\(this LocalFunctionStatementSyntax localFunctionStatement\);
* &emsp; \| &emsp; public static bool ContainsYield\(this MethodDeclarationSyntax methodDeclaration\);
* &emsp; \| &emsp; public static CSharpSyntaxNode DeclarationOrExpression\(this UsingStatementSyntax usingStatement\);
* &emsp; \| &emsp; public static SwitchSectionSyntax DefaultSection\(this SwitchStatementSyntax switchStatement\);
* &emsp; \| &emsp; public static IEnumerable\<XmlElementSyntax> Elements\(this DocumentationCommentTriviaSyntax documentationComment, string localName\);
* &emsp; \| &emsp; public static SyntaxToken Find\(this SyntaxTokenList tokenList, SyntaxKind kind\);
* &emsp; \| &emsp; public static SyntaxTrivia Find\(this SyntaxTriviaList triviaList, SyntaxKind kind\);
* &emsp; \| &emsp; public static TNode Find\<TNode>\(this SeparatedSyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode Find\<TNode>\(this SyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxNode FirstAncestor\(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static SyntaxNode FirstAncestor\(this SyntaxNode node, Func\<SyntaxNode, bool> predicate, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static SyntaxNode FirstAncestor\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static SyntaxNode FirstAncestor\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static SyntaxNode FirstAncestorOrSelf\(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static SyntaxNode FirstAncestorOrSelf\(this SyntaxNode node, Func\<SyntaxNode, bool> predicate, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static SyntaxNode FirstAncestorOrSelf\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static SyntaxNode FirstAncestorOrSelf\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static IfStatementCascadeInfo GetCascadeInfo\(this IfStatementSyntax ifStatement\);
* &emsp; \| &emsp; public static DocumentationCommentTriviaSyntax GetDocumentationComment\(this MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static SyntaxTrivia GetDocumentationCommentTrivia\(this MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static EndRegionDirectiveTriviaSyntax GetEndRegionDirective\(this RegionDirectiveTriviaSyntax regionDirective\);
* &emsp; \| &emsp; public static DirectiveTriviaSyntax GetFirstDirective\(this SyntaxNode node, TextSpan span, Func\<DirectiveTriviaSyntax, bool> predicate = null\);
* &emsp; \| &emsp; public static DirectiveTriviaSyntax GetNextRelatedDirective\(this DirectiveTriviaSyntax directiveTrivia\);
* &emsp; \| &emsp; public static SyntaxTrivia GetPreprocessingMessageTrivia\(this EndRegionDirectiveTriviaSyntax endRegionDirective\);
* &emsp; \| &emsp; public static SyntaxTrivia GetPreprocessingMessageTrivia\(this RegionDirectiveTriviaSyntax regionDirective\);
* &emsp; \| &emsp; public static RegionDirectiveTriviaSyntax GetRegionDirective\(this EndRegionDirectiveTriviaSyntax endRegionDirective\);
* &emsp; \| &emsp; public static DocumentationCommentTriviaSyntax GetSingleLineDocumentationComment\(this MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static SyntaxTrivia GetSingleLineDocumentationCommentTrivia\(this MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static IfStatementSyntax GetTopmostIf\(this ElseClauseSyntax elseClause\);
* &emsp; \| &emsp; public static IfStatementSyntax GetTopmostIf\(this IfStatementSyntax ifStatement\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax Getter\(this AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax Getter\(this IndexerDeclarationSyntax indexerDeclaration\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax Getter\(this PropertyDeclarationSyntax propertyDeclaration\);
* &emsp; \| &emsp; public static bool HasDocumentationComment\(this MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static bool HasSingleLineDocumentationComment\(this MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static bool IsAutoImplemented\(this AccessorDeclarationSyntax accessorDeclaration\);
* &emsp; \| &emsp; public static bool IsDescendantOf\(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true\);
* &emsp; \| &emsp; public static bool IsEmbedded\(this StatementSyntax statement, bool canBeBlock = false, bool canBeIfInsideElse = true, bool canBeUsingInsideUsing = true\);
* &emsp; \| &emsp; public static bool IsEmptyOrWhitespace\(this SyntaxTriviaList triviaList\);
* &emsp; \| &emsp; public static bool IsEndOfLineTrivia\(this SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static bool IsHexNumericLiteral\(this LiteralExpressionSyntax literalExpression\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6\);
* &emsp; \| &emsp; public static bool IsKind\(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6\);
* &emsp; \| &emsp; public static bool IsLast\(this SyntaxList\<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions\);
* &emsp; \| &emsp; public static bool IsParams\(this ParameterSyntax parameter\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxNode node, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxToken token, SyntaxKind kind\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6\);
* &emsp; \| &emsp; public static bool IsParentKind\(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6\);
* &emsp; \| &emsp; public static bool IsSimpleIf\(this IfStatementSyntax ifStatement\);
* &emsp; \| &emsp; public static bool IsTopmostIf\(this IfStatementSyntax ifStatement\);
* &emsp; \| &emsp; public static bool IsVerbatim\(this InterpolatedStringExpressionSyntax interpolatedString\);
* &emsp; \| &emsp; public static bool IsVoid\(this TypeSyntax type\);
* &emsp; \| &emsp; public static bool IsWhitespaceOrEndOfLineTrivia\(this SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static bool IsWhitespaceTrivia\(this SyntaxTrivia trivia\);
* &emsp; \| &emsp; public static bool IsYieldBreak\(this YieldStatementSyntax yieldStatement\);
* &emsp; \| &emsp; public static bool IsYieldReturn\(this YieldStatementSyntax yieldStatement\);
* &emsp; \| &emsp; public static int LastIndexOf\(this SyntaxTriviaList triviaList, SyntaxKind kind\);
* &emsp; \| &emsp; public static int LastIndexOf\<TNode>\(this SeparatedSyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static int LastIndexOf\<TNode>\(this SyntaxList\<TNode> list, SyntaxKind kind\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static StatementSyntax NextStatement\(this StatementSyntax statement\);
* &emsp; \| &emsp; public static TextSpan ParenthesesSpan\(this CastExpressionSyntax castExpression\);
* &emsp; \| &emsp; public static TextSpan ParenthesesSpan\(this CommonForEachStatementSyntax forEachStatement\);
* &emsp; \| &emsp; public static TextSpan ParenthesesSpan\(this ForStatementSyntax forStatement\);
* &emsp; \| &emsp; public static StatementSyntax PreviousStatement\(this StatementSyntax statement\);
* &emsp; \| &emsp; public static SyntaxTokenList RemoveRange\(this SyntaxTokenList list, int index, int count\);
* &emsp; \| &emsp; public static SyntaxTriviaList RemoveRange\(this SyntaxTriviaList list, int index, int count\);
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> RemoveRange\<TNode>\(this SeparatedSyntaxList\<TNode> list, int index, int count\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxList\<TNode> RemoveRange\<TNode>\(this SyntaxList\<TNode> list, int index, int count\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode RemoveTrivia\<TNode>\(this TNode node, TextSpan? span = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode RemoveWhitespace\<TNode>\(this TNode node, TextSpan? span = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxTokenList ReplaceRange\(this SyntaxTokenList list, int index, int count, IEnumerable\<SyntaxToken> newTokens\);
* &emsp; \| &emsp; public static SyntaxTriviaList ReplaceRange\(this SyntaxTriviaList list, int index, int count, IEnumerable\<SyntaxTrivia> newTrivia\);
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> ReplaceRange\<TNode>\(this SeparatedSyntaxList\<TNode> list, int index, int count, IEnumerable\<TNode> newNodes\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxList\<TNode> ReplaceRange\<TNode>\(this SyntaxList\<TNode> list, int index, int count, IEnumerable\<TNode> newNodes\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static TNode ReplaceWhitespace\<TNode>\(this TNode node, SyntaxTrivia replacement, TextSpan? span = null\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool ReturnsVoid\(this DelegateDeclarationSyntax delegateDeclaration\);
* &emsp; \| &emsp; public static bool ReturnsVoid\(this LocalFunctionStatementSyntax localFunctionStatement\);
* &emsp; \| &emsp; public static bool ReturnsVoid\(this MethodDeclarationSyntax methodDeclaration\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax Setter\(this AccessorListSyntax accessorList\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax Setter\(this IndexerDeclarationSyntax indexerDeclaration\);
* &emsp; \| &emsp; public static AccessorDeclarationSyntax Setter\(this PropertyDeclarationSyntax propertyDeclaration\);
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> ToSeparatedSyntaxList\<TNode>\(this IEnumerable\<TNode> nodes\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SeparatedSyntaxList\<TNode> ToSeparatedSyntaxList\<TNode>\(this IEnumerable\<SyntaxNodeOrToken> nodesAndTokens\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxList\<TNode> ToSyntaxList\<TNode>\(this IEnumerable\<TNode> nodes\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxTokenList ToSyntaxTokenList\(this IEnumerable\<SyntaxToken> tokens\);
* &emsp; \| &emsp; public static SyntaxToken TrimLeadingTrivia\(this SyntaxToken token\);
* &emsp; \| &emsp; public static TNode TrimLeadingTrivia\<TNode>\(this TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxToken TrimTrailingTrivia\(this SyntaxToken token\);
* &emsp; \| &emsp; public static TNode TrimTrailingTrivia\<TNode>\(this TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxToken TrimTrivia\(this SyntaxToken token\);
* &emsp; \| &emsp; public static TNode TrimTrivia\<TNode>\(this TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static bool TryGetContainingList\(this StatementSyntax statement, out SyntaxList\<StatementSyntax> statements\);
* &emsp; \| &emsp; public static ExpressionSyntax WalkDownParentheses\(this ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ExpressionSyntax WalkUpParentheses\(this ExpressionSyntax expression\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax WithMembers\(this ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static ClassDeclarationSyntax WithMembers\(this ClassDeclarationSyntax classDeclaration, IEnumerable\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static CompilationUnitSyntax WithMembers\(this CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static CompilationUnitSyntax WithMembers\(this CompilationUnitSyntax compilationUnit, IEnumerable\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax WithMembers\(this InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static InterfaceDeclarationSyntax WithMembers\(this InterfaceDeclarationSyntax interfaceDeclaration, IEnumerable\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static NamespaceDeclarationSyntax WithMembers\(this NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static NamespaceDeclarationSyntax WithMembers\(this NamespaceDeclarationSyntax namespaceDeclaration, IEnumerable\<MemberDeclarationSyntax> members\);
* &emsp; \| &emsp; public static StructDeclarationSyntax WithMembers\(this StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member\);
* &emsp; \| &emsp; public static StructDeclarationSyntax WithMembers\(this StructDeclarationSyntax structDeclaration, IEnumerable\<MemberDeclarationSyntax> members\);
* &emsp; public static class Roslynator\.CSharp\.SyntaxInfo
* &emsp; \| &emsp; public static AsExpressionInfo AsExpressionInfo\(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static AsExpressionInfo AsExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static AssignmentExpressionInfo AssignmentExpressionInfo\(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static AssignmentExpressionInfo AssignmentExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static BinaryExpressionInfo BinaryExpressionInfo\(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static BinaryExpressionInfo BinaryExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static ConditionalExpressionInfo ConditionalExpressionInfo\(ConditionalExpressionSyntax conditionalExpression, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static ConditionalExpressionInfo ConditionalExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(TypeParameterConstraintClauseSyntax constraintClause\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(DelegateDeclarationSyntax delegateDeclaration\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(LocalFunctionStatementSyntax localFunctionStatement\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(MethodDeclarationSyntax methodDeclaration\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(SyntaxNode node\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(TypeDeclarationSyntax typeDeclaration\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(TypeParameterSyntax typeParameter\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(TypeParameterConstraintSyntax typeParameterConstraint\);
* &emsp; \| &emsp; public static GenericInfo GenericInfo\(TypeParameterListSyntax typeParameterList\);
* &emsp; \| &emsp; public static IsExpressionInfo IsExpressionInfo\(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static IsExpressionInfo IsExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo\(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false\);
* &emsp; \| &emsp; public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo\(ExpressionSyntax value, bool allowMissing = false\);
* &emsp; \| &emsp; public static MemberDeclarationListInfo MemberDeclarationListInfo\(CompilationUnitSyntax compilationUnit\);
* &emsp; \| &emsp; public static MemberDeclarationListInfo MemberDeclarationListInfo\(NamespaceDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static MemberDeclarationListInfo MemberDeclarationListInfo\(TypeDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static MemberDeclarationListInfo MemberDeclarationListInfo\(ClassDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static MemberDeclarationListInfo MemberDeclarationListInfo\(StructDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static MemberDeclarationListInfo MemberDeclarationListInfo\(InterfaceDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static MemberDeclarationListInfo MemberDeclarationListInfo\(SyntaxNode node\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(AccessorDeclarationSyntax accessorDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(ClassDeclarationSyntax classDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(ConstructorDeclarationSyntax constructorDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(DelegateDeclarationSyntax delegateDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(DestructorDeclarationSyntax destructorDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(EnumDeclarationSyntax enumDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(EventDeclarationSyntax eventDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(EventFieldDeclarationSyntax eventFieldDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(FieldDeclarationSyntax fieldDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(IncompleteMemberSyntax incompleteMember\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(IndexerDeclarationSyntax indexerDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(InterfaceDeclarationSyntax interfaceDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(LocalDeclarationStatementSyntax localDeclarationStatement\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(LocalFunctionStatementSyntax localFunctionStatement\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(MethodDeclarationSyntax methodDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(SyntaxNode node\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(OperatorDeclarationSyntax operatorDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(ParameterSyntax parameter\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(PropertyDeclarationSyntax propertyDeclaration\);
* &emsp; \| &emsp; public static ModifierListInfo ModifierListInfo\(StructDeclarationSyntax structDeclaration\);
* &emsp; \| &emsp; public static NullCheckExpressionInfo NullCheckExpressionInfo\(SyntaxNode node, NullCheckStyles allowedStyles = ComparisonToNull \| IsPattern, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static NullCheckExpressionInfo NullCheckExpressionInfo\(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles = All, bool walkDownParentheses = true, bool allowMissing = false, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static RegionInfo RegionInfo\(EndRegionDirectiveTriviaSyntax endRegionDirective\);
* &emsp; \| &emsp; public static RegionInfo RegionInfo\(RegionDirectiveTriviaSyntax regionDirective\);
* &emsp; \| &emsp; public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo\(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo\(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo\(ExpressionStatementSyntax expressionStatement, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo\(StatementSyntax statement, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleIfElseInfo SimpleIfElseInfo\(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleIfStatementInfo SimpleIfStatementInfo\(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleIfStatementInfo SimpleIfStatementInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo\(InvocationExpressionSyntax invocationExpression, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo\(ExpressionStatementSyntax expressionStatement, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo\(InvocationExpressionSyntax invocationExpression, bool allowMissing = false\);
* &emsp; \| &emsp; public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo\(SyntaxNode node, bool allowMissing = false\);
* &emsp; \| &emsp; public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo\(ExpressionSyntax value\);
* &emsp; \| &emsp; public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo\(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false\);
* &emsp; \| &emsp; public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo\(VariableDeclarationSyntax variableDeclaration, bool allowMissing = false\);
* &emsp; \| &emsp; public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo\(LambdaExpressionSyntax lambdaExpression, bool allowMissing = false\);
* &emsp; \| &emsp; public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false\);
* &emsp; \| &emsp; public static StatementListInfo StatementListInfo\(StatementSyntax statement\);
* &emsp; \| &emsp; public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo\(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo\(in ExpressionChain expressionChain, SemanticModel semanticModel, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo\(SyntaxNode node, SemanticModel semanticModel, bool walkDownParentheses = true, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static StringLiteralExpressionInfo StringLiteralExpressionInfo\(LiteralExpressionSyntax literalExpression\);
* &emsp; \| &emsp; public static StringLiteralExpressionInfo StringLiteralExpressionInfo\(SyntaxNode node, bool walkDownParentheses = true\);
* &emsp; \| &emsp; public static UsingDirectiveListInfo UsingDirectiveListInfo\(CompilationUnitSyntax compilationUnit\);
* &emsp; \| &emsp; public static UsingDirectiveListInfo UsingDirectiveListInfo\(NamespaceDeclarationSyntax declaration\);
* &emsp; \| &emsp; public static UsingDirectiveListInfo UsingDirectiveListInfo\(SyntaxNode node\);
* &emsp; \| &emsp; public static XmlElementInfo XmlElementInfo\(XmlNodeSyntax xmlNode\);
* &emsp; public static class Roslynator\.CSharp\.SyntaxInverter
* &emsp; \| &emsp; public static ExpressionSyntax LogicallyInvert\(ExpressionSyntax expression, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static ExpressionSyntax LogicallyInvert\(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken = default\);
* &emsp; public static class Roslynator\.CSharp\.WorkspaceExtensions
* &emsp; \| &emsp; public static Task\<Document> RemoveCommentsAsync\(this Document document, CommentFilter comments, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> RemoveCommentsAsync\(this Document document, TextSpan span, CommentFilter comments, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> RemovePreprocessorDirectivesAsync\(this Document document, PreprocessorDirectiveFilter directiveFilter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> RemovePreprocessorDirectivesAsync\(this Document document, TextSpan span, PreprocessorDirectiveFilter directiveFilter, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> RemoveRegionAsync\(this Document document, RegionInfo region, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; public static Task\<Document> RemoveTriviaAsync\(this Document document, TextSpan span, CancellationToken cancellationToken = default\);
* &emsp; public static class Roslynator\.CSharp\.WorkspaceSyntaxExtensions
* &emsp; \| &emsp; public static ParenthesizedExpressionSyntax Parenthesize\(this ExpressionSyntax expression, bool includeElasticTrivia = true, bool simplifiable = true\);
* &emsp; \| &emsp; public static SyntaxToken WithFormatterAnnotation\(this SyntaxToken token\);
* &emsp; \| &emsp; public static TNode WithFormatterAnnotation\<TNode>\(this TNode node\) where TNode : SyntaxNode;
* &emsp; \| &emsp; public static SyntaxToken WithRenameAnnotation\(this SyntaxToken token\);
* &emsp; \| &emsp; public static SyntaxToken WithSimplifierAnnotation\(this SyntaxToken token\);
* &emsp; \| &emsp; public static TNode WithSimplifierAnnotation\<TNode>\(this TNode node\) where TNode : SyntaxNode;
* 
* &emsp; public interface Microsoft\.CodeAnalysis\.IAliasSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; INamespaceOrTypeSymbol Target \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IAnalyzerAssemblyLoader
* &emsp; \| &emsp; void AddDependencyLocation\(string fullPath\);
* &emsp; \| &emsp; Assembly LoadFromPath\(string fullPath\);
* &emsp; public interface Microsoft\.CodeAnalysis\.IArrayTypeSymbol : IEquatable\<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> CustomModifiers \{ get; \}
* &emsp; \| &emsp; ITypeSymbol ElementType \{ get; \}
* &emsp; \| &emsp; bool IsSZArray \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<int> LowerBounds \{ get; \}
* &emsp; \| &emsp; int Rank \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<int> Sizes \{ get; \}
* &emsp; \| &emsp; bool Equals\(IArrayTypeSymbol other\);
* &emsp; public interface Microsoft\.CodeAnalysis\.IAssemblySymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; INamespaceSymbol GlobalNamespace \{ get; \}
* &emsp; \| &emsp; AssemblyIdentity Identity \{ get; \}
* &emsp; \| &emsp; bool IsInteractive \{ get; \}
* &emsp; \| &emsp; bool MightContainExtensionMethods \{ get; \}
* &emsp; \| &emsp; IEnumerable\<IModuleSymbol> Modules \{ get; \}
* &emsp; \| &emsp; ICollection\<string> NamespaceNames \{ get; \}
* &emsp; \| &emsp; ICollection\<string> TypeNames \{ get; \}
* &emsp; \| &emsp; AssemblyMetadata GetMetadata\(\);
* &emsp; \| &emsp; INamedTypeSymbol GetTypeByMetadataName\(string fullyQualifiedMetadataName\);
* &emsp; \| &emsp; bool GivesAccessTo\(IAssemblySymbol toAssembly\);
* &emsp; \| &emsp; INamedTypeSymbol ResolveForwardedType\(string fullyQualifiedMetadataName\);
* &emsp; public interface Microsoft\.CodeAnalysis\.ICompilationUnitSyntax
* &emsp; \| &emsp; SyntaxToken EndOfFileToken \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IDiscardSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; ITypeSymbol Type \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IDynamicTypeSymbol : IEquatable\<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol
* &emsp; public interface Microsoft\.CodeAnalysis\.IErrorTypeSymbol : IEquatable\<ISymbol>, INamedTypeSymbol, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol
* &emsp; \| &emsp; CandidateReason CandidateReason \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ISymbol> CandidateSymbols \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IEventSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; IMethodSymbol AddMethod \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IEventSymbol> ExplicitInterfaceImplementations \{ get; \}
* &emsp; \| &emsp; bool IsWindowsRuntimeEvent \{ get; \}
* &emsp; \| &emsp; IEventSymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; IEventSymbol OverriddenEvent \{ get; \}
* &emsp; \| &emsp; IMethodSymbol RaiseMethod \{ get; \}
* &emsp; \| &emsp; IMethodSymbol RemoveMethod \{ get; \}
* &emsp; \| &emsp; ITypeSymbol Type \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IFieldSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; ISymbol AssociatedSymbol \{ get; \}
* &emsp; \| &emsp; object ConstantValue \{ get; \}
* &emsp; \| &emsp; IFieldSymbol CorrespondingTupleField \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> CustomModifiers \{ get; \}
* &emsp; \| &emsp; bool HasConstantValue \{ get; \}
* &emsp; \| &emsp; bool IsConst \{ get; \}
* &emsp; \| &emsp; bool IsReadOnly \{ get; \}
* &emsp; \| &emsp; bool IsVolatile \{ get; \}
* &emsp; \| &emsp; IFieldSymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; ITypeSymbol Type \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.ILabelSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; IMethodSymbol ContainingMethod \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.ILocalSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; object ConstantValue \{ get; \}
* &emsp; \| &emsp; bool HasConstantValue \{ get; \}
* &emsp; \| &emsp; bool IsConst \{ get; \}
* &emsp; \| &emsp; bool IsFunctionValue \{ get; \}
* &emsp; \| &emsp; bool IsRef \{ get; \}
* &emsp; \| &emsp; ITypeSymbol Type \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IMethodSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; int Arity \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol AssociatedAnonymousDelegate \{ get; \}
* &emsp; \| &emsp; ISymbol AssociatedSymbol \{ get; \}
* &emsp; \| &emsp; IMethodSymbol ConstructedFrom \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IMethodSymbol> ExplicitInterfaceImplementations \{ get; \}
* &emsp; \| &emsp; bool HidesBaseMethodsByName \{ get; \}
* &emsp; \| &emsp; bool IsAsync \{ get; \}
* &emsp; \| &emsp; bool IsCheckedBuiltin \{ get; \}
* &emsp; \| &emsp; bool IsExtensionMethod \{ get; \}
* &emsp; \| &emsp; bool IsGenericMethod \{ get; \}
* &emsp; \| &emsp; bool IsVararg \{ get; \}
* &emsp; \| &emsp; MethodKind MethodKind \{ get; \}
* &emsp; \| &emsp; IMethodSymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; IMethodSymbol OverriddenMethod \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IParameterSymbol> Parameters \{ get; \}
* &emsp; \| &emsp; IMethodSymbol PartialDefinitionPart \{ get; \}
* &emsp; \| &emsp; IMethodSymbol PartialImplementationPart \{ get; \}
* &emsp; \| &emsp; ITypeSymbol ReceiverType \{ get; \}
* &emsp; \| &emsp; IMethodSymbol ReducedFrom \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> RefCustomModifiers \{ get; \}
* &emsp; \| &emsp; ITypeSymbol ReturnType \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> ReturnTypeCustomModifiers \{ get; \}
* &emsp; \| &emsp; bool ReturnsByRef \{ get; \}
* &emsp; \| &emsp; bool ReturnsVoid \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ITypeSymbol> TypeArguments \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ITypeParameterSymbol> TypeParameters \{ get; \}
* &emsp; \| &emsp; IMethodSymbol Construct\(params ITypeSymbol\[\] typeArguments\);
* &emsp; \| &emsp; DllImportData GetDllImportData\(\);
* &emsp; \| &emsp; ImmutableArray\<AttributeData> GetReturnTypeAttributes\(\);
* &emsp; \| &emsp; ITypeSymbol GetTypeInferredDuringReduction\(ITypeParameterSymbol reducedFromTypeParameter\);
* &emsp; \| &emsp; IMethodSymbol ReduceExtensionMethod\(ITypeSymbol receiverType\);
* &emsp; public interface Microsoft\.CodeAnalysis\.IModuleSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; INamespaceSymbol GlobalNamespace \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<AssemblyIdentity> ReferencedAssemblies \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IAssemblySymbol> ReferencedAssemblySymbols \{ get; \}
* &emsp; \| &emsp; ModuleMetadata GetMetadata\(\);
* &emsp; \| &emsp; INamespaceSymbol GetModuleNamespace\(INamespaceSymbol namespaceSymbol\);
* &emsp; public interface Microsoft\.CodeAnalysis\.INamedTypeSymbol : IEquatable\<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol
* &emsp; \| &emsp; int Arity \{ get; \}
* &emsp; \| &emsp; ISymbol AssociatedSymbol \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol ConstructedFrom \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IMethodSymbol> Constructors \{ get; \}
* &emsp; \| &emsp; IMethodSymbol DelegateInvokeMethod \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol EnumUnderlyingType \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IMethodSymbol> InstanceConstructors \{ get; \}
* &emsp; \| &emsp; bool IsComImport \{ get; \}
* &emsp; \| &emsp; bool IsGenericType \{ get; \}
* &emsp; \| &emsp; bool IsImplicitClass \{ get; \}
* &emsp; \| &emsp; bool IsScriptClass \{ get; \}
* &emsp; \| &emsp; bool IsUnboundGenericType \{ get; \}
* &emsp; \| &emsp; IEnumerable\<string> MemberNames \{ get; \}
* &emsp; \| &emsp; bool MightContainExtensionMethods \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IMethodSymbol> StaticConstructors \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IFieldSymbol> TupleElements \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol TupleUnderlyingType \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ITypeSymbol> TypeArguments \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ITypeParameterSymbol> TypeParameters \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol Construct\(params ITypeSymbol\[\] typeArguments\);
* &emsp; \| &emsp; INamedTypeSymbol ConstructUnboundGenericType\(\);
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> GetTypeArgumentCustomModifiers\(int ordinal\);
* &emsp; public interface Microsoft\.CodeAnalysis\.INamespaceOrTypeSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; bool IsNamespace \{ get; \}
* &emsp; \| &emsp; bool IsType \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ISymbol> GetMembers\(\);
* &emsp; \| &emsp; ImmutableArray\<ISymbol> GetMembers\(string name\);
* &emsp; \| &emsp; ImmutableArray\<INamedTypeSymbol> GetTypeMembers\(\);
* &emsp; \| &emsp; ImmutableArray\<INamedTypeSymbol> GetTypeMembers\(string name\);
* &emsp; \| &emsp; ImmutableArray\<INamedTypeSymbol> GetTypeMembers\(string name, int arity\);
* &emsp; public interface Microsoft\.CodeAnalysis\.INamespaceSymbol : IEquatable\<ISymbol>, INamespaceOrTypeSymbol, ISymbol
* &emsp; \| &emsp; ImmutableArray\<INamespaceSymbol> ConstituentNamespaces \{ get; \}
* &emsp; \| &emsp; Compilation ContainingCompilation \{ get; \}
* &emsp; \| &emsp; bool IsGlobalNamespace \{ get; \}
* &emsp; \| &emsp; NamespaceKind NamespaceKind \{ get; \}
* &emsp; \| &emsp; IEnumerable\<INamespaceOrTypeSymbol> GetMembers\(\);
* &emsp; \| &emsp; IEnumerable\<INamespaceOrTypeSymbol> GetMembers\(string name\);
* &emsp; \| &emsp; IEnumerable\<INamespaceSymbol> GetNamespaceMembers\(\);
* &emsp; public interface Microsoft\.CodeAnalysis\.IOperation
* &emsp; \| &emsp; Optional\<object> ConstantValue \{ get; \}
* &emsp; \| &emsp; bool IsInvalid \{ get; \}
* &emsp; \| &emsp; OperationKind Kind \{ get; \}
* &emsp; \| &emsp; SyntaxNode Syntax \{ get; \}
* &emsp; \| &emsp; ITypeSymbol Type \{ get; \}
* &emsp; \| &emsp; void Accept\(OperationVisitor visitor\);
* &emsp; \| &emsp; TResult Accept\<TArgument, TResult>\(OperationVisitor\<TArgument, TResult> visitor, TArgument argument\);
* &emsp; public interface Microsoft\.CodeAnalysis\.IParameterSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> CustomModifiers \{ get; \}
* &emsp; \| &emsp; object ExplicitDefaultValue \{ get; \}
* &emsp; \| &emsp; bool HasExplicitDefaultValue \{ get; \}
* &emsp; \| &emsp; bool IsOptional \{ get; \}
* &emsp; \| &emsp; bool IsParams \{ get; \}
* &emsp; \| &emsp; bool IsThis \{ get; \}
* &emsp; \| &emsp; int Ordinal \{ get; \}
* &emsp; \| &emsp; IParameterSymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> RefCustomModifiers \{ get; \}
* &emsp; \| &emsp; RefKind RefKind \{ get; \}
* &emsp; \| &emsp; ITypeSymbol Type \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IPointerTypeSymbol : IEquatable\<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> CustomModifiers \{ get; \}
* &emsp; \| &emsp; ITypeSymbol PointedAtType \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IPreprocessingSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; public interface Microsoft\.CodeAnalysis\.IPropertySymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; \| &emsp; ImmutableArray\<IPropertySymbol> ExplicitInterfaceImplementations \{ get; \}
* &emsp; \| &emsp; IMethodSymbol GetMethod \{ get; \}
* &emsp; \| &emsp; bool IsIndexer \{ get; \}
* &emsp; \| &emsp; bool IsReadOnly \{ get; \}
* &emsp; \| &emsp; bool IsWithEvents \{ get; \}
* &emsp; \| &emsp; bool IsWriteOnly \{ get; \}
* &emsp; \| &emsp; IPropertySymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; IPropertySymbol OverriddenProperty \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IParameterSymbol> Parameters \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> RefCustomModifiers \{ get; \}
* &emsp; \| &emsp; bool ReturnsByRef \{ get; \}
* &emsp; \| &emsp; IMethodSymbol SetMethod \{ get; \}
* &emsp; \| &emsp; ITypeSymbol Type \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<CustomModifier> TypeCustomModifiers \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IRangeVariableSymbol : IEquatable\<ISymbol>, ISymbol
* &emsp; public interface Microsoft\.CodeAnalysis\.ISkippedTokensTriviaSyntax
* &emsp; \| &emsp; SyntaxTokenList Tokens \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.ISourceAssemblySymbol : IEquatable\<ISymbol>, IAssemblySymbol, ISymbol
* &emsp; \| &emsp; Compilation Compilation \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.IStructuredTriviaSyntax
* &emsp; \| &emsp; SyntaxTrivia ParentTrivia \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.ISymbol : IEquatable\<ISymbol>
* &emsp; \| &emsp; bool CanBeReferencedByName \{ get; \}
* &emsp; \| &emsp; IAssemblySymbol ContainingAssembly \{ get; \}
* &emsp; \| &emsp; IModuleSymbol ContainingModule \{ get; \}
* &emsp; \| &emsp; INamespaceSymbol ContainingNamespace \{ get; \}
* &emsp; \| &emsp; ISymbol ContainingSymbol \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol ContainingType \{ get; \}
* &emsp; \| &emsp; Accessibility DeclaredAccessibility \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<SyntaxReference> DeclaringSyntaxReferences \{ get; \}
* &emsp; \| &emsp; bool HasUnsupportedMetadata \{ get; \}
* &emsp; \| &emsp; bool IsAbstract \{ get; \}
* &emsp; \| &emsp; bool IsDefinition \{ get; \}
* &emsp; \| &emsp; bool IsExtern \{ get; \}
* &emsp; \| &emsp; bool IsImplicitlyDeclared \{ get; \}
* &emsp; \| &emsp; bool IsOverride \{ get; \}
* &emsp; \| &emsp; bool IsSealed \{ get; \}
* &emsp; \| &emsp; bool IsStatic \{ get; \}
* &emsp; \| &emsp; bool IsVirtual \{ get; \}
* &emsp; \| &emsp; SymbolKind Kind \{ get; \}
* &emsp; \| &emsp; string Language \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<Location> Locations \{ get; \}
* &emsp; \| &emsp; string MetadataName \{ get; \}
* &emsp; \| &emsp; string Name \{ get; \}
* &emsp; \| &emsp; ISymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; void Accept\(SymbolVisitor visitor\);
* &emsp; \| &emsp; TResult Accept\<TResult>\(SymbolVisitor\<TResult> visitor\);
* &emsp; \| &emsp; ImmutableArray\<AttributeData> GetAttributes\(\);
* &emsp; \| &emsp; string GetDocumentationCommentId\(\);
* &emsp; \| &emsp; string GetDocumentationCommentXml\(CultureInfo preferredCulture = null, bool expandIncludes = false, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; ImmutableArray\<SymbolDisplayPart> ToDisplayParts\(SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; string ToDisplayString\(SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; ImmutableArray\<SymbolDisplayPart> ToMinimalDisplayParts\(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null\);
* &emsp; \| &emsp; string ToMinimalDisplayString\(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null\);
* &emsp; public interface Microsoft\.CodeAnalysis\.ITypeParameterSymbol : IEquatable\<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol
* &emsp; \| &emsp; ImmutableArray\<ITypeSymbol> ConstraintTypes \{ get; \}
* &emsp; \| &emsp; IMethodSymbol DeclaringMethod \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol DeclaringType \{ get; \}
* &emsp; \| &emsp; bool HasConstructorConstraint \{ get; \}
* &emsp; \| &emsp; bool HasReferenceTypeConstraint \{ get; \}
* &emsp; \| &emsp; bool HasValueTypeConstraint \{ get; \}
* &emsp; \| &emsp; int Ordinal \{ get; \}
* &emsp; \| &emsp; ITypeParameterSymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; ITypeParameterSymbol ReducedFrom \{ get; \}
* &emsp; \| &emsp; TypeParameterKind TypeParameterKind \{ get; \}
* &emsp; \| &emsp; VarianceKind Variance \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.ITypeSymbol : IEquatable\<ISymbol>, INamespaceOrTypeSymbol, ISymbol
* &emsp; \| &emsp; ImmutableArray\<INamedTypeSymbol> AllInterfaces \{ get; \}
* &emsp; \| &emsp; INamedTypeSymbol BaseType \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<INamedTypeSymbol> Interfaces \{ get; \}
* &emsp; \| &emsp; bool IsAnonymousType \{ get; \}
* &emsp; \| &emsp; bool IsReferenceType \{ get; \}
* &emsp; \| &emsp; bool IsTupleType \{ get; \}
* &emsp; \| &emsp; bool IsValueType \{ get; \}
* &emsp; \| &emsp; ITypeSymbol OriginalDefinition \{ get; \}
* &emsp; \| &emsp; SpecialType SpecialType \{ get; \}
* &emsp; \| &emsp; TypeKind TypeKind \{ get; \}
* &emsp; \| &emsp; ISymbol FindImplementationForInterfaceMember\(ISymbol interfaceMember\);
* &emsp; public interface Microsoft\.CodeAnalysis\.FindSymbols\.IFindReferencesProgress
* &emsp; \| &emsp; void OnCompleted\(\);
* &emsp; \| &emsp; void OnDefinitionFound\(ISymbol symbol\);
* &emsp; \| &emsp; void OnFindInDocumentCompleted\(Document document\);
* &emsp; \| &emsp; void OnFindInDocumentStarted\(Document document\);
* &emsp; \| &emsp; void OnReferenceFound\(ISymbol symbol, ReferenceLocation location\);
* &emsp; \| &emsp; void OnStarted\(\);
* &emsp; \| &emsp; void ReportProgress\(int current, int maximum\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.IAnalyzerService : IWorkspaceService
* &emsp; \| &emsp; IAnalyzerAssemblyLoader GetLoader\(\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.ILanguageService
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.IPersistentStorage : IDisposable
* &emsp; \| &emsp; Task\<Stream> ReadStreamAsync\(string name, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task\<Stream> ReadStreamAsync\(Document document, string name, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task\<Stream> ReadStreamAsync\(Project project, string name, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task\<bool> WriteStreamAsync\(string name, Stream stream, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task\<bool> WriteStreamAsync\(Document document, string name, Stream stream, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task\<bool> WriteStreamAsync\(Project project, string name, Stream stream, CancellationToken cancellationToken = default\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.IPersistentStorageService : IWorkspaceService
* &emsp; \| &emsp; IPersistentStorage GetStorage\(Solution solution\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.ITemporaryStorageService : IWorkspaceService
* &emsp; \| &emsp; ITemporaryStreamStorage CreateTemporaryStreamStorage\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; ITemporaryTextStorage CreateTemporaryTextStorage\(CancellationToken cancellationToken = default\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.ITemporaryStreamStorage : IDisposable
* &emsp; \| &emsp; Stream ReadStream\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task\<Stream> ReadStreamAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; void WriteStream\(Stream stream, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task WriteStreamAsync\(Stream stream, CancellationToken cancellationToken = default\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.ITemporaryTextStorage : IDisposable
* &emsp; \| &emsp; SourceText ReadText\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task\<SourceText> ReadTextAsync\(CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; void WriteText\(SourceText text, CancellationToken cancellationToken = default\);
* &emsp; \| &emsp; Task WriteTextAsync\(SourceText text, CancellationToken cancellationToken = default\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.IWorkspaceService
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.Mef\.ILanguageServiceFactory
* &emsp; \| &emsp; ILanguageService CreateLanguageService\(HostLanguageServices languageServices\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Host\.Mef\.IWorkspaceServiceFactory
* &emsp; \| &emsp; IWorkspaceService CreateService\(HostWorkspaceServices workspaceServices\);
* &emsp; public interface Microsoft\.CodeAnalysis\.Options\.IOption
* &emsp; \| &emsp; object DefaultValue \{ get; \}
* &emsp; \| &emsp; string Feature \{ get; \}
* &emsp; \| &emsp; bool IsPerLanguage \{ get; \}
* &emsp; \| &emsp; string Name \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<OptionStorageLocation> StorageLocations \{ get; \}
* &emsp; \| &emsp; Type Type \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IAddressOfExpression : IOperation
* &emsp; \| &emsp; IOperation Reference \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IArgument : IOperation
* &emsp; \| &emsp; ArgumentKind ArgumentKind \{ get; \}
* &emsp; \| &emsp; IOperation InConversion \{ get; \}
* &emsp; \| &emsp; IOperation OutConversion \{ get; \}
* &emsp; \| &emsp; IParameterSymbol Parameter \{ get; \}
* &emsp; \| &emsp; IOperation Value \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IArrayCreationExpression : IOperation
* &emsp; \| &emsp; ImmutableArray\<IOperation> DimensionSizes \{ get; \}
* &emsp; \| &emsp; ITypeSymbol ElementType \{ get; \}
* &emsp; \| &emsp; IArrayInitializer Initializer \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IArrayElementReferenceExpression : IOperation
* &emsp; \| &emsp; IOperation ArrayReference \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IOperation> Indices \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IArrayInitializer : IOperation
* &emsp; \| &emsp; ImmutableArray\<IOperation> ElementValues \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IAssignmentExpression : IOperation
* &emsp; \| &emsp; IOperation Target \{ get; \}
* &emsp; \| &emsp; IOperation Value \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IAwaitExpression : IOperation
* &emsp; \| &emsp; IOperation AwaitedValue \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IBinaryOperatorExpression : IOperation, IHasOperatorMethodExpression
* &emsp; \| &emsp; BinaryOperationKind BinaryOperationKind \{ get; \}
* &emsp; \| &emsp; IOperation LeftOperand \{ get; \}
* &emsp; \| &emsp; IOperation RightOperand \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IBlockStatement : IOperation
* &emsp; \| &emsp; ImmutableArray\<ILocalSymbol> Locals \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IOperation> Statements \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IBranchStatement : IOperation
* &emsp; \| &emsp; BranchKind BranchKind \{ get; \}
* &emsp; \| &emsp; ILabelSymbol Target \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ICaseClause : IOperation
* &emsp; \| &emsp; CaseKind CaseKind \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ICatchClause : IOperation
* &emsp; \| &emsp; ITypeSymbol CaughtType \{ get; \}
* &emsp; \| &emsp; ILocalSymbol ExceptionLocal \{ get; \}
* &emsp; \| &emsp; IOperation Filter \{ get; \}
* &emsp; \| &emsp; IBlockStatement Handler \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ICompoundAssignmentExpression : IOperation, IAssignmentExpression, IHasOperatorMethodExpression
* &emsp; \| &emsp; BinaryOperationKind BinaryOperationKind \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IConditionalAccessExpression : IOperation
* &emsp; \| &emsp; IOperation ConditionalInstance \{ get; \}
* &emsp; \| &emsp; IOperation ConditionalValue \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IConditionalAccessInstanceExpression : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IConditionalChoiceExpression : IOperation
* &emsp; \| &emsp; IOperation Condition \{ get; \}
* &emsp; \| &emsp; IOperation IfFalseValue \{ get; \}
* &emsp; \| &emsp; IOperation IfTrueValue \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IConversionExpression : IOperation, IHasOperatorMethodExpression
* &emsp; \| &emsp; ConversionKind ConversionKind \{ get; \}
* &emsp; \| &emsp; bool IsExplicit \{ get; \}
* &emsp; \| &emsp; IOperation Operand \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IDefaultValueExpression : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IEmptyStatement : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IEndStatement : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IEventAssignmentExpression : IOperation
* &emsp; \| &emsp; bool Adds \{ get; \}
* &emsp; \| &emsp; IEventSymbol Event \{ get; \}
* &emsp; \| &emsp; IOperation EventInstance \{ get; \}
* &emsp; \| &emsp; IOperation HandlerValue \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IEventReferenceExpression : IOperation, IMemberReferenceExpression
* &emsp; \| &emsp; IEventSymbol Event \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IExpressionStatement : IOperation
* &emsp; \| &emsp; IOperation Expression \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IFieldInitializer : IOperation, ISymbolInitializer
* &emsp; \| &emsp; ImmutableArray\<IFieldSymbol> InitializedFields \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IFieldReferenceExpression : IOperation, IMemberReferenceExpression
* &emsp; \| &emsp; IFieldSymbol Field \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IFixedStatement : IOperation
* &emsp; \| &emsp; IOperation Body \{ get; \}
* &emsp; \| &emsp; IVariableDeclarationStatement Variables \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IForEachLoopStatement : IOperation, ILoopStatement
* &emsp; \| &emsp; IOperation Collection \{ get; \}
* &emsp; \| &emsp; ILocalSymbol IterationVariable \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IForLoopStatement : IOperation, IForWhileUntilLoopStatement, ILoopStatement
* &emsp; \| &emsp; ImmutableArray\<IOperation> AtLoopBottom \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IOperation> Before \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ILocalSymbol> Locals \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IForWhileUntilLoopStatement : IOperation, ILoopStatement
* &emsp; \| &emsp; IOperation Condition \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IHasArgumentsExpression : IOperation
* &emsp; \| &emsp; ImmutableArray\<IArgument> ArgumentsInEvaluationOrder \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IHasOperatorMethodExpression : IOperation
* &emsp; \| &emsp; IMethodSymbol OperatorMethod \{ get; \}
* &emsp; \| &emsp; bool UsesOperatorMethod \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IIfStatement : IOperation
* &emsp; \| &emsp; IOperation Condition \{ get; \}
* &emsp; \| &emsp; IOperation IfFalseStatement \{ get; \}
* &emsp; \| &emsp; IOperation IfTrueStatement \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IIncrementExpression : IOperation, IAssignmentExpression, ICompoundAssignmentExpression, IHasOperatorMethodExpression
* &emsp; \| &emsp; UnaryOperationKind IncrementOperationKind \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IIndexedPropertyReferenceExpression : IOperation, IHasArgumentsExpression, IMemberReferenceExpression, IPropertyReferenceExpression
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IInstanceReferenceExpression : IOperation
* &emsp; \| &emsp; InstanceReferenceKind InstanceReferenceKind \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IInvalidExpression : IOperation
* &emsp; \| &emsp; ImmutableArray\<IOperation> Children \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IInvalidStatement : IOperation
* &emsp; \| &emsp; ImmutableArray\<IOperation> Children \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IInvocationExpression : IOperation, IHasArgumentsExpression
* &emsp; \| &emsp; IOperation Instance \{ get; \}
* &emsp; \| &emsp; bool IsVirtual \{ get; \}
* &emsp; \| &emsp; IMethodSymbol TargetMethod \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IIsTypeExpression : IOperation
* &emsp; \| &emsp; ITypeSymbol IsType \{ get; \}
* &emsp; \| &emsp; IOperation Operand \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ILabelStatement : IOperation
* &emsp; \| &emsp; ILabelSymbol Label \{ get; \}
* &emsp; \| &emsp; IOperation LabeledStatement \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ILambdaExpression : IOperation
* &emsp; \| &emsp; IBlockStatement Body \{ get; \}
* &emsp; \| &emsp; IMethodSymbol Signature \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ILateBoundMemberReferenceExpression : IOperation
* &emsp; \| &emsp; IOperation Instance \{ get; \}
* &emsp; \| &emsp; string MemberName \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ILiteralExpression : IOperation
* &emsp; \| &emsp; string Text \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ILocalReferenceExpression : IOperation
* &emsp; \| &emsp; ILocalSymbol Local \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ILockStatement : IOperation
* &emsp; \| &emsp; IOperation Body \{ get; \}
* &emsp; \| &emsp; IOperation LockedObject \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ILoopStatement : IOperation
* &emsp; \| &emsp; IOperation Body \{ get; \}
* &emsp; \| &emsp; LoopKind LoopKind \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IMemberReferenceExpression : IOperation
* &emsp; \| &emsp; IOperation Instance \{ get; \}
* &emsp; \| &emsp; ISymbol Member \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IMethodBindingExpression : IOperation, IMemberReferenceExpression
* &emsp; \| &emsp; bool IsVirtual \{ get; \}
* &emsp; \| &emsp; IMethodSymbol Method \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.INullCoalescingExpression : IOperation
* &emsp; \| &emsp; IOperation PrimaryOperand \{ get; \}
* &emsp; \| &emsp; IOperation SecondaryOperand \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IObjectCreationExpression : IOperation, IHasArgumentsExpression
* &emsp; \| &emsp; IMethodSymbol Constructor \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<IOperation> Initializers \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IOmittedArgumentExpression : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IParameterInitializer : IOperation, ISymbolInitializer
* &emsp; \| &emsp; IParameterSymbol Parameter \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IParameterReferenceExpression : IOperation
* &emsp; \| &emsp; IParameterSymbol Parameter \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IParenthesizedExpression : IOperation
* &emsp; \| &emsp; IOperation Operand \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IPlaceholderExpression : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IPointerIndirectionReferenceExpression : IOperation
* &emsp; \| &emsp; IOperation Pointer \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IPropertyInitializer : IOperation, ISymbolInitializer
* &emsp; \| &emsp; IPropertySymbol InitializedProperty \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IPropertyReferenceExpression : IOperation, IMemberReferenceExpression
* &emsp; \| &emsp; IPropertySymbol Property \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IRangeCaseClause : IOperation, ICaseClause
* &emsp; \| &emsp; IOperation MaximumValue \{ get; \}
* &emsp; \| &emsp; IOperation MinimumValue \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IRelationalCaseClause : IOperation, ICaseClause
* &emsp; \| &emsp; BinaryOperationKind Relation \{ get; \}
* &emsp; \| &emsp; IOperation Value \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IReturnStatement : IOperation
* &emsp; \| &emsp; IOperation ReturnedValue \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ISingleValueCaseClause : IOperation, ICaseClause
* &emsp; \| &emsp; BinaryOperationKind Equality \{ get; \}
* &emsp; \| &emsp; IOperation Value \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ISizeOfExpression : IOperation, ITypeOperationExpression
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IStopStatement : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ISwitchCase : IOperation
* &emsp; \| &emsp; ImmutableArray\<IOperation> Body \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ICaseClause> Clauses \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ISwitchStatement : IOperation
* &emsp; \| &emsp; ImmutableArray\<ISwitchCase> Cases \{ get; \}
* &emsp; \| &emsp; IOperation Value \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ISymbolInitializer : IOperation
* &emsp; \| &emsp; IOperation Value \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ISyntheticLocalReferenceExpression : IOperation
* &emsp; \| &emsp; IOperation ContainingStatement \{ get; \}
* &emsp; \| &emsp; SyntheticLocalKind SyntheticLocalKind \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IThrowStatement : IOperation
* &emsp; \| &emsp; IOperation ThrownObject \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ITryStatement : IOperation
* &emsp; \| &emsp; IBlockStatement Body \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ICatchClause> Catches \{ get; \}
* &emsp; \| &emsp; IBlockStatement FinallyHandler \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ITypeOfExpression : IOperation, ITypeOperationExpression
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ITypeOperationExpression : IOperation
* &emsp; \| &emsp; ITypeSymbol TypeOperand \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.ITypeParameterObjectCreationExpression : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IUnaryOperatorExpression : IOperation, IHasOperatorMethodExpression
* &emsp; \| &emsp; IOperation Operand \{ get; \}
* &emsp; \| &emsp; UnaryOperationKind UnaryOperationKind \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IUnboundLambdaExpression : IOperation
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IUsingStatement : IOperation
* &emsp; \| &emsp; IOperation Body \{ get; \}
* &emsp; \| &emsp; IVariableDeclarationStatement Declaration \{ get; \}
* &emsp; \| &emsp; IOperation Value \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IVariableDeclaration : IOperation
* &emsp; \| &emsp; IOperation Initializer \{ get; \}
* &emsp; \| &emsp; ImmutableArray\<ILocalSymbol> Variables \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IVariableDeclarationStatement : IOperation
* &emsp; \| &emsp; ImmutableArray\<IVariableDeclaration> Declarations \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IWhileUntilLoopStatement : IOperation, IForWhileUntilLoopStatement, ILoopStatement
* &emsp; \| &emsp; bool IsTopTest \{ get; \}
* &emsp; \| &emsp; bool IsWhile \{ get; \}
* &emsp; public interface Microsoft\.CodeAnalysis\.Semantics\.IWithStatement : IOperation
* &emsp; \| &emsp; IOperation Body \{ get; \}
* &emsp; \| &emsp; IOperation Value \{ get; \}
* &emsp; public interface Roslynator\.ISelection\<T> : IReadOnlyList\<T>
* &emsp; \| &emsp; int FirstIndex \{ get; \}
* &emsp; \| &emsp; int LastIndex \{ get; \}
* &emsp; \| &emsp; T First\(\);
* &emsp; \| &emsp; T Last\(\);
