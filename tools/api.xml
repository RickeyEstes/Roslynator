<?xml version="1.0" encoding="utf-8"?>
<root>
  <assemblies>
    <assembly name="Roslynator.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=3aeedfaf14b2cebf">
      <attributes>
        <attribute>AssemblyCompany("Josef Pihrt")</attribute>
        <attribute>AssemblyConfiguration("Debug")</attribute>
        <attribute>AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")</attribute>
        <attribute>AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.Common.")</attribute>
        <attribute>AssemblyFileVersion("1.0.0.10")</attribute>
        <attribute>AssemblyInformationalVersion("1.0.0.10")</attribute>
        <attribute>AssemblyProduct("Roslynator.Core")</attribute>
        <attribute>AssemblyTitle("Roslynator.Core")</attribute>
        <attribute>AssemblyVersion("1.0.0.10")</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Roslynator.CSharp, Version=1.0.0.10, Culture=neutral, PublicKeyToken=390be46f77b79f52">
      <attributes>
        <attribute>AssemblyCompany("Josef Pihrt")</attribute>
        <attribute>AssemblyConfiguration("Debug")</attribute>
        <attribute>AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")</attribute>
        <attribute>AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.CSharp\n\nCommonly Used Types:\nRoslynator.CSharp.CSharpFactory\nRoslynator.CSharp.CSharpFacts\nRoslynator.CSharp.SyntaxInfo\nRoslynator.NameGenerator")</attribute>
        <attribute>AssemblyFileVersion("1.0.0.10")</attribute>
        <attribute>AssemblyInformationalVersion("1.0.0.10")</attribute>
        <attribute>AssemblyProduct("Roslynator.CSharp")</attribute>
        <attribute>AssemblyTitle("Roslynator.CSharp")</attribute>
        <attribute>AssemblyVersion("1.0.0.10")</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Roslynator.CSharp.Workspaces, Version=1.0.0.10, Culture=neutral, PublicKeyToken=ec3f0c29a7973f23">
      <attributes>
        <attribute>AssemblyCompany("Josef Pihrt")</attribute>
        <attribute>AssemblyConfiguration("Debug")</attribute>
        <attribute>AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")</attribute>
        <attribute>AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.CSharp.Workspaces\n\nCommonly Used Types:\nRoslynator.CSharp.CSharpFactory\nRoslynator.CSharp.CSharpFacts\nRoslynator.CSharp.SyntaxInfo\nRoslynator.NameGenerator")</attribute>
        <attribute>AssemblyFileVersion("1.0.0.10")</attribute>
        <attribute>AssemblyInformationalVersion("1.0.0.10")</attribute>
        <attribute>AssemblyProduct("Roslynator.CSharp.Workspaces")</attribute>
        <attribute>AssemblyTitle("Roslynator.CSharp.Workspaces")</attribute>
        <attribute>AssemblyVersion("1.0.0.10")</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
    <assembly name="Roslynator.Workspaces.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=be1ec334fe31b7bb">
      <attributes>
        <attribute>AssemblyCompany("Josef Pihrt")</attribute>
        <attribute>AssemblyConfiguration("Debug")</attribute>
        <attribute>AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")</attribute>
        <attribute>AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.Workspaces.Common.")</attribute>
        <attribute>AssemblyFileVersion("1.0.0.10")</attribute>
        <attribute>AssemblyInformationalVersion("1.0.0.10")</attribute>
        <attribute>AssemblyProduct("Roslynator.Workspaces.Core")</attribute>
        <attribute>AssemblyTitle("Roslynator.Workspaces.Core")</attribute>
        <attribute>AssemblyVersion("1.0.0.10")</attribute>
        <attribute>TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")</attribute>
      </attributes>
    </assembly>
  </assemblies>
  <namespaces>
    <namespace name="Roslynator">
      <types>
        <type def="public static class DiagnosticsExtensions">
          <doc>
            <summary>A set of extension methods for <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext" />, <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext" /> and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext" />.</summary>
          </doc>
          <members>
            <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.ISymbol" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode" />.</summary>
              </doc>
            </member>
            <member def="public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable&lt;Location&gt; additionalLocations, ImmutableDictionary&lt;string, string&gt; properties, params object[] messageArgs)">
              <doc>
                <summary>Report a <see cref="T:Microsoft.CodeAnalysis.Diagnostic" /> about a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class EnumExtensions">
          <doc>
            <summary>A set of extension methods for enumerations.</summary>
          </doc>
          <members>
            <member def="public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2)">
              <doc>
                <summary>Returns true if the accessibility is one of the specified accessibilities.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2)">
              <doc>
                <summary>Returns true if the method kind is one of the specified method kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2)">
              <doc>
                <summary>Returns true if the special type is one of the specified special types.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2)">
              <doc>
                <summary>Returns true if the type kind is one of the specified type kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3)">
              <doc>
                <summary>Returns true if the accessibility is one of the specified accessibilities.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3)">
              <doc>
                <summary>Returns true if the method kind is one of the specified method kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3)">
              <doc>
                <summary>Returns true if the special type is one of the specified special types.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3)">
              <doc>
                <summary>Returns true if the type kind is one of the specified type kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4)">
              <doc>
                <summary>Returns true if the accessibility is one of the specified accessibilities.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4)">
              <doc>
                <summary>Returns true if the method kind is one of the specified method kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4)">
              <doc>
                <summary>Returns true if the special type is one of the specified special types.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4)">
              <doc>
                <summary>Returns true if the type kind is one of the specified type kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4, Accessibility accessibility5)">
              <doc>
                <summary>Returns true if the accessibility is one of the specified accessibilities.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4, MethodKind methodKind5)">
              <doc>
                <summary>Returns true if the method kind is one of the specified method kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4, SpecialType specialType5)">
              <doc>
                <summary>Returns true if the special type is one of the specified special types.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4, TypeKind typeKind5)">
              <doc>
                <summary>Returns true if the type kind is one of the specified type kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsMoreRestrictiveThan(this Accessibility accessibility, Accessibility other)">
              <doc>
                <summary>Returns true if the accessibility if more restrictrive than the other accessibility.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class FileLinePositionSpanExtensions">
          <doc>
            <summary>A set of extension methods for <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan" />.</summary>
          </doc>
          <members>
            <member def="public static int EndLine(this FileLinePositionSpan fileLinePositionSpan)">
              <doc>
                <summary>Returns zero-based index of the end line of the specified span.</summary>
              </doc>
            </member>
            <member def="public static bool IsMultiLine(this FileLinePositionSpan fileLinePositionSpan)">
              <doc>
                <summary>Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan" /> spans over multiple lines.</summary>
              </doc>
            </member>
            <member def="public static bool IsSingleLine(this FileLinePositionSpan fileLinePositionSpan)">
              <doc>
                <summary>Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan" /> does not span over multiple lines.</summary>
              </doc>
            </member>
            <member def="public static int StartLine(this FileLinePositionSpan fileLinePositionSpan)">
              <doc>
                <summary>Returns zero-based index of the start line of the specified span.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public sealed class MetadataNameEqualityComparer&lt;TSymbol&gt; : EqualityComparer&lt;TSymbol&gt; where TSymbol : ISymbol">
          <doc>
            <summary>
            Provides equality comparison for <typeparamref name="TSymbol" /> by comparing <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName" />,
            metadata name of <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType" />(s) and metadata name of <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingNamespace" />(s).
            </summary>
          </doc>
          <members>
            <member def="public static MetadataNameEqualityComparer&lt;TSymbol&gt; Instance { get; }">
              <doc>
                <summary>Get the instance of <see cref="T:Roslynator.MetadataNameEqualityComparer`1" /> for the specified <typeparamref name="TSymbol" />.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(TSymbol x, TSymbol y)">
              <doc>
                <summary>When overridden in a derived class, determines whether two objects of type <typeparamref name="TSymbol" /> are equal.</summary>
                <param name="x">The first object to compare.</param>
                <param name="y">The second object to compare.</param>
                <returns>true if the specified objects are equal; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode(TSymbol obj)">
              <doc>
                <summary>Serves as a hash function for the specified symbol.</summary>
                <param name="obj">The symbol for which to get a hash code.</param>
                <returns>A hash code for the specified symbol.</returns>
                <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> is <c>null</c>.</exception>
              </doc>
            </member>
          </members>
        </type>
        <type def="public abstract class NameGenerator">
          <doc>
            <summary>Provides methods to obtain an unique identifier.</summary>
          </doc>
          <members>
            <member def="protected NameGenerator()" />
            <member def="public static NameGenerator Default { get; }">
              <doc>
                <summary>Default implementation of <see cref="T:Roslynator.NameGenerator" /> that adds number suffix to ensure uniqueness.</summary>
              </doc>
            </member>
            <member def="public static string CreateName(ITypeSymbol typeSymbol, bool firstCharToLower = false)">
              <doc>
                <summary>Creates a syntax identifier from the specified type symbol.</summary>
              </doc>
            </member>
            <member def="public string EnsureUniqueEnumMemberName(string baseName, INamedTypeSymbol enumType, bool isCaseSensitive = true)">
              <doc>
                <summary>Returns unique enum member name for a specified enum type.</summary>
              </doc>
            </member>
            <member def="public string EnsureUniqueLocalName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Return a local name that will be unique at the specified position.</summary>
              </doc>
            </member>
            <member def="public string EnsureUniqueMemberName(string baseName, INamedTypeSymbol typeSymbol, bool isCaseSensitive = true)">
              <attributes>
                <attribute>Obsolete("This member is obsolete.")</attribute>
              </attributes>
            </member>
            <member def="public string EnsureUniqueMemberName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns a member name that will be unique at the specified position.</summary>
              </doc>
              <attributes>
                <attribute>Obsolete("This member is obsolete.")</attribute>
              </attributes>
            </member>
            <member def="public abstract string EnsureUniqueName(string baseName, IEnumerable&lt;string&gt; reservedNames, bool isCaseSensitive = true)">
              <doc>
                <summary>Returns an unique name using the specified list of reserved names.</summary>
              </doc>
            </member>
            <member def="public abstract string EnsureUniqueName(string baseName, ImmutableArray&lt;ISymbol&gt; symbols, bool isCaseSensitive = true)">
              <doc>
                <summary>Returns an unique name using the specified list of symbols.</summary>
              </doc>
            </member>
            <member def="public string EnsureUniqueName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true)">
              <doc>
                <summary>Returns a name that will be unique at the specified position.</summary>
              </doc>
            </member>
            <member def="public static bool IsUniqueName(string name, IEnumerable&lt;string&gt; reservedNames, bool isCaseSensitive = true)">
              <doc>
                <summary>Returns true if the name is not contained in the specified list.</summary>
              </doc>
            </member>
            <member def="public static bool IsUniqueName(string name, ImmutableArray&lt;ISymbol&gt; symbols, bool isCaseSensitive = true)">
              <doc>
                <summary>Returns true if the name is not contained in the specified list. <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name" /> is used to compare names.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class SemanticModelExtensions">
          <doc>
            <summary>A set of extension methods for a <see cref="T:Microsoft.CodeAnalysis.SemanticModel" />.</summary>
          </doc>
          <members>
            <member def="public static INamedTypeSymbol GetEnclosingNamedType(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns the innermost named type symbol that the specified position is considered inside of.</summary>
              </doc>
            </member>
            <member def="public static TSymbol GetEnclosingSymbol&lt;TSymbol&gt;(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default) where TSymbol : ISymbol">
              <doc>
                <summary>Returns the innermost symbol of type <typeparamref name="TSymbol" /> that the specified position is considered inside of.</summary>
              </doc>
            </member>
            <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what symbol, if any, the specified node bound to.</summary>
              </doc>
            </member>
            <member def="public static INamedTypeSymbol GetTypeByMetadataName(this SemanticModel semanticModel, string fullyQualifiedMetadataName)">
              <doc>
                <summary>Returns the type within the compilation's assembly using its canonical CLR metadata name.</summary>
              </doc>
            </member>
            <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns type information about the specified node.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public class SeparatedSyntaxListSelection&lt;TNode&gt; : ISelection&lt;TNode&gt; where TNode : SyntaxNode">
          <doc>
            <summary>Represents selected nodes in a <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
          </doc>
          <members>
            <member def="protected SeparatedSyntaxListSelection(SeparatedSyntaxList&lt;TNode&gt; list, TextSpan span, int firstIndex, int lastIndex)">
              <doc>
                <summary>Initializes a new instance of the <see cref="T:Roslynator.SeparatedSyntaxListSelection`1" />.</summary>
              </doc>
            </member>
            <member def="public int Count { get; }">
              <doc>
                <summary>Gets a number of selected nodes.</summary>
              </doc>
            </member>
            <member def="public int FirstIndex { get; }">
              <doc>
                <summary>Gets an index of the first selected node.</summary>
              </doc>
            </member>
            <member def="public int LastIndex { get; }">
              <doc>
                <summary>Gets an index of the last selected node.</summary>
              </doc>
            </member>
            <member def="public TextSpan OriginalSpan { get; }">
              <doc>
                <summary>Gets the original span that was used to determine selected nodes.</summary>
              </doc>
            </member>
            <member def="public SeparatedSyntaxList&lt;TNode&gt; UnderlyingList { get; }">
              <doc>
                <summary>Gets an underlying list that contains selected nodes.</summary>
              </doc>
            </member>
            <member def="public TNode this[int index] { get; }">
              <doc>
                <summary>Gets the selected node at the specified index.</summary>
                <returns>The node at the specified index.</returns>
                <param name="index">The zero-based index of the node to get. </param>
              </doc>
            </member>
            <member def="public static SeparatedSyntaxListSelection&lt;TNode&gt; Create(SeparatedSyntaxList&lt;TNode&gt; list, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.SeparatedSyntaxListSelection`1" /> based on the specified list and span.</summary>
              </doc>
            </member>
            <member def="public TNode First()">
              <doc>
                <summary>Gets the first selected node.</summary>
              </doc>
            </member>
            <member def="public SeparatedSyntaxListSelection&lt;TNode&gt;.Enumerator GetEnumerator()">
              <doc>
                <summary>Returns an enumerator that iterates through selected nodes.</summary>
              </doc>
            </member>
            <member def="public TNode Last()">
              <doc>
                <summary>Gets the last selected node.</summary>
              </doc>
            </member>
            <member def="public static bool TryCreate(SeparatedSyntaxList&lt;TNode&gt; list, TextSpan span, out SeparatedSyntaxListSelection&lt;TNode&gt; selection)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.SeparatedSyntaxListSelection`1" /> based on the specified list and span.</summary>
                <returns>True if the specified span contains at least one node; otherwise, false.</returns>
              </doc>
            </member>
          </members>
          <types>
            <type def="public struct Enumerator">
              <members>
                <member def="public TNode Current { get; }" />
                <member def="public override bool Equals(object obj)" />
                <member def="public override int GetHashCode()" />
                <member def="public bool MoveNext()" />
                <member def="public void Reset()" />
              </members>
            </type>
          </types>
        </type>
        <type def="public static class SymbolExtensions">
          <doc>
            <summary>A set of extension methods for <see cref="T:Microsoft.CodeAnalysis.ISymbol" /> and its derived types.</summary>
          </doc>
          <members>
            <member def="public static IEnumerable&lt;INamedTypeSymbol&gt; BaseTypes(this ITypeSymbol type)">
              <doc>
                <summary>Gets a list of base types of this type.</summary>
              </doc>
            </member>
            <member def="public static IEnumerable&lt;ITypeSymbol&gt; BaseTypesAndSelf(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Gets a list of base types of this type (including this type).</summary>
              </doc>
            </member>
            <member def="public static bool EqualsOrInheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false)">
              <doc>
                <summary>Returns true if the type is equal or inherits from a specified base type.</summary>
              </doc>
            </member>
            <member def="public static bool EqualsOrInheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false)">
              <doc>
                <summary>Returns true if the type is equal or inherits from a type wit the specified name.</summary>
              </doc>
            </member>
            <member def="public static TSymbol FindMember&lt;TSymbol&gt;(this ITypeSymbol typeSymbol, Func&lt;TSymbol, bool&gt; predicate = null) where TSymbol : ISymbol">
              <doc>
                <summary>Searches for a member that matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
              </doc>
            </member>
            <member def="public static TSymbol FindMember&lt;TSymbol&gt;(this ITypeSymbol typeSymbol, string name, Func&lt;TSymbol, bool&gt; predicate = null) where TSymbol : ISymbol">
              <doc>
                <summary>Searches for a member that has the specified name and matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
              </doc>
            </member>
            <member def="public static TSymbol FindMember&lt;TSymbol&gt;(this INamedTypeSymbol typeSymbol, Func&lt;TSymbol, bool&gt; predicate, bool includeBaseTypes = false) where TSymbol : ISymbol">
              <doc>
                <summary>Searches for a member that matches the conditions defined by the specified predicate and returns the first occurrence within the type's members.</summary>
              </doc>
            </member>
            <member def="public static TSymbol FindMember&lt;TSymbol&gt;(this INamedTypeSymbol typeSymbol, string name, Func&lt;TSymbol, bool&gt; predicate = null, bool includeBaseTypes = false) where TSymbol : ISymbol">
              <doc>
                <summary>Searches for a member that has the specified name and matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
              </doc>
            </member>
            <member def="public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, Func&lt;INamedTypeSymbol, bool&gt; predicate, bool includeBaseTypes = false)">
              <doc>
                <summary>Searches for a type member that matches the conditions defined by the specified predicate and returns the first occurrence within the type's members.</summary>
              </doc>
            </member>
            <member def="public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, Func&lt;INamedTypeSymbol, bool&gt; predicate = null, bool includeBaseTypes = false)">
              <doc>
                <summary>Searches for a type member that has the specified name and matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
              </doc>
            </member>
            <member def="public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, int arity, Func&lt;INamedTypeSymbol, bool&gt; predicate = null, bool includeBaseTypes = false)">
              <doc>
                <summary>Searches for a type member that has the specified name, arity and matches the conditions defined by the specified predicate, if any, and returns the first occurrence within the type's members.</summary>
              </doc>
            </member>
            <member def="public static AttributeData GetAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass)">
              <doc>
                <summary>Returns the attribute for the symbol that matches the specified attribute class, or null if the symbol does not have the specified attribute.</summary>
              </doc>
            </member>
            <member def="public static AttributeData GetAttribute(this ISymbol symbol, in MetadataName attributeName)">
              <doc>
                <summary>Returns the attribute for the symbol that matches the specified name, or null if the symbol does not have the specified attribute.</summary>
              </doc>
            </member>
            <member def="public static bool HasAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass)">
              <doc>
                <summary>Returns true if the symbol has the specified attribute.</summary>
              </doc>
            </member>
            <member def="public static bool HasAttribute(this ISymbol symbol, in MetadataName attributeName)">
              <doc>
                <summary>Returns true if the symbol has attribute with the specified name.</summary>
              </doc>
            </member>
            <member def="public static bool HasAttribute(this ITypeSymbol typeSymbol, INamedTypeSymbol attributeClass, bool includeBaseTypes)">
              <doc>
                <summary>Returns true if the type symbol has the specified attribute.</summary>
              </doc>
            </member>
            <member def="public static bool HasAttribute(this ITypeSymbol typeSymbol, in MetadataName attributeName, bool includeBaseTypes)">
              <doc>
                <summary>Returns true if the type symbol has attribute with the specified name.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, bool value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, char value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, sbyte value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, byte value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, short value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ushort value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, int value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, uint value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, long value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ulong value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, decimal value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, float value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, double value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this IFieldSymbol fieldSymbol, string value)">
              <doc>
                <summary>Get a value indicating whether the field symbol has specified constant value.</summary>
              </doc>
            </member>
            <member def="public static bool HasMetadataName(this ISymbol symbol, in MetadataName metadataName)">
              <doc>
                <summary>Returns true if a symbol has the specified <see cref="T:Roslynator.MetadataName" />.</summary>
              </doc>
            </member>
            <member def="public static bool Implements(this ITypeSymbol typeSymbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false)">
              <doc>
                <summary>Returns true if the type implements specified interface.</summary>
                <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
              </doc>
            </member>
            <member def="public static bool Implements(this ITypeSymbol typeSymbol, SpecialType interfaceType, bool allInterfaces = false)">
              <doc>
                <summary>Returns true if the type implements specified interface.</summary>
                <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
              </doc>
            </member>
            <member def="public static bool Implements(this ITypeSymbol typeSymbol, in MetadataName interfaceName, bool allInterfaces = false)">
              <doc>
                <summary>Returns true if the type implements specified interface name.</summary>
              </doc>
            </member>
            <member def="public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, bool allInterfaces = false)">
              <doc>
                <summary>Returns true if the type implements any of specified interfaces.</summary>
                <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
              </doc>
            </member>
            <member def="public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, SpecialType interfaceType3, bool allInterfaces = false)">
              <doc>
                <summary>Returns true if the type implements any of specified interfaces.</summary>
                <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
              </doc>
            </member>
            <member def="public static bool ImplementsInterfaceMember(this ISymbol symbol, bool allInterfaces = false)">
              <doc>
                <summary>Returns true if the the symbol implements any interface member.</summary>
                <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
              </doc>
            </member>
            <member def="public static bool ImplementsInterfaceMember(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false)">
              <doc>
                <summary>Returns true if the symbol implements any member of the specified interface.</summary>
                <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
              </doc>
            </member>
            <member def="public static bool ImplementsInterfaceMember&lt;TSymbol&gt;(this ISymbol symbol, bool allInterfaces = false) where TSymbol : ISymbol">
              <doc>
                <summary>Returns true if the symbol implements any interface member.</summary>
                <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
              </doc>
            </member>
            <member def="public static bool ImplementsInterfaceMember&lt;TSymbol&gt;(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false) where TSymbol : ISymbol">
              <doc>
                <summary>Returns true if the symbol implements any member of the specified interface.</summary>
                <param name="allInterfaces">If true, use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces" />, otherwise use <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces" />.</param>
              </doc>
            </member>
            <member def="public static bool InheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false)">
              <doc>
                <summary>Returns true if the type inherits from a specified base type.</summary>
              </doc>
            </member>
            <member def="public static bool InheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false)">
              <doc>
                <summary>Returns true if the type inherits from a type with the specified name.</summary>
              </doc>
            </member>
            <member def="public static bool IsAsyncMethod(this ISymbol symbol)">
              <doc>
                <summary>Returns true if the symbol is an async method.</summary>
              </doc>
            </member>
            <member def="public static bool IsErrorType(this ISymbol symbol)">
              <doc>
                <summary>Returns true if the symbol represents an error.</summary>
              </doc>
            </member>
            <member def="public static bool IsIEnumerableOfT(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsIEnumerableOrIEnumerableOfT(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Collections.IEnumerable" /> or <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind)">
              <doc>
                <summary>Returns true if the symbol is the specified kind.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2)">
              <doc>
                <summary>Returns true if the symbol is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3)">
              <doc>
                <summary>Returns true if the symbol is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4)">
              <doc>
                <summary>Returns true if the symbol is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4, SymbolKind kind5)">
              <doc>
                <summary>Returns true if the symbol is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, SpecialType specialType)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Nullable`1" /> and it has specified type argument.</summary>
              </doc>
            </member>
            <member def="public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, ITypeSymbol typeArgument)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Nullable`1" /> and it has specified type argument.</summary>
              </doc>
            </member>
            <member def="public static bool IsNullableOf(this ITypeSymbol typeSymbol, SpecialType specialType)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Nullable`1" /> and it has specified type argument.</summary>
              </doc>
            </member>
            <member def="public static bool IsNullableOf(this ITypeSymbol typeSymbol, ITypeSymbol typeArgument)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Nullable`1" /> and it has specified type argument.</summary>
              </doc>
            </member>
            <member def="public static bool IsNullableType(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the type is a nullable type.</summary>
              </doc>
            </member>
            <member def="public static bool IsObject(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Object" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsOrdinaryExtensionMethod(this IMethodSymbol methodSymbol)">
              <doc>
                <summary>Returns true if this method is an ordinary extension method (i.e. "this" parameter has not been removed).</summary>
              </doc>
            </member>
            <member def="public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType)">
              <doc>
                <summary>Returns true if the parameter was declared as a parameter array that has a specified element type.</summary>
              </doc>
            </member>
            <member def="public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2)">
              <doc>
                <summary>Returns true if the parameter was declared as a parameter array that has one of specified element types.</summary>
              </doc>
            </member>
            <member def="public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2, SpecialType elementType3)">
              <doc>
                <summary>Returns true if the parameter was declared as a parameter array that has one of specified element types.</summary>
              </doc>
            </member>
            <member def="public static bool IsPubliclyVisible(this ISymbol symbol)">
              <doc>
                <summary>Return true if the specified symbol is publicly visible.</summary>
              </doc>
            </member>
            <member def="public static bool IsReducedExtensionMethod(this IMethodSymbol methodSymbol)">
              <doc>
                <summary>Returns true if this method is a reduced extension method.</summary>
              </doc>
            </member>
            <member def="public static bool IsRefOrOut(this IParameterSymbol parameterSymbol)">
              <doc>
                <summary>Returns true if the parameter was declared as "ref" or "out" parameter.</summary>
              </doc>
            </member>
            <member def="public static bool IsReferenceTypeOrNullableType(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the type is a reference type or a nullable type.</summary>
              </doc>
            </member>
            <member def="public static bool IsString(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.String" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsVoid(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Void" />.</summary>
              </doc>
            </member>
            <member def="public static IMethodSymbol ReducedFromOrSelf(this IMethodSymbol methodSymbol)">
              <doc>
                <summary>If this method is a reduced extension method, returns the definition of extension method from which this was reduced. Otherwise, returns this symbol.</summary>
              </doc>
            </member>
            <member def="public static bool SupportsExplicitDeclaration(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the type can be declared explicitly in a source code.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class SyntaxExtensions">
          <doc>
            <summary>A set of extension method for a syntax.</summary>
          </doc>
          <members>
            <member def="public static bool All(this SyntaxTokenList list, Func&lt;SyntaxToken, bool&gt; predicate)">
              <doc>
                <summary>Returns true if all tokens in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" /> matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static bool All(this SyntaxTriviaList list, Func&lt;SyntaxTrivia, bool&gt; predicate)">
              <doc>
                <summary>Returns true if all trivia in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" /> matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static bool All&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, Func&lt;TNode, bool&gt; predicate) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if all nodes in a list matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static bool All&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, Func&lt;TNode, bool&gt; predicate) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if all nodes in a list matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static bool Any(this SyntaxTokenList list, Func&lt;SyntaxToken, bool&gt; predicate)">
              <doc>
                <summary>Returns true if any token in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" /> matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static bool Any(this SyntaxTriviaList list, Func&lt;SyntaxTrivia, bool&gt; predicate)">
              <doc>
                <summary>Returns true if any trivia in a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" /> matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static bool Any&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, Func&lt;TNode, bool&gt; predicate) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if any node in a list matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static bool Any&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, Func&lt;TNode, bool&gt; predicate) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if any node in a list matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia)">
              <doc>
                <summary>Creates a new token from this token with the leading trivia replaced with a new trivia where the specified trivia is added at the end of the leading trivia.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia)">
              <doc>
                <summary>Creates a new token from this token with the leading trivia replaced with a new trivia where the specified trivia is added at the end of the leading trivia.</summary>
              </doc>
            </member>
            <member def="public static TNode AppendToLeadingTrivia&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with the leading trivia replaced with a new trivia where the specified trivia is added at the end of the leading trivia.</summary>
              </doc>
            </member>
            <member def="public static TNode AppendToLeadingTrivia&lt;TNode&gt;(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with the leading trivia replaced with a new trivia where the specified trivia is added at the end of the leading trivia.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia)">
              <doc>
                <summary>Creates a new token from this token with the trailing trivia replaced with a new trivia where the specified trivia is added at the end of the trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia)">
              <doc>
                <summary>Creates a new token from this token with the trailing trivia replaced with a new trivia where the specified trivia is added at the end of the trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TNode AppendToTrailingTrivia&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with the trailing trivia replaced with a new trivia where the specified trivia is added at the end of the trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TNode AppendToTrailingTrivia&lt;TNode&gt;(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with the trailing trivia replaced with a new trivia where the specified trivia is added at the end of the trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool Contains(this SyntaxTokenList tokens, SyntaxToken token)">
              <doc>
                <summary>Returns true if the specified token is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
              </doc>
            </member>
            <member def="public static bool Contains&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if the specified node is in the <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static bool Contains&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if the specified node is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static bool ContainsDirectives(this SyntaxNode node, TextSpan span)">
              <doc>
                <summary>Returns true if the node contains any preprocessor directives inside the specified span.</summary>
              </doc>
            </member>
            <member def="public static IEnumerable&lt;SyntaxTrivia&gt; DescendantTrivia&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode">
              <doc>
                <summary>Get a list of all the trivia associated with the nodes in the list.</summary>
              </doc>
            </member>
            <member def="public static IEnumerable&lt;SyntaxTrivia&gt; DescendantTrivia&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode">
              <doc>
                <summary>Get a list of all the trivia associated with the nodes in the list.</summary>
              </doc>
            </member>
            <member def="public static TNode FirstAncestor&lt;TNode&gt;(this SyntaxNode node, Func&lt;TNode, bool&gt; predicate = null, bool ascendOutOfTrivia = true) where TNode : SyntaxNode">
              <doc>
                <summary>Returns the first node of type <typeparamref name="TNode" /> that matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static TNode FirstDescendant&lt;TNode&gt;(this SyntaxNode node, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode">
              <doc>
                <summary>Searches a list of descendant nodes in prefix document order and returns first descendant of type <typeparamref name="TNode" />.</summary>
              </doc>
            </member>
            <member def="public static TNode FirstDescendant&lt;TNode&gt;(this SyntaxNode node, TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode">
              <doc>
                <summary>Searches a list of descendant nodes in prefix document order and returns first descendant of type <typeparamref name="TNode" />.</summary>
              </doc>
            </member>
            <member def="public static TNode FirstDescendantOrSelf&lt;TNode&gt;(this SyntaxNode node, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode">
              <doc>
                <summary>Searches a list of descendant nodes (including this node) in prefix document order and returns first descendant of type <typeparamref name="TNode" />.</summary>
              </doc>
            </member>
            <member def="public static TNode FirstDescendantOrSelf&lt;TNode&gt;(this SyntaxNode node, TextSpan span, Func&lt;SyntaxNode, bool&gt; descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode">
              <doc>
                <summary>Searches a list of descendant nodes (including this node) in prefix document order and returns first descendant of type <typeparamref name="TNode" />.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTriviaList GetLeadingAndTrailingTrivia(this SyntaxNode node)">
              <doc>
                <summary>Returns leading and trailing trivia of the specified node in a single list.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken GetTrailingSeparator&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list) where TNode : SyntaxNode">
              <doc>
                <summary>Returns the trailing separator, if any.</summary>
              </doc>
            </member>
            <member def="public static bool HasTrailingSeparator&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if the specified list contains trailing separator.</summary>
              </doc>
            </member>
            <member def="public static int IndexOf(this SyntaxTokenList tokens, Func&lt;SyntaxToken, bool&gt; predicate)">
              <doc>
                <summary>Searches for a token that matches the predicate and returns the zero-based index of the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
              </doc>
            </member>
            <member def="public static int IndexOf(this SyntaxTriviaList triviaList, Func&lt;SyntaxTrivia, bool&gt; predicate)">
              <doc>
                <summary>Searches for a trivia that matches the predicate and returns the zero-based index of the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsFirst&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if the specified node is a first node in the list.</summary>
              </doc>
            </member>
            <member def="public static bool IsFirst&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if the specified node is a first node in the list.</summary>
              </doc>
            </member>
            <member def="public static bool IsLast&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if the specified node is a last node in the list.</summary>
              </doc>
            </member>
            <member def="public static bool IsLast&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if the specified node is a last node in the list.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTriviaList LeadingAndTrailingTrivia(this SyntaxToken token)">
              <doc>
                <summary>Returns leading and trailing trivia of the specified node in a single list.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia)">
              <doc>
                <summary>Creates a new token from this token with the leading trivia replaced with a new trivia where the specified trivia is inserted at the begining of the leading trivia.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia)">
              <doc>
                <summary>Creates a new token from this token with the leading trivia replaced with a new trivia where the specified trivia is inserted at the begining of the leading trivia.</summary>
              </doc>
            </member>
            <member def="public static TNode PrependToLeadingTrivia&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with the leading trivia replaced with a new trivia where the specified trivia is inserted at the begining of the leading trivia.</summary>
              </doc>
            </member>
            <member def="public static TNode PrependToLeadingTrivia&lt;TNode&gt;(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with the leading trivia replaced with a new trivia where the specified trivia is inserted at the begining of the leading trivia.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, IEnumerable&lt;SyntaxTrivia&gt; trivia)">
              <doc>
                <summary>Creates a new token from this token with the trailing trivia replaced with a new trivia where the specified trivia is inserted at the begining of the trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia)">
              <doc>
                <summary>Creates a new token from this token with the trailing trivia replaced with a new trivia where the specified trivia is inserted at the begining of the trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TNode PrependToTrailingTrivia&lt;TNode&gt;(this TNode node, IEnumerable&lt;SyntaxTrivia&gt; trivia) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with the trailing trivia replaced with a new trivia where the specified trivia is inserted at the begining of the trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TNode PrependToTrailingTrivia&lt;TNode&gt;(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with the trailing trivia replaced with a new trivia where the specified trivia is inserted at the begining of the trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList ReplaceAt(this SyntaxTokenList tokenList, int index, SyntaxToken newToken)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" /> with a token at the specified index replaced with a new token.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTriviaList ReplaceAt(this SyntaxTriviaList triviaList, int index, SyntaxTrivia newTrivia)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" /> with a trivia at the specified index replaced with new trivia.</summary>
              </doc>
            </member>
            <member def="public static SeparatedSyntaxList&lt;TNode&gt; ReplaceAt&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, int index, TNode newNode) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new list with a node at the specified index replaced with a new node.</summary>
              </doc>
            </member>
            <member def="public static SyntaxList&lt;TNode&gt; ReplaceAt&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, int index, TNode newNode) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new list with the node at the specified index replaced with a new node.</summary>
              </doc>
            </member>
            <member def="public static bool SpanContainsDirectives(this SyntaxNode node)">
              <doc>
                <summary>Returns true if the node's span contains any preprocessor directives.</summary>
              </doc>
            </member>
            <member def="public static bool TryGetContainingList(this SyntaxTrivia trivia, out SyntaxTriviaList triviaList, bool allowLeading = true, bool allowTrailing = true)">
              <doc>
                <summary>Gets a <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" /> the specified trivia is contained in.</summary>
                <param name="allowLeading">If true, trivia can be part of leading trivia.</param>
                <param name="allowTrailing">If true, trivia can be part of trailing trivia.</param>
              </doc>
            </member>
            <member def="public static SyntaxToken WithTriviaFrom(this SyntaxToken token, SyntaxNode node)">
              <doc>
                <summary>Creates a new token from this token with both the leading and trailing trivia of the specified node.</summary>
              </doc>
            </member>
            <member def="public static SeparatedSyntaxList&lt;TNode&gt; WithTriviaFrom&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxNode node) where TNode : SyntaxNode">
              <doc>
                <summary>
                Creates a new separated list with both leading and trailing trivia of the specified node.
                If the list contains more than one item, first item is updated with leading trivia and last item is updated with trailing trivia.
                </summary>
              </doc>
            </member>
            <member def="public static SyntaxList&lt;TNode&gt; WithTriviaFrom&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxNode node) where TNode : SyntaxNode">
              <doc>
                <summary>
                Creates a new list with both leading and trailing trivia of the specified node.
                If the list contains more than one item, first item is updated with leading trivia and last item is updated with trailing trivia.
                </summary>
              </doc>
            </member>
            <member def="public static TNode WithTriviaFrom&lt;TNode&gt;(this TNode node, SyntaxToken token) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node from this node with both the leading and trailing trivia of the specified token.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNodeOrToken WithoutLeadingTrivia(this SyntaxNodeOrToken nodeOrToken)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> with the leading trivia removed.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken WithoutLeadingTrivia(this SyntaxToken token)">
              <doc>
                <summary>Creates a new token from this token with the leading trivia removed.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNodeOrToken WithoutTrailingTrivia(this SyntaxNodeOrToken nodeOrToken)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> with the trailing trivia removed.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken WithoutTrailingTrivia(this SyntaxToken token)">
              <doc>
                <summary>Creates a new token from this token with the trailing trivia removed.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNodeOrToken WithoutTrivia(this SyntaxNodeOrToken nodeOrToken)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken" /> from this node without leading and trailing trivia.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public class SyntaxListSelection&lt;TNode&gt; : ISelection&lt;TNode&gt; where TNode : SyntaxNode">
          <doc>
            <summary>Represents selected nodes in a <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
          </doc>
          <members>
            <member def="protected SyntaxListSelection(SyntaxList&lt;TNode&gt; list, TextSpan span, int firstIndex, int lastIndex)">
              <doc>
                <summary>Initializes a new instance of the <see cref="T:Roslynator.SyntaxListSelection`1" />.</summary>
              </doc>
            </member>
            <member def="public int Count { get; }">
              <doc>
                <summary>Gets a number of selected nodes.</summary>
              </doc>
            </member>
            <member def="public int FirstIndex { get; }">
              <doc>
                <summary>Gets an index of the first selected node.</summary>
              </doc>
            </member>
            <member def="public int LastIndex { get; }">
              <doc>
                <summary>Gets an index of the last selected node.</summary>
              </doc>
            </member>
            <member def="public TextSpan OriginalSpan { get; }">
              <doc>
                <summary>Gets the original span that was used to determine selected nodes.</summary>
              </doc>
            </member>
            <member def="public SyntaxList&lt;TNode&gt; UnderlyingList { get; }">
              <doc>
                <summary>Gets an underlying list that contains selected nodes.</summary>
              </doc>
            </member>
            <member def="public TNode this[int index] { get; }">
              <doc>
                <summary>Gets the selected node at the specified index.</summary>
                <returns>The node at the specified index.</returns>
                <param name="index">The zero-based index of the node to get. </param>
              </doc>
            </member>
            <member def="public static SyntaxListSelection&lt;TNode&gt; Create(SyntaxList&lt;TNode&gt; list, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.SyntaxListSelection`1" /> based on the specified list and span.</summary>
              </doc>
            </member>
            <member def="public TNode First()">
              <doc>
                <summary>Gets the first selected node.</summary>
              </doc>
            </member>
            <member def="public SyntaxListSelection&lt;TNode&gt;.Enumerator GetEnumerator()">
              <doc>
                <summary>Returns an enumerator that iterates through selected nodes.</summary>
              </doc>
            </member>
            <member def="public TNode Last()">
              <doc>
                <summary>Gets the last selected node.</summary>
              </doc>
            </member>
            <member def="public static bool TryCreate(SyntaxList&lt;TNode&gt; list, TextSpan span, out SyntaxListSelection&lt;TNode&gt; selection)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.SyntaxListSelection`1" /> based on the specified list and span.</summary>
                <returns>True if the specified span contains at least one node; otherwise, false.</returns>
              </doc>
            </member>
          </members>
          <types>
            <type def="public struct Enumerator">
              <members>
                <member def="public TNode Current { get; }" />
                <member def="public override bool Equals(object obj)" />
                <member def="public override int GetHashCode()" />
                <member def="public bool MoveNext()" />
                <member def="public void Reset()" />
              </members>
            </type>
          </types>
        </type>
        <type def="public static class SyntaxTreeExtensions">
          <doc>
            <summary>A set of extension methods for <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" />.</summary>
          </doc>
          <members>
            <member def="public static int GetEndLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns zero-based index of the end line of the specified span.</summary>
              </doc>
            </member>
            <member def="public static int GetStartLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns zero-based index of the start line of the specified span.</summary>
              </doc>
            </member>
            <member def="public static bool IsMultiLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan" /> spans over multiple lines.</summary>
              </doc>
            </member>
            <member def="public static bool IsSingleLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan" /> does not span over multiple lines.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class WorkspaceExtensions">
          <doc>
            <summary>A set of extension methods for the workspace layer.</summary>
          </doc>
          <members>
            <member def="public static Task&lt;Document&gt; InsertNodeAfterAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with a new node inserted after the specified node.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; InsertNodeBeforeAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with a new node inserted before the specified node.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; InsertNodesAfterAsync(this Document document, SyntaxNode nodeInList, IEnumerable&lt;SyntaxNode&gt; newNodes, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with new nodes inserted after the specified node.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; InsertNodesBeforeAsync(this Document document, SyntaxNode nodeInList, IEnumerable&lt;SyntaxNode&gt; newNodes, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with new nodes inserted before the specified node.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; RemoveNodeAsync(this Document document, SyntaxNode node, SyntaxRemoveOptions options, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified node removed.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; RemoveNodesAsync(this Document document, IEnumerable&lt;SyntaxNode&gt; nodes, SyntaxRemoveOptions options, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified nodes removed.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; ReplaceNodeAsync(this Document document, SyntaxNode oldNode, SyntaxNode newNode, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified old node replaced with a new node.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; ReplaceNodeAsync(this Document document, SyntaxNode oldNode, IEnumerable&lt;SyntaxNode&gt; newNodes, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified old node replaced with new nodes.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Solution&gt; ReplaceNodeAsync&lt;TNode&gt;(this Solution solution, TNode oldNode, TNode newNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new solution with the specified old node replaced with a new node.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; ReplaceNodesAsync&lt;TNode&gt;(this Document document, IEnumerable&lt;TNode&gt; nodes, Func&lt;TNode, TNode, SyntaxNode&gt; computeReplacementNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new document with the specified old nodes replaced with new nodes.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Solution&gt; ReplaceNodesAsync&lt;TNode&gt;(this Solution solution, IEnumerable&lt;TNode&gt; nodes, Func&lt;TNode, TNode, SyntaxNode&gt; computeReplacementNodes, CancellationToken cancellationToken = default) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new solution with the specified old nodes replaced with new nodes.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; ReplaceTokenAsync(this Document document, SyntaxToken oldToken, SyntaxToken newToken, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified old token replaced with a new token.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; ReplaceTokenAsync(this Document document, SyntaxToken oldToken, IEnumerable&lt;SyntaxToken&gt; newTokens, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified old token replaced with new tokens.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified old trivia replaced with a new trivia.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, IEnumerable&lt;SyntaxTrivia&gt; newTrivia, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified old trivia replaced with a new trivia.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; WithTextChangeAsync(this Document document, TextChange textChange, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document updated with the specified text change.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; WithTextChangesAsync(this Document document, TextChange[] textChanges, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document updated with the specified text changes.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; WithTextChangesAsync(this Document document, IEnumerable&lt;TextChange&gt; textChanges, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document updated with the specified text changes.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public readonly struct ExtensionMethodSymbolInfo : IEquatable&lt;ExtensionMethodSymbolInfo&gt;">
          <doc>
            <summary>Represents an extension method symbol.</summary>
          </doc>
          <members>
            <member def="public bool IsReduced { get; }">
              <doc>
                <summary>True if the symbol was reduced.</summary>
              </doc>
            </member>
            <member def="public IMethodSymbol ReducedSymbol { get; }">
              <doc>
                <summary>The definition of extension method from which this symbol was reduced, or null, if the symbol was not reduced.</summary>
              </doc>
            </member>
            <member def="public IMethodSymbol ReducedSymbolOrSymbol { get; }">
              <doc>
                <summary>The reduced symbol or the symbol if the reduced symbol is null.</summary>
              </doc>
            </member>
            <member def="public IMethodSymbol Symbol { get; }">
              <doc>
                <summary>The extension method symbol.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)" />
            <member def="public bool Equals(ExtensionMethodSymbolInfo other)" />
            <member def="public override int GetHashCode()" />
            <member def="public static bool operator ==(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2)" />
            <member def="public static bool operator !=(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct MetadataName : IEquatable&lt;MetadataName&gt;">
          <doc>
            <summary>Represents fully qualified metadata name of a symbol.</summary>
          </doc>
          <members>
            <member def="public MetadataName(IEnumerable&lt;string&gt; containingNamespaces, string name)">
              <doc>
                <summary>Initializes a new instance of <see cref="T:Roslynator.MetadataName" />.</summary>
              </doc>
            </member>
            <member def="public MetadataName(ImmutableArray&lt;string&gt; containingNamespaces, string name)">
              <doc>
                <summary>Initializes a new instance of <see cref="T:Roslynator.MetadataName" />.</summary>
              </doc>
            </member>
            <member def="public MetadataName(IEnumerable&lt;string&gt; containingNamespaces, IEnumerable&lt;string&gt; containingTypes, string name)">
              <doc>
                <summary>Initializes a new instance of <see cref="T:Roslynator.MetadataName" />.</summary>
              </doc>
            </member>
            <member def="public MetadataName(ImmutableArray&lt;string&gt; containingNamespaces, ImmutableArray&lt;string&gt; containingTypes, string name)">
              <doc>
                <summary>Initializes a new instance of <see cref="T:Roslynator.MetadataName" />.</summary>
              </doc>
            </member>
            <member def="public ImmutableArray&lt;string&gt; ContainingNamespaces { get; }">
              <doc>
                <summary>Gets metadata names of containing namespaces</summary>
              </doc>
            </member>
            <member def="public ImmutableArray&lt;string&gt; ContainingTypes { get; }">
              <doc>
                <summary>Get metadata names of containing types.</summary>
              </doc>
            </member>
            <member def="public bool IsDefault { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual names.</summary>
              </doc>
            </member>
            <member def="public string Name { get; }">
              <doc>
                <summary>Get metadata name.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Indicates whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance.</param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(MetadataName other)">
              <doc>
                <summary>Indicates whether this instance and a specified <see cref="T:Roslynator.MetadataName" /> are equal.</summary>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public static MetadataName Parse(string name)">
              <doc>
                <summary>Converts the string representation of a fully qualified metadata name to its <see cref="T:Roslynator.MetadataName" /> equivalent.</summary>
                <exception cref="T:System.ArgumentNullException"><paramref name="name" /> is <c>null</c>.</exception>
                <exception cref="T:System.ArgumentException"><paramref name="name" /> is empty or invalid.</exception>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the fully qualified metadata name.</summary>
              </doc>
            </member>
            <member def="public static bool TryParse(string name, out MetadataName metadataName)">
              <doc>
                <summary>
                Converts the string representation of a fully qualified metadata name to its <see cref="T:Roslynator.MetadataName" /> equivalent.
                A return value indicates whether the parsing succeeded.
                </summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in MetadataName metadataName1, in MetadataName metadataName2)" />
            <member def="public static bool operator !=(in MetadataName metadataName1, in MetadataName metadataName2)" />
          </members>
        </type>
        <type def="public interface ISelection&lt;T&gt; : IReadOnlyList&lt;T&gt;">
          <doc>
            <summary>Represents consecutive sequence of selected items in a collection.</summary>
          </doc>
          <members>
            <member def="int FirstIndex { get; }">
              <doc>
                <summary>Gets an index of the first selected item.</summary>
              </doc>
            </member>
            <member def="int LastIndex { get; }">
              <doc>
                <summary>Gets an index of the last selected item.</summary>
              </doc>
            </member>
            <member def="T First()">
              <doc>
                <summary>Gets the first selected item.</summary>
              </doc>
            </member>
            <member def="T Last()">
              <doc>
                <summary>Gets the last selected item.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public enum Visibility">
          <doc>
            <summary>Specifies visibility of a symbol.</summary>
          </doc>
          <members>
            <member def="NotApplicable = 0">
              <doc>
                <summary>No visibility specified.</summary>
              </doc>
            </member>
            <member def="Private = 1">
              <doc>
                <summary>Symbol is privately visible.</summary>
              </doc>
            </member>
            <member def="Internal = 2">
              <doc>
                <summary>Symbol is internally visible.</summary>
              </doc>
            </member>
            <member def="Public = 3">
              <doc>
                <summary>Symbol is publicly visible.</summary>
              </doc>
            </member>
          </members>
        </type>
      </types>
    </namespace>
    <namespace name="Roslynator.CSharp">
      <types>
        <type def="public static class CSharpExtensions">
          <doc>
            <summary>A set of extension methods for a <see cref="T:Microsoft.CodeAnalysis.SemanticModel" />.</summary>
          </doc>
          <members>
            <member def="public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, ArgumentSyntax argument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default)">
              <doc>
                <summary>
                Determines a parameter symbol that matches to the specified argument.
                Returns null if no matching parameter is found.
                </summary>
              </doc>
            </member>
            <member def="public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, AttributeArgumentSyntax attributeArgument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default)">
              <doc>
                <summary>
                Determines a parameter symbol that matches to the specified attribute argument.
                Returns null if not matching parameter is found.
                </summary>
              </doc>
            </member>
            <member def="public static ExtensionMethodSymbolInfo GetExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what extension method symbol, if any, the specified expression syntax bound to.</summary>
              </doc>
            </member>
            <member def="public static IMethodSymbol GetMethodSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns method symbol, if any, the specified expression syntax bound to.</summary>
              </doc>
            </member>
            <member def="public static ExtensionMethodSymbolInfo GetReducedExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what extension method symbol, if any, the specified expression syntax bound to.</summary>
              </doc>
            </member>
            <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what symbol, if any, the specified attribute syntax bound to.</summary>
              </doc>
            </member>
            <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what symbol, if any, the specified constructor initializer syntax bound to.</summary>
              </doc>
            </member>
            <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, CrefSyntax cref, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what symbol, if any, the specified cref syntax bound to.</summary>
              </doc>
            </member>
            <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what symbol, if any, the specified expression syntax bound to.</summary>
              </doc>
            </member>
            <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, OrderingSyntax ordering, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what symbol, if any, the specified ordering syntax bound to.</summary>
              </doc>
            </member>
            <member def="public static ISymbol GetSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns what symbol, if any, the specified select or group clause bound to.</summary>
              </doc>
            </member>
            <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns type information about an attribute syntax.</summary>
              </doc>
            </member>
            <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns type information about a constructor initializer syntax.</summary>
              </doc>
            </member>
            <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns type information about an expression syntax.</summary>
              </doc>
            </member>
            <member def="public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns type information about a select or group clause.</summary>
              </doc>
            </member>
            <member def="public static bool HasConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns true if the specified node has a constant value.</summary>
              </doc>
            </member>
            <member def="public static bool IsDefaultValue(this SemanticModel semanticModel, ITypeSymbol typeSymbol, ExpressionSyntax expression, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns true if the specified expression represents default value of the specified type.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class CSharpFactory">
          <doc>
            <summary>A factory for syntax nodes, tokens and trivia. This class is built on top of <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxFactory" /> members.</summary>
          </doc>
          <members>
            <member def="public static AccessorListSyntax AccessorList(AccessorDeclarationSyntax accessor)" />
            <member def="public static AccessorListSyntax AccessorList(params AccessorDeclarationSyntax[] accessors)" />
            <member def="public static AccessorDeclarationSyntax AddAccessorDeclaration(BlockSyntax body)" />
            <member def="public static AccessorDeclarationSyntax AddAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)" />
            <member def="public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand)" />
            <member def="public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static ArgumentSyntax Argument(NameColonSyntax nameColon, ExpressionSyntax expression)" />
            <member def="public static ArgumentListSyntax ArgumentList(ArgumentSyntax argument)" />
            <member def="public static ArgumentListSyntax ArgumentList(params ArgumentSyntax[] arguments)" />
            <member def="public static InitializerExpressionSyntax ArrayInitializerExpression(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
            <member def="public static InitializerExpressionSyntax ArrayInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
            <member def="public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentSyntax argument)" />
            <member def="public static AttributeArgumentSyntax AttributeArgument(NameColonSyntax nameColon, ExpressionSyntax expression)" />
            <member def="public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, ExpressionSyntax expression)" />
            <member def="public static AttributeArgumentListSyntax AttributeArgumentList(AttributeArgumentSyntax attributeArgument)" />
            <member def="public static AttributeArgumentListSyntax AttributeArgumentList(params AttributeArgumentSyntax[] attributeArguments)" />
            <member def="public static AttributeListSyntax AttributeList(AttributeSyntax attribute)" />
            <member def="public static AttributeListSyntax AttributeList(params AttributeSyntax[] attributes)" />
            <member def="public static AccessorDeclarationSyntax AutoGetAccessorDeclaration(SyntaxTokenList modifiers = default)" />
            <member def="public static AccessorDeclarationSyntax AutoSetAccessorDeclaration(SyntaxTokenList modifiers = default)" />
            <member def="public static ConstructorInitializerSyntax BaseConstructorInitializer(ArgumentListSyntax argumentList = null)" />
            <member def="public static ConstructorInitializerSyntax BaseConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList)" />
            <member def="public static BaseListSyntax BaseList(BaseTypeSyntax type)" />
            <member def="public static BaseListSyntax BaseList(params BaseTypeSyntax[] types)" />
            <member def="public static BaseListSyntax BaseList(SyntaxToken colonToken, BaseTypeSyntax baseType)" />
            <member def="public static BaseListSyntax BaseList(SyntaxToken colonToken, params BaseTypeSyntax[] types)" />
            <member def="public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand)" />
            <member def="public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BlockSyntax Block(StatementSyntax statement)" />
            <member def="public static BlockSyntax Block(SyntaxToken openBrace, StatementSyntax statement, SyntaxToken closeBrace)" />
            <member def="public static LiteralExpressionSyntax BooleanLiteralExpression(bool value)" />
            <member def="public static BracketedArgumentListSyntax BracketedArgumentList(ArgumentSyntax argument)" />
            <member def="public static BracketedArgumentListSyntax BracketedArgumentList(params ArgumentSyntax[] arguments)" />
            <member def="public static BracketedParameterListSyntax BracketedParameterList(ParameterSyntax parameter)" />
            <member def="public static BracketedParameterListSyntax BracketedParameterList(params ParameterSyntax[] parameters)" />
            <member def="public static LiteralExpressionSyntax CharacterLiteralExpression(char value)" />
            <member def="public static CheckedExpressionSyntax CheckedExpression(ExpressionSyntax expression)" />
            <member def="public static CheckedExpressionSyntax CheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
            <member def="public static ClassOrStructConstraintSyntax ClassConstraint()" />
            <member def="public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
            <member def="public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
            <member def="public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static InitializerExpressionSyntax CollectionInitializerExpression(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
            <member def="public static InitializerExpressionSyntax CollectionInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
            <member def="public static CompilationUnitSyntax CompilationUnit(MemberDeclarationSyntax member)" />
            <member def="public static CompilationUnitSyntax CompilationUnit(SyntaxList&lt;UsingDirectiveSyntax&gt; usings, MemberDeclarationSyntax member)" />
            <member def="public static CompilationUnitSyntax CompilationUnit(SyntaxList&lt;UsingDirectiveSyntax&gt; usings, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
            <member def="public static InitializerExpressionSyntax ComplexElementInitializerExpression(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
            <member def="public static InitializerExpressionSyntax ComplexElementInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
            <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)" />
            <member def="public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static LiteralExpressionSyntax DefaultLiteralExpression()" />
            <member def="public static SwitchSectionSyntax DefaultSwitchSection(StatementSyntax statement)" />
            <member def="public static SwitchSectionSyntax DefaultSwitchSection(SyntaxList&lt;StatementSyntax&gt; statements)" />
            <member def="public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, string identifier, ParameterListSyntax parameterList)" />
            <member def="public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList)" />
            <member def="public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static SyntaxTrivia EmptyWhitespace()" />
            <member def="public static EnumDeclarationSyntax EnumDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SeparatedSyntaxList&lt;EnumMemberDeclarationSyntax&gt; members)" />
            <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, ExpressionSyntax value)" />
            <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, EqualsValueClauseSyntax value)" />
            <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, ExpressionSyntax value)" />
            <member def="public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, EqualsValueClauseSyntax value)" />
            <member def="public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, AccessorListSyntax accessorList)" />
            <member def="public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList)" />
            <member def="public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier)" />
            <member def="public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier)" />
            <member def="public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body)" />
            <member def="public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static LiteralExpressionSyntax FalseLiteralExpression()" />
            <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer)" />
            <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)" />
            <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, ExpressionSyntax value = null)" />
            <member def="public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)" />
            <member def="public static GenericNameSyntax GenericName(string identifier, TypeSyntax typeArgument)" />
            <member def="public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeSyntax typeArgument)" />
            <member def="public static AccessorDeclarationSyntax GetAccessorDeclaration(BlockSyntax body)" />
            <member def="public static AccessorDeclarationSyntax GetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)" />
            <member def="public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body)" />
            <member def="public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList)" />
            <member def="public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
            <member def="public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
            <member def="public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static LiteralExpressionSyntax LiteralExpression(object value)" />
            <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer)" />
            <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)" />
            <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, ExpressionSyntax value = null)" />
            <member def="public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)" />
            <member def="public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)" />
            <member def="public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand)" />
            <member def="public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body)" />
            <member def="public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static InvocationExpressionSyntax NameOfExpression(ExpressionSyntax expression)" />
            <member def="public static InvocationExpressionSyntax NameOfExpression(string identifier)" />
            <member def="public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, MemberDeclarationSyntax member)" />
            <member def="public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList&lt;MemberDeclarationSyntax&gt; members)" />
            <member def="public static SyntaxTrivia NewLine()" />
            <member def="public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static LiteralExpressionSyntax NullLiteralExpression()" />
            <member def="public static LiteralExpressionSyntax NumericLiteralExpression(int value)" />
            <member def="public static LiteralExpressionSyntax NumericLiteralExpression(uint value)" />
            <member def="public static LiteralExpressionSyntax NumericLiteralExpression(sbyte value)" />
            <member def="public static LiteralExpressionSyntax NumericLiteralExpression(decimal value)" />
            <member def="public static LiteralExpressionSyntax NumericLiteralExpression(double value)" />
            <member def="public static LiteralExpressionSyntax NumericLiteralExpression(float value)" />
            <member def="public static LiteralExpressionSyntax NumericLiteralExpression(long value)" />
            <member def="public static LiteralExpressionSyntax NumericLiteralExpression(ulong value)" />
            <member def="public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList)" />
            <member def="public static InitializerExpressionSyntax ObjectInitializerExpression(SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions = default)" />
            <member def="public static InitializerExpressionSyntax ObjectInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList&lt;ExpressionSyntax&gt; expressions, SyntaxToken closeBraceToken)" />
            <member def="public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body)" />
            <member def="public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static ParameterSyntax Parameter(TypeSyntax type, string identifier, ExpressionSyntax @default = null)" />
            <member def="public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax @default = null)" />
            <member def="public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)" />
            <member def="public static ParameterListSyntax ParameterList(ParameterSyntax parameter)" />
            <member def="public static ParameterListSyntax ParameterList(params ParameterSyntax[] parameters)" />
            <member def="public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand)" />
            <member def="public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand)" />
            <member def="public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand)" />
            <member def="public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand)" />
            <member def="public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand)" />
            <member def="public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static PredefinedTypeSyntax PredefinedBoolType()" />
            <member def="public static PredefinedTypeSyntax PredefinedByteType()" />
            <member def="public static PredefinedTypeSyntax PredefinedCharType()" />
            <member def="public static PredefinedTypeSyntax PredefinedDecimalType()" />
            <member def="public static PredefinedTypeSyntax PredefinedDoubleType()" />
            <member def="public static PredefinedTypeSyntax PredefinedFloatType()" />
            <member def="public static PredefinedTypeSyntax PredefinedIntType()" />
            <member def="public static PredefinedTypeSyntax PredefinedLongType()" />
            <member def="public static PredefinedTypeSyntax PredefinedObjectType()" />
            <member def="public static PredefinedTypeSyntax PredefinedSByteType()" />
            <member def="public static PredefinedTypeSyntax PredefinedShortType()" />
            <member def="public static PredefinedTypeSyntax PredefinedStringType()" />
            <member def="public static PredefinedTypeSyntax PredefinedUIntType()" />
            <member def="public static PredefinedTypeSyntax PredefinedULongType()" />
            <member def="public static PredefinedTypeSyntax PredefinedUShortType()" />
            <member def="public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList, ExpressionSyntax value = null)" />
            <member def="public static AccessorDeclarationSyntax RemoveAccessorDeclaration(BlockSyntax body)" />
            <member def="public static AccessorDeclarationSyntax RemoveAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)" />
            <member def="public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static AccessorDeclarationSyntax SetAccessorDeclaration(BlockSyntax body)" />
            <member def="public static AccessorDeclarationSyntax SetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body)" />
            <member def="public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody)" />
            <member def="public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SimpleNameSyntax name)" />
            <member def="public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)" />
            <member def="public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name)" />
            <member def="public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentSyntax argument)" />
            <member def="public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentListSyntax argumentList)" />
            <member def="public static LiteralExpressionSyntax StringLiteralExpression(string value)" />
            <member def="public static ClassOrStructConstraintSyntax StructConstraint()" />
            <member def="public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
            <member def="public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList&lt;MemberDeclarationSyntax&gt; members = default)" />
            <member def="public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, ExpressionSyntax right)" />
            <member def="public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)" />
            <member def="public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, StatementSyntax statement)" />
            <member def="public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, SyntaxList&lt;StatementSyntax&gt; statements)" />
            <member def="public static SwitchSectionSyntax SwitchSection(SyntaxList&lt;SwitchLabelSyntax&gt; switchLabels, StatementSyntax statement)" />
            <member def="public static ConstructorInitializerSyntax ThisConstructorInitializer(ArgumentListSyntax argumentList = null)" />
            <member def="public static ConstructorInitializerSyntax ThisConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList)" />
            <member def="public static SyntaxTokenList TokenList(Accessibility accessibility)">
              <doc>
                <summary>Creates a list of modifiers from the specified accessibility.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList TokenList(SyntaxKind kind)" />
            <member def="public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2)" />
            <member def="public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)" />
            <member def="public static LiteralExpressionSyntax TrueLiteralExpression()" />
            <member def="public static TryStatementSyntax TryStatement(BlockSyntax block, CatchClauseSyntax @catch, FinallyClauseSyntax @finally = null)" />
            <member def="public static TypeArgumentListSyntax TypeArgumentList(TypeSyntax argument)" />
            <member def="public static TypeArgumentListSyntax TypeArgumentList(params TypeSyntax[] arguments)" />
            <member def="public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax identifierName, TypeParameterConstraintSyntax typeParameterConstraint)" />
            <member def="public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name, TypeParameterConstraintSyntax typeParameterConstraint)" />
            <member def="public static TypeParameterListSyntax TypeParameterList(TypeParameterSyntax parameter)" />
            <member def="public static TypeParameterListSyntax TypeParameterList(params TypeParameterSyntax[] parameters)" />
            <member def="public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand)" />
            <member def="public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand)" />
            <member def="public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand, SyntaxToken operatorToken)" />
            <member def="public static CheckedExpressionSyntax UncheckedExpression(ExpressionSyntax expression)" />
            <member def="public static CheckedExpressionSyntax UncheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)" />
            <member def="public static UsingDirectiveSyntax UsingStaticDirective(NameSyntax name)" />
            <member def="public static UsingDirectiveSyntax UsingStaticDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameSyntax name, SyntaxToken semicolonToken)" />
            <member def="public static IdentifierNameSyntax VarType()" />
            <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, VariableDeclaratorSyntax variable)" />
            <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer)" />
            <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, string identifier, ExpressionSyntax value = null)" />
            <member def="public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null)" />
            <member def="public static VariableDeclaratorSyntax VariableDeclarator(string identifier, EqualsValueClauseSyntax initializer)" />
            <member def="public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, EqualsValueClauseSyntax initializer)" />
            <member def="public static PredefinedTypeSyntax VoidType()" />
            <member def="public static YieldStatementSyntax YieldBreakStatement()" />
            <member def="public static YieldStatementSyntax YieldReturnStatement(ExpressionSyntax expression)" />
          </members>
        </type>
        <type def="public static class CSharpFacts">
          <members>
            <member def="public static bool CanBeEmbeddedStatement(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind can be an embedded statement.</summary>
              </doc>
            </member>
            <member def="public static bool CanHaveEmbeddedStatement(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind can have an embedded statement.</summary>
              </doc>
            </member>
            <member def="public static bool CanHaveExpressionBody(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind can have expression body.</summary>
              </doc>
            </member>
            <member def="public static bool CanHaveMembers(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind can have members.</summary>
              </doc>
            </member>
            <member def="public static bool CanHaveModifiers(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind can have modifiers.</summary>
              </doc>
            </member>
            <member def="public static bool CanHaveStatements(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind can have statements. It can be either <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" /> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsAnonymousFunctionExpression(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is an anonymous method or lambda expression.</summary>
              </doc>
            </member>
            <member def="public static bool IsBooleanExpression(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a boolean expression.</summary>
              </doc>
            </member>
            <member def="public static bool IsBooleanLiteralExpression(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is true or false literal expression.</summary>
              </doc>
            </member>
            <member def="public static bool IsCommentTrivia(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is comment trivia.</summary>
              </doc>
            </member>
            <member def="public static bool IsCompoundAssignmentExpression(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a compound assignment expression.</summary>
              </doc>
            </member>
            <member def="public static bool IsConstraint(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a constraint.</summary>
              </doc>
            </member>
            <member def="public static bool IsFunction(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind if local function or anonymous function.</summary>
              </doc>
            </member>
            <member def="public static bool IsIfElseDirective(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is #if, #else, #elif or #endif directive.</summary>
              </doc>
            </member>
            <member def="public static bool IsIncrementOrDecrementExpression(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is pre/post increment/decrement expression.</summary>
              </doc>
            </member>
            <member def="public static bool IsIterationStatement(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a for, foreach, while or do statement.</summary>
              </doc>
            </member>
            <member def="public static bool IsJumpStatement(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a jump statement.</summary>
              </doc>
            </member>
            <member def="public static bool IsLambdaExpression(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a lambda expression.</summary>
              </doc>
            </member>
            <member def="public static bool IsLiteralExpression(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a literal expression.</summary>
              </doc>
            </member>
            <member def="public static bool IsPredefinedType(SpecialType specialType)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a predefined type.</summary>
              </doc>
            </member>
            <member def="public static bool IsSimpleType(SpecialType specialType)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a simple type.</summary>
              </doc>
            </member>
            <member def="public static bool IsSwitchLabel(SyntaxKind kind)">
              <doc>
                <summary>Returns true if a syntax of the specified kind is a switch label.</summary>
              </doc>
            </member>
            <member def="public static bool SupportsPrefixOrPostfixUnaryOperator(SpecialType specialType)">
              <doc>
                <summary>Returns true if an expression of the specified type can be used in a prefix or postfix unary operator.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class EnumExtensions">
          <doc>
            <summary>A set of extension methods for enumerations.</summary>
          </doc>
          <members>
            <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2)">
              <doc>
                <summary>Returns true if the kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)">
              <doc>
                <summary>Returns true if the kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)">
              <doc>
                <summary>Returns true if the kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)">
              <doc>
                <summary>Returns true if the kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)">
              <doc>
                <summary>Returns true if the kind is one of the specified kinds.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public sealed class MemberDeclarationListSelection : SyntaxListSelection&lt;MemberDeclarationSyntax&gt;">
          <doc>
            <summary>Represents selected member declarations in a <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
          </doc>
          <members>
            <member def="public SyntaxNode Parent { get; }">
              <doc>
                <summary>Gets a node that contains selected members.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListSelection Create(CompilationUnitSyntax compilationUnit, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified compilation unit and span.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListSelection Create(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified namespace declaration and span.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListSelection Create(TypeDeclarationSyntax typeDeclaration, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified type declaration and span.</summary>
              </doc>
            </member>
            <member def="public static bool TryCreate(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified namespace declaration and span.</summary>
                <returns>True if the specified span contains at least one member; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public static bool TryCreate(TypeDeclarationSyntax typeDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.MemberDeclarationListSelection" /> based on the specified type declaration and span.</summary>
                <returns>True if the specified span contains at least one member; otherwise, false.</returns>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class ModifierList">
          <doc>
            <summary>A set of static methods that allows manipulation with modifiers.</summary>
          </doc>
          <members>
            <member def="public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxKind kind, IComparer&lt;SyntaxKind&gt; comparer = null)">
              <doc>
                <summary>Returns an index a token with the specified kind should be inserted at.</summary>
              </doc>
            </member>
            <member def="public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxToken token, IComparer&lt;SyntaxToken&gt; comparer = null)">
              <doc>
                <summary>Returns an index the specified token should be inserted at.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxKind kind, IComparer&lt;SyntaxKind&gt; comparer = null)">
              <doc>
                <summary>Creates a new list of modifiers with the modifier of the specified kind inserted.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxToken modifier, IComparer&lt;SyntaxToken&gt; comparer = null)">
              <doc>
                <summary>Creates a new list of modifiers with a specified modifier inserted.</summary>
              </doc>
            </member>
            <member def="public static TNode Insert&lt;TNode&gt;(TNode node, SyntaxKind kind, IComparer&lt;SyntaxKind&gt; comparer = null) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with a modifier of the specified kind inserted.</summary>
              </doc>
            </member>
            <member def="public static TNode Insert&lt;TNode&gt;(TNode node, SyntaxToken modifier, IComparer&lt;SyntaxToken&gt; comparer = null) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the specified modifier inserted.</summary>
              </doc>
            </member>
            <member def="public static TNode Remove&lt;TNode&gt;(TNode node, SyntaxKind kind) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with a modifier of the specified kind removed.</summary>
              </doc>
            </member>
            <member def="public static TNode Remove&lt;TNode&gt;(TNode node, SyntaxToken modifier) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the specified modifier removed.</summary>
              </doc>
            </member>
            <member def="public static TNode RemoveAll&lt;TNode&gt;(TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with all modifiers removed.</summary>
              </doc>
            </member>
            <member def="public static TNode RemoveAll&lt;TNode&gt;(TNode node, Func&lt;SyntaxToken, bool&gt; predicate) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with modifiers that matches the predicate removed.</summary>
              </doc>
            </member>
            <member def="public static TNode RemoveAt&lt;TNode&gt;(TNode node, int index) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with a modifier at the specified index removed.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public abstract class ModifierList&lt;TNode&gt; where TNode : SyntaxNode">
          <doc>
            <summary>Represents a list of modifiers.</summary>
          </doc>
          <members>
            <member def="public static ModifierList&lt;TNode&gt; Instance { get; }">
              <doc>
                <summary>Gets an instance of the <see cref="T:Roslynator.CSharp.ModifierList`1" /> for a syntax specified by the generic argument.</summary>
              </doc>
            </member>
            <member def="public TNode Insert(TNode node, SyntaxKind kind, IComparer&lt;SyntaxKind&gt; comparer = null)">
              <doc>
                <summary>Creates a new node with a modifier of the specified kind inserted.</summary>
              </doc>
            </member>
            <member def="public TNode Insert(TNode node, SyntaxToken modifier, IComparer&lt;SyntaxToken&gt; comparer = null)">
              <doc>
                <summary>Creates a new node with the specified modifier inserted.</summary>
              </doc>
            </member>
            <member def="public TNode Remove(TNode node, SyntaxKind kind)">
              <doc>
                <summary>Creates a new node with a modifier of the specified kind removed.</summary>
              </doc>
            </member>
            <member def="public TNode Remove(TNode node, SyntaxToken modifier)">
              <doc>
                <summary>Creates a new node with the specified modifier removed.</summary>
              </doc>
            </member>
            <member def="public TNode RemoveAll(TNode node)">
              <doc>
                <summary>Creates a new node with all modifiers removed.</summary>
              </doc>
            </member>
            <member def="public TNode RemoveAll(TNode node, Func&lt;SyntaxToken, bool&gt; predicate)">
              <doc>
                <summary>Creates a new node with modifiers that matches the predicate removed.</summary>
              </doc>
            </member>
            <member def="public TNode RemoveAt(TNode node, int index)">
              <doc>
                <summary>Creates a new node with a modifier at the specified index removed.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class Modifiers">
          <doc>
            <summary>Serves as a factory for a modifier list.</summary>
          </doc>
          <members>
            <member def="public static SyntaxTokenList Const()">
              <doc>
                <summary>Creates a list of modifiers that contains "const" modifier.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal" modifier.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_Abstract()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal abstract" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_Const()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal const" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_Override()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal override" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_Partial()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal partial" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_Static()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal static" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_Static_Partial()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal static partial" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_Static_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal static readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Internal_Virtual()">
              <doc>
                <summary>Creates a list of modifiers that contains "internal virtual" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Partial()">
              <doc>
                <summary>Creates a list of modifiers that contains "partial" modifier.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Private()">
              <doc>
                <summary>Creates a list of modifiers that contains "private" modifier.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Private_Const()">
              <doc>
                <summary>Creates a list of modifiers that contains "private const" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Private_Partial()">
              <doc>
                <summary>Creates a list of modifiers that contains "private partial" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Private_Protected()">
              <doc>
                <summary>Creates a list of modifiers that contains "private protected" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Private_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "private readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Private_Static()">
              <doc>
                <summary>Creates a list of modifiers that contains "private static" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Private_Static_Partial()">
              <doc>
                <summary>Creates a list of modifiers that contains "private static partial" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Private_Static_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "private static readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected()">
              <doc>
                <summary>Creates a list of modifiers that contains "protected" modifier.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected_Abstract()">
              <doc>
                <summary>Creates a list of modifiers that contains "protected abstract" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected_Const()">
              <doc>
                <summary>Creates a list of modifiers that contains "protected const" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected_Internal()">
              <doc>
                <summary>Return modifier list that contains "protected internal" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected_Override()">
              <doc>
                <summary>Creates a list of modifiers that contains "protected override" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "protected readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected_Static()">
              <doc>
                <summary>Creates a list of modifiers that contains "protected static" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected_Static_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "protected static readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Protected_Virtual()">
              <doc>
                <summary>Creates a list of modifiers that contains "protected virtual" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public()">
              <doc>
                <summary>Creates a list of modifiers that contains "public" modifier.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_Abstract()">
              <doc>
                <summary>Creates a list of modifiers that contains "public abstract" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_Const()">
              <doc>
                <summary>Creates a list of modifiers that contains "public const" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_Override()">
              <doc>
                <summary>Creates a list of modifiers that contains "public override" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_Partial()">
              <doc>
                <summary>Creates a list of modifiers that contains "public partial" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "public readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_Static()">
              <doc>
                <summary>Creates a list of modifiers that contains "public static" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_Static_Partial()">
              <doc>
                <summary>Creates a list of modifiers that contains "public static partial" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_Static_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "public static readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Public_Virtual()">
              <doc>
                <summary>Creates a list of modifiers that contains "public virtual" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "readonly" modifier.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Ref_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "ref readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Static()">
              <doc>
                <summary>Creates a list of modifiers that contains "static" modifier.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Static_ReadOnly()">
              <doc>
                <summary>Creates a list of modifiers that contains "static readonly" modifiers.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList Virtual()">
              <doc>
                <summary>Creates a list of modifiers that contains "virtual" modifier.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public sealed class StatementListSelection : SyntaxListSelection&lt;StatementSyntax&gt;">
          <doc>
            <summary>Represents selected statements in a <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
          </doc>
          <members>
            <member def="public static StatementListSelection Create(BlockSyntax block, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified block and span.</summary>
              </doc>
            </member>
            <member def="public static StatementListSelection Create(SwitchSectionSyntax switchSection, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified switch section and span.</summary>
              </doc>
            </member>
            <member def="public static StatementListSelection Create(in StatementListInfo statementsInfo, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> and span.</summary>
              </doc>
            </member>
            <member def="public static bool TryCreate(BlockSyntax block, TextSpan span, out StatementListSelection selectedStatements)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified block and span.</summary>
                <returns>True if the specified span contains at least one statement; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public static bool TryCreate(SwitchSectionSyntax switchSection, TextSpan span, out StatementListSelection selectedStatements)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.StatementListSelection" /> based on the specified switch section and span.</summary>
                <returns>True if the specified span contains at least one statement; otherwise, false.</returns>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class SymbolExtensions">
          <doc>
            <summary>A set of static methods for <see cref="T:Microsoft.CodeAnalysis.ISymbol" /> and derived types.</summary>
          </doc>
          <members>
            <member def="public static bool SupportsConstantValue(this ITypeSymbol typeSymbol)">
              <doc>
                <summary>Returns true if the specified type can be used to declare constant value.</summary>
              </doc>
            </member>
            <member def="public static TypeSyntax ToMinimalTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified namespace or type symbol</summary>
              </doc>
            </member>
            <member def="public static TypeSyntax ToMinimalTypeSyntax(this INamespaceSymbol namespaceSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified namespace symbol.</summary>
              </doc>
            </member>
            <member def="public static TypeSyntax ToMinimalTypeSyntax(this ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified type symbol.</summary>
              </doc>
            </member>
            <member def="public static TypeSyntax ToTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SymbolDisplayFormat format = null)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified namespace or type symbol.</summary>
              </doc>
            </member>
            <member def="public static TypeSyntax ToTypeSyntax(this INamespaceSymbol namespaceSymbol, SymbolDisplayFormat format = null)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified namespace symbol.</summary>
              </doc>
            </member>
            <member def="public static TypeSyntax ToTypeSyntax(this ITypeSymbol typeSymbol, SymbolDisplayFormat format = null)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax" /> based on the specified type symbol.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class SyntaxAccessibility">
          <doc>
            <summary>A set of static methods that are related to C# accessibility.</summary>
          </doc>
          <members>
            <member def="public static Accessibility GetAccessibility(SyntaxNode declaration)">
              <doc>
                <summary>Returns an accessibility of the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static Accessibility GetDefaultAccessibility(SyntaxNode declaration)">
              <doc>
                <summary>Returns a default accessibility of the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static Accessibility GetDefaultExplicitAccessibility(SyntaxNode declaration)">
              <doc>
                <summary>Returns a default explicit accessibility of the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static Accessibility GetExplicitAccessibility(SyntaxNode declaration)">
              <doc>
                <summary>Returns an explicit accessibility of the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static Accessibility GetExplicitAccessibility(SyntaxTokenList modifiers)">
              <doc>
                <summary>Returns an explicit accessibility of the specified modifiers.</summary>
              </doc>
            </member>
            <member def="public static bool IsPubliclyVisible(MemberDeclarationSyntax declaration)">
              <doc>
                <summary>Return true if the specified declaration is publicly visible.</summary>
              </doc>
            </member>
            <member def="public static bool IsValidAccessibility(SyntaxNode node, Accessibility accessibility, bool ignoreOverride = false)">
              <doc>
                <summary>Returns true if the node can have specified accessibility.</summary>
                <param name="ignoreOverride">Ignore "override" modifier.</param>
              </doc>
            </member>
            <member def="public static TNode WithExplicitAccessibility&lt;TNode&gt;(TNode node, Accessibility newAccessibility, IComparer&lt;SyntaxKind&gt; comparer = null) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the specified explicit accessibility updated.</summary>
              </doc>
            </member>
            <member def="public static TNode WithoutExplicitAccessibility&lt;TNode&gt;(TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the explicit accessibility removed.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class SyntaxExtensions">
          <doc>
            <summary>A set of extension methods for syntax (types derived from <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode" />).</summary>
          </doc>
          <members>
            <member def="public static SyntaxList&lt;StatementSyntax&gt; Add(this SyntaxList&lt;StatementSyntax&gt; statements, StatementSyntax statement, bool ignoreLocalFunctions)">
              <doc>
                <summary>Creates a new list with the specified node added or inserted.</summary>
                <param name="ignoreLocalFunctions">Insert statement before local function statements at the end of the list.</param>
              </doc>
            </member>
            <member def="public static ClassDeclarationSyntax AddAttributeLists(this ClassDeclarationSyntax classDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)">
              <doc>
                <summary>Creates a new class declaration with the specified attribute lists added.</summary>
                <param name="keepDocumentationCommentOnTop">If the declaration has no attribute lists and has a documentation comment the specified attribute lists will be inserted after the documentation comment.</param>
              </doc>
              <attributes>
                <attribute>Obsolete("This method is obsolete.")</attribute>
              </attributes>
            </member>
            <member def="public static InterfaceDeclarationSyntax AddAttributeLists(this InterfaceDeclarationSyntax interfaceDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)">
              <doc>
                <summary>Creates a new interface declaration with the specified attribute lists added.</summary>
                <param name="keepDocumentationCommentOnTop">If the declaration has no attribute lists and has a documentation comment the specified attribute lists will be inserted after the documentation comment.</param>
              </doc>
              <attributes>
                <attribute>Obsolete("This method is obsolete.")</attribute>
              </attributes>
            </member>
            <member def="public static StructDeclarationSyntax AddAttributeLists(this StructDeclarationSyntax structDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists)">
              <doc>
                <summary>Creates a new struct declaration with the specified attribute lists added.</summary>
                <param name="keepDocumentationCommentOnTop">If the declaration has no attribute lists and has a documentation comment the specified attribute lists will be inserted after the documentation comment.</param>
              </doc>
              <attributes>
                <attribute>Obsolete("This method is obsolete.")</attribute>
              </attributes>
            </member>
            <member def="public static CompilationUnitSyntax AddUsings(this CompilationUnitSyntax compilationUnit, bool keepSingleLineCommentsOnTop, params UsingDirectiveSyntax[] usings)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax" /> with the specified using directives added.</summary>
              </doc>
            </member>
            <member def="public static IfStatementCascade AsCascade(this IfStatementSyntax ifStatement)">
              <doc>
                <summary>Returns <see cref="T:Roslynator.CSharp.IfStatementCascade" /> that enables to enumerate if-else cascade.</summary>
              </doc>
            </member>
            <member def="public static ExpressionChain AsChain(this BinaryExpressionSyntax binaryExpression, TextSpan? span = null)">
              <doc>
                <summary>Returns <see cref="T:Roslynator.CSharp.ExpressionChain" /> that enables to enumerate expressions of a binary expression.</summary>
              </doc>
            </member>
            <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this AccessorDeclarationSyntax accessorDeclaration)">
              <doc>
                <summary>Returns accessor body or an expression body if the body is null.</summary>
              </doc>
            </member>
            <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this ConstructorDeclarationSyntax constructorDeclaration)">
              <doc>
                <summary>Returns constructor body or an expression body if the body is null.</summary>
              </doc>
            </member>
            <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this ConversionOperatorDeclarationSyntax conversionOperatorDeclaration)">
              <doc>
                <summary>Returns conversion operator body or an expression body if the body is null.</summary>
              </doc>
            </member>
            <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this DestructorDeclarationSyntax destructorDeclaration)">
              <doc>
                <summary>Returns destructor body or an expression body if the body is null.</summary>
              </doc>
            </member>
            <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this LocalFunctionStatementSyntax localFunctionStatement)">
              <doc>
                <summary>Returns local function body or an expression body if the body is null.</summary>
              </doc>
            </member>
            <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this MethodDeclarationSyntax methodDeclaration)">
              <doc>
                <summary>Returns method body or an expression body if the body is null.</summary>
              </doc>
            </member>
            <member def="public static CSharpSyntaxNode BodyOrExpressionBody(this OperatorDeclarationSyntax operatorDeclaration)">
              <doc>
                <summary>Returns operator body or an expression body if the body is null.</summary>
              </doc>
            </member>
            <member def="public static TextSpan BracesSpan(this ClassDeclarationSyntax classDeclaration)">
              <doc>
                <summary>The absolute span of the braces, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TextSpan BracesSpan(this EnumDeclarationSyntax enumDeclaration)">
              <doc>
                <summary>The absolute span of the braces, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TextSpan BracesSpan(this InterfaceDeclarationSyntax interfaceDeclaration)">
              <doc>
                <summary>The absolute span of the braces, not including it leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TextSpan BracesSpan(this NamespaceDeclarationSyntax namespaceDeclaration)">
              <doc>
                <summary>The absolute span of the braces, not including leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TextSpan BracesSpan(this StructDeclarationSyntax structDeclaration)">
              <doc>
                <summary>The absolute span of the braces, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool Contains(this SyntaxTokenList tokenList, SyntaxKind kind)">
              <doc>
                <summary>Returns true if a token of the specified kind is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
              </doc>
            </member>
            <member def="public static bool Contains(this SyntaxTriviaList triviaList, SyntaxKind kind)">
              <doc>
                <summary>Returns true if a trivia of the specified kind is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />.</summary>
              </doc>
            </member>
            <member def="public static bool Contains&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode">
              <doc>
                <summary>Searches for a node of the specified kind and returns the zero-based index of the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static bool Contains&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode">
              <doc>
                <summary>Returns true if a node of the specified kind is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2)">
              <doc>
                <summary>Returns true if a token of the specified kinds is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
              </doc>
            </member>
            <member def="public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)">
              <doc>
                <summary>Returns true if a token of the specified kinds is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
              </doc>
            </member>
            <member def="public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)">
              <doc>
                <summary>Returns true if a token of the specified kinds is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
              </doc>
            </member>
            <member def="public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)">
              <doc>
                <summary>Returns true if a token of the specified kinds is in the <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
              </doc>
            </member>
            <member def="public static bool ContainsDefaultLabel(this SwitchSectionSyntax switchSection)">
              <doc>
                <summary>Returns true if the specified switch section contains default switch label.</summary>
              </doc>
            </member>
            <member def="public static bool ContainsYield(this LocalFunctionStatementSyntax localFunctionStatement)">
              <doc>
                <summary>Returns true if the specified local function contains yield statement. Nested local functions are excluded.</summary>
              </doc>
            </member>
            <member def="public static bool ContainsYield(this MethodDeclarationSyntax methodDeclaration)">
              <doc>
                <summary>Returns true if the specified method contains yield statement. Nested local functions are excluded.</summary>
              </doc>
            </member>
            <member def="public static CSharpSyntaxNode DeclarationOrExpression(this UsingStatementSyntax usingStatement)">
              <doc>
                <summary>Returns using statement's declaration or an expression if the declaration is null.</summary>
              </doc>
            </member>
            <member def="public static SwitchSectionSyntax DefaultSection(this SwitchStatementSyntax switchStatement)">
              <doc>
                <summary>Returns a section that contains default label, or null if the specified swtich statement does not contains section with default label.</summary>
              </doc>
            </member>
            <member def="public static IEnumerable&lt;XmlElementSyntax&gt; Elements(this DocumentationCommentTriviaSyntax documentationComment, string localName)">
              <doc>
                <summary>Gets a list of xml elements with the specified local name.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken Find(this SyntaxTokenList tokenList, SyntaxKind kind)">
              <doc>
                <summary>Searches for a token of the specified kind and returns the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxTokenList" />.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTrivia Find(this SyntaxTriviaList triviaList, SyntaxKind kind)">
              <doc>
                <summary>Searches for a trivia of the specified kind and returns the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static TNode Find&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode">
              <doc>
                <summary>Searches for a node of the specified kind and returns the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static TNode Find&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode">
              <doc>
                <summary>Searches for a node of the specified kind and returns the first occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Gets the first ancestor of the specified kind.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNode FirstAncestor(this SyntaxNode node, Func&lt;SyntaxNode, bool&gt; predicate, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Gets the first ancestor that matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Gets the first ancestor of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Gets the first ancestor of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Gets the first ancestor of the specified kind.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, Func&lt;SyntaxNode, bool&gt; predicate, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Gets the first ancestor that matches the predicate.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Gets the first ancestor of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Gets the first ancestor of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static IfStatementCascadeInfo GetCascadeInfo(this IfStatementSyntax ifStatement)">
              <doc>
                <summary>Returns <see cref="T:Roslynator.CSharp.IfStatementCascadeInfo" /> that summarizes information about if-else cascade.</summary>
              </doc>
            </member>
            <member def="public static DocumentationCommentTriviaSyntax GetDocumentationComment(this MemberDeclarationSyntax member)">
              <doc>
                <summary>Returns documentation comment syntax that is part of the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTrivia GetDocumentationCommentTrivia(this MemberDeclarationSyntax member)">
              <doc>
                <summary>Returns documentation comment that is part of the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static EndRegionDirectiveTriviaSyntax GetEndRegionDirective(this RegionDirectiveTriviaSyntax regionDirective)">
              <doc>
                <summary>Returns endregion directive that is related to the specified region directive. Returns null if no matching endregion directive is found.</summary>
              </doc>
            </member>
            <member def="public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, TextSpan span, Func&lt;DirectiveTriviaSyntax, bool&gt; predicate = null)">
              <doc>
                <summary>Gets the first directive of the tree rooted by this node.</summary>
              </doc>
            </member>
            <member def="public static DirectiveTriviaSyntax GetNextRelatedDirective(this DirectiveTriviaSyntax directiveTrivia)">
              <doc>
                <summary>Returns the next related directive.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTrivia GetPreprocessingMessageTrivia(this EndRegionDirectiveTriviaSyntax endRegionDirective)">
              <doc>
                <summary>Gets preprocessing message for the specified endregion directive if such message exists.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTrivia GetPreprocessingMessageTrivia(this RegionDirectiveTriviaSyntax regionDirective)">
              <doc>
                <summary>Gets preprocessing message for the specified region directive if such message exists.</summary>
              </doc>
            </member>
            <member def="public static RegionDirectiveTriviaSyntax GetRegionDirective(this EndRegionDirectiveTriviaSyntax endRegionDirective)">
              <doc>
                <summary>Returns region directive that is related to the specified endregion directive. Returns null if no matching region directive is found.</summary>
              </doc>
            </member>
            <member def="public static DocumentationCommentTriviaSyntax GetSingleLineDocumentationComment(this MemberDeclarationSyntax member)">
              <doc>
                <summary>Returns single-line documentation comment syntax that is part of the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTrivia GetSingleLineDocumentationCommentTrivia(this MemberDeclarationSyntax member)">
              <doc>
                <summary>Returns single-line documentation comment that is part of the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static IfStatementSyntax GetTopmostIf(this ElseClauseSyntax elseClause)">
              <doc>
                <summary>Returns topmost if statement of the if-else cascade the specified else clause is part of.</summary>
              </doc>
            </member>
            <member def="public static IfStatementSyntax GetTopmostIf(this IfStatementSyntax ifStatement)">
              <doc>
                <summary>Returns topmost if statement of the if-else cascade the specified if statement is part of.</summary>
              </doc>
            </member>
            <member def="public static AccessorDeclarationSyntax Getter(this AccessorListSyntax accessorList)">
              <doc>
                <summary>Returns a get accessor contained in the specified list.</summary>
              </doc>
            </member>
            <member def="public static AccessorDeclarationSyntax Getter(this IndexerDeclarationSyntax indexerDeclaration)">
              <doc>
                <summary>Returns a get accessor that is contained in the specified indexer declaration.</summary>
              </doc>
            </member>
            <member def="public static AccessorDeclarationSyntax Getter(this PropertyDeclarationSyntax propertyDeclaration)">
              <doc>
                <summary>Returns property get accessor, if any.</summary>
              </doc>
            </member>
            <member def="public static bool HasDocumentationComment(this MemberDeclarationSyntax member)">
              <doc>
                <summary>Returns true if the specified declaration has a documentation comment.</summary>
              </doc>
            </member>
            <member def="public static bool HasSingleLineDocumentationComment(this MemberDeclarationSyntax member)">
              <doc>
                <summary>Returns true if the specified declaration has a single-line documentation comment.</summary>
              </doc>
            </member>
            <member def="public static bool IsAutoImplemented(this AccessorDeclarationSyntax accessorDeclaration)">
              <doc>
                <summary>Returns true is the specified accessor is auto-implemented accessor.</summary>
              </doc>
            </member>
            <member def="public static bool IsDescendantOf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true)">
              <doc>
                <summary>Returns true if a node is a descendant of a node with the specified kind.</summary>
              </doc>
            </member>
            <member def="public static bool IsEmbedded(this StatementSyntax statement, bool canBeBlock = false, bool canBeIfInsideElse = true, bool canBeUsingInsideUsing = true)">
              <doc>
                <summary>Returns true if the specified statement is an embedded statement.</summary>
                <param name="canBeBlock">Block can be considered as embedded statement</param>
                <param name="canBeIfInsideElse">If statement that is a child of an else statement can be considered as an embedded statement.</param>
                <param name="canBeUsingInsideUsing">Using statement that is a child of an using statement can be considered as en embedded statement.</param>
              </doc>
            </member>
            <member def="public static bool IsEmptyOrWhitespace(this SyntaxTriviaList triviaList)">
              <doc>
                <summary>Returns true if the list of either empty or contains only whitespace.</summary>
              </doc>
            </member>
            <member def="public static bool IsEndOfLineTrivia(this SyntaxTrivia trivia)">
              <doc>
                <summary>Returns true if the trivia is <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsHexNumericLiteral(this LiteralExpressionSyntax literalExpression)">
              <doc>
                <summary>Returns true if the specified literal expression is a hexadecimal numeric literal expression.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2)">
              <doc>
                <summary>Returns true if a node's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2)">
              <doc>
                <summary>Returns true if a trivia's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)">
              <doc>
                <summary>Returns true if a node's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)">
              <doc>
                <summary>Returns true if a node's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)">
              <doc>
                <summary>Returns true if a node's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)">
              <doc>
                <summary>Returns true if a node's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)">
              <doc>
                <summary>Returns true if a token's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsLast(this SyntaxList&lt;StatementSyntax&gt; statements, StatementSyntax statement, bool ignoreLocalFunctions)">
              <doc>
                <summary>Returns true if the specified statement is a last statement in the list.</summary>
                <param name="ignoreLocalFunctions">Ignore local function statements at the end of the list.</param>
              </doc>
            </member>
            <member def="public static bool IsParams(this ParameterSyntax parameter)">
              <doc>
                <summary>Returns true if the specified parameter has "params" modifier.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind)">
              <doc>
                <summary>Returns true if a node parent's kind is the specified kind.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind)">
              <doc>
                <summary>Returns true if a token parent's kind is the specified kind.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2)">
              <doc>
                <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2)">
              <doc>
                <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)">
              <doc>
                <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3)">
              <doc>
                <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)">
              <doc>
                <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4)">
              <doc>
                <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)">
              <doc>
                <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5)">
              <doc>
                <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)">
              <doc>
                <summary>Returns true if a node parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6)">
              <doc>
                <summary>Returns true if a token parent's kind is one of the specified kinds.</summary>
              </doc>
            </member>
            <member def="public static bool IsSimpleIf(this IfStatementSyntax ifStatement)">
              <doc>
                <summary>
                Returns true if the specified if statement is a simple if statement.
                Simple if statement is defined as follows: it is not a child of an else clause and it has no else clause.
                </summary>
              </doc>
            </member>
            <member def="public static bool IsTopmostIf(this IfStatementSyntax ifStatement)">
              <doc>
                <summary>Returns true if the specified if statement is not a child of an else clause.</summary>
              </doc>
            </member>
            <member def="public static bool IsVerbatim(this InterpolatedStringExpressionSyntax interpolatedString)">
              <doc>
                <summary>Returns true if the specified interpolated string is a verbatim.</summary>
              </doc>
            </member>
            <member def="public static bool IsVoid(this TypeSyntax type)">
              <doc>
                <summary>Returns true if the type is <see cref="T:System.Void" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsWhitespaceOrEndOfLineTrivia(this SyntaxTrivia trivia)">
              <doc>
                <summary>Returns true if the trivia is either <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> or <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsWhitespaceTrivia(this SyntaxTrivia trivia)">
              <doc>
                <summary>Returns true if the trivia is <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" />.</summary>
              </doc>
            </member>
            <member def="public static bool IsYieldBreak(this YieldStatementSyntax yieldStatement)">
              <doc>
                <summary>Returns true if the specified statement is a yield break statement.</summary>
              </doc>
            </member>
            <member def="public static bool IsYieldReturn(this YieldStatementSyntax yieldStatement)">
              <doc>
                <summary>Returns true if the specified statement is a yield return statement.</summary>
              </doc>
            </member>
            <member def="public static int LastIndexOf(this SyntaxTriviaList triviaList, SyntaxKind kind)">
              <doc>
                <summary>Searches for a trivia of the specified kind and returns the zero-based index of the last occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxTriviaList" />.</summary>
              </doc>
            </member>
            <member def="public static int LastIndexOf&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode">
              <doc>
                <summary>Searches for a node of the specified kind and returns the zero-based index of the last occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static int LastIndexOf&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, SyntaxKind kind) where TNode : SyntaxNode">
              <doc>
                <summary>Searches for a node of the specified kind and returns the zero-based index of the last occurrence within the entire <see cref="T:Microsoft.CodeAnalysis.SyntaxList`1" />.</summary>
              </doc>
            </member>
            <member def="public static StatementSyntax NextStatement(this StatementSyntax statement)">
              <doc>
                <summary>
                Gets the next statement of the specified statement.
                If the specified statement is not contained in the list, or if there is no next statement, then this method returns null.
                </summary>
              </doc>
            </member>
            <member def="public static TextSpan ParenthesesSpan(this CastExpressionSyntax castExpression)">
              <doc>
                <summary>The absolute span of the parentheses, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TextSpan ParenthesesSpan(this CommonForEachStatementSyntax forEachStatement)">
              <doc>
                <summary>The absolute span of the parentheses, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static TextSpan ParenthesesSpan(this ForStatementSyntax forStatement)">
              <doc>
                <summary>Absolute span of the parentheses, not including the leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static StatementSyntax PreviousStatement(this StatementSyntax statement)">
              <doc>
                <summary>
                Gets the previous statement of the specified statement.
                If the specified statement is not contained in the list, or if there is no previous statement, then this method returns null.
                </summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList RemoveRange(this SyntaxTokenList list, int index, int count)">
              <doc>
                <summary>Creates a new list with tokens in the specified range removed.</summary>
                <param name="index">An index of the first element to remove.</param>
                <param name="count">A number of elements to remove.</param>
              </doc>
            </member>
            <member def="public static SyntaxTriviaList RemoveRange(this SyntaxTriviaList list, int index, int count)">
              <doc>
                <summary>Creates a new list with trivia in the specified range removed.</summary>
                <param name="index">An index of the first element to remove.</param>
                <param name="count">A number of elements to remove.</param>
              </doc>
            </member>
            <member def="public static SeparatedSyntaxList&lt;TNode&gt; RemoveRange&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, int index, int count) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new list with elements in the specified range removed.</summary>
                <param name="index">An index of the first element to remove.</param>
                <param name="count">A number of elements to remove.</param>
              </doc>
            </member>
            <member def="public static SyntaxList&lt;TNode&gt; RemoveRange&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, int index, int count) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new list with elements in the specified range removed.</summary>
                <param name="index">An index of the first element to remove.</param>
                <param name="count">A number of elements to remove.</param>
              </doc>
            </member>
            <member def="public static TNode RemoveTrivia&lt;TNode&gt;(this TNode node, TextSpan? span = null) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the trivia removed.</summary>
              </doc>
            </member>
            <member def="public static TNode RemoveWhitespace&lt;TNode&gt;(this TNode node, TextSpan? span = null) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the whitespace removed.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList ReplaceRange(this SyntaxTokenList list, int index, int count, IEnumerable&lt;SyntaxToken&gt; newTokens)">
              <doc>
                <summary>Creates a new list with the tokens in the specified range replaced with new tokens.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTriviaList ReplaceRange(this SyntaxTriviaList list, int index, int count, IEnumerable&lt;SyntaxTrivia&gt; newTrivia)">
              <doc>
                <summary>Creates a new list with the trivia in the specified range replaced with new trivia.</summary>
              </doc>
            </member>
            <member def="public static SeparatedSyntaxList&lt;TNode&gt; ReplaceRange&lt;TNode&gt;(this SeparatedSyntaxList&lt;TNode&gt; list, int index, int count, IEnumerable&lt;TNode&gt; newNodes) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new list with the elements in the specified range replaced with new nodes.</summary>
              </doc>
            </member>
            <member def="public static SyntaxList&lt;TNode&gt; ReplaceRange&lt;TNode&gt;(this SyntaxList&lt;TNode&gt; list, int index, int count, IEnumerable&lt;TNode&gt; newNodes) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new list with the elements in the specified range replaced with new nodes.</summary>
              </doc>
            </member>
            <member def="public static TNode ReplaceWhitespace&lt;TNode&gt;(this TNode node, SyntaxTrivia replacement, TextSpan? span = null) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the whitespace replaced.</summary>
              </doc>
            </member>
            <member def="public static bool ReturnsVoid(this DelegateDeclarationSyntax delegateDeclaration)">
              <doc>
                <summary>Returns true the specified delegate return type is <see cref="T:System.Void" />.</summary>
              </doc>
            </member>
            <member def="public static bool ReturnsVoid(this LocalFunctionStatementSyntax localFunctionStatement)">
              <doc>
                <summary>Returns true if the specified local function' return type is <see cref="T:System.Void" />.</summary>
              </doc>
            </member>
            <member def="public static bool ReturnsVoid(this MethodDeclarationSyntax methodDeclaration)">
              <doc>
                <summary>Returns true if the specified method return type is <see cref="T:System.Void" />.</summary>
              </doc>
            </member>
            <member def="public static AccessorDeclarationSyntax Setter(this AccessorListSyntax accessorList)">
              <doc>
                <summary>Returns a set accessor contained in the specified list.</summary>
              </doc>
            </member>
            <member def="public static AccessorDeclarationSyntax Setter(this IndexerDeclarationSyntax indexerDeclaration)">
              <doc>
                <summary>Returns a set accessor that is contained in the specified indexer declaration.</summary>
              </doc>
            </member>
            <member def="public static AccessorDeclarationSyntax Setter(this PropertyDeclarationSyntax propertyDeclaration)">
              <doc>
                <summary>Returns property set accessor, if any.</summary>
              </doc>
            </member>
            <member def="public static SeparatedSyntaxList&lt;TNode&gt; ToSeparatedSyntaxList&lt;TNode&gt;(this IEnumerable&lt;TNode&gt; nodes) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a separated list of syntax nodes from a sequence of nodes.</summary>
              </doc>
            </member>
            <member def="public static SeparatedSyntaxList&lt;TNode&gt; ToSeparatedSyntaxList&lt;TNode&gt;(this IEnumerable&lt;SyntaxNodeOrToken&gt; nodesAndTokens) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a separated list of syntax nodes from a sequence of nodes and tokens.</summary>
              </doc>
            </member>
            <member def="public static SyntaxList&lt;TNode&gt; ToSyntaxList&lt;TNode&gt;(this IEnumerable&lt;TNode&gt; nodes) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a list of syntax nodes from a sequence of nodes.</summary>
              </doc>
            </member>
            <member def="public static SyntaxTokenList ToSyntaxTokenList(this IEnumerable&lt;SyntaxToken&gt; tokens)">
              <doc>
                <summary>Creates a list of syntax tokens from a sequence of tokens.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken TrimLeadingTrivia(this SyntaxToken token)">
              <doc>
                <summary>
                Removes all leading whitespace from the leading trivia and returns a new token with the new leading trivia.
                <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
                Returns the same token if there is nothing to trim.
                </summary>
              </doc>
            </member>
            <member def="public static TNode TrimLeadingTrivia&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>
                Removes all leading whitespace from the leading trivia and returns a new node with the new leading trivia.
                <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
                Returns the same node if there is nothing to trim.
                </summary>
              </doc>
            </member>
            <member def="public static SyntaxToken TrimTrailingTrivia(this SyntaxToken token)">
              <doc>
                <summary>
                Removes all trailing whitespace from the trailing trivia and returns a new token with the new trailing trivia.
                <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
                Returns the same token if there is nothing to trim.
                </summary>
              </doc>
            </member>
            <member def="public static TNode TrimTrailingTrivia&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>
                Removes all trailing whitespace from the trailing trivia and returns a new node with the new trailing trivia.
                <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
                Returns the same node if there is nothing to trim.
                </summary>
              </doc>
            </member>
            <member def="public static SyntaxToken TrimTrivia(this SyntaxToken token)">
              <doc>
                <summary>
                Removes all leading whitespace from the leading trivia and all trailing whitespace from the trailing trivia and returns a new token with the new trivia.
                <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
                Returns the same token if there is nothing to trim.
                </summary>
              </doc>
            </member>
            <member def="public static TNode TrimTrivia&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>
                Removes all leading whitespace from the leading trivia and all trailing whitespace from the trailing trivia and returns a new node with the new trivia.
                <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.WhitespaceTrivia" /> and <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.EndOfLineTrivia" /> is considered to be a whitespace.
                Returns the same node if there is nothing to trim.
                </summary>
              </doc>
            </member>
            <member def="public static bool TryGetContainingList(this StatementSyntax statement, out SyntaxList&lt;StatementSyntax&gt; statements)">
              <doc>
                <summary>
                Gets a list the specified statement is contained in.
                This method succeeds if the statement is in a block's statements or a switch section's statements.
                </summary>
                <returns>True if the statement is contained in the list; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public static ExpressionSyntax WalkDownParentheses(this ExpressionSyntax expression)">
              <doc>
                <summary>Returns lowest expression in parentheses or self if the expression is not parenthesized.</summary>
              </doc>
            </member>
            <member def="public static ExpressionSyntax WalkUpParentheses(this ExpressionSyntax expression)">
              <doc>
                <summary>Returns topmost parenthesized expression or self if the expression if not parenthesized.</summary>
              </doc>
            </member>
            <member def="public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, IEnumerable&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, IEnumerable&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, IEnumerable&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, IEnumerable&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, IEnumerable&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax" /> with the members updated.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class SyntaxInfo">
          <doc>
            <summary>Serves as a factory for types in Roslynator.CSharp.Syntax namespace.</summary>
          </doc>
          <members>
            <member def="public static AsExpressionInfo AsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.AsExpressionInfo" /> from the specified binary expression.</summary>
              </doc>
            </member>
            <member def="public static AsExpressionInfo AsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.AsExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static AssignmentExpressionInfo AssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.AssignmentExpressionInfo" /> from the specified assignment expression.</summary>
              </doc>
            </member>
            <member def="public static AssignmentExpressionInfo AssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.AssignmentExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static BinaryExpressionInfo BinaryExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.BinaryExpressionInfo" /> from the specified binary expression.</summary>
              </doc>
            </member>
            <member def="public static BinaryExpressionInfo BinaryExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.BinaryExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static ConditionalExpressionInfo ConditionalExpressionInfo(ConditionalExpressionSyntax conditionalExpression, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ConditionalExpressionInfo" /> from the specified conditional expression.</summary>
              </doc>
            </member>
            <member def="public static ConditionalExpressionInfo ConditionalExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ConditionalExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(TypeParameterConstraintClauseSyntax constraintClause)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified constraint clause.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(DelegateDeclarationSyntax delegateDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified delegate declaration.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(LocalFunctionStatementSyntax localFunctionStatement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified local function.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(MethodDeclarationSyntax methodDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified method declaration.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(SyntaxNode node)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(TypeDeclarationSyntax typeDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified type declaration.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(TypeParameterSyntax typeParameter)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified type parameter.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(TypeParameterConstraintSyntax typeParameterConstraint)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified type parameter constraint.</summary>
              </doc>
            </member>
            <member def="public static GenericInfo GenericInfo(TypeParameterListSyntax typeParameterList)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> from the specified type parameter list.</summary>
              </doc>
            </member>
            <member def="public static IsExpressionInfo IsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.IsExpressionInfo" /> from the specified binary expression.</summary>
              </doc>
            </member>
            <member def="public static IsExpressionInfo IsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.IsExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.LocalDeclarationStatementInfo" /> from the specified local declaration statement.</summary>
              </doc>
            </member>
            <member def="public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(ExpressionSyntax value, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.LocalDeclarationStatementInfo" /> from the specified expression.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(CompilationUnitSyntax compilationUnit)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified compilation unit.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(NamespaceDeclarationSyntax declaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(TypeDeclarationSyntax declaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(ClassDeclarationSyntax declaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(StructDeclarationSyntax declaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(InterfaceDeclarationSyntax declaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static MemberDeclarationListInfo MemberDeclarationListInfo(SyntaxNode node)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(AccessorDeclarationSyntax accessorDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified accessor declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(ClassDeclarationSyntax classDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified class declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(ConstructorDeclarationSyntax constructorDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified constructor declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified conversion operator declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(DelegateDeclarationSyntax delegateDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified delegate declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(DestructorDeclarationSyntax destructorDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified destructor declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(EnumDeclarationSyntax enumDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified enum declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(EventDeclarationSyntax eventDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified event declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(EventFieldDeclarationSyntax eventFieldDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified event field declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(FieldDeclarationSyntax fieldDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified field declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(IncompleteMemberSyntax incompleteMember)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified incomplete member.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(IndexerDeclarationSyntax indexerDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified indexer declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(InterfaceDeclarationSyntax interfaceDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified interface declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(LocalDeclarationStatementSyntax localDeclarationStatement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified local declaration statement.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(LocalFunctionStatementSyntax localFunctionStatement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified local function.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(MethodDeclarationSyntax methodDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified method declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(SyntaxNode node)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(OperatorDeclarationSyntax operatorDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified operator declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(ParameterSyntax parameter)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified parameter.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(PropertyDeclarationSyntax propertyDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified property declaration.</summary>
              </doc>
            </member>
            <member def="public static ModifierListInfo ModifierListInfo(StructDeclarationSyntax structDeclaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> from the specified struct declaration.</summary>
              </doc>
            </member>
            <member def="public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, NullCheckStyles allowedStyles = ComparisonToNull | IsPattern, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.NullCheckExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles = All, bool walkDownParentheses = true, bool allowMissing = false, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.NullCheckExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static RegionInfo RegionInfo(EndRegionDirectiveTriviaSyntax endRegionDirective)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.RegionInfo" /> from the specified endregion directive.</summary>
              </doc>
            </member>
            <member def="public static RegionInfo RegionInfo(RegionDirectiveTriviaSyntax regionDirective)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.RegionInfo" /> from the specified region directive.</summary>
              </doc>
            </member>
            <member def="public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentExpressionInfo" /> from the specified assignment expression.</summary>
              </doc>
            </member>
            <member def="public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo" /> from the specified assignment expression.</summary>
              </doc>
            </member>
            <member def="public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(ExpressionStatementSyntax expressionStatement, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo" /> from the specified expression statement.</summary>
              </doc>
            </member>
            <member def="public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(StatementSyntax statement, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo" /> from the specified statement.</summary>
              </doc>
            </member>
            <member def="public static SimpleIfElseInfo SimpleIfElseInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleIfElseInfo" /> from the specified if statement.</summary>
              </doc>
            </member>
            <member def="public static SimpleIfStatementInfo SimpleIfStatementInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleIfStatementInfo" /> from the specified if statement.</summary>
              </doc>
            </member>
            <member def="public static SimpleIfStatementInfo SimpleIfStatementInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleIfStatementInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationExpressionInfo" /> from the specified invocation expression.</summary>
              </doc>
            </member>
            <member def="public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(ExpressionStatementSyntax expressionStatement, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo" /> from the specified expression statement.</summary>
              </doc>
            </member>
            <member def="public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo" /> from the specified invocation expression.</summary>
              </doc>
            </member>
            <member def="public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(SyntaxNode node, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(ExpressionSyntax value)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo" /> from the specified value.</summary>
              </doc>
            </member>
            <member def="public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo" /> from the specified local declaration statement.</summary>
              </doc>
            </member>
            <member def="public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(VariableDeclarationSyntax variableDeclaration, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo" /> from the specified variable declaration.</summary>
              </doc>
            </member>
            <member def="public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(LambdaExpressionSyntax lambdaExpression, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleParameterLambdaExpressionInfo" /> from the specified lambda expression.</summary>
              </doc>
            </member>
            <member def="public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.SingleParameterLambdaExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static StatementListInfo StatementListInfo(StatementSyntax statement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> from the specified statement.</summary>
              </doc>
            </member>
            <member def="public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(in ExpressionChain expressionChain, SemanticModel semanticModel, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo" /> from the specified expression chain.</summary>
              </doc>
            </member>
            <member def="public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(SyntaxNode node, SemanticModel semanticModel, bool walkDownParentheses = true, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static StringLiteralExpressionInfo StringLiteralExpressionInfo(LiteralExpressionSyntax literalExpression)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringLiteralExpressionInfo" /> from the specified literal expression.</summary>
              </doc>
            </member>
            <member def="public static StringLiteralExpressionInfo StringLiteralExpressionInfo(SyntaxNode node, bool walkDownParentheses = true)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StringLiteralExpressionInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static UsingDirectiveListInfo UsingDirectiveListInfo(CompilationUnitSyntax compilationUnit)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> from the specified compilation unit.</summary>
              </doc>
            </member>
            <member def="public static UsingDirectiveListInfo UsingDirectiveListInfo(NamespaceDeclarationSyntax declaration)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> from the specified declaration.</summary>
              </doc>
            </member>
            <member def="public static UsingDirectiveListInfo UsingDirectiveListInfo(SyntaxNode node)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> from the specified node.</summary>
              </doc>
            </member>
            <member def="public static XmlElementInfo XmlElementInfo(XmlNodeSyntax xmlNode)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.XmlElementInfo" /> from the specified xml node.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class SyntaxInverter">
          <doc>
            <summary>Provides static methods for syntax inversion.</summary>
          </doc>
          <members>
            <member def="public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns new expression that represents logical inversion of the specified expression.</summary>
              </doc>
            </member>
            <member def="public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Returns new expression that represents logical inversion of the specified expression.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class WorkspaceExtensions">
          <doc>
            <summary>A set of extension methods for the workspace layer.</summary>
          </doc>
          <members>
            <member def="public static Task&lt;Document&gt; RemoveCommentsAsync(this Document document, CommentFilter comments, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with comments of the specified kind removed.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; RemoveCommentsAsync(this Document document, TextSpan span, CommentFilter comments, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with comments of the specified kind removed.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; RemovePreprocessorDirectivesAsync(this Document document, PreprocessorDirectiveFilter directiveFilter, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with preprocessor directives of the specified kind removed.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; RemovePreprocessorDirectivesAsync(this Document document, TextSpan span, PreprocessorDirectiveFilter directiveFilter, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with preprocessor directives of the specified kind removed.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; RemoveRegionAsync(this Document document, RegionInfo region, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with the specified region removed.</summary>
              </doc>
            </member>
            <member def="public static Task&lt;Document&gt; RemoveTriviaAsync(this Document document, TextSpan span, CancellationToken cancellationToken = default)">
              <doc>
                <summary>Creates a new document with trivia inside the specified span removed.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public static class WorkspaceSyntaxExtensions">
          <doc>
            <summary>A set of extension methods for syntax. These methods are dependent on the workspace layer.</summary>
          </doc>
          <members>
            <member def="public static ParenthesizedExpressionSyntax Parenthesize(this ExpressionSyntax expression, bool includeElasticTrivia = true, bool simplifiable = true)">
              <doc>
                <summary>Creates parenthesized expression that is parenthesizing the specified expression.</summary>
                <param name="includeElasticTrivia">If true, add elastic trivia.</param>
                <param name="simplifiable">If true, attach <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> to the parenthesized expression.</param>
              </doc>
            </member>
            <member def="public static SyntaxToken WithFormatterAnnotation(this SyntaxToken token)">
              <doc>
                <summary>Adds <see cref="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation" /> to the specified token, creating a new token of the same type with the <see cref="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation" /> on it.</summary>
              </doc>
            </member>
            <member def="public static TNode WithFormatterAnnotation&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the <see cref="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation" /> attached.</summary>
              </doc>
            </member>
            <member def="public static SyntaxToken WithRenameAnnotation(this SyntaxToken token)">
              <doc>
                <summary>
                Adds "rename" annotation to the specified token, creating a new token of the same type with the "rename" annotation on it.
                "Rename" annotation is specified by <see cref="F:Microsoft.CodeAnalysis.CodeActions.RenameAnnotation.Kind" />.
                </summary>
              </doc>
            </member>
            <member def="public static SyntaxToken WithSimplifierAnnotation(this SyntaxToken token)">
              <doc>
                <summary>
                Adds <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> to the specified token, creating a new token of the same type with the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> on it.
                "Rename" annotation is specified by <see cref="F:Microsoft.CodeAnalysis.CodeActions.RenameAnnotation.Kind" />.
                </summary>
              </doc>
            </member>
            <member def="public static TNode WithSimplifierAnnotation&lt;TNode&gt;(this TNode node) where TNode : SyntaxNode">
              <doc>
                <summary>Creates a new node with the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> attached.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public readonly struct ExpressionChain : IEquatable&lt;ExpressionChain&gt;, IEnumerable&lt;ExpressionSyntax&gt;">
          <doc>
            <summary>Enables to enumerate expressions of a binary expression and expressions of nested binary expressions of the same kind as parent binary expression.</summary>
          </doc>
          <members>
            <member def="public BinaryExpressionSyntax BinaryExpression { get; }">
              <doc>
                <summary>The binary expression.</summary>
              </doc>
            </member>
            <member def="public TextSpan? Span { get; }">
              <doc>
                <summary>The span that represents selected expressions.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(ExpressionChain other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public ExpressionChain.Enumerator GetEnumerator()">
              <doc>
                <summary>Gets the enumerator for the expressions.</summary>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public ExpressionChain.Reversed Reverse()">
              <doc>
                <summary>Returns a chain which contains all expressions of <see cref="T:Roslynator.CSharp.ExpressionChain" /> in reversed order.</summary>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the expressions, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in ExpressionChain info1, in ExpressionChain info2)" />
            <member def="public static bool operator !=(in ExpressionChain info1, in ExpressionChain info2)" />
          </members>
          <types>
            <type def="public struct Enumerator">
              <members>
                <member def="public ExpressionSyntax Current { get; }" />
                <member def="public override bool Equals(object obj)" />
                <member def="public override int GetHashCode()" />
                <member def="public bool MoveNext()" />
                <member def="public void Reset()" />
              </members>
            </type>
            <type def="public readonly struct Reversed : IEquatable&lt;ExpressionChain.Reversed&gt;, IEnumerable&lt;ExpressionSyntax&gt;">
              <doc>
                <summary>Enables to enumerate expressions of <see cref="T:Roslynator.CSharp.ExpressionChain" /> in a reversed order.</summary>
              </doc>
              <members>
                <member def="public Reversed(in ExpressionChain chain)" />
                <member def="public override bool Equals(object obj)" />
                <member def="public bool Equals(ExpressionChain.Reversed other)" />
                <member def="public ExpressionChain.Reversed.Enumerator GetEnumerator()" />
                <member def="public override int GetHashCode()" />
                <member def="public override string ToString()" />
                <member def="public static bool operator ==(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2)" />
                <member def="public static bool operator !=(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2)" />
              </members>
              <types>
                <type def="public struct Enumerator">
                  <members>
                    <member def="public ExpressionSyntax Current { get; }" />
                    <member def="public override bool Equals(object obj)" />
                    <member def="public override int GetHashCode()" />
                    <member def="public bool MoveNext()" />
                    <member def="public void Reset()" />
                  </members>
                </type>
              </types>
            </type>
          </types>
        </type>
        <type def="public readonly struct IfStatementCascade : IEquatable&lt;IfStatementCascade&gt;, IEnumerable&lt;IfStatementOrElseClause&gt;">
          <doc>
            <summary>Enables to enumerate if statement cascade.</summary>
          </doc>
          <members>
            <member def="public IfStatementSyntax IfStatement { get; }">
              <doc>
                <summary>The if statement.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(IfStatementCascade other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public IfStatementCascade.Enumerator GetEnumerator()">
              <doc>
                <summary>Gets the enumerator for the if-else cascade.</summary>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in IfStatementCascade cascade1, in IfStatementCascade cascade2)" />
            <member def="public static bool operator !=(in IfStatementCascade cascade1, in IfStatementCascade cascade2)" />
          </members>
          <types>
            <type def="public struct Enumerator">
              <members>
                <member def="public IfStatementOrElseClause Current { get; }" />
                <member def="public override bool Equals(object obj)" />
                <member def="public override int GetHashCode()" />
                <member def="public bool MoveNext()" />
                <member def="public void Reset()" />
              </members>
            </type>
          </types>
        </type>
        <type def="public readonly struct IfStatementCascadeInfo : IEquatable&lt;IfStatementCascadeInfo&gt;">
          <doc>
            <summary>Summarizes information about <see cref="T:Roslynator.CSharp.IfStatementCascade" />.</summary>
          </doc>
          <members>
            <member def="public IfStatementCascadeInfo(IfStatementSyntax ifStatement)">
              <doc>
                <summary>Initializes a new instance of <see cref="T:Roslynator.CSharp.IfStatementCascadeInfo" />.</summary>
              </doc>
            </member>
            <member def="public int Count { get; }">
              <doc>
                <summary>Gets a number of 'if' statements plus optional 'else' clause at the end of a cascade.</summary>
              </doc>
            </member>
            <member def="public bool EndsWithElse { get; }">
              <doc>
                <summary>Determines whether the cascade ends with 'else' clause.</summary>
              </doc>
            </member>
            <member def="public bool EndsWithIf { get; }">
              <doc>
                <summary>Determines whether the cascade ends with 'if' statement.</summary>
              </doc>
            </member>
            <member def="public IfStatementSyntax IfStatement { get; }">
              <doc>
                <summary>Gets the topmost 'if' statement.</summary>
              </doc>
            </member>
            <member def="public bool IsSimpleIf { get; }">
              <doc>
                <summary>Determines whether the cascade consists of single 'if' statement.</summary>
              </doc>
            </member>
            <member def="public bool IsSimpleIfElse { get; }">
              <doc>
                <summary>Determines whether the cascade consists of single if-else.</summary>
              </doc>
            </member>
            <member def="public IfStatementOrElseClause Last { get; }">
              <doc>
                <summary>Gets a last 'if' or 'else' in a cascade.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(IfStatementCascadeInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2)" />
            <member def="public static bool operator !=(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct IfStatementOrElseClause : IEquatable&lt;IfStatementOrElseClause&gt;">
          <doc>
            <summary>A wrapper for either an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax" /> or an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax" />.</summary>
          </doc>
          <members>
            <member def="public IfStatementOrElseClause(ElseClauseSyntax elseClause)" />
            <member def="public IfStatementOrElseClause(IfStatementSyntax ifStatement)" />
            <member def="public TextSpan FullSpan { get; }">
              <doc>
                <summary>The absolute span of this node in characters, including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public bool IsElse { get; }">
              <doc>
                <summary>Determines whether this <see cref="T:Roslynator.CSharp.IfStatementOrElseClause" /> is wrapping an else clause.</summary>
              </doc>
            </member>
            <member def="public bool IsIf { get; }">
              <doc>
                <summary>Determines whether this <see cref="T:Roslynator.CSharp.IfStatementOrElseClause" /> is wrapping an if statement.</summary>
              </doc>
            </member>
            <member def="public SyntaxKind Kind { get; }">
              <doc>
                <summary>Gets an underlying node kind.</summary>
              </doc>
            </member>
            <member def="public SyntaxNode Parent { get; }">
              <doc>
                <summary>The node that contains the underlying node in its <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes" /> collection.</summary>
              </doc>
            </member>
            <member def="public TextSpan Span { get; }">
              <doc>
                <summary>The absolute span of this node in characters, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public StatementSyntax Statement { get; }">
              <doc>
                <summary>Gets <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Statement" /> or <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax.Statement" />.</summary>
              </doc>
            </member>
            <member def="public ElseClauseSyntax AsElse()">
              <doc>
                <summary>Returns the underlying else clause if this <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax" /> is wrapping else clause.</summary>
              </doc>
            </member>
            <member def="public IfStatementSyntax AsIf()">
              <doc>
                <summary>Returns the underlying if statement if this <see cref="T:Roslynator.CSharp.IfStatementOrElseClause" /> is wrapping if statement.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(IfStatementOrElseClause other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying node, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static implicit operator IfStatementOrElseClause(IfStatementSyntax ifStatement)" />
            <member def="public static implicit operator IfStatementSyntax(in IfStatementOrElseClause ifOrElse)" />
            <member def="public static implicit operator IfStatementOrElseClause(ElseClauseSyntax elseClause)" />
            <member def="public static implicit operator ElseClauseSyntax(in IfStatementOrElseClause ifOrElse)" />
            <member def="public static bool operator ==(in IfStatementOrElseClause left, in IfStatementOrElseClause right)" />
            <member def="public static bool operator !=(in IfStatementOrElseClause left, in IfStatementOrElseClause right)" />
          </members>
        </type>
        <type def="public enum CommentFilter">
          <doc>
            <summary>Specifies C# comments.</summary>
          </doc>
          <attributes>
            <attribute>Flags</attribute>
          </attributes>
          <members>
            <member def="None = 0">
              <doc>
                <summary>None comment specified.</summary>
              </doc>
            </member>
            <member def="SingleLine = 1">
              <doc>
                <summary>Single-line comment.</summary>
              </doc>
            </member>
            <member def="MultiLine = 2">
              <doc>
                <summary>Multi-line comment.</summary>
              </doc>
            </member>
            <member def="NonDocumentation = SingleLine | MultiLine">
              <doc>
                <summary>Non-documentation comment (single-line or multi-line).</summary>
              </doc>
            </member>
            <member def="SingleLineDocumentation = 4">
              <doc>
                <summary>Single-line documentation comment.</summary>
              </doc>
            </member>
            <member def="MultiLineDocumentation = 8">
              <doc>
                <summary>Multi-line documentation comment.</summary>
              </doc>
            </member>
            <member def="Documentation = SingleLineDocumentation | MultiLineDocumentation">
              <doc>
                <summary>Documentation comment (single-line or multi-line).</summary>
              </doc>
            </member>
            <member def="All = NonDocumentation | Documentation">
              <doc>
                <summary>Documentation or non-documentation comment.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public enum ModifierFilter">
          <doc>
            <summary>Specifies C# modifier.</summary>
          </doc>
          <attributes>
            <attribute>Flags</attribute>
          </attributes>
          <members>
            <member def="None = 0">
              <doc>
                <summary>None modifier.</summary>
              </doc>
            </member>
            <member def="New = 1">
              <doc>
                <summary>A "new" modifier.</summary>
              </doc>
            </member>
            <member def="Public = 2">
              <doc>
                <summary>A "public" modifier.</summary>
              </doc>
            </member>
            <member def="Private = 4">
              <doc>
                <summary>A "private" modifier.</summary>
              </doc>
            </member>
            <member def="Protected = 8">
              <doc>
                <summary>A "protected" modifier.</summary>
              </doc>
            </member>
            <member def="Internal = 16">
              <doc>
                <summary>An "internal" modifier.</summary>
              </doc>
            </member>
            <member def="Accessibility = Public | Private | Protected | Internal">
              <doc>
                <summary>An accessibility modifier.</summary>
              </doc>
            </member>
            <member def="Const = 32">
              <doc>
                <summary>A "const" modifier.</summary>
              </doc>
            </member>
            <member def="Static = 64">
              <doc>
                <summary>A "static" modifier.</summary>
              </doc>
            </member>
            <member def="Virtual = 128">
              <doc>
                <summary>A "virtual" modifier.</summary>
              </doc>
            </member>
            <member def="Sealed = 256">
              <doc>
                <summary>A "sealed" modifier.</summary>
              </doc>
            </member>
            <member def="Override = 512">
              <doc>
                <summary>An "override" modifier.</summary>
              </doc>
            </member>
            <member def="Abstract = 1024">
              <doc>
                <summary>An "abstract" modifier.</summary>
              </doc>
            </member>
            <member def="AbstractVirtualOverride = Virtual | Override | Abstract">
              <doc>
                <summary>"abstract", "virtual" or "override" modifier.</summary>
              </doc>
            </member>
            <member def="ReadOnly = 2048">
              <doc>
                <summary>A "readonly" modifier.</summary>
              </doc>
            </member>
            <member def="Extern = 4096">
              <doc>
                <summary>An "extern" modifier.</summary>
              </doc>
            </member>
            <member def="Unsafe = 8192">
              <doc>
                <summary>A "unsafe" modifier.</summary>
              </doc>
            </member>
            <member def="Volatile = 16384">
              <doc>
                <summary>A "volatile" modifier.</summary>
              </doc>
            </member>
            <member def="Async = 32768">
              <doc>
                <summary>An "async" modifier.</summary>
              </doc>
            </member>
            <member def="Partial = 65536">
              <doc>
                <summary>A "partial" modifier.</summary>
              </doc>
            </member>
            <member def="Ref = 131072">
              <doc>
                <summary>A "ref" modifier.</summary>
              </doc>
            </member>
            <member def="Out = 262144">
              <doc>
                <summary>An "out" modifier.</summary>
              </doc>
            </member>
            <member def="In = 524288">
              <doc>
                <summary>An "in" modifier.</summary>
              </doc>
            </member>
            <member def="Params = 1048576">
              <doc>
                <summary>A "params" modifier.</summary>
              </doc>
            </member>
            <member def="This = 2097152">
              <doc>
                <summary>A "this" modifier.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public enum NullCheckStyles">
          <doc>
            <summary>Specifies a null check.</summary>
          </doc>
          <attributes>
            <attribute>Flags</attribute>
          </attributes>
          <members>
            <member def="None = 0">
              <doc>
                <summary>No null check specified.</summary>
              </doc>
            </member>
            <member def="EqualsToNull = 1">
              <doc>
                <summary><c>x == null</c></summary>
              </doc>
            </member>
            <member def="NotEqualsToNull = 2">
              <doc>
                <summary><c>x != null</c></summary>
              </doc>
            </member>
            <member def="ComparisonToNull = EqualsToNull | NotEqualsToNull">
              <doc>
                <summary>Expression that uses equality/inequality operator.</summary>
              </doc>
            </member>
            <member def="IsNull = 4">
              <doc>
                <summary><c>x is null</c></summary>
              </doc>
            </member>
            <member def="NotIsNull = 8">
              <doc>
                <summary><c>!(x is null)</c></summary>
              </doc>
            </member>
            <member def="IsPattern = IsNull | NotIsNull">
              <doc>
                <summary>Expression that uses pattern syntax.</summary>
              </doc>
            </member>
            <member def="NotHasValue = 16">
              <doc>
                <summary><c>!x.HasValue</c></summary>
              </doc>
            </member>
            <member def="CheckingNull = EqualsToNull | IsNull | NotHasValue">
              <doc>
                <summary>Expression that checks whether an expression is null.</summary>
              </doc>
            </member>
            <member def="HasValue = 32">
              <doc>
                <summary><c>x.HasValue</c></summary>
              </doc>
            </member>
            <member def="CheckingNotNull = NotEqualsToNull | NotIsNull | HasValue">
              <doc>
                <summary>Expression that checks whether an expression is not null.</summary>
              </doc>
            </member>
            <member def="HasValueProperty = NotHasValue | HasValue">
              <doc>
                <summary>Expression that uses <see cref="P:System.Nullable`1.HasValue" /> property.</summary>
              </doc>
            </member>
            <member def="All = ComparisonToNull | IsPattern | HasValueProperty">
              <doc>
                <summary>All null check styles.</summary>
              </doc>
            </member>
          </members>
        </type>
        <type def="public enum PreprocessorDirectiveFilter">
          <doc>
            <summary>Specifies C# preprocessor directives.</summary>
          </doc>
          <attributes>
            <attribute>Flags</attribute>
          </attributes>
          <members>
            <member def="None = 0">
              <doc>
                <summary>No preprocessor directive.</summary>
              </doc>
            </member>
            <member def="If = 1">
              <doc>
                <summary>#if preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Elif = 2">
              <doc>
                <summary>#elif preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Else = 4">
              <doc>
                <summary>#else preprocessor directive.</summary>
              </doc>
            </member>
            <member def="EndIf = 8">
              <doc>
                <summary>#endif preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Region = 16">
              <doc>
                <summary>#region preprocessor directive.</summary>
              </doc>
            </member>
            <member def="EndRegion = 32">
              <doc>
                <summary>#endregion preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Define = 64">
              <doc>
                <summary>#define preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Undef = 128">
              <doc>
                <summary>#undef preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Error = 256">
              <doc>
                <summary>#error preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Warning = 512">
              <doc>
                <summary>#warning preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Line = 1024">
              <doc>
                <summary>#line preprocessor directive.</summary>
              </doc>
            </member>
            <member def="PragmaWarning = 2048">
              <doc>
                <summary>#pragma warning preprocessor directive.</summary>
              </doc>
            </member>
            <member def="PragmaChecksum = 4096">
              <doc>
                <summary>#pragma checksum preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Pragma = PragmaWarning | PragmaChecksum">
              <doc>
                <summary>#pragma preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Reference = 8192">
              <doc>
                <summary>#r preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Load = 16384">
              <doc>
                <summary>#load preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Bad = 32768">
              <doc>
                <summary>Bad preprocessor directive.</summary>
              </doc>
            </member>
            <member def="Shebang = 65536">
              <doc>
                <summary>Shebang preprocessor directive.</summary>
              </doc>
            </member>
            <member def="All = If | Elif | Else | EndIf | Region | EndRegion | Define | Undef | Error | Warning | Line | Pragma | Reference | Load | Bad | Shebang">
              <doc>
                <summary>All preprocessor directives.</summary>
              </doc>
            </member>
          </members>
        </type>
      </types>
    </namespace>
    <namespace name="Roslynator.CSharp.Syntax">
      <types>
        <type def="public readonly struct AsExpressionInfo : IEquatable&lt;AsExpressionInfo&gt;">
          <doc>
            <summary>Provides information about "as" expression.</summary>
          </doc>
          <members>
            <member def="public BinaryExpressionSyntax AsExpression { get; }">
              <doc>
                <summary>The "as" expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Expression { get; }">
              <doc>
                <summary>The expression that is being casted.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken OperatorToken { get; }">
              <doc>
                <summary>The "as" operator token.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public TypeSyntax Type { get; }">
              <doc>
                <summary>The type to which the expression is being cast.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(AsExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in AsExpressionInfo info1, in AsExpressionInfo info2)" />
            <member def="public static bool operator !=(in AsExpressionInfo info1, in AsExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct AssignmentExpressionInfo : IEquatable&lt;AssignmentExpressionInfo&gt;">
          <doc>
            <summary>Provides information about simple assignment expression.</summary>
          </doc>
          <members>
            <member def="public AssignmentExpressionSyntax AssignmentExpression { get; }">
              <doc>
                <summary>The simple assignment expression.</summary>
              </doc>
            </member>
            <member def="public SyntaxKind Kind { get; }">
              <doc>
                <summary>The kind of the assignment expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Left { get; }">
              <doc>
                <summary>The expression on the left of the assignment operator.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken OperatorToken { get; }">
              <doc>
                <summary>The operator of the simple assignment expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Right { get; }">
              <doc>
                <summary>The expression on the right of the assignment operator.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(AssignmentExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2)" />
            <member def="public static bool operator !=(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct BinaryExpressionInfo : IEquatable&lt;BinaryExpressionInfo&gt;">
          <doc>
            <summary>Provides information about binary expression.</summary>
          </doc>
          <members>
            <member def="public BinaryExpressionSyntax BinaryExpression { get; }">
              <doc>
                <summary>The binary expression.</summary>
              </doc>
            </member>
            <member def="public SyntaxKind Kind { get; }">
              <doc>
                <summary>The kind of the binary expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Left { get; }">
              <doc>
                <summary>The expression on the left of the binary operator.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken OperatorToken { get; }">
              <doc>
                <summary>The operator of the binary expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Right { get; }">
              <doc>
                <summary>The expression on the right of the binary operator.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public ExpressionChain AsChain()">
              <doc>
                <summary>Returns <see cref="T:Roslynator.CSharp.ExpressionChain" /> that enables to enumerate expressions of a binary expression.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(BinaryExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public IEnumerable&lt;ExpressionSyntax&gt; Expressions(bool leftToRight = false)">
              <doc>
                <summary>Returns expressions of this binary expression, including expressions of nested binary expressions of the same kind as parent binary expression.</summary>
                <param name="leftToRight">If true expressions are enumerated as they are displayed in the source code.</param>
              </doc>
              <attributes>
                <attribute>Obsolete("This method is obsolete. Use method 'AsChain' instead.")</attribute>
              </attributes>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2)" />
            <member def="public static bool operator !=(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct ConditionalExpressionInfo : IEquatable&lt;ConditionalExpressionInfo&gt;">
          <doc>
            <summary>Provides information about conditional expression.</summary>
          </doc>
          <members>
            <member def="public SyntaxToken ColonToken { get; }">
              <doc>
                <summary>The token representing the colon.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Condition { get; }">
              <doc>
                <summary>The condition expression.</summary>
              </doc>
            </member>
            <member def="public ConditionalExpressionSyntax ConditionalExpression { get; }">
              <doc>
                <summary>The conditional expression.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken QuestionToken { get; }">
              <doc>
                <summary>The token representing the question mark.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax WhenFalse { get; }">
              <doc>
                <summary>The expression to be executed when the expression is false.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax WhenTrue { get; }">
              <doc>
                <summary>The expression to be executed when the expression is true.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(ConditionalExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2)" />
            <member def="public static bool operator !=(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct GenericInfo : IEquatable&lt;GenericInfo&gt;">
          <doc>
            <summary>Provides information about generic syntax (class, struct, interface, delegate, method or local function).</summary>
          </doc>
          <members>
            <member def="public SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; ConstraintClauses { get; }">
              <doc>
                <summary>A list of constraint clauses.</summary>
              </doc>
            </member>
            <member def="public SyntaxKind Kind { get; }">
              <doc>
                <summary>The kind of this syntax node.</summary>
              </doc>
            </member>
            <member def="public SyntaxNode Node { get; }">
              <doc>
                <summary>The syntax node that can be generic (for example <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax" /> for a class or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax" /> for a local function).</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public TypeParameterListSyntax TypeParameterList { get; }">
              <doc>
                <summary>The type parameter list.</summary>
              </doc>
            </member>
            <member def="public SeparatedSyntaxList&lt;TypeParameterSyntax&gt; TypeParameters { get; }">
              <doc>
                <summary>A list of type parameters.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(GenericInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public TypeParameterConstraintClauseSyntax FindConstraintClause(string typeParameterName)">
              <doc>
                <summary>Searches for a constraint clause with the specified type parameter name and returns the first occurrence within the constraint clauses.</summary>
              </doc>
            </member>
            <member def="public TypeParameterSyntax FindTypeParameter(string name)">
              <doc>
                <summary>Searches for a type parameter with the specified name and returns the first occurrence within the type parameters.</summary>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public GenericInfo RemoveAllConstraintClauses()">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with all constraint clauses removed.</summary>
              </doc>
            </member>
            <member def="public GenericInfo RemoveConstraintClause(TypeParameterConstraintClauseSyntax constraintClause)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with the specified constraint clause removed.</summary>
              </doc>
            </member>
            <member def="public GenericInfo RemoveTypeParameter(TypeParameterSyntax typeParameter)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with the specified type parameter removed.</summary>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public GenericInfo WithConstraintClauses(SyntaxList&lt;TypeParameterConstraintClauseSyntax&gt; constraintClauses)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with the constraint clauses updated.</summary>
              </doc>
            </member>
            <member def="public GenericInfo WithTypeParameterList(TypeParameterListSyntax typeParameterList)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.GenericInfo" /> with the type parameter list updated.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in GenericInfo info1, in GenericInfo info2)" />
            <member def="public static bool operator !=(in GenericInfo info1, in GenericInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct IsExpressionInfo : IEquatable&lt;IsExpressionInfo&gt;">
          <doc>
            <summary>Provides information about "is" expression.</summary>
          </doc>
          <members>
            <member def="public ExpressionSyntax Expression { get; }">
              <doc>
                <summary>The expression that is being casted.</summary>
              </doc>
            </member>
            <member def="public BinaryExpressionSyntax IsExpression { get; }">
              <doc>
                <summary>The "is" expression.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken OperatorToken { get; }">
              <doc>
                <summary>The "is" operator token.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public TypeSyntax Type { get; }">
              <doc>
                <summary>The type to which the expression is being cast.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(IsExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in IsExpressionInfo info1, in IsExpressionInfo info2)" />
            <member def="public static bool operator !=(in IsExpressionInfo info1, in IsExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct LocalDeclarationStatementInfo : IEquatable&lt;LocalDeclarationStatementInfo&gt;">
          <doc>
            <summary>Provides information about local declaration statement.</summary>
          </doc>
          <members>
            <member def="public VariableDeclarationSyntax Declaration { get; }">
              <doc>
                <summary>The variable declaration.</summary>
              </doc>
            </member>
            <member def="public SyntaxTokenList Modifiers { get; }">
              <doc>
                <summary>The modifier list.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken SemicolonToken { get; }">
              <doc>
                <summary>The semicolon token.</summary>
              </doc>
            </member>
            <member def="public LocalDeclarationStatementSyntax Statement { get; }">
              <doc>
                <summary>The local declaration statement.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public TypeSyntax Type { get; }">
              <doc>
                <summary>The type of the declaration.</summary>
              </doc>
            </member>
            <member def="public SeparatedSyntaxList&lt;VariableDeclaratorSyntax&gt; Variables { get; }">
              <doc>
                <summary>A list of variables.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(LocalDeclarationStatementInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2)" />
            <member def="public static bool operator !=(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct MemberDeclarationListInfo : IEquatable&lt;MemberDeclarationListInfo&gt;, IReadOnlyList&lt;MemberDeclarationSyntax&gt;">
          <doc>
            <summary>Provides information about a list of member declaration list.</summary>
          </doc>
          <members>
            <member def="public int Count { get; }">
              <doc>
                <summary>A number of members in the list.</summary>
              </doc>
            </member>
            <member def="public SyntaxList&lt;MemberDeclarationSyntax&gt; Members { get; }">
              <doc>
                <summary>A list of members.</summary>
              </doc>
            </member>
            <member def="public SyntaxNode Parent { get; }">
              <doc>
                <summary>The declaration that contains the members.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationSyntax this[int index] { get; }">
              <doc>
                <summary>Gets the member at the specified index in the list.</summary>
                <returns>The member at the specified index in the list.</returns>
                <param name="index">The zero-based index of the member to get. </param>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo Add(MemberDeclarationSyntax member)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member added at the end.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo AddRange(IEnumerable&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified members added at the end.</summary>
              </doc>
            </member>
            <member def="public bool Any()">
              <doc>
                <summary>True if the list has at least one member.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(MemberDeclarationListInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public MemberDeclarationSyntax First()">
              <doc>
                <summary>The first member in the list.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationSyntax FirstOrDefault()">
              <doc>
                <summary>The first member in the list or null if the list is empty.</summary>
              </doc>
            </member>
            <member def="public SyntaxList&lt;MemberDeclarationSyntax&gt;.Enumerator GetEnumerator()">
              <doc>
                <summary>Gets the enumerator for the list of members.</summary>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public int IndexOf(MemberDeclarationSyntax member)">
              <doc>
                <summary>The index of the member in the list.</summary>
              </doc>
            </member>
            <member def="public int IndexOf(Func&lt;MemberDeclarationSyntax, bool&gt; predicate)">
              <doc>
                <summary>Searches for a member that matches the predicate and returns returns zero-based index of the first occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo Insert(int index, MemberDeclarationSyntax member)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member inserted at the index.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo InsertRange(int index, IEnumerable&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified members inserted at the index.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationSyntax Last()">
              <doc>
                <summary>The last member in the list.</summary>
              </doc>
            </member>
            <member def="public int LastIndexOf(MemberDeclarationSyntax member)">
              <doc>
                <summary>Searches for a member and returns zero-based index of the last occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public int LastIndexOf(Func&lt;MemberDeclarationSyntax, bool&gt; predicate)">
              <doc>
                <summary>Searches for a member that matches the predicate and returns returns zero-based index of the last occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationSyntax LastOrDefault()">
              <doc>
                <summary>The last member in the list or null if the list is empty.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo Remove(MemberDeclarationSyntax member)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member removed.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo RemoveAt(int index)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the member at the specified index removed.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified node removed.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo Replace(MemberDeclarationSyntax memberInList, MemberDeclarationSyntax newMember)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member replaced with the new member.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo ReplaceAt(int index, MemberDeclarationSyntax newMember)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the member at the specified index replaced with a new member.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified old node replaced with a new node.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo ReplaceRange(MemberDeclarationSyntax memberInList, IEnumerable&lt;MemberDeclarationSyntax&gt; newMembers)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the specified member replaced with new members.</summary>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo WithMembers(IEnumerable&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public MemberDeclarationListInfo WithMembers(SyntaxList&lt;MemberDeclarationSyntax&gt; members)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.MemberDeclarationListInfo" /> with the members updated.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2)" />
            <member def="public static bool operator !=(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct ModifierListInfo : IEquatable&lt;ModifierListInfo&gt;">
          <doc>
            <summary>Provides information about modifier list.</summary>
          </doc>
          <members>
            <member def="public Accessibility ExplicitAccessibility { get; }">
              <doc>
                <summary>The explicit accessibility.</summary>
              </doc>
            </member>
            <member def="public bool IsAbstract { get; }">
              <doc>
                <summary>True if the modifier list contains "abstract" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsAsync { get; }">
              <doc>
                <summary>True if the modifier list contains "async" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsConst { get; }">
              <doc>
                <summary>True if the modifier list contains "const" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsExtern { get; }">
              <doc>
                <summary>True if the modifier list contains "extern" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsIn { get; }">
              <doc>
                <summary>True if the modifier list contains "in" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsNew { get; }">
              <doc>
                <summary>True if the modifier list contains "new" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsOut { get; }">
              <doc>
                <summary>True if the modifier list contains "out" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsOverride { get; }">
              <doc>
                <summary>True if the modifier list contains "override" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsParams { get; }">
              <doc>
                <summary>True if the modifier list contains "params" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsPartial { get; }">
              <doc>
                <summary>True if the modifier list contains "partial" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsReadOnly { get; }">
              <doc>
                <summary>True if the modifier list contains "readonly" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsRef { get; }">
              <doc>
                <summary>True if the modifier list contains "ref" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsSealed { get; }">
              <doc>
                <summary>True if the modifier list contains "sealed" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsStatic { get; }">
              <doc>
                <summary>True if the modifier list contains "static" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsUnsafe { get; }">
              <doc>
                <summary>True if the modifier list contains "unsafe" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsVirtual { get; }">
              <doc>
                <summary>True if the modifier list contains "virtual" modifier.</summary>
              </doc>
            </member>
            <member def="public bool IsVolatile { get; }">
              <doc>
                <summary>True if the modifier list contains "volatile" modifier.</summary>
              </doc>
            </member>
            <member def="public SyntaxTokenList Modifiers { get; }">
              <doc>
                <summary>The modifier list.</summary>
              </doc>
            </member>
            <member def="public SyntaxNode Parent { get; }">
              <doc>
                <summary>The node that contains the modifiers.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(ModifierListInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public ModifierFilter GetFilter()">
              <doc>
                <summary>Gets the modifier filter.</summary>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public ModifierListInfo WithExplicitAccessibility(Accessibility newAccessibility, IComparer&lt;SyntaxKind&gt; comparer = null)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> with accessibility modifiers updated.</summary>
              </doc>
            </member>
            <member def="public ModifierListInfo WithModifiers(SyntaxTokenList modifiers)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> with the specified modifiers updated.</summary>
              </doc>
            </member>
            <member def="public ModifierListInfo WithoutExplicitAccessibility()">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.ModifierListInfo" /> with accessibility modifiers removed.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in ModifierListInfo info1, in ModifierListInfo info2)" />
            <member def="public static bool operator !=(in ModifierListInfo info1, in ModifierListInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct NullCheckExpressionInfo : IEquatable&lt;NullCheckExpressionInfo&gt;">
          <doc>
            <summary>Provides information about a null check expression.</summary>
          </doc>
          <members>
            <member def="public ExpressionSyntax Expression { get; }">
              <doc>
                <summary>The expression that is evaluated whether is (not) null. for example "x" in "x == null".</summary>
              </doc>
            </member>
            <member def="public bool IsCheckingNotNull { get; }">
              <doc>
                <summary>Determines whether this null check is checking if the expression is not null.</summary>
              </doc>
            </member>
            <member def="public bool IsCheckingNull { get; }">
              <doc>
                <summary>Determines whether this null check is checking if the expression is null.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax NullCheckExpression { get; }">
              <doc>
                <summary>The null check expression, e.g. "x == null".</summary>
              </doc>
            </member>
            <member def="public NullCheckStyles Style { get; }">
              <doc>
                <summary>The style of this null check.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(NullCheckExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2)" />
            <member def="public static bool operator !=(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct RegionInfo : IEquatable&lt;RegionInfo&gt;">
          <doc>
            <summary>Provides information about a region.</summary>
          </doc>
          <members>
            <member def="public RegionDirectiveTriviaSyntax Directive { get; }">
              <doc>
                <summary>#region directive.</summary>
              </doc>
            </member>
            <member def="public EndRegionDirectiveTriviaSyntax EndDirective { get; }">
              <doc>
                <summary>#endregion directive.</summary>
              </doc>
            </member>
            <member def="public TextSpan FullSpan { get; }">
              <doc>
                <summary>The absolute span of this region, including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public bool IsEmpty { get; }">
              <doc>
                <summary>Determines whether this region is empty, i.e. contains only white-space.</summary>
              </doc>
            </member>
            <member def="public TextSpan Span { get; }">
              <doc>
                <summary>The absolute span of this region, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(RegionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in RegionInfo info1, in RegionInfo info2)" />
            <member def="public static bool operator !=(in RegionInfo info1, in RegionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct SimpleAssignmentExpressionInfo : IEquatable&lt;SimpleAssignmentExpressionInfo&gt;">
          <doc>
            <summary>Provides information about simple assignment expression.</summary>
          </doc>
          <members>
            <member def="public AssignmentExpressionSyntax AssignmentExpression { get; }">
              <doc>
                <summary>The simple assignment expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Left { get; }">
              <doc>
                <summary>The expression on the left of the assignment operator.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken OperatorToken { get; }">
              <doc>
                <summary>The operator of the simple assignment expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Right { get; }">
              <doc>
                <summary>The expression on the right of the assignment operator.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(SimpleAssignmentExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2)" />
            <member def="public static bool operator !=(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct SimpleAssignmentStatementInfo : IEquatable&lt;SimpleAssignmentStatementInfo&gt;">
          <doc>
            <summary>Provides information about a simple assignment expression in an expression statement.</summary>
          </doc>
          <members>
            <member def="public AssignmentExpressionSyntax AssignmentExpression { get; }">
              <doc>
                <summary>The simple assignment expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Left { get; }">
              <doc>
                <summary>The expression on the left of the assignment operator.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken OperatorToken { get; }">
              <doc>
                <summary>The operator of the simple assignment expression.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Right { get; }">
              <doc>
                <summary>The expression of the right of the assignment operator.</summary>
              </doc>
            </member>
            <member def="public ExpressionStatementSyntax Statement { get; }">
              <doc>
                <summary>The expression statement the simple assignment expression is contained in.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(SimpleAssignmentStatementInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2)" />
            <member def="public static bool operator !=(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct SimpleIfElseInfo : IEquatable&lt;SimpleIfElseInfo&gt;">
          <doc>
            <summary>
            Provides information about a simple if-else.
            Simple if-else is defined as follows: it is not a child of an else clause and it has an else clause and the else clause does not continue with another if statement.
            </summary>
          </doc>
          <members>
            <member def="public ExpressionSyntax Condition { get; }">
              <doc>
                <summary>The condition.</summary>
              </doc>
            </member>
            <member def="public ElseClauseSyntax Else { get; }">
              <doc>
                <summary>The else clause.</summary>
              </doc>
            </member>
            <member def="public IfStatementSyntax IfStatement { get; }">
              <doc>
                <summary>The if statement.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public StatementSyntax WhenFalse { get; }">
              <doc>
                <summary>The statement that is executed if the condition evaluates to false.</summary>
              </doc>
            </member>
            <member def="public StatementSyntax WhenTrue { get; }">
              <doc>
                <summary>The statement that is executed if the condition evaluates to true.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(SimpleIfElseInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2)" />
            <member def="public static bool operator !=(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct SimpleIfStatementInfo : IEquatable&lt;SimpleIfStatementInfo&gt;">
          <doc>
            <summary>
            Provides information about a simple if statement.
            Simple if statement is defined as follows: it is not a child of an else clause and it has no else clause.
            </summary>
          </doc>
          <members>
            <member def="public ExpressionSyntax Condition { get; }">
              <doc>
                <summary>The condition.</summary>
              </doc>
            </member>
            <member def="public IfStatementSyntax IfStatement { get; }">
              <doc>
                <summary>The if statement.</summary>
              </doc>
            </member>
            <member def="public StatementSyntax Statement { get; }">
              <doc>
                <summary>The statement.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(SimpleIfStatementInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2)" />
            <member def="public static bool operator !=(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct SimpleMemberInvocationExpressionInfo : IEquatable&lt;SimpleMemberInvocationExpressionInfo&gt;">
          <doc>
            <summary>Provides information about invocation expression.</summary>
          </doc>
          <members>
            <member def="public ArgumentListSyntax ArgumentList { get; }">
              <doc>
                <summary>The argumet list.</summary>
              </doc>
            </member>
            <member def="public SeparatedSyntaxList&lt;ArgumentSyntax&gt; Arguments { get; }">
              <doc>
                <summary>The list of the arguments.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Expression { get; }">
              <doc>
                <summary>The expression that contains the member being invoked.</summary>
              </doc>
            </member>
            <member def="public InvocationExpressionSyntax InvocationExpression { get; }">
              <doc>
                <summary>The invocation expression.</summary>
              </doc>
            </member>
            <member def="public MemberAccessExpressionSyntax MemberAccessExpression { get; }">
              <doc>
                <summary>The member access expression.</summary>
              </doc>
            </member>
            <member def="public SimpleNameSyntax Name { get; }">
              <doc>
                <summary>The name of the member being invoked.</summary>
              </doc>
            </member>
            <member def="public string NameText { get; }">
              <doc>
                <summary>The name of the member being invoked.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken OperatorToken { get; }">
              <doc>
                <summary>The operator in the member access expression.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(SimpleMemberInvocationExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2)" />
            <member def="public static bool operator !=(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct SimpleMemberInvocationStatementInfo : IEquatable&lt;SimpleMemberInvocationStatementInfo&gt;">
          <doc>
            <summary>Provides information about invocation expression in an expression statement.</summary>
          </doc>
          <members>
            <member def="public ArgumentListSyntax ArgumentList { get; }">
              <doc>
                <summary>The argument list.</summary>
              </doc>
            </member>
            <member def="public SeparatedSyntaxList&lt;ArgumentSyntax&gt; Arguments { get; }">
              <doc>
                <summary>A list of arguments.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Expression { get; }">
              <doc>
                <summary>The expression that contains the member being invoked.</summary>
              </doc>
            </member>
            <member def="public InvocationExpressionSyntax InvocationExpression { get; }">
              <doc>
                <summary>The invocation expression.</summary>
              </doc>
            </member>
            <member def="public MemberAccessExpressionSyntax MemberAccessExpression { get; }">
              <doc>
                <summary>The member access expression.</summary>
              </doc>
            </member>
            <member def="public SimpleNameSyntax Name { get; }">
              <doc>
                <summary>The name of the member being invoked.</summary>
              </doc>
            </member>
            <member def="public string NameText { get; }">
              <doc>
                <summary>The name of the member being invoked.</summary>
              </doc>
            </member>
            <member def="public ExpressionStatementSyntax Statement { get; }">
              <doc>
                <summary>The expression statement that contains the invocation expression.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(SimpleMemberInvocationStatementInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2)" />
            <member def="public static bool operator !=(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct SingleLocalDeclarationStatementInfo : IEquatable&lt;SingleLocalDeclarationStatementInfo&gt;">
          <doc>
            <summary>Provides information about a local declaration statement with a single variable.</summary>
          </doc>
          <members>
            <member def="public VariableDeclarationSyntax Declaration { get; }">
              <doc>
                <summary>The variable declaration.</summary>
              </doc>
            </member>
            <member def="public VariableDeclaratorSyntax Declarator { get; }">
              <doc>
                <summary>The variable declarator.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken EqualsToken { get; }">
              <doc>
                <summary>The equals token.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken Identifier { get; }">
              <doc>
                <summary>Variable identifier.</summary>
              </doc>
            </member>
            <member def="public string IdentifierText { get; }">
              <doc>
                <summary>Variable name.</summary>
              </doc>
            </member>
            <member def="public EqualsValueClauseSyntax Initializer { get; }">
              <doc>
                <summary>The variable initializer, if any.</summary>
              </doc>
            </member>
            <member def="public SyntaxTokenList Modifiers { get; }">
              <doc>
                <summary>The modifier list.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken SemicolonToken { get; }">
              <doc>
                <summary>The semicolon.</summary>
              </doc>
            </member>
            <member def="public LocalDeclarationStatementSyntax Statement { get; }">
              <doc>
                <summary>The local declaration statement.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public TypeSyntax Type { get; }">
              <doc>
                <summary>The type of a declaration.</summary>
              </doc>
            </member>
            <member def="public ExpressionSyntax Value { get; }">
              <doc>
                <summary>The initialized value, if any.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(SingleLocalDeclarationStatementInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2)" />
            <member def="public static bool operator !=(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct SingleParameterLambdaExpressionInfo : IEquatable&lt;SingleParameterLambdaExpressionInfo&gt;">
          <doc>
            <summary>Provides information about a lambda expression with a single parameter.</summary>
          </doc>
          <members>
            <member def="public CSharpSyntaxNode Body { get; }">
              <doc>
                <summary>The body of the lambda expression.</summary>
              </doc>
            </member>
            <member def="public bool IsParenthesizedLambda { get; }">
              <doc>
                <summary>True if this instance is a parenthesized lambda expression.</summary>
              </doc>
            </member>
            <member def="public bool IsSimpleLambda { get; }">
              <doc>
                <summary>True if this instance is a simple lambda expression.</summary>
              </doc>
            </member>
            <member def="public LambdaExpressionSyntax LambdaExpression { get; }">
              <doc>
                <summary>The lambda expression.</summary>
              </doc>
            </member>
            <member def="public ParameterSyntax Parameter { get; }">
              <doc>
                <summary>The parameter.</summary>
              </doc>
            </member>
            <member def="public ParameterListSyntax ParameterList { get; }">
              <doc>
                <summary>The parameter list that contains the parameter.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(SingleParameterLambdaExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2)" />
            <member def="public static bool operator !=(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct StatementListInfo : IEquatable&lt;StatementListInfo&gt;, IReadOnlyList&lt;StatementSyntax&gt;">
          <doc>
            <summary>Provides information about a list of statements.</summary>
          </doc>
          <members>
            <member def="public int Count { get; }">
              <doc>
                <summary>The number of statement in the list.</summary>
              </doc>
            </member>
            <member def="public bool IsParentBlock { get; }">
              <doc>
                <summary>Determines whether the statements are contained in a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" />.</summary>
              </doc>
            </member>
            <member def="public bool IsParentSwitchSection { get; }">
              <doc>
                <summary>Determines whether the statements are contained in a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax" />.</summary>
              </doc>
            </member>
            <member def="public SyntaxNode Parent { get; }">
              <doc>
                <summary>The node that contains the statements. It can be either a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax" /> or a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax" />.</summary>
              </doc>
            </member>
            <member def="public BlockSyntax ParentAsBlock { get; }">
              <doc>
                <summary>Gets a block that contains the statements. Returns null if the statements are not contained in a block.</summary>
              </doc>
            </member>
            <member def="public SwitchSectionSyntax ParentAsSwitchSection { get; }">
              <doc>
                <summary>Gets a switch section that contains the statements. Returns null if the statements are not contained in a switch section.</summary>
              </doc>
            </member>
            <member def="public SyntaxList&lt;StatementSyntax&gt; Statements { get; }">
              <doc>
                <summary>The list of statements.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public StatementSyntax this[int index] { get; }">
              <doc>
                <summary>Gets the statement at the specified index in the list.</summary>
                <returns>The statement at the specified index in the list.</returns>
                <param name="index">The zero-based index of the statement to get. </param>
              </doc>
            </member>
            <member def="public StatementListInfo Add(StatementSyntax statement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement added at the end.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo AddRange(IEnumerable&lt;StatementSyntax&gt; statements)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statements added at the end.</summary>
              </doc>
            </member>
            <member def="public bool Any()">
              <doc>
                <summary>True if the list has at least one statement.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(StatementListInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public StatementSyntax First()">
              <doc>
                <summary>The first statement in the list.</summary>
              </doc>
            </member>
            <member def="public StatementSyntax FirstOrDefault()">
              <doc>
                <summary>The first statement in the list or null if the list is empty.</summary>
              </doc>
            </member>
            <member def="public SyntaxList&lt;StatementSyntax&gt;.Enumerator GetEnumerator()">
              <doc>
                <summary>Gets the enumerator the list of statements.</summary>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public int IndexOf(Func&lt;StatementSyntax, bool&gt; predicate)">
              <doc>
                <summary>Searches for a statement that matches the predicate and returns returns zero-based index of the first occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public int IndexOf(StatementSyntax statement)">
              <doc>
                <summary>The index of the statement in the list.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo Insert(int index, StatementSyntax statement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement inserted at the index.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo InsertRange(int index, IEnumerable&lt;StatementSyntax&gt; statements)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statements inserted at the index.</summary>
              </doc>
            </member>
            <member def="public StatementSyntax Last()">
              <doc>
                <summary>The last statement in the list.</summary>
              </doc>
            </member>
            <member def="public int LastIndexOf(Func&lt;StatementSyntax, bool&gt; predicate)">
              <doc>
                <summary>Searches for a statement that matches the predicate and returns returns zero-based index of the last occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public int LastIndexOf(StatementSyntax statement)">
              <doc>
                <summary>Searches for a statement and returns zero-based index of the last occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public StatementSyntax LastOrDefault()">
              <doc>
                <summary>The last statement in the list or null if the list is empty.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo Remove(StatementSyntax statement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement removed.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo RemoveAt(int index)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the statement at the specified index removed.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified node removed.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo Replace(StatementSyntax statementInList, StatementSyntax newStatement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement replaced with the new statement.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo ReplaceAt(int index, StatementSyntax newStatement)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the statement at the specified index replaced with a new statement.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified old node replaced with a new node.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo ReplaceRange(StatementSyntax statementInList, IEnumerable&lt;StatementSyntax&gt; newStatements)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the specified statement replaced with new statements.</summary>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo WithStatements(IEnumerable&lt;StatementSyntax&gt; statements)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the statements updated.</summary>
              </doc>
            </member>
            <member def="public StatementListInfo WithStatements(SyntaxList&lt;StatementSyntax&gt; statements)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.StatementListInfo" /> with the statements updated.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in StatementListInfo info1, in StatementListInfo info2)" />
            <member def="public static bool operator !=(in StatementListInfo info1, in StatementListInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct StringConcatenationExpressionInfo : IEquatable&lt;StringConcatenationExpressionInfo&gt;">
          <doc>
            <summary>Provides information about string concatenation, i.e. a binary expression that binds to string '+' operator.</summary>
          </doc>
          <members>
            <member def="public BinaryExpressionSyntax BinaryExpression { get; }">
              <doc>
                <summary>The binary expression that represents the string concatenation.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public ExpressionChain AsChain()">
              <doc>
                <summary>Returns <see cref="T:Roslynator.CSharp.ExpressionChain" /> that enables to enumerate expressions of a string concatenation.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(StringConcatenationExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public IEnumerable&lt;ExpressionSyntax&gt; Expressions(bool leftToRight = false)">
              <doc>
                <summary>Returns expressions of this binary expression, including expressions of nested binary expressions of the same kind as parent binary expression.</summary>
                <param name="leftToRight">If true expressions are enumerated as they are displayed in the source code.</param>
              </doc>
              <attributes>
                <attribute>Obsolete("This method is obsolete. Use method 'AsChain' instead.")</attribute>
              </attributes>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2)" />
            <member def="public static bool operator !=(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct StringLiteralExpressionInfo : IEquatable&lt;StringLiteralExpressionInfo&gt;">
          <doc>
            <summary>Provides information about string literal expression.</summary>
          </doc>
          <members>
            <member def="public bool ContainsEscapeSequence { get; }">
              <doc>
                <summary>True if the string literal expression contains escape sequence.</summary>
              </doc>
            </member>
            <member def="public bool ContainsLinefeed { get; }">
              <doc>
                <summary>True if the string literal contains linefeed.</summary>
              </doc>
            </member>
            <member def="public LiteralExpressionSyntax Expression { get; }">
              <doc>
                <summary>The string literal expression.</summary>
              </doc>
            </member>
            <member def="public string InnerText { get; }">
              <doc>
                <summary>The token text, not including leading ampersand, if any, and enclosing quotation marks.</summary>
              </doc>
            </member>
            <member def="public bool IsRegular { get; }">
              <doc>
                <summary>True if this instance is regular string literal expression.</summary>
              </doc>
            </member>
            <member def="public bool IsVerbatim { get; }">
              <doc>
                <summary>True if this instance is verbatim string literal expression.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public string Text { get; }">
              <doc>
                <summary>The token text.</summary>
              </doc>
            </member>
            <member def="public SyntaxToken Token { get; }">
              <doc>
                <summary>The token representing the string literal expression.</summary>
              </doc>
            </member>
            <member def="public string ValueText { get; }">
              <doc>
                <summary>The token value text.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(StringLiteralExpressionInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2)" />
            <member def="public static bool operator !=(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct UsingDirectiveListInfo : IEquatable&lt;UsingDirectiveListInfo&gt;, IReadOnlyList&lt;UsingDirectiveSyntax&gt;">
          <doc>
            <summary>Provides information about a list of using directives.</summary>
          </doc>
          <members>
            <member def="public int Count { get; }">
              <doc>
                <summary>A number of usings in the list.</summary>
              </doc>
            </member>
            <member def="public SyntaxNode Parent { get; }">
              <doc>
                <summary>The declaration that contains the usings.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public SyntaxList&lt;UsingDirectiveSyntax&gt; Usings { get; }">
              <doc>
                <summary>A list of usings.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveSyntax this[int index] { get; }">
              <doc>
                <summary>Gets the using directive at the specified index in the list.</summary>
                <returns>The using directive at the specified index in the list.</returns>
                <param name="index">The zero-based index of the using directive to get. </param>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo Add(UsingDirectiveSyntax usingDirective)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive added at the end.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo AddRange(IEnumerable&lt;UsingDirectiveSyntax&gt; usings)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified usings added at the end.</summary>
              </doc>
            </member>
            <member def="public bool Any()">
              <doc>
                <summary>True if the list has at least one using directive.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(UsingDirectiveListInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public UsingDirectiveSyntax First()">
              <doc>
                <summary>The first using directive in the list.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveSyntax FirstOrDefault()">
              <doc>
                <summary>The first using directive in the list or null if the list is empty.</summary>
              </doc>
            </member>
            <member def="public SyntaxList&lt;UsingDirectiveSyntax&gt;.Enumerator GetEnumerator()">
              <doc>
                <summary>Gets the enumerator for the list of usings.</summary>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public int IndexOf(Func&lt;UsingDirectiveSyntax, bool&gt; predicate)">
              <doc>
                <summary>Searches for an using directive that matches the predicate and returns returns zero-based index of the first occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public int IndexOf(UsingDirectiveSyntax usingDirective)">
              <doc>
                <summary>The index of the using directive in the list.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo Insert(int index, UsingDirectiveSyntax usingDirective)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive inserted at the index.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo InsertRange(int index, IEnumerable&lt;UsingDirectiveSyntax&gt; usings)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified usings inserted at the index.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveSyntax Last()">
              <doc>
                <summary>The last using directive in the list.</summary>
              </doc>
            </member>
            <member def="public int LastIndexOf(Func&lt;UsingDirectiveSyntax, bool&gt; predicate)">
              <doc>
                <summary>Searches for an using directive that matches the predicate and returns returns zero-based index of the last occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public int LastIndexOf(UsingDirectiveSyntax usingDirective)">
              <doc>
                <summary>Searches for an using directive and returns zero-based index of the last occurrence in the list.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveSyntax LastOrDefault()">
              <doc>
                <summary>The last using directive in the list or null if the list is empty.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo Remove(UsingDirectiveSyntax usingDirective)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive removed.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo RemoveAt(int index)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the using directive at the specified index removed.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified node removed.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo Replace(UsingDirectiveSyntax usingInLine, UsingDirectiveSyntax newUsingDirective)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive replaced with the new using directive.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo ReplaceAt(int index, UsingDirectiveSyntax newUsingDirective)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the using directive at the specified index replaced with a new using directive.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified old node replaced with a new node.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo ReplaceRange(UsingDirectiveSyntax usingInLine, IEnumerable&lt;UsingDirectiveSyntax&gt; newUsingDirectives)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the specified using directive replaced with new usings.</summary>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo WithUsings(IEnumerable&lt;UsingDirectiveSyntax&gt; usings)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the usings updated.</summary>
              </doc>
            </member>
            <member def="public UsingDirectiveListInfo WithUsings(SyntaxList&lt;UsingDirectiveSyntax&gt; usings)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.CSharp.Syntax.UsingDirectiveListInfo" /> with the usings updated.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2)" />
            <member def="public static bool operator !=(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2)" />
          </members>
        </type>
        <type def="public readonly struct XmlElementInfo : IEquatable&lt;XmlElementInfo&gt;">
          <doc>
            <summary>Provides information about a <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax" /> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax" />.</summary>
          </doc>
          <members>
            <member def="public XmlNodeSyntax Element { get; }">
              <doc>
                <summary>The xml element.</summary>
              </doc>
            </member>
            <member def="public bool IsEmptyElement { get; }">
              <doc>
                <summary>Determines whether the element is <see cref="F:Microsoft.CodeAnalysis.CSharp.SyntaxKind.XmlEmptyElement" />.</summary>
              </doc>
            </member>
            <member def="public SyntaxKind Kind { get; }">
              <doc>
                <summary>Element kind.</summary>
              </doc>
            </member>
            <member def="public string LocalName { get; }">
              <doc>
                <summary>Local name of the element.</summary>
              </doc>
            </member>
            <member def="public bool Success { get; }">
              <doc>
                <summary>Determines whether this struct was initialized with an actual syntax.</summary>
              </doc>
            </member>
            <member def="public override bool Equals(object obj)">
              <doc>
                <summary>Determines whether this instance and a specified object are equal.</summary>
                <param name="obj">The object to compare with the current instance. </param>
                <returns>true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false. </returns>
              </doc>
            </member>
            <member def="public bool Equals(XmlElementInfo other)">
              <doc>
                <summary>Determines whether this instance is equal to another object of the same type.</summary>
                <param name="other">An object to compare with this object.</param>
                <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
              </doc>
            </member>
            <member def="public override int GetHashCode()">
              <doc>
                <summary>Returns the hash code for this instance.</summary>
                <returns>A 32-bit signed integer that is the hash code for this instance.</returns>
              </doc>
            </member>
            <member def="public override string ToString()">
              <doc>
                <summary>Returns the string representation of the underlying syntax, not including its leading and trailing trivia.</summary>
              </doc>
            </member>
            <member def="public static bool operator ==(in XmlElementInfo info1, in XmlElementInfo info2)" />
            <member def="public static bool operator !=(in XmlElementInfo info1, in XmlElementInfo info2)" />
          </members>
        </type>
      </types>
    </namespace>
    <namespace name="Roslynator.Text">
      <types>
        <type def="public class TextLineCollectionSelection : ISelection&lt;TextLine&gt;">
          <doc>
            <summary>Represents selected lines in a <see cref="T:Microsoft.CodeAnalysis.Text.TextLineCollection" />.</summary>
          </doc>
          <members>
            <member def="protected TextLineCollectionSelection(TextLineCollection lines, TextSpan span, int firstIndex, int lastIndex)">
              <doc>
                <summary>Initializes a new instance of <see cref="T:Roslynator.Text.TextLineCollectionSelection" />.</summary>
              </doc>
            </member>
            <member def="public int Count { get; }">
              <doc>
                <summary>Gets a number of selected lines.</summary>
              </doc>
            </member>
            <member def="public int FirstIndex { get; }">
              <doc>
                <summary>Gets an index of the first selected line.</summary>
              </doc>
            </member>
            <member def="public int LastIndex { get; }">
              <doc>
                <summary>Gets an index of the last selected line.</summary>
              </doc>
            </member>
            <member def="public TextSpan OriginalSpan { get; }">
              <doc>
                <summary>Gets the original span that was used to determine selected lines.</summary>
              </doc>
            </member>
            <member def="public TextLineCollection UnderlyingLines { get; }">
              <doc>
                <summary>Gets an underlying collection that contains selected lines.</summary>
              </doc>
            </member>
            <member def="public TextLine this[int index] { get; }">
              <doc>
                <summary>Gets the selected line at the specified index.</summary>
                <returns>The line at the specified index.</returns>
                <param name="index">The zero-based index of the line to get. </param>
              </doc>
            </member>
            <member def="public static TextLineCollectionSelection Create(TextLineCollection lines, TextSpan span)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.Text.TextLineCollectionSelection" /> based on the specified list and span.</summary>
              </doc>
            </member>
            <member def="public TextLine First()">
              <doc>
                <summary>Gets the first selected line.</summary>
              </doc>
            </member>
            <member def="public TextLineCollectionSelection.Enumerator GetEnumerator()">
              <doc>
                <summary>Returns an enumerator that iterates through selected lines.</summary>
              </doc>
            </member>
            <member def="public TextLine Last()">
              <doc>
                <summary>Gets the last selected line.</summary>
              </doc>
            </member>
            <member def="public static bool TryCreate(TextLineCollection lines, TextSpan span, out TextLineCollectionSelection selectedLines)">
              <doc>
                <summary>Creates a new <see cref="T:Roslynator.Text.TextLineCollectionSelection" /> based on the specified list and span.</summary>
                <returns>True if the specified span contains at least one line; otherwise, false.</returns>
              </doc>
            </member>
          </members>
          <types>
            <type def="public struct Enumerator">
              <members>
                <member def="public TextLine Current { get; }" />
                <member def="public override bool Equals(object obj)" />
                <member def="public override int GetHashCode()" />
                <member def="public bool MoveNext()" />
                <member def="public void Reset()" />
              </members>
            </type>
          </types>
        </type>
      </types>
    </namespace>
  </namespaces>
</root>