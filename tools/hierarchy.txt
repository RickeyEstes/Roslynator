assembly Microsoft.CodeAnalysis, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
  [AssemblyCompany("Microsoft Corporation")]
  [AssemblyCopyright("© Microsoft Corporation. All rights reserved.")]
  [AssemblyFileVersion("2.3.0.61908")]
  [AssemblyInformationalVersion("2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c")]
  [AssemblyMetadata("Serviceable", "True")]
  [RuntimeCompatibility(WrapNonExceptionThrows = true)]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Microsoft.CodeAnalysis.CSharp, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
  [AssemblyCompany("Microsoft Corporation")]
  [AssemblyCopyright("© Microsoft Corporation. All rights reserved.")]
  [AssemblyFileVersion("2.3.0.61908")]
  [AssemblyInformationalVersion("2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c")]
  [AssemblyMetadata("Serviceable", "True")]
  [CommitHash("281ac90b8b5dd9fd923a353afd4af74f3246ca5c")]
  [RuntimeCompatibility(WrapNonExceptionThrows = true)]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Microsoft.CodeAnalysis.CSharp.Workspaces, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
  [AssemblyCompany("Microsoft Corporation")]
  [AssemblyCopyright("© Microsoft Corporation. All rights reserved.")]
  [AssemblyFileVersion("2.3.0.61908")]
  [AssemblyInformationalVersion("2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c")]
  [AssemblyMetadata("Serviceable", "True")]
  [RuntimeCompatibility(WrapNonExceptionThrows = true)]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Microsoft.CodeAnalysis.Workspaces, Version=2.3.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
  [AssemblyCompany("Microsoft Corporation")]
  [AssemblyCopyright("© Microsoft Corporation. All rights reserved.")]
  [AssemblyFileVersion("2.3.0.61908")]
  [AssemblyInformationalVersion("2.3.0-beta4-61908-01. Commit Hash: 281ac90b8b5dd9fd923a353afd4af74f3246ca5c")]
  [AssemblyMetadata("Serviceable", "True")]
  [RuntimeCompatibility(WrapNonExceptionThrows = true)]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Roslynator.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=3aeedfaf14b2cebf
  [AssemblyCompany("Josef Pihrt")]
  [AssemblyConfiguration("Debug")]
  [AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
  [AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.Common.")]
  [AssemblyFileVersion("1.0.0.10")]
  [AssemblyInformationalVersion("1.0.0.10")]
  [AssemblyProduct("Roslynator.Core")]
  [AssemblyTitle("Roslynator.Core")]
  [AssemblyVersion("1.0.0.10")]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Roslynator.CSharp, Version=1.0.0.10, Culture=neutral, PublicKeyToken=390be46f77b79f52
  [AssemblyCompany("Josef Pihrt")]
  [AssemblyConfiguration("Debug")]
  [AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
  [AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.CSharp\n\nCommonly Used Types:\nRoslynator.CSharp.CSharpFactory\nRoslynator.CSharp.CSharpFacts\nRoslynator.CSharp.SyntaxInfo\nRoslynator.NameGenerator")]
  [AssemblyFileVersion("1.0.0.10")]
  [AssemblyInformationalVersion("1.0.0.10")]
  [AssemblyProduct("Roslynator.CSharp")]
  [AssemblyTitle("Roslynator.CSharp")]
  [AssemblyVersion("1.0.0.10")]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Roslynator.CSharp.Workspaces, Version=1.0.0.10, Culture=neutral, PublicKeyToken=ec3f0c29a7973f23
  [AssemblyCompany("Josef Pihrt")]
  [AssemblyConfiguration("Debug")]
  [AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
  [AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.CSharp.Workspaces\n\nCommonly Used Types:\nRoslynator.CSharp.CSharpFactory\nRoslynator.CSharp.CSharpFacts\nRoslynator.CSharp.SyntaxInfo\nRoslynator.NameGenerator")]
  [AssemblyFileVersion("1.0.0.10")]
  [AssemblyInformationalVersion("1.0.0.10")]
  [AssemblyProduct("Roslynator.CSharp.Workspaces")]
  [AssemblyTitle("Roslynator.CSharp.Workspaces")]
  [AssemblyVersion("1.0.0.10")]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

assembly Roslynator.Workspaces.Core, Version=1.0.0.10, Culture=neutral, PublicKeyToken=be1ec334fe31b7bb
  [AssemblyCompany("Josef Pihrt")]
  [AssemblyConfiguration("Debug")]
  [AssemblyCopyright("Copyright (c) 2017-2018 Josef Pihrt")]
  [AssemblyDescription("This library extends functionality of package Microsoft.CodeAnalysis.Workspaces.Common.")]
  [AssemblyFileVersion("1.0.0.10")]
  [AssemblyInformationalVersion("1.0.0.10")]
  [AssemblyProduct("Roslynator.Workspaces.Core")]
  [AssemblyTitle("Roslynator.Workspaces.Core")]
  [AssemblyVersion("1.0.0.10")]
  [TargetFramework(".NETStandard,Version=v1.3", FrameworkDisplayName = "")]

public class System.Object

  public abstract class System.Attribute

    public class System.Composition.ExportAttribute : Attribute

      public sealed class Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute : ExportAttribute

        public ExportCodeFixProviderAttribute(string firstLanguage, params string[] additionalLanguages);

        public string[] Languages { get; }
        public string Name { get; set; }

      public sealed class Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute : ExportAttribute

        public ExportCodeRefactoringProviderAttribute(string firstLanguage, params string[] additionalLanguages);

        public string[] Languages { get; }
        public string Name { get; set; }

      public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute : ExportAttribute

        public ExportLanguageServiceAttribute(Type type, string language, string layer = "Default");

        public string Language { get; }
        public string Layer { get; }
        public string ServiceType { get; }

      public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute : ExportAttribute

        public ExportLanguageServiceFactoryAttribute(Type type, string language, string layer = "Default");

        public string Language { get; }
        public string Layer { get; }
        public string ServiceType { get; }

      public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute : ExportAttribute

        public ExportWorkspaceServiceAttribute(Type serviceType, string layer = "Default");

        public string Layer { get; }
        public string ServiceType { get; }

      public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute : ExportAttribute

        public ExportWorkspaceServiceFactoryAttribute(Type serviceType, string layer = "Default");

        public string Layer { get; }
        public string ServiceType { get; }

    public sealed class Microsoft.CodeAnalysis.ExtensionOrderAttribute : Attribute

      public ExtensionOrderAttribute();

      public string After { get; set; }
      public string Before { get; set; }

    public sealed class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute : Attribute

      public DiagnosticAnalyzerAttribute(string firstLanguage, params string[] additionalLanguages);

      public string[] Languages { get; }

  public abstract class System.Delegate

    public abstract class System.MulticastDelegate : Delegate

      public delegate Task Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction(DocumentEditor editor, SyntaxNode declaration, CancellationToken cancellationToken);

      public delegate void Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction(DocumentEditor editor, SyntaxNode declaration);

      public delegate bool Microsoft.CodeAnalysis.Host.HostWorkspaceServices.MetadataFilter(IReadOnlyDictionary<string, object> metadata);

  public class System.EventArgs

    public sealed class Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs : EventArgs

      public DocumentActiveContextChangedEventArgs(Solution solution, SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId);

      public DocumentId NewActiveContextDocumentId { get; }
      public DocumentId OldActiveContextDocumentId { get; }
      public Solution Solution { get; }
      public SourceTextContainer SourceTextContainer { get; }

    public class Microsoft.CodeAnalysis.DocumentEventArgs : EventArgs

      public DocumentEventArgs(Document document);

      public Document Document { get; }

    public class Microsoft.CodeAnalysis.WorkspaceChangeEventArgs : EventArgs

      public WorkspaceChangeEventArgs(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId = null, DocumentId documentId = null);

      public DocumentId DocumentId { get; }
      public WorkspaceChangeKind Kind { get; }
      public Solution NewSolution { get; }
      public Solution OldSolution { get; }
      public ProjectId ProjectId { get; }

    public class Microsoft.CodeAnalysis.WorkspaceDiagnosticEventArgs : EventArgs

      public WorkspaceDiagnosticEventArgs(WorkspaceDiagnostic diagnostic);

      public WorkspaceDiagnostic Diagnostic { get; }

    public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs : EventArgs

      public AnalyzerLoadFailureEventArgs(AnalyzerLoadFailureEventArgs.FailureErrorCode errorCode, string message, Exception exceptionOpt = null, string typeNameOpt = null);

      public AnalyzerLoadFailureEventArgs.FailureErrorCode ErrorCode { get; }
      public Exception Exception { get; }
      public string Message { get; }
      public string TypeName { get; }

    public class Microsoft.CodeAnalysis.Text.TextChangeEventArgs : EventArgs

      public TextChangeEventArgs(SourceText oldText, SourceText newText, IEnumerable<TextChangeRange> changes);
      public TextChangeEventArgs(SourceText oldText, SourceText newText, params TextChangeRange[] changes);

      public IReadOnlyList<TextChangeRange> Changes { get; }
      public SourceText NewText { get; }
      public SourceText OldText { get; }

  public abstract class System.ValueType

    public abstract class System.Enum : ValueType, IComparable, IConvertible, IFormattable

      public enum Microsoft.CodeAnalysis.Accessibility

        NotApplicable = 0,
        Private = 1,
        ProtectedAndInternal = 2,
        ProtectedAndFriend = 2,
        Protected = 3,
        Internal = 4,
        Friend = 4,
        ProtectedOrInternal = 5,
        ProtectedOrFriend = 5,
        Public = 6,

      public enum Microsoft.CodeAnalysis.ApplyChangesKind

        AddProject = 0,
        RemoveProject = 1,
        AddProjectReference = 2,
        RemoveProjectReference = 3,
        AddMetadataReference = 4,
        RemoveMetadataReference = 5,
        AddDocument = 6,
        RemoveDocument = 7,
        ChangeDocument = 8,
        AddAnalyzerReference = 9,
        RemoveAnalyzerReference = 10,
        AddAdditionalDocument = 11,
        RemoveAdditionalDocument = 12,
        ChangeAdditionalDocument = 13,
        ChangeCompilationOptions = 14,
        ChangeParseOptions = 15,
        ChangeDocumentInfo = 16,

      public enum Microsoft.CodeAnalysis.AssemblyIdentityComparer.ComparisonResult

        NotEquivalent = 0,
        Equivalent = 1,
        EquivalentIgnoringVersion = 2,

      public enum Microsoft.CodeAnalysis.AssemblyIdentityParts

        Name = 1,
        Version = VersionMajor | VersionMinor | VersionBuild | VersionRevision,
        VersionMajor = 2,
        VersionMinor = 4,
        VersionBuild = 8,
        VersionRevision = 16,
        Culture = 32,
        PublicKey = 64,
        PublicKeyToken = 128,
        PublicKeyOrToken = PublicKey | PublicKeyToken,
        Retargetability = 256,
        ContentType = 512,
        Unknown = 1024,

      public enum Microsoft.CodeAnalysis.CandidateReason

        None = 0,
        NotATypeOrNamespace = 1,
        NotAnEvent = 2,
        NotAWithEventsMember = 3,
        NotAnAttributeType = 4,
        WrongArity = 5,
        NotCreatable = 6,
        NotReferencable = 7,
        Inaccessible = 8,
        NotAValue = 9,
        NotAVariable = 10,
        NotInvocable = 11,
        StaticInstanceMismatch = 12,
        OverloadResolutionFailure = 13,
        LateBound = 14,
        Ambiguous = 15,
        MemberGroup = 16,

      public enum Microsoft.CodeAnalysis.DiagnosticSeverity

        Hidden = 0,
        Info = 1,
        Warning = 2,
        Error = 3,

      public enum Microsoft.CodeAnalysis.DocumentationMode

        None = 0,
        Parse = 1,
        Diagnose = 2,

      public enum Microsoft.CodeAnalysis.LineVisibility

        BeforeFirstLineDirective = 0,
        Hidden = 1,
        Visible = 2,

      public enum Microsoft.CodeAnalysis.LocationKind

        None = 0,
        SourceFile = 1,
        MetadataFile = 2,
        XmlFile = 3,
        ExternalFile = 4,

      public enum Microsoft.CodeAnalysis.MetadataImageKind

        Assembly = 0,
        Module = 1,

      public enum Microsoft.CodeAnalysis.MethodKind

        AnonymousFunction = 0,
        LambdaMethod = 0,
        Constructor = 1,
        Conversion = 2,
        DelegateInvoke = 3,
        Destructor = 4,
        EventAdd = 5,
        EventRaise = 6,
        EventRemove = 7,
        ExplicitInterfaceImplementation = 8,
        UserDefinedOperator = 9,
        Ordinary = 10,
        PropertyGet = 11,
        PropertySet = 12,
        ReducedExtension = 13,
        StaticConstructor = 14,
        SharedConstructor = 14,
        BuiltinOperator = 15,
        DeclareMethod = 16,
        LocalFunction = 17,

      public enum Microsoft.CodeAnalysis.NamespaceKind

        Module = 1,
        Assembly = 2,
        Compilation = 3,

      public enum Microsoft.CodeAnalysis.OperationKind

        None = 0,
        InvalidStatement = 1,
        BlockStatement = 2,
        VariableDeclarationStatement = 3,
        SwitchStatement = 4,
        IfStatement = 5,
        LoopStatement = 6,
        LabelStatement = 7,
        BranchStatement = 8,
        EmptyStatement = 9,
        ThrowStatement = 10,
        ReturnStatement = 11,
        YieldBreakStatement = 12,
        LockStatement = 13,
        TryStatement = 14,
        UsingStatement = 15,
        YieldReturnStatement = 16,
        ExpressionStatement = 17,
        FixedStatement = 48,
        LocalFunctionStatement = 49,
        StopStatement = 80,
        EndStatement = 81,
        WithStatement = 82,
        InvalidExpression = 256,
        LiteralExpression = 257,
        ConversionExpression = 258,
        InvocationExpression = 259,
        ArrayElementReferenceExpression = 260,
        LocalReferenceExpression = 261,
        ParameterReferenceExpression = 262,
        SyntheticLocalReferenceExpression = 263,
        FieldReferenceExpression = 264,
        MethodBindingExpression = 265,
        PropertyReferenceExpression = 266,
        IndexedPropertyReferenceExpression = 267,
        EventReferenceExpression = 268,
        UnaryOperatorExpression = 269,
        BinaryOperatorExpression = 270,
        ConditionalChoiceExpression = 271,
        NullCoalescingExpression = 272,
        LambdaExpression = 273,
        ObjectCreationExpression = 274,
        TypeParameterObjectCreationExpression = 275,
        ArrayCreationExpression = 276,
        InstanceReferenceExpression = 277,
        IsTypeExpression = 278,
        AwaitExpression = 279,
        AssignmentExpression = 280,
        CompoundAssignmentExpression = 281,
        ParenthesizedExpression = 282,
        EventAssignmentExpression = 283,
        ConditionalAccessExpression = 284,
        ConditionalAccessInstanceExpression = 285,
        DefaultValueExpression = 512,
        TypeOfExpression = 513,
        SizeOfExpression = 514,
        AddressOfExpression = 515,
        PointerIndirectionReferenceExpression = 516,
        UnboundLambdaExpression = 517,
        IncrementExpression = 518,
        OmittedArgumentExpression = 768,
        LateBoundMemberReferenceExpression = 769,
        PlaceholderExpression = 770,
        FieldInitializerInCreation = 1024,
        FieldInitializerAtDeclaration = 1025,
        PropertyInitializerInCreation = 1026,
        PropertyInitializerAtDeclaration = 1027,
        ParameterInitializerAtDeclaration = 1028,
        ArrayInitializer = 1029,
        VariableDeclaration = 1030,
        Argument = 1031,
        CatchClause = 1032,
        SwitchCase = 1033,
        SingleValueCaseClause = 1034,
        RelationalCaseClause = 1035,
        RangeCaseClause = 1036,

      public enum Microsoft.CodeAnalysis.OptimizationLevel

        Debug = 0,
        Release = 1,

      public enum Microsoft.CodeAnalysis.OutputKind

        ConsoleApplication = 0,
        WindowsApplication = 1,
        DynamicallyLinkedLibrary = 2,
        NetModule = 3,
        WindowsRuntimeMetadata = 4,
        WindowsRuntimeApplication = 5,

      public enum Microsoft.CodeAnalysis.Platform

        AnyCpu = 0,
        X86 = 1,
        X64 = 2,
        Itanium = 3,
        AnyCpu32BitPreferred = 4,
        Arm = 5,

      public enum Microsoft.CodeAnalysis.PreservationMode

        PreserveValue = 0,
        PreserveIdentity = 1,

      public enum Microsoft.CodeAnalysis.RefKind

        None = 0,
        Ref = 1,
        Out = 2,

      public enum Microsoft.CodeAnalysis.ReportDiagnostic

        Default = 0,
        Error = 1,
        Warn = 2,
        Info = 3,
        Hidden = 4,
        Suppress = 5,

      public enum Microsoft.CodeAnalysis.SourceCodeKind

        Regular = 0,
        Script = 1,
        Interactive = 2,

      public enum Microsoft.CodeAnalysis.SpecialType

        None = 0,
        System_Object = 1,
        System_Enum = 2,
        System_MulticastDelegate = 3,
        System_Delegate = 4,
        System_ValueType = 5,
        System_Void = 6,
        System_Boolean = 7,
        System_Char = 8,
        System_SByte = 9,
        System_Byte = 10,
        System_Int16 = 11,
        System_UInt16 = 12,
        System_Int32 = 13,
        System_UInt32 = 14,
        System_Int64 = 15,
        System_UInt64 = 16,
        System_Decimal = 17,
        System_Single = 18,
        System_Double = 19,
        System_String = 20,
        System_IntPtr = 21,
        System_UIntPtr = 22,
        System_Array = 23,
        System_Collections_IEnumerable = 24,
        System_Collections_Generic_IEnumerable_T = 25,
        System_Collections_Generic_IList_T = 26,
        System_Collections_Generic_ICollection_T = 27,
        System_Collections_IEnumerator = 28,
        System_Collections_Generic_IEnumerator_T = 29,
        System_Collections_Generic_IReadOnlyList_T = 30,
        System_Collections_Generic_IReadOnlyCollection_T = 31,
        System_Nullable_T = 32,
        System_DateTime = 33,
        System_Runtime_CompilerServices_IsVolatile = 34,
        System_IDisposable = 35,
        System_TypedReference = 36,
        System_ArgIterator = 37,
        System_RuntimeArgumentHandle = 38,
        System_RuntimeFieldHandle = 39,
        System_RuntimeMethodHandle = 40,
        System_RuntimeTypeHandle = 41,
        System_IAsyncResult = 42,
        System_AsyncCallback = 43,
        Count = 43,

      public enum Microsoft.CodeAnalysis.SpeculativeBindingOption

        BindAsExpression = 0,
        BindAsTypeOrNamespace = 1,

      public enum Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle

        NameOnly = 0,
        NameAndParameters = 1,
        NameAndSignature = 2,

      public enum Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle

        Default = 0,
        InstanceMethod = 1,
        StaticMethod = 2,

      public enum Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions

        None = 0,
        IncludeTypeParameters = 1,
        IncludeTypeConstraints = 2,
        IncludeVariance = 4,

      public enum Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle

        Omitted = 0,
        OmittedAsContaining = 1,
        Included = 2,

      public enum Microsoft.CodeAnalysis.SymbolDisplayKindOptions

        None = 0,
        IncludeNamespaceKeyword = 1,
        IncludeTypeKeyword = 2,
        IncludeMemberKeyword = 4,

      public enum Microsoft.CodeAnalysis.SymbolDisplayLocalOptions

        None = 0,
        IncludeType = 1,
        IncludeConstantValue = 2,
        IncludeRef = 4,

      public enum Microsoft.CodeAnalysis.SymbolDisplayMemberOptions

        None = 0,
        IncludeType = 1,
        IncludeModifiers = 2,
        IncludeAccessibility = 4,
        IncludeExplicitInterface = 8,
        IncludeParameters = 16,
        IncludeContainingType = 32,
        IncludeConstantValue = 64,
        IncludeRef = 128,

      public enum Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions

        None = 0,
        UseSpecialTypes = 1,
        EscapeKeywordIdentifiers = 2,
        UseAsterisksInMultiDimensionalArrays = 4,
        UseErrorTypeSymbolName = 8,
        RemoveAttributeSuffix = 16,
        ExpandNullable = 32,

      public enum Microsoft.CodeAnalysis.SymbolDisplayParameterOptions

        None = 0,
        IncludeExtensionThis = 1,
        IncludeParamsRefOut = 2,
        IncludeType = 4,
        IncludeName = 8,
        IncludeDefaultValue = 16,
        IncludeOptionalBrackets = 32,

      public enum Microsoft.CodeAnalysis.SymbolDisplayPartKind

        AliasName = 0,
        AssemblyName = 1,
        ClassName = 2,
        DelegateName = 3,
        EnumName = 4,
        ErrorTypeName = 5,
        EventName = 6,
        FieldName = 7,
        InterfaceName = 8,
        Keyword = 9,
        LabelName = 10,
        LineBreak = 11,
        NumericLiteral = 12,
        StringLiteral = 13,
        LocalName = 14,
        MethodName = 15,
        ModuleName = 16,
        NamespaceName = 17,
        Operator = 18,
        ParameterName = 19,
        PropertyName = 20,
        Punctuation = 21,
        Space = 22,
        StructName = 23,
        AnonymousTypeIndicator = 24,
        Text = 25,
        TypeParameterName = 26,
        RangeVariableName = 27,

      public enum Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle

        NameOnly = 0,
        ShowReadWriteDescriptor = 1,

      public enum Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle

        NameOnly = 0,
        NameAndContainingTypes = 1,
        NameAndContainingTypesAndNamespaces = 2,

      public enum Microsoft.CodeAnalysis.SymbolFilter

        None = 0,
        Namespace = 1,
        Type = 2,
        Member = 4,
        TypeAndMember = Type | Member,
        All = Namespace | TypeAndMember,

      public enum Microsoft.CodeAnalysis.SymbolKind

        Alias = 0,
        ArrayType = 1,
        Assembly = 2,
        DynamicType = 3,
        ErrorType = 4,
        Event = 5,
        Field = 6,
        Label = 7,
        Local = 8,
        Method = 9,
        NetModule = 10,
        NamedType = 11,
        Namespace = 12,
        Parameter = 13,
        PointerType = 14,
        Property = 15,
        RangeVariable = 16,
        TypeParameter = 17,
        Preprocessing = 18,
        Discard = 19,

      public enum Microsoft.CodeAnalysis.SyntaxRemoveOptions

        KeepNoTrivia = 0,
        KeepLeadingTrivia = 1,
        KeepTrailingTrivia = 2,
        KeepExteriorTrivia = KeepLeadingTrivia | KeepTrailingTrivia,
        KeepUnbalancedDirectives = 4,
        KeepDirectives = 8,
        KeepEndOfLine = 16,
        AddElasticMarker = 32,

      public enum Microsoft.CodeAnalysis.SyntaxWalkerDepth

        Node = 0,
        Token = 1,
        Trivia = 2,
        StructuredTrivia = 3,

      public enum Microsoft.CodeAnalysis.TypeKind

        Unknown = 0,
        Array = 1,
        Class = 2,
        Delegate = 3,
        Dynamic = 4,
        Enum = 5,
        Error = 6,
        Interface = 7,
        Module = 8,
        Pointer = 9,
        Struct = 10,
        Structure = 10,
        TypeParameter = 11,
        Submission = 12,

      public enum Microsoft.CodeAnalysis.TypeParameterKind

        Type = 0,
        Method = 1,
        Cref = 2,

      public enum Microsoft.CodeAnalysis.TypedConstantKind

        Error = 0,
        Primitive = 1,
        Enum = 2,
        Type = 3,
        Array = 4,

      public enum Microsoft.CodeAnalysis.VarianceKind

        None = 0,
        Out = 1,
        In = 2,

      public enum Microsoft.CodeAnalysis.WorkspaceChangeKind

        SolutionChanged = 0,
        SolutionAdded = 1,
        SolutionRemoved = 2,
        SolutionCleared = 3,
        SolutionReloaded = 4,
        ProjectAdded = 5,
        ProjectRemoved = 6,
        ProjectChanged = 7,
        ProjectReloaded = 8,
        DocumentAdded = 9,
        DocumentRemoved = 10,
        DocumentReloaded = 11,
        DocumentChanged = 12,
        AdditionalDocumentAdded = 13,
        AdditionalDocumentRemoved = 14,
        AdditionalDocumentReloaded = 15,
        AdditionalDocumentChanged = 16,
        DocumentInfoChanged = 17,

      public enum Microsoft.CodeAnalysis.WorkspaceDiagnosticKind

        Failure = 0,
        Warning = 1,

      public enum Microsoft.CodeAnalysis.CSharp.LanguageVersion

        Default = 0,
        CSharp1 = 1,
        CSharp2 = 2,
        CSharp3 = 3,
        CSharp4 = 4,
        CSharp5 = 5,
        CSharp6 = 6,
        CSharp7 = 7,
        CSharp7_1 = 701,
        Latest = 2147483647,

      public enum Microsoft.CodeAnalysis.CSharp.SyntaxKind

        None = 0,
        List = 1,
        TildeToken = 8193,
        ExclamationToken = 8194,
        DollarToken = 8195,
        PercentToken = 8196,
        CaretToken = 8197,
        AmpersandToken = 8198,
        AsteriskToken = 8199,
        OpenParenToken = 8200,
        CloseParenToken = 8201,
        MinusToken = 8202,
        PlusToken = 8203,
        EqualsToken = 8204,
        OpenBraceToken = 8205,
        CloseBraceToken = 8206,
        OpenBracketToken = 8207,
        CloseBracketToken = 8208,
        BarToken = 8209,
        BackslashToken = 8210,
        ColonToken = 8211,
        SemicolonToken = 8212,
        DoubleQuoteToken = 8213,
        SingleQuoteToken = 8214,
        LessThanToken = 8215,
        CommaToken = 8216,
        GreaterThanToken = 8217,
        DotToken = 8218,
        QuestionToken = 8219,
        HashToken = 8220,
        SlashToken = 8221,
        SlashGreaterThanToken = 8232,
        LessThanSlashToken = 8233,
        XmlCommentStartToken = 8234,
        XmlCommentEndToken = 8235,
        XmlCDataStartToken = 8236,
        XmlCDataEndToken = 8237,
        XmlProcessingInstructionStartToken = 8238,
        XmlProcessingInstructionEndToken = 8239,
        BarBarToken = 8260,
        AmpersandAmpersandToken = 8261,
        MinusMinusToken = 8262,
        PlusPlusToken = 8263,
        ColonColonToken = 8264,
        QuestionQuestionToken = 8265,
        MinusGreaterThanToken = 8266,
        ExclamationEqualsToken = 8267,
        EqualsEqualsToken = 8268,
        EqualsGreaterThanToken = 8269,
        LessThanEqualsToken = 8270,
        LessThanLessThanToken = 8271,
        LessThanLessThanEqualsToken = 8272,
        GreaterThanEqualsToken = 8273,
        GreaterThanGreaterThanToken = 8274,
        GreaterThanGreaterThanEqualsToken = 8275,
        SlashEqualsToken = 8276,
        AsteriskEqualsToken = 8277,
        BarEqualsToken = 8278,
        AmpersandEqualsToken = 8279,
        PlusEqualsToken = 8280,
        MinusEqualsToken = 8281,
        CaretEqualsToken = 8282,
        PercentEqualsToken = 8283,
        BoolKeyword = 8304,
        ByteKeyword = 8305,
        SByteKeyword = 8306,
        ShortKeyword = 8307,
        UShortKeyword = 8308,
        IntKeyword = 8309,
        UIntKeyword = 8310,
        LongKeyword = 8311,
        ULongKeyword = 8312,
        DoubleKeyword = 8313,
        FloatKeyword = 8314,
        DecimalKeyword = 8315,
        StringKeyword = 8316,
        CharKeyword = 8317,
        VoidKeyword = 8318,
        ObjectKeyword = 8319,
        TypeOfKeyword = 8320,
        SizeOfKeyword = 8321,
        NullKeyword = 8322,
        TrueKeyword = 8323,
        FalseKeyword = 8324,
        IfKeyword = 8325,
        ElseKeyword = 8326,
        WhileKeyword = 8327,
        ForKeyword = 8328,
        ForEachKeyword = 8329,
        DoKeyword = 8330,
        SwitchKeyword = 8331,
        CaseKeyword = 8332,
        DefaultKeyword = 8333,
        TryKeyword = 8334,
        CatchKeyword = 8335,
        FinallyKeyword = 8336,
        LockKeyword = 8337,
        GotoKeyword = 8338,
        BreakKeyword = 8339,
        ContinueKeyword = 8340,
        ReturnKeyword = 8341,
        ThrowKeyword = 8342,
        PublicKeyword = 8343,
        PrivateKeyword = 8344,
        InternalKeyword = 8345,
        ProtectedKeyword = 8346,
        StaticKeyword = 8347,
        ReadOnlyKeyword = 8348,
        SealedKeyword = 8349,
        ConstKeyword = 8350,
        FixedKeyword = 8351,
        StackAllocKeyword = 8352,
        VolatileKeyword = 8353,
        NewKeyword = 8354,
        OverrideKeyword = 8355,
        AbstractKeyword = 8356,
        VirtualKeyword = 8357,
        EventKeyword = 8358,
        ExternKeyword = 8359,
        RefKeyword = 8360,
        OutKeyword = 8361,
        InKeyword = 8362,
        IsKeyword = 8363,
        AsKeyword = 8364,
        ParamsKeyword = 8365,
        ArgListKeyword = 8366,
        MakeRefKeyword = 8367,
        RefTypeKeyword = 8368,
        RefValueKeyword = 8369,
        ThisKeyword = 8370,
        BaseKeyword = 8371,
        NamespaceKeyword = 8372,
        UsingKeyword = 8373,
        ClassKeyword = 8374,
        StructKeyword = 8375,
        InterfaceKeyword = 8376,
        EnumKeyword = 8377,
        DelegateKeyword = 8378,
        CheckedKeyword = 8379,
        UncheckedKeyword = 8380,
        UnsafeKeyword = 8381,
        OperatorKeyword = 8382,
        ExplicitKeyword = 8383,
        ImplicitKeyword = 8384,
        YieldKeyword = 8405,
        PartialKeyword = 8406,
        AliasKeyword = 8407,
        GlobalKeyword = 8408,
        AssemblyKeyword = 8409,
        ModuleKeyword = 8410,
        TypeKeyword = 8411,
        FieldKeyword = 8412,
        MethodKeyword = 8413,
        ParamKeyword = 8414,
        PropertyKeyword = 8415,
        TypeVarKeyword = 8416,
        GetKeyword = 8417,
        SetKeyword = 8418,
        AddKeyword = 8419,
        RemoveKeyword = 8420,
        WhereKeyword = 8421,
        FromKeyword = 8422,
        GroupKeyword = 8423,
        JoinKeyword = 8424,
        IntoKeyword = 8425,
        LetKeyword = 8426,
        ByKeyword = 8427,
        SelectKeyword = 8428,
        OrderByKeyword = 8429,
        OnKeyword = 8430,
        EqualsKeyword = 8431,
        AscendingKeyword = 8432,
        DescendingKeyword = 8433,
        NameOfKeyword = 8434,
        AsyncKeyword = 8435,
        AwaitKeyword = 8436,
        WhenKeyword = 8437,
        ElifKeyword = 8467,
        EndIfKeyword = 8468,
        RegionKeyword = 8469,
        EndRegionKeyword = 8470,
        DefineKeyword = 8471,
        UndefKeyword = 8472,
        WarningKeyword = 8473,
        ErrorKeyword = 8474,
        LineKeyword = 8475,
        PragmaKeyword = 8476,
        HiddenKeyword = 8477,
        ChecksumKeyword = 8478,
        DisableKeyword = 8479,
        RestoreKeyword = 8480,
        ReferenceKeyword = 8481,
        LoadKeyword = 8485,
        InterpolatedStringStartToken = 8482,
        InterpolatedStringEndToken = 8483,
        InterpolatedVerbatimStringStartToken = 8484,
        UnderscoreToken = 8491,
        OmittedTypeArgumentToken = 8492,
        OmittedArraySizeExpressionToken = 8493,
        EndOfDirectiveToken = 8494,
        EndOfDocumentationCommentToken = 8495,
        EndOfFileToken = 8496,
        BadToken = 8507,
        IdentifierToken = 8508,
        NumericLiteralToken = 8509,
        CharacterLiteralToken = 8510,
        StringLiteralToken = 8511,
        XmlEntityLiteralToken = 8512,
        XmlTextLiteralToken = 8513,
        XmlTextLiteralNewLineToken = 8514,
        InterpolatedStringToken = 8515,
        InterpolatedStringTextToken = 8517,
        EndOfLineTrivia = 8539,
        WhitespaceTrivia = 8540,
        SingleLineCommentTrivia = 8541,
        MultiLineCommentTrivia = 8542,
        DocumentationCommentExteriorTrivia = 8543,
        SingleLineDocumentationCommentTrivia = 8544,
        MultiLineDocumentationCommentTrivia = 8545,
        DisabledTextTrivia = 8546,
        PreprocessingMessageTrivia = 8547,
        IfDirectiveTrivia = 8548,
        ElifDirectiveTrivia = 8549,
        ElseDirectiveTrivia = 8550,
        EndIfDirectiveTrivia = 8551,
        RegionDirectiveTrivia = 8552,
        EndRegionDirectiveTrivia = 8553,
        DefineDirectiveTrivia = 8554,
        UndefDirectiveTrivia = 8555,
        ErrorDirectiveTrivia = 8556,
        WarningDirectiveTrivia = 8557,
        LineDirectiveTrivia = 8558,
        PragmaWarningDirectiveTrivia = 8559,
        PragmaChecksumDirectiveTrivia = 8560,
        ReferenceDirectiveTrivia = 8561,
        BadDirectiveTrivia = 8562,
        SkippedTokensTrivia = 8563,
        ConflictMarkerTrivia = 8564,
        XmlElement = 8574,
        XmlElementStartTag = 8575,
        XmlElementEndTag = 8576,
        XmlEmptyElement = 8577,
        XmlTextAttribute = 8578,
        XmlCrefAttribute = 8579,
        XmlNameAttribute = 8580,
        XmlName = 8581,
        XmlPrefix = 8582,
        XmlText = 8583,
        XmlCDataSection = 8584,
        XmlComment = 8585,
        XmlProcessingInstruction = 8586,
        TypeCref = 8597,
        QualifiedCref = 8598,
        NameMemberCref = 8599,
        IndexerMemberCref = 8600,
        OperatorMemberCref = 8601,
        ConversionOperatorMemberCref = 8602,
        CrefParameterList = 8603,
        CrefBracketedParameterList = 8604,
        CrefParameter = 8605,
        IdentifierName = 8616,
        QualifiedName = 8617,
        GenericName = 8618,
        TypeArgumentList = 8619,
        AliasQualifiedName = 8620,
        PredefinedType = 8621,
        ArrayType = 8622,
        ArrayRankSpecifier = 8623,
        PointerType = 8624,
        NullableType = 8625,
        OmittedTypeArgument = 8626,
        ParenthesizedExpression = 8632,
        ConditionalExpression = 8633,
        InvocationExpression = 8634,
        ElementAccessExpression = 8635,
        ArgumentList = 8636,
        BracketedArgumentList = 8637,
        Argument = 8638,
        NameColon = 8639,
        CastExpression = 8640,
        AnonymousMethodExpression = 8641,
        SimpleLambdaExpression = 8642,
        ParenthesizedLambdaExpression = 8643,
        ObjectInitializerExpression = 8644,
        CollectionInitializerExpression = 8645,
        ArrayInitializerExpression = 8646,
        AnonymousObjectMemberDeclarator = 8647,
        ComplexElementInitializerExpression = 8648,
        ObjectCreationExpression = 8649,
        AnonymousObjectCreationExpression = 8650,
        ArrayCreationExpression = 8651,
        ImplicitArrayCreationExpression = 8652,
        StackAllocArrayCreationExpression = 8653,
        OmittedArraySizeExpression = 8654,
        InterpolatedStringExpression = 8655,
        ImplicitElementAccess = 8656,
        IsPatternExpression = 8657,
        AddExpression = 8668,
        SubtractExpression = 8669,
        MultiplyExpression = 8670,
        DivideExpression = 8671,
        ModuloExpression = 8672,
        LeftShiftExpression = 8673,
        RightShiftExpression = 8674,
        LogicalOrExpression = 8675,
        LogicalAndExpression = 8676,
        BitwiseOrExpression = 8677,
        BitwiseAndExpression = 8678,
        ExclusiveOrExpression = 8679,
        EqualsExpression = 8680,
        NotEqualsExpression = 8681,
        LessThanExpression = 8682,
        LessThanOrEqualExpression = 8683,
        GreaterThanExpression = 8684,
        GreaterThanOrEqualExpression = 8685,
        IsExpression = 8686,
        AsExpression = 8687,
        CoalesceExpression = 8688,
        SimpleMemberAccessExpression = 8689,
        PointerMemberAccessExpression = 8690,
        ConditionalAccessExpression = 8691,
        MemberBindingExpression = 8707,
        ElementBindingExpression = 8708,
        SimpleAssignmentExpression = 8714,
        AddAssignmentExpression = 8715,
        SubtractAssignmentExpression = 8716,
        MultiplyAssignmentExpression = 8717,
        DivideAssignmentExpression = 8718,
        ModuloAssignmentExpression = 8719,
        AndAssignmentExpression = 8720,
        ExclusiveOrAssignmentExpression = 8721,
        OrAssignmentExpression = 8722,
        LeftShiftAssignmentExpression = 8723,
        RightShiftAssignmentExpression = 8724,
        UnaryPlusExpression = 8730,
        UnaryMinusExpression = 8731,
        BitwiseNotExpression = 8732,
        LogicalNotExpression = 8733,
        PreIncrementExpression = 8734,
        PreDecrementExpression = 8735,
        PointerIndirectionExpression = 8736,
        AddressOfExpression = 8737,
        PostIncrementExpression = 8738,
        PostDecrementExpression = 8739,
        AwaitExpression = 8740,
        ThisExpression = 8746,
        BaseExpression = 8747,
        ArgListExpression = 8748,
        NumericLiteralExpression = 8749,
        StringLiteralExpression = 8750,
        CharacterLiteralExpression = 8751,
        TrueLiteralExpression = 8752,
        FalseLiteralExpression = 8753,
        NullLiteralExpression = 8754,
        DefaultLiteralExpression = 8755,
        TypeOfExpression = 8760,
        SizeOfExpression = 8761,
        CheckedExpression = 8762,
        UncheckedExpression = 8763,
        DefaultExpression = 8764,
        MakeRefExpression = 8765,
        RefValueExpression = 8766,
        RefTypeExpression = 8767,
        QueryExpression = 8774,
        QueryBody = 8775,
        FromClause = 8776,
        LetClause = 8777,
        JoinClause = 8778,
        JoinIntoClause = 8779,
        WhereClause = 8780,
        OrderByClause = 8781,
        AscendingOrdering = 8782,
        DescendingOrdering = 8783,
        SelectClause = 8784,
        GroupClause = 8785,
        QueryContinuation = 8786,
        Block = 8792,
        LocalDeclarationStatement = 8793,
        VariableDeclaration = 8794,
        VariableDeclarator = 8795,
        EqualsValueClause = 8796,
        ExpressionStatement = 8797,
        EmptyStatement = 8798,
        LabeledStatement = 8799,
        GotoStatement = 8800,
        GotoCaseStatement = 8801,
        GotoDefaultStatement = 8802,
        BreakStatement = 8803,
        ContinueStatement = 8804,
        ReturnStatement = 8805,
        YieldReturnStatement = 8806,
        YieldBreakStatement = 8807,
        ThrowStatement = 8808,
        WhileStatement = 8809,
        DoStatement = 8810,
        ForStatement = 8811,
        ForEachStatement = 8812,
        UsingStatement = 8813,
        FixedStatement = 8814,
        CheckedStatement = 8815,
        UncheckedStatement = 8816,
        UnsafeStatement = 8817,
        LockStatement = 8818,
        IfStatement = 8819,
        ElseClause = 8820,
        SwitchStatement = 8821,
        SwitchSection = 8822,
        CaseSwitchLabel = 8823,
        DefaultSwitchLabel = 8824,
        TryStatement = 8825,
        CatchClause = 8826,
        CatchDeclaration = 8827,
        CatchFilterClause = 8828,
        FinallyClause = 8829,
        LocalFunctionStatement = 8830,
        CompilationUnit = 8840,
        GlobalStatement = 8841,
        NamespaceDeclaration = 8842,
        UsingDirective = 8843,
        ExternAliasDirective = 8844,
        AttributeList = 8847,
        AttributeTargetSpecifier = 8848,
        Attribute = 8849,
        AttributeArgumentList = 8850,
        AttributeArgument = 8851,
        NameEquals = 8852,
        ClassDeclaration = 8855,
        StructDeclaration = 8856,
        InterfaceDeclaration = 8857,
        EnumDeclaration = 8858,
        DelegateDeclaration = 8859,
        BaseList = 8864,
        SimpleBaseType = 8865,
        TypeParameterConstraintClause = 8866,
        ConstructorConstraint = 8867,
        ClassConstraint = 8868,
        StructConstraint = 8869,
        TypeConstraint = 8870,
        ExplicitInterfaceSpecifier = 8871,
        EnumMemberDeclaration = 8872,
        FieldDeclaration = 8873,
        EventFieldDeclaration = 8874,
        MethodDeclaration = 8875,
        OperatorDeclaration = 8876,
        ConversionOperatorDeclaration = 8877,
        ConstructorDeclaration = 8878,
        BaseConstructorInitializer = 8889,
        ThisConstructorInitializer = 8890,
        DestructorDeclaration = 8891,
        PropertyDeclaration = 8892,
        EventDeclaration = 8893,
        IndexerDeclaration = 8894,
        AccessorList = 8895,
        GetAccessorDeclaration = 8896,
        SetAccessorDeclaration = 8897,
        AddAccessorDeclaration = 8898,
        RemoveAccessorDeclaration = 8899,
        UnknownAccessorDeclaration = 8900,
        ParameterList = 8906,
        BracketedParameterList = 8907,
        Parameter = 8908,
        TypeParameterList = 8909,
        TypeParameter = 8910,
        IncompleteMember = 8916,
        ArrowExpressionClause = 8917,
        Interpolation = 8918,
        InterpolatedStringText = 8919,
        InterpolationAlignmentClause = 8920,
        InterpolationFormatClause = 8921,
        ShebangDirectiveTrivia = 8922,
        LoadDirectiveTrivia = 8923,
        TupleType = 8924,
        TupleElement = 8925,
        TupleExpression = 8926,
        SingleVariableDesignation = 8927,
        ParenthesizedVariableDesignation = 8928,
        ForEachVariableStatement = 8929,
        DeclarationPattern = 9000,
        ConstantPattern = 9002,
        CasePatternSwitchLabel = 9009,
        WhenClause = 9013,
        DiscardDesignation = 9014,
        DeclarationExpression = 9040,
        RefExpression = 9050,
        RefType = 9051,
        ThrowExpression = 9052,

      public enum Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions

        Single = 0,
        Ignore = 1,
        Remove = 2,

      public enum Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions

        LeftMost = 0,
        OneLess = 1,
        NoIndent = 2,

      public enum Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeElementKind

        Parameter = 0,
        ParameterReference = 1,
        TypeParameter = 2,
        TypeParameterReference = 3,

      public enum Microsoft.CodeAnalysis.CodeFixes.FixAllScope

        Document = 0,
        Project = 1,
        Solution = 2,
        Custom = 3,

      public enum Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs.FailureErrorCode

        None = 0,
        UnableToLoadAnalyzer = 1,
        UnableToCreateAnalyzer = 2,
        NoAnalyzers = 3,

      public enum Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags

        None = 0,
        Analyze = 1,
        ReportDiagnostics = 2,

      public enum Microsoft.CodeAnalysis.Differencing.EditKind

        None = 0,
        Update = 1,
        Insert = 2,
        Delete = 3,
        Move = 4,
        Reorder = 5,

      public enum Microsoft.CodeAnalysis.Editing.DeclarationKind

        None = 0,
        CompilationUnit = 1,
        Class = 2,
        Struct = 3,
        Interface = 4,
        Enum = 5,
        Delegate = 6,
        Method = 7,
        Operator = 8,
        ConversionOperator = 9,
        Constructor = 10,
        Destructor = 11,
        Field = 12,
        Property = 13,
        Indexer = 14,
        EnumMember = 15,
        Event = 16,
        CustomEvent = 17,
        Namespace = 18,
        NamespaceImport = 19,
        Parameter = 20,
        Variable = 21,
        Attribute = 22,
        LambdaExpression = 23,
        GetAccessor = 24,
        SetAccessor = 25,
        AddAccessor = 26,
        RemoveAccessor = 27,
        RaiseAccessor = 28,

      public enum Microsoft.CodeAnalysis.Editing.OperatorKind

        ImplicitConversion = 0,
        ExplicitConversion = 1,
        Addition = 2,
        BitwiseAnd = 3,
        BitwiseOr = 4,
        Decrement = 5,
        Division = 6,
        Equality = 7,
        ExclusiveOr = 8,
        False = 9,
        GreaterThan = 10,
        GreaterThanOrEqual = 11,
        Increment = 12,
        Inequality = 13,
        LeftShift = 14,
        LessThan = 15,
        LessThanOrEqual = 16,
        LogicalNot = 17,
        Modulus = 18,
        Multiply = 19,
        OnesComplement = 20,
        RightShift = 21,
        Subtraction = 22,
        True = 23,
        UnaryNegation = 24,
        UnaryPlus = 25,

      public enum Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind

        None = 0,
        ReferenceType = 1,
        ValueType = 2,
        Constructor = 4,

      public enum Microsoft.CodeAnalysis.Emit.DebugInformationFormat

        Pdb = 1,
        PortablePdb = 2,
        Embedded = 3,

      public enum Microsoft.CodeAnalysis.Emit.InstrumentationKind

        None = 0,
        TestCoverage = 1,

      public enum Microsoft.CodeAnalysis.Emit.SemanticEditKind

        None = 0,
        Update = 1,
        Insert = 2,
        Delete = 3,

      public enum Microsoft.CodeAnalysis.Formatting.FormattingOptions.IndentStyle

        None = 0,
        Block = 1,
        Smart = 2,

      public enum Microsoft.CodeAnalysis.Rename.RenameEntityKind

        BaseSymbol = 0,
        OverloadedSymbols = 1,

      public enum Microsoft.CodeAnalysis.Semantics.ArgumentKind

        None = 0,
        Explicit = 1,
        ParamArray = 2,
        DefaultValue = 3,

      public enum Microsoft.CodeAnalysis.Semantics.BinaryOperandsKind

        None = 0,
        OperatorMethod = 256,
        Integer = 512,
        Unsigned = 768,
        Floating = 1024,
        Decimal = 1280,
        Boolean = 1536,
        Enum = 1792,
        Dynamic = 2048,
        Object = 2304,
        Pointer = 2560,
        PointerInteger = 2816,
        IntegerPointer = 3072,
        String = 3328,
        Delegate = 3584,
        Nullable = 3840,
        Invalid = 65280,

      public enum Microsoft.CodeAnalysis.Semantics.BinaryOperationKind

        None = 0,
        OperatorMethodAdd = 257,
        OperatorMethodSubtract = 258,
        OperatorMethodMultiply = 259,
        OperatorMethodDivide = 260,
        OperatorMethodIntegerDivide = 261,
        OperatorMethodRemainder = 262,
        OperatorMethodLeftShift = 264,
        OperatorMethodRightShift = 265,
        OperatorMethodAnd = 266,
        OperatorMethodOr = 267,
        OperatorMethodExclusiveOr = 268,
        OperatorMethodConditionalAnd = 269,
        OperatorMethodConditionalOr = 270,
        IntegerAdd = 513,
        IntegerSubtract = 514,
        IntegerMultiply = 515,
        IntegerDivide = 516,
        IntegerRemainder = 518,
        IntegerLeftShift = 520,
        IntegerRightShift = 521,
        IntegerAnd = 522,
        IntegerOr = 523,
        IntegerExclusiveOr = 524,
        UnsignedAdd = 769,
        UnsignedSubtract = 770,
        UnsignedMultiply = 771,
        UnsignedDivide = 772,
        UnsignedRemainder = 774,
        UnsignedLeftShift = 776,
        UnsignedRightShift = 777,
        UnsignedAnd = 778,
        UnsignedOr = 779,
        UnsignedExclusiveOr = 780,
        FloatingAdd = 1025,
        FloatingSubtract = 1026,
        FloatingMultiply = 1027,
        FloatingDivide = 1028,
        FloatingRemainder = 1030,
        FloatingPower = 1031,
        DecimalAdd = 1281,
        DecimalSubtract = 1282,
        DecimalMultiply = 1283,
        DecimalDivide = 1284,
        BooleanAnd = 1546,
        BooleanOr = 1547,
        BooleanExclusiveOr = 1548,
        BooleanConditionalAnd = 1549,
        BooleanConditionalOr = 1550,
        EnumAdd = 1793,
        EnumSubtract = 1794,
        EnumAnd = 1802,
        EnumOr = 1803,
        EnumExclusiveOr = 1804,
        PointerIntegerAdd = 2817,
        IntegerPointerAdd = 3073,
        PointerIntegerSubtract = 2818,
        PointerSubtract = 2562,
        DynamicAdd = 2049,
        DynamicSubtract = 2050,
        DynamicMultiply = 2051,
        DynamicDivide = 2052,
        DynamicRemainder = 2054,
        DynamicLeftShift = 2056,
        DynamicRightShift = 2057,
        DynamicAnd = 2058,
        DynamicOr = 2059,
        DynamicExclusiveOr = 2060,
        ObjectAdd = 2305,
        ObjectSubtract = 2306,
        ObjectMultiply = 2307,
        ObjectDivide = 2308,
        ObjectIntegerDivide = 2309,
        ObjectRemainder = 2310,
        ObjectPower = 2311,
        ObjectLeftShift = 2312,
        ObjectRightShift = 2313,
        ObjectAnd = 2314,
        ObjectOr = 2315,
        ObjectExclusiveOr = 2316,
        ObjectConditionalAnd = 2317,
        ObjectConditionalOr = 2318,
        ObjectConcatenate = 2319,
        StringConcatenate = 3343,
        OperatorMethodEquals = 272,
        OperatorMethodNotEquals = 274,
        OperatorMethodLessThan = 276,
        OperatorMethodLessThanOrEqual = 277,
        OperatorMethodGreaterThanOrEqual = 278,
        OperatorMethodGreaterThan = 279,
        OperatorMethodPower = 263,
        IntegerEquals = 528,
        IntegerNotEquals = 530,
        IntegerLessThan = 532,
        IntegerLessThanOrEqual = 533,
        IntegerGreaterThanOrEqual = 534,
        IntegerGreaterThan = 535,
        UnsignedLessThan = 788,
        UnsignedLessThanOrEqual = 789,
        UnsignedGreaterThanOrEqual = 790,
        UnsignedGreaterThan = 791,
        FloatingEquals = 1040,
        FloatingNotEquals = 1042,
        FloatingLessThan = 1044,
        FloatingLessThanOrEqual = 1045,
        FloatingGreaterThanOrEqual = 1046,
        FloatingGreaterThan = 1047,
        DecimalEquals = 1296,
        DecimalNotEquals = 1298,
        DecimalLessThan = 1300,
        DecimalLessThanOrEqual = 1301,
        DecimalGreaterThanOrEqual = 1302,
        DecimalGreaterThan = 1303,
        BooleanEquals = 1552,
        BooleanNotEquals = 1554,
        StringEquals = 3344,
        StringNotEquals = 3346,
        StringLike = 3352,
        DelegateEquals = 3600,
        DelegateNotEquals = 3602,
        NullableEquals = 3856,
        NullableNotEquals = 3858,
        ObjectEquals = 2320,
        ObjectNotEquals = 2322,
        ObjectVBEquals = 2321,
        ObjectVBNotEquals = 2323,
        ObjectLike = 2328,
        ObjectLessThan = 2324,
        ObjectLessThanOrEqual = 2325,
        ObjectGreaterThanOrEqual = 2326,
        ObjectGreaterThan = 2327,
        EnumEquals = 1808,
        EnumNotEquals = 1810,
        EnumLessThan = 1812,
        EnumLessThanOrEqual = 1813,
        EnumGreaterThanOrEqual = 1814,
        EnumGreaterThan = 1815,
        PointerEquals = 2576,
        PointerNotEquals = 2578,
        PointerLessThan = 2580,
        PointerLessThanOrEqual = 2581,
        PointerGreaterThanOrEqual = 2582,
        PointerGreaterThan = 2583,
        DynamicEquals = 2064,
        DynamicNotEquals = 2066,
        DynamicLessThan = 2068,
        DynamicLessThanOrEqual = 2069,
        DynamicGreaterThanOrEqual = 2070,
        DynamicGreaterThan = 2071,
        Invalid = 65535,

      public enum Microsoft.CodeAnalysis.Semantics.BranchKind

        None = 0,
        Continue = 1,
        Break = 2,
        GoTo = 3,

      public enum Microsoft.CodeAnalysis.Semantics.CaseKind

        None = 0,
        SingleValue = 1,
        Relational = 2,
        Range = 3,
        Default = 4,

      public enum Microsoft.CodeAnalysis.Semantics.ConversionKind

        None = 0,
        Cast = 1,
        TryCast = 2,
        Basic = 3,
        CSharp = 4,
        OperatorMethod = 5,
        Invalid = 15,

      public enum Microsoft.CodeAnalysis.Semantics.InstanceReferenceKind

        None = 0,
        Implicit = 1,
        Explicit = 2,
        BaseClass = 3,
        ThisClass = 4,

      public enum Microsoft.CodeAnalysis.Semantics.LoopKind

        None = 0,
        WhileUntil = 1,
        For = 2,
        ForEach = 3,

      public enum Microsoft.CodeAnalysis.Semantics.SimpleBinaryOperationKind

        None = 0,
        Add = 1,
        Subtract = 2,
        Multiply = 3,
        Divide = 4,
        IntegerDivide = 5,
        Remainder = 6,
        Power = 7,
        LeftShift = 8,
        RightShift = 9,
        And = 10,
        Or = 11,
        ExclusiveOr = 12,
        ConditionalAnd = 13,
        ConditionalOr = 14,
        Concatenate = 15,
        Equals = 16,
        ObjectValueEquals = 17,
        NotEquals = 18,
        ObjectValueNotEquals = 19,
        LessThan = 20,
        LessThanOrEqual = 21,
        GreaterThanOrEqual = 22,
        GreaterThan = 23,
        Like = 24,
        Invalid = 255,

      public enum Microsoft.CodeAnalysis.Semantics.SimpleUnaryOperationKind

        None = 0,
        BitwiseNegation = 1,
        LogicalNot = 2,
        PostfixIncrement = 3,
        PostfixDecrement = 4,
        PrefixIncrement = 5,
        PrefixDecrement = 6,
        Plus = 7,
        Minus = 8,
        True = 9,
        False = 10,
        BitwiseOrLogicalNot = 11,
        Invalid = 255,

      public enum Microsoft.CodeAnalysis.Semantics.SyntheticLocalKind

        None = 0,
        ForLoopStepValue = 1,
        ForLoopLimitValue = 2,

      public enum Microsoft.CodeAnalysis.Semantics.UnaryOperandKind

        None = 0,
        OperatorMethod = 256,
        Integer = 512,
        Unsigned = 768,
        Floating = 1024,
        Decimal = 1280,
        Boolean = 1536,
        Enum = 1792,
        Dynamic = 2048,
        Object = 2304,
        Pointer = 2560,
        Invalid = 65280,

      public enum Microsoft.CodeAnalysis.Semantics.UnaryOperationKind

        None = 0,
        OperatorMethodBitwiseNegation = 257,
        OperatorMethodLogicalNot = 258,
        OperatorMethodPostfixIncrement = 259,
        OperatorMethodPostfixDecrement = 260,
        OperatorMethodPrefixIncrement = 261,
        OperatorMethodPrefixDecrement = 262,
        OperatorMethodPlus = 263,
        OperatorMethodMinus = 264,
        OperatorMethodTrue = 265,
        OperatorMethodFalse = 266,
        IntegerBitwiseNegation = 513,
        IntegerPlus = 519,
        IntegerMinus = 520,
        IntegerPostfixIncrement = 515,
        IntegerPostfixDecrement = 516,
        IntegerPrefixIncrement = 517,
        IntegerPrefixDecrement = 518,
        UnsignedPostfixIncrement = 771,
        UnsignedPostfixDecrement = 772,
        UnsignedPrefixIncrement = 773,
        UnsignedPrefixDecrement = 774,
        FloatingPlus = 1031,
        FloatingMinus = 1032,
        FloatingPostfixIncrement = 1027,
        FloatingPostfixDecrement = 1028,
        FloatingPrefixIncrement = 1029,
        FloatingPrefixDecrement = 1030,
        DecimalPlus = 1287,
        DecimalMinus = 1288,
        DecimalPostfixIncrement = 1283,
        DecimalPostfixDecrement = 1284,
        DecimalPrefixIncrement = 1285,
        DecimalPrefixDecrement = 1286,
        BooleanBitwiseNegation = 1537,
        BooleanLogicalNot = 1538,
        EnumPostfixIncrement = 1795,
        EnumPostfixDecrement = 1796,
        EnumPrefixIncrement = 1797,
        EnumPrefixDecrement = 1798,
        PointerPostfixIncrement = 2563,
        PointerPostfixDecrement = 2564,
        PointerPrefixIncrement = 2565,
        PointerPrefixDecrement = 2566,
        DynamicBitwiseNegation = 2049,
        DynamicLogicalNot = 2050,
        DynamicTrue = 2057,
        DynamicFalse = 2058,
        DynamicPlus = 2055,
        DynamicMinus = 2056,
        DynamicPostfixIncrement = 2051,
        DynamicPostfixDecrement = 2052,
        DynamicPrefixIncrement = 2053,
        DynamicPrefixDecrement = 2054,
        ObjectPlus = 2311,
        ObjectMinus = 2312,
        ObjectNot = 2315,
        Invalid = 65535,

      public enum Microsoft.CodeAnalysis.Text.SourceHashAlgorithm

        None = 0,
        Sha1 = 1,
        Sha256 = 2,

      public enum Roslynator.Visibility

        NotApplicable = 0,
        Private = 1,
        Internal = 2,
        Public = 3,

      public enum Roslynator.CSharp.CommentFilter

        None = 0,
        SingleLine = 1,
        MultiLine = 2,
        NonDocumentation = SingleLine | MultiLine,
        SingleLineDocumentation = 4,
        MultiLineDocumentation = 8,
        Documentation = SingleLineDocumentation | MultiLineDocumentation,
        All = NonDocumentation | Documentation,

      public enum Roslynator.CSharp.ModifierFilter

        None = 0,
        New = 1,
        Public = 2,
        Private = 4,
        Protected = 8,
        Internal = 16,
        Accessibility = Public | Private | Protected | Internal,
        Const = 32,
        Static = 64,
        Virtual = 128,
        Sealed = 256,
        Override = 512,
        Abstract = 1024,
        AbstractVirtualOverride = Virtual | Override | Abstract,
        ReadOnly = 2048,
        Extern = 4096,
        Unsafe = 8192,
        Volatile = 16384,
        Async = 32768,
        Partial = 65536,
        Ref = 131072,
        Out = 262144,
        In = 524288,
        Params = 1048576,
        This = 2097152,

      public enum Roslynator.CSharp.NullCheckStyles

        None = 0,
        EqualsToNull = 1,
        NotEqualsToNull = 2,
        ComparisonToNull = EqualsToNull | NotEqualsToNull,
        IsNull = 4,
        NotIsNull = 8,
        IsPattern = IsNull | NotIsNull,
        NotHasValue = 16,
        CheckingNull = EqualsToNull | IsNull | NotHasValue,
        HasValue = 32,
        CheckingNotNull = NotEqualsToNull | NotIsNull | HasValue,
        HasValueProperty = NotHasValue | HasValue,
        All = ComparisonToNull | IsPattern | HasValueProperty,

      public enum Roslynator.CSharp.PreprocessorDirectiveFilter

        None = 0,
        If = 1,
        Elif = 2,
        Else = 4,
        EndIf = 8,
        Region = 16,
        EndRegion = 32,
        Define = 64,
        Undef = 128,
        Error = 256,
        Warning = 512,
        Line = 1024,
        PragmaWarning = 2048,
        PragmaChecksum = 4096,
        Pragma = PragmaWarning | PragmaChecksum,
        Reference = 8192,
        Load = 16384,
        Bad = 32768,
        Shebang = 65536,
        All = If | Elif | Else | EndIf | Region | EndRegion | Define | Undef | Error | Warning | Line | Pragma | Reference | Load | Bad | Shebang,

    public struct Microsoft.CodeAnalysis.ChildSyntaxList : IEquatable<ChildSyntaxList>, IEnumerable<SyntaxNodeOrToken>, IReadOnlyCollection<SyntaxNodeOrToken>, IReadOnlyList<SyntaxNodeOrToken>

      public int Count { get; }

      public SyntaxNodeOrToken this[int index] { get; }

      public bool Any();
      public override bool Equals(object obj);
      public bool Equals(ChildSyntaxList other);
      public SyntaxNodeOrToken First();
      public ChildSyntaxList.Enumerator GetEnumerator();
      public override int GetHashCode();
      public SyntaxNodeOrToken Last();
      public ChildSyntaxList.Reversed Reverse();

      public static bool operator ==(ChildSyntaxList list1, ChildSyntaxList list2);
      public static bool operator !=(ChildSyntaxList list1, ChildSyntaxList list2);

    public struct Microsoft.CodeAnalysis.ChildSyntaxList.Enumerator

      public SyntaxNodeOrToken Current { get; }

      public bool MoveNext();
      public void Reset();

    public struct Microsoft.CodeAnalysis.ChildSyntaxList.Reversed : IEquatable<ChildSyntaxList.Reversed>, IEnumerable<SyntaxNodeOrToken>

      public override bool Equals(object obj);
      public bool Equals(ChildSyntaxList.Reversed other);
      public ChildSyntaxList.Reversed.Enumerator GetEnumerator();
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.ChildSyntaxList.Reversed.Enumerator

      public SyntaxNodeOrToken Current { get; }

      public bool MoveNext();
      public void Reset();

    public struct Microsoft.CodeAnalysis.CommandLineAnalyzerReference : IEquatable<CommandLineAnalyzerReference>

      public CommandLineAnalyzerReference(string path);

      public string FilePath { get; }

      public override bool Equals(object obj);
      public bool Equals(CommandLineAnalyzerReference other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.CommandLineReference : IEquatable<CommandLineReference>

      public CommandLineReference(string reference, MetadataReferenceProperties properties);

      public MetadataReferenceProperties Properties { get; }
      public string Reference { get; }

      public override bool Equals(object obj);
      public bool Equals(CommandLineReference other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.CommandLineSourceFile

      public CommandLineSourceFile(string path, bool isScript);

      public bool IsScript { get; }
      public string Path { get; }

    public struct Microsoft.CodeAnalysis.FileLinePositionSpan : IEquatable<FileLinePositionSpan>

      public FileLinePositionSpan(string path, LinePositionSpan span);
      public FileLinePositionSpan(string path, LinePosition start, LinePosition end);

      public LinePosition EndLinePosition { get; }
      public bool HasMappedPath { get; }
      public bool IsValid { get; }
      public string Path { get; }
      public LinePositionSpan Span { get; }
      public LinePosition StartLinePosition { get; }

      public bool Equals(FileLinePositionSpan other);
      public override bool Equals(object other);
      public override int GetHashCode();
      public override string ToString();

    public struct Microsoft.CodeAnalysis.MetadataReferenceProperties : IEquatable<MetadataReferenceProperties>

      public MetadataReferenceProperties(MetadataImageKind kind = Assembly, ImmutableArray<string> aliases = default, bool embedInteropTypes = false);

      public ImmutableArray<string> Aliases { get; }
      public static MetadataReferenceProperties Assembly { get; }
      public bool EmbedInteropTypes { get; }
      public static string GlobalAlias { get; }
      public MetadataImageKind Kind { get; }
      public static MetadataReferenceProperties Module { get; }

      public override bool Equals(object obj);
      public bool Equals(MetadataReferenceProperties other);
      public override int GetHashCode();
      public MetadataReferenceProperties WithAliases(IEnumerable<string> aliases);
      public MetadataReferenceProperties WithAliases(ImmutableArray<string> aliases);
      public MetadataReferenceProperties WithEmbedInteropTypes(bool embedInteropTypes);

      public static bool operator ==(MetadataReferenceProperties left, MetadataReferenceProperties right);
      public static bool operator !=(MetadataReferenceProperties left, MetadataReferenceProperties right);

    public struct Microsoft.CodeAnalysis.Optional<T>

      public Optional(T value);

      public bool HasValue { get; }
      public T Value { get; }

      public static implicit operator Optional<T>(T value);

    public struct Microsoft.CodeAnalysis.PreprocessingSymbolInfo : IEquatable<PreprocessingSymbolInfo>

      public bool IsDefined { get; }
      public IPreprocessingSymbol Symbol { get; }

      public override bool Equals(object obj);
      public bool Equals(PreprocessingSymbolInfo other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.ProjectChanges

      public Project NewProject { get; }
      public Project OldProject { get; }
      public ProjectId ProjectId { get; }

      public IEnumerable<DocumentId> GetAddedAdditionalDocuments();
      public IEnumerable<AnalyzerReference> GetAddedAnalyzerReferences();
      public IEnumerable<DocumentId> GetAddedDocuments();
      public IEnumerable<MetadataReference> GetAddedMetadataReferences();
      public IEnumerable<ProjectReference> GetAddedProjectReferences();
      public IEnumerable<DocumentId> GetChangedAdditionalDocuments();
      public IEnumerable<DocumentId> GetChangedDocuments();
      public IEnumerable<DocumentId> GetRemovedAdditionalDocuments();
      public IEnumerable<AnalyzerReference> GetRemovedAnalyzerReferences();
      public IEnumerable<DocumentId> GetRemovedDocuments();
      public IEnumerable<MetadataReference> GetRemovedMetadataReferences();
      public IEnumerable<ProjectReference> GetRemovedProjectReferences();

    public struct Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> : IEquatable<SeparatedSyntaxList<TNode>>, IEnumerable<TNode>, IReadOnlyCollection<TNode>, IReadOnlyList<TNode> where TNode : SyntaxNode

      public int Count { get; }
      public TextSpan FullSpan { get; }
      public int SeparatorCount { get; }
      public TextSpan Span { get; }

      public TNode this[int index] { get; }

      public SeparatedSyntaxList<TNode> Add(TNode node);
      public SeparatedSyntaxList<TNode> AddRange(IEnumerable<TNode> nodes);
      public bool Any();
      public bool Contains(TNode node);
      public override bool Equals(object obj);
      public bool Equals(SeparatedSyntaxList<TNode> other);
      public TNode First();
      public TNode FirstOrDefault();
      public SeparatedSyntaxList<TNode>.Enumerator GetEnumerator();
      public override int GetHashCode();
      public SyntaxToken GetSeparator(int index);
      public IEnumerable<SyntaxToken> GetSeparators();
      public SyntaxNodeOrTokenList GetWithSeparators();
      public int IndexOf(TNode node);
      public int IndexOf(Func<TNode, bool> predicate);
      public SeparatedSyntaxList<TNode> Insert(int index, TNode node);
      public SeparatedSyntaxList<TNode> InsertRange(int index, IEnumerable<TNode> nodes);
      public TNode Last();
      public int LastIndexOf(TNode node);
      public int LastIndexOf(Func<TNode, bool> predicate);
      public TNode LastOrDefault();
      public SeparatedSyntaxList<TNode> Remove(TNode node);
      public SeparatedSyntaxList<TNode> RemoveAt(int index);
      public SeparatedSyntaxList<TNode> Replace(TNode nodeInList, TNode newNode);
      public SeparatedSyntaxList<TNode> ReplaceRange(TNode nodeInList, IEnumerable<TNode> newNodes);
      public SeparatedSyntaxList<TNode> ReplaceSeparator(SyntaxToken separatorToken, SyntaxToken newSeparator);
      public string ToFullString();
      public override string ToString();

      public static implicit operator SeparatedSyntaxList<SyntaxNode>(SeparatedSyntaxList<TNode> nodes);
      public static implicit operator SeparatedSyntaxList<TNode>(SeparatedSyntaxList<SyntaxNode> nodes);

      public static bool operator ==(SeparatedSyntaxList<TNode> left, SeparatedSyntaxList<TNode> right);
      public static bool operator !=(SeparatedSyntaxList<TNode> left, SeparatedSyntaxList<TNode> right);

    public struct Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode>.Enumerator

      public TNode Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

    public struct Microsoft.CodeAnalysis.SolutionChanges

      public IEnumerable<Project> GetAddedProjects();
      public IEnumerable<ProjectChanges> GetProjectChanges();
      public IEnumerable<Project> GetRemovedProjects();

    public struct Microsoft.CodeAnalysis.SubsystemVersion : IEquatable<SubsystemVersion>

      public bool IsValid { get; }
      public int Major { get; }
      public int Minor { get; }
      public static SubsystemVersion None { get; }
      public static SubsystemVersion Windows2000 { get; }
      public static SubsystemVersion Windows7 { get; }
      public static SubsystemVersion Windows8 { get; }
      public static SubsystemVersion WindowsVista { get; }
      public static SubsystemVersion WindowsXP { get; }

      public static SubsystemVersion Create(int major, int minor);
      public override bool Equals(object obj);
      public bool Equals(SubsystemVersion other);
      public override int GetHashCode();
      public override string ToString();
      public static bool TryParse(string str, out SubsystemVersion version);

    public struct Microsoft.CodeAnalysis.SymbolDisplayPart

      public SymbolDisplayPart(SymbolDisplayPartKind kind, ISymbol symbol, string text);

      public SymbolDisplayPartKind Kind { get; }
      public ISymbol Symbol { get; }

      public override string ToString();

    public struct Microsoft.CodeAnalysis.SymbolInfo : IEquatable<SymbolInfo>

      public CandidateReason CandidateReason { get; }
      public ImmutableArray<ISymbol> CandidateSymbols { get; }
      public ISymbol Symbol { get; }

      public override bool Equals(object obj);
      public bool Equals(SymbolInfo other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.SyntaxList<TNode> : IEquatable<SyntaxList<TNode>>, IEnumerable<TNode>, IReadOnlyCollection<TNode>, IReadOnlyList<TNode> where TNode : SyntaxNode

      public int Count { get; }
      public TextSpan FullSpan { get; }
      public TextSpan Span { get; }

      public TNode this[int index] { get; }

      public SyntaxList<TNode> Add(TNode node);
      public SyntaxList<TNode> AddRange(IEnumerable<TNode> nodes);
      public bool Any();
      public override bool Equals(object obj);
      public bool Equals(SyntaxList<TNode> other);
      public TNode First();
      public TNode FirstOrDefault();
      public SyntaxList<TNode>.Enumerator GetEnumerator();
      public override int GetHashCode();
      public int IndexOf(TNode node);
      public int IndexOf(Func<TNode, bool> predicate);
      public SyntaxList<TNode> Insert(int index, TNode node);
      public SyntaxList<TNode> InsertRange(int index, IEnumerable<TNode> nodes);
      public TNode Last();
      public int LastIndexOf(TNode node);
      public int LastIndexOf(Func<TNode, bool> predicate);
      public TNode LastOrDefault();
      public SyntaxList<TNode> Remove(TNode node);
      public SyntaxList<TNode> RemoveAt(int index);
      public SyntaxList<TNode> Replace(TNode nodeInList, TNode newNode);
      public SyntaxList<TNode> ReplaceRange(TNode nodeInList, IEnumerable<TNode> newNodes);
      public string ToFullString();
      public override string ToString();

      public static implicit operator SyntaxList<TNode>(SyntaxList<SyntaxNode> nodes);
      public static implicit operator SyntaxList<SyntaxNode>(SyntaxList<TNode> nodes);

      public static bool operator ==(SyntaxList<TNode> left, SyntaxList<TNode> right);
      public static bool operator !=(SyntaxList<TNode> left, SyntaxList<TNode> right);

    public struct Microsoft.CodeAnalysis.SyntaxList<TNode>.Enumerator

      public TNode Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

    public struct Microsoft.CodeAnalysis.SyntaxNodeOrToken : IEquatable<SyntaxNodeOrToken>

      public bool ContainsAnnotations { get; }
      public bool ContainsDiagnostics { get; }
      public bool ContainsDirectives { get; }
      public TextSpan FullSpan { get; }
      public bool HasLeadingTrivia { get; }
      public bool HasTrailingTrivia { get; }
      public bool IsMissing { get; }
      public bool IsNode { get; }
      public bool IsToken { get; }
      public string Language { get; }
      public SyntaxNode Parent { get; }
      public int RawKind { get; }
      public TextSpan Span { get; }
      public int SpanStart { get; }
      public SyntaxTree SyntaxTree { get; }

      public SyntaxNode AsNode();
      public SyntaxToken AsToken();
      public ChildSyntaxList ChildNodesAndTokens();
      public override bool Equals(object obj);
      public bool Equals(SyntaxNodeOrToken other);
      public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind);
      public IEnumerable<SyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds);
      public IEnumerable<Diagnostic> GetDiagnostics();
      public static int GetFirstChildIndexSpanningPosition(SyntaxNode node, int position);
      public override int GetHashCode();
      public SyntaxTriviaList GetLeadingTrivia();
      public Location GetLocation();
      public SyntaxNodeOrToken GetNextSibling();
      public SyntaxNodeOrToken GetPreviousSibling();
      public SyntaxTriviaList GetTrailingTrivia();
      public bool HasAnnotation(SyntaxAnnotation annotation);
      public bool HasAnnotations(string annotationKind);
      public bool HasAnnotations(IEnumerable<string> annotationKinds);
      public bool IsEquivalentTo(SyntaxNodeOrToken other);
      public string ToFullString();
      public override string ToString();
      public SyntaxNodeOrToken WithAdditionalAnnotations(params SyntaxAnnotation[] annotations);
      public SyntaxNodeOrToken WithAdditionalAnnotations(IEnumerable<SyntaxAnnotation> annotations);
      public SyntaxNodeOrToken WithLeadingTrivia(IEnumerable<SyntaxTrivia> trivia);
      public SyntaxNodeOrToken WithLeadingTrivia(params SyntaxTrivia[] trivia);
      public SyntaxNodeOrToken WithTrailingTrivia(IEnumerable<SyntaxTrivia> trivia);
      public SyntaxNodeOrToken WithTrailingTrivia(params SyntaxTrivia[] trivia);
      public SyntaxNodeOrToken WithoutAnnotations(string annotationKind);
      public SyntaxNodeOrToken WithoutAnnotations(params SyntaxAnnotation[] annotations);
      public SyntaxNodeOrToken WithoutAnnotations(IEnumerable<SyntaxAnnotation> annotations);
      public void WriteTo(TextWriter writer);

      public static explicit operator SyntaxToken(SyntaxNodeOrToken nodeOrToken);
      public static explicit operator SyntaxNode(SyntaxNodeOrToken nodeOrToken);
      public static implicit operator SyntaxNodeOrToken(SyntaxToken token);
      public static implicit operator SyntaxNodeOrToken(SyntaxNode node);

      public static bool operator ==(SyntaxNodeOrToken left, SyntaxNodeOrToken right);
      public static bool operator !=(SyntaxNodeOrToken left, SyntaxNodeOrToken right);

    public struct Microsoft.CodeAnalysis.SyntaxNodeOrTokenList : IEquatable<SyntaxNodeOrTokenList>, IEnumerable<SyntaxNodeOrToken>, IReadOnlyCollection<SyntaxNodeOrToken>

      public int Count { get; }
      public TextSpan FullSpan { get; }
      public TextSpan Span { get; }

      public SyntaxNodeOrToken this[int index] { get; }

      public SyntaxNodeOrTokenList Add(SyntaxNodeOrToken nodeOrToken);
      public SyntaxNodeOrTokenList AddRange(IEnumerable<SyntaxNodeOrToken> nodesOrTokens);
      public bool Any();
      public override bool Equals(object obj);
      public bool Equals(SyntaxNodeOrTokenList other);
      public SyntaxNodeOrToken First();
      public SyntaxNodeOrToken FirstOrDefault();
      public SyntaxNodeOrTokenList.Enumerator GetEnumerator();
      public override int GetHashCode();
      public int IndexOf(SyntaxNodeOrToken nodeOrToken);
      public SyntaxNodeOrTokenList Insert(int index, SyntaxNodeOrToken nodeOrToken);
      public SyntaxNodeOrTokenList InsertRange(int index, IEnumerable<SyntaxNodeOrToken> nodesAndTokens);
      public SyntaxNodeOrToken Last();
      public SyntaxNodeOrToken LastOrDefault();
      public SyntaxNodeOrTokenList Remove(SyntaxNodeOrToken nodeOrTokenInList);
      public SyntaxNodeOrTokenList RemoveAt(int index);
      public SyntaxNodeOrTokenList Replace(SyntaxNodeOrToken nodeOrTokenInList, SyntaxNodeOrToken newNodeOrToken);
      public SyntaxNodeOrTokenList ReplaceRange(SyntaxNodeOrToken nodeOrTokenInList, IEnumerable<SyntaxNodeOrToken> newNodesAndTokens);
      public string ToFullString();
      public override string ToString();

      public static bool operator ==(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right);
      public static bool operator !=(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right);

    public struct Microsoft.CodeAnalysis.SyntaxNodeOrTokenList.Enumerator : IDisposable, IEnumerator, IEnumerator<SyntaxNodeOrToken>

      public SyntaxNodeOrToken Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();

    public struct Microsoft.CodeAnalysis.SyntaxToken : IEquatable<SyntaxToken>

      public bool ContainsAnnotations { get; }
      public bool ContainsDiagnostics { get; }
      public bool ContainsDirectives { get; }
      public TextSpan FullSpan { get; }
      public bool HasLeadingTrivia { get; }
      public bool HasStructuredTrivia { get; }
      public bool HasTrailingTrivia { get; }
      public bool IsMissing { get; }
      public string Language { get; }
      public SyntaxTriviaList LeadingTrivia { get; }
      public SyntaxNode Parent { get; }
      public int RawKind { get; }
      public TextSpan Span { get; }
      public int SpanStart { get; }
      public SyntaxTree SyntaxTree { get; }
      public string Text { get; }
      public SyntaxTriviaList TrailingTrivia { get; }
      public object Value { get; }
      public string ValueText { get; }

      public SyntaxToken CopyAnnotationsTo(SyntaxToken token);
      public override bool Equals(object obj);
      public bool Equals(SyntaxToken other);
      public IEnumerable<SyntaxTrivia> GetAllTrivia();
      public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind);
      public IEnumerable<SyntaxAnnotation> GetAnnotations(params string[] annotationKinds);
      public IEnumerable<SyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds);
      public IEnumerable<Diagnostic> GetDiagnostics();
      public override int GetHashCode();
      public Location GetLocation();
      public SyntaxToken GetNextToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false);
      public SyntaxToken GetPreviousToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false);
      public bool HasAnnotation(SyntaxAnnotation annotation);
      public bool HasAnnotations(string annotationKind);
      public bool HasAnnotations(params string[] annotationKinds);
      public bool IsEquivalentTo(SyntaxToken token);
      public bool IsPartOfStructuredTrivia();
      public string ToFullString();
      public override string ToString();
      public SyntaxToken WithAdditionalAnnotations(params SyntaxAnnotation[] annotations);
      public SyntaxToken WithAdditionalAnnotations(IEnumerable<SyntaxAnnotation> annotations);
      public SyntaxToken WithLeadingTrivia(SyntaxTriviaList trivia);
      public SyntaxToken WithLeadingTrivia(params SyntaxTrivia[] trivia);
      public SyntaxToken WithLeadingTrivia(IEnumerable<SyntaxTrivia> trivia);
      public SyntaxToken WithTrailingTrivia(SyntaxTriviaList trivia);
      public SyntaxToken WithTrailingTrivia(params SyntaxTrivia[] trivia);
      public SyntaxToken WithTrailingTrivia(IEnumerable<SyntaxTrivia> trivia);
      public SyntaxToken WithTriviaFrom(SyntaxToken token);
      public SyntaxToken WithoutAnnotations(string annotationKind);
      public SyntaxToken WithoutAnnotations(params SyntaxAnnotation[] annotations);
      public SyntaxToken WithoutAnnotations(IEnumerable<SyntaxAnnotation> annotations);
      public void WriteTo(TextWriter writer);

      public static bool operator ==(SyntaxToken left, SyntaxToken right);
      public static bool operator !=(SyntaxToken left, SyntaxToken right);

    public struct Microsoft.CodeAnalysis.SyntaxTokenList : IEquatable<SyntaxTokenList>, IEnumerable<SyntaxToken>, IReadOnlyCollection<SyntaxToken>, IReadOnlyList<SyntaxToken>

      public int Count { get; }
      public TextSpan FullSpan { get; }
      public TextSpan Span { get; }

      public SyntaxToken this[int index] { get; }

      public SyntaxTokenList Add(SyntaxToken token);
      public SyntaxTokenList AddRange(IEnumerable<SyntaxToken> tokens);
      public bool Any();
      public static SyntaxTokenList Create(SyntaxToken token);
      public override bool Equals(object obj);
      public bool Equals(SyntaxTokenList other);
      public SyntaxToken First();
      public SyntaxTokenList.Enumerator GetEnumerator();
      public override int GetHashCode();
      public int IndexOf(SyntaxToken tokenInList);
      public SyntaxTokenList Insert(int index, SyntaxToken token);
      public SyntaxTokenList InsertRange(int index, IEnumerable<SyntaxToken> tokens);
      public SyntaxToken Last();
      public SyntaxTokenList Remove(SyntaxToken tokenInList);
      public SyntaxTokenList RemoveAt(int index);
      public SyntaxTokenList Replace(SyntaxToken tokenInList, SyntaxToken newToken);
      public SyntaxTokenList ReplaceRange(SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens);
      public SyntaxTokenList.Reversed Reverse();
      public string ToFullString();
      public override string ToString();

      public static bool operator ==(SyntaxTokenList left, SyntaxTokenList right);
      public static bool operator !=(SyntaxTokenList left, SyntaxTokenList right);

    public struct Microsoft.CodeAnalysis.SyntaxTokenList.Enumerator

      public SyntaxToken Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();

    public struct Microsoft.CodeAnalysis.SyntaxTokenList.Reversed : IEquatable<SyntaxTokenList.Reversed>, IEnumerable<SyntaxToken>

      public Reversed(SyntaxTokenList list);

      public override bool Equals(object obj);
      public bool Equals(SyntaxTokenList.Reversed other);
      public SyntaxTokenList.Reversed.Enumerator GetEnumerator();
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.SyntaxTokenList.Reversed.Enumerator

      public Enumerator(ref SyntaxTokenList list);

      public SyntaxToken Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();

    public struct Microsoft.CodeAnalysis.SyntaxTrivia : IEquatable<SyntaxTrivia>

      public bool ContainsDiagnostics { get; }
      public TextSpan FullSpan { get; }
      public bool HasStructure { get; }
      public bool IsDirective { get; }
      public string Language { get; }
      public int RawKind { get; }
      public TextSpan Span { get; }
      public int SpanStart { get; }
      public SyntaxTree SyntaxTree { get; }
      public SyntaxToken Token { get; }

      public SyntaxTrivia CopyAnnotationsTo(SyntaxTrivia trivia);
      public override bool Equals(object obj);
      public bool Equals(SyntaxTrivia other);
      public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind);
      public IEnumerable<SyntaxAnnotation> GetAnnotations(params string[] annotationKinds);
      public IEnumerable<Diagnostic> GetDiagnostics();
      public override int GetHashCode();
      public Location GetLocation();
      public SyntaxNode GetStructure();
      public bool HasAnnotation(SyntaxAnnotation annotation);
      public bool HasAnnotations(string annotationKind);
      public bool HasAnnotations(params string[] annotationKinds);
      public bool IsEquivalentTo(SyntaxTrivia trivia);
      public bool IsPartOfStructuredTrivia();
      public string ToFullString();
      public override string ToString();
      public SyntaxTrivia WithAdditionalAnnotations(params SyntaxAnnotation[] annotations);
      public SyntaxTrivia WithAdditionalAnnotations(IEnumerable<SyntaxAnnotation> annotations);
      public SyntaxTrivia WithoutAnnotations(string annotationKind);
      public SyntaxTrivia WithoutAnnotations(params SyntaxAnnotation[] annotations);
      public SyntaxTrivia WithoutAnnotations(IEnumerable<SyntaxAnnotation> annotations);
      public void WriteTo(TextWriter writer);

      public static bool operator ==(SyntaxTrivia left, SyntaxTrivia right);
      public static bool operator !=(SyntaxTrivia left, SyntaxTrivia right);

    public struct Microsoft.CodeAnalysis.SyntaxTriviaList : IEquatable<SyntaxTriviaList>, IEnumerable<SyntaxTrivia>, IReadOnlyCollection<SyntaxTrivia>, IReadOnlyList<SyntaxTrivia>

      public int Count { get; }
      public static SyntaxTriviaList Empty { get; }
      public TextSpan FullSpan { get; }
      public TextSpan Span { get; }

      public SyntaxTrivia this[int index] { get; }

      public SyntaxTriviaList Add(SyntaxTrivia trivia);
      public SyntaxTriviaList AddRange(IEnumerable<SyntaxTrivia> trivia);
      public bool Any();
      public static SyntaxTriviaList Create(SyntaxTrivia trivia);
      public SyntaxTrivia ElementAt(int index);
      public override bool Equals(object obj);
      public bool Equals(SyntaxTriviaList other);
      public SyntaxTrivia First();
      public SyntaxTriviaList.Enumerator GetEnumerator();
      public override int GetHashCode();
      public int IndexOf(SyntaxTrivia triviaInList);
      public SyntaxTriviaList Insert(int index, SyntaxTrivia trivia);
      public SyntaxTriviaList InsertRange(int index, IEnumerable<SyntaxTrivia> trivia);
      public SyntaxTrivia Last();
      public SyntaxTriviaList Remove(SyntaxTrivia triviaInList);
      public SyntaxTriviaList RemoveAt(int index);
      public SyntaxTriviaList Replace(SyntaxTrivia triviaInList, SyntaxTrivia newTrivia);
      public SyntaxTriviaList ReplaceRange(SyntaxTrivia triviaInList, IEnumerable<SyntaxTrivia> newTrivia);
      public SyntaxTriviaList.Reversed Reverse();
      public string ToFullString();
      public override string ToString();

      public static bool operator ==(SyntaxTriviaList left, SyntaxTriviaList right);
      public static bool operator !=(SyntaxTriviaList left, SyntaxTriviaList right);

    public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Enumerator

      public SyntaxTrivia Current { get; }

      public bool MoveNext();

    public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed : IEquatable<SyntaxTriviaList.Reversed>, IEnumerable<SyntaxTrivia>

      public Reversed(SyntaxTriviaList list);

      public override bool Equals(object obj);
      public bool Equals(SyntaxTriviaList.Reversed other);
      public SyntaxTriviaList.Reversed.Enumerator GetEnumerator();
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.SyntaxTriviaList.Reversed.Enumerator

      public Enumerator(ref SyntaxTriviaList list);

      public SyntaxTrivia Current { get; }

      public bool MoveNext();

    public struct Microsoft.CodeAnalysis.TypeInfo : IEquatable<TypeInfo>

      public ITypeSymbol ConvertedType { get; }
      public ITypeSymbol Type { get; }

      public override bool Equals(object obj);
      public bool Equals(TypeInfo other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.TypedConstant : IEquatable<TypedConstant>

      public bool IsNull { get; }
      public TypedConstantKind Kind { get; }
      public ITypeSymbol Type { get; }
      public object Value { get; }
      public ImmutableArray<TypedConstant> Values { get; }

      public override bool Equals(object obj);
      public bool Equals(TypedConstant other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.VersionStamp : IEquatable<VersionStamp>, IObjectWritable

      public static VersionStamp Default { get; }

      public static VersionStamp Create();
      public static VersionStamp Create(DateTime utcTimeLastModified);
      public override bool Equals(object obj);
      public bool Equals(VersionStamp version);
      public override int GetHashCode();
      public VersionStamp GetNewerVersion();
      public VersionStamp GetNewerVersion(VersionStamp version);
      public override string ToString();

      public static bool operator ==(VersionStamp left, VersionStamp right);
      public static bool operator !=(VersionStamp left, VersionStamp right);

    public struct Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo : IEquatable<AwaitExpressionInfo>

      public IMethodSymbol GetAwaiterMethod { get; }
      public IMethodSymbol GetResultMethod { get; }
      public IPropertySymbol IsCompletedProperty { get; }
      public bool IsDynamic { get; }

      public override bool Equals(object obj);
      public bool Equals(AwaitExpressionInfo other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.CSharp.Conversion : IEquatable<Conversion>

      public bool Exists { get; }
      public bool IsAnonymousFunction { get; }
      public bool IsBoxing { get; }
      public bool IsConstantExpression { get; }
      public bool IsDynamic { get; }
      public bool IsEnumeration { get; }
      public bool IsExplicit { get; }
      public bool IsIdentity { get; }
      public bool IsImplicit { get; }
      public bool IsIntPtr { get; }
      public bool IsInterpolatedString { get; }
      public bool IsMethodGroup { get; }
      public bool IsNullLiteral { get; }
      public bool IsNullable { get; }
      public bool IsNumeric { get; }
      public bool IsPointer { get; }
      public bool IsReference { get; }
      public bool IsThrow { get; }
      public bool IsTupleConversion { get; }
      public bool IsTupleLiteralConversion { get; }
      public bool IsUnboxing { get; }
      public bool IsUserDefined { get; }
      public IMethodSymbol MethodSymbol { get; }

      public override bool Equals(object obj);
      public bool Equals(Conversion other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(Conversion left, Conversion right);
      public static bool operator !=(Conversion left, Conversion right);

    public struct Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo : IEquatable<ForEachStatementInfo>

      public Conversion CurrentConversion { get; }
      public IPropertySymbol CurrentProperty { get; }
      public IMethodSymbol DisposeMethod { get; }
      public Conversion ElementConversion { get; }
      public ITypeSymbol ElementType { get; }
      public IMethodSymbol GetEnumeratorMethod { get; }
      public IMethodSymbol MoveNextMethod { get; }

      public override bool Equals(object obj);
      public bool Equals(ForEachStatementInfo other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.CSharp.QueryClauseInfo : IEquatable<QueryClauseInfo>

      public SymbolInfo CastInfo { get; }
      public SymbolInfo OperationInfo { get; }

      public override bool Equals(object obj);
      public bool Equals(QueryClauseInfo other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.Classification.ClassifiedSpan : IEquatable<ClassifiedSpan>

      public ClassifiedSpan(string classificationType, TextSpan textSpan);
      public ClassifiedSpan(TextSpan textSpan, string classificationType);

      public string ClassificationType { get; }
      public TextSpan TextSpan { get; }

      public override bool Equals(object obj);
      public bool Equals(ClassifiedSpan other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.CodeFixes.CodeFixContext

      public CodeFixContext(Document document, Diagnostic diagnostic, Action<CodeAction, ImmutableArray<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);
      public CodeFixContext(Document document, TextSpan span, ImmutableArray<Diagnostic> diagnostics, Action<CodeAction, ImmutableArray<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public ImmutableArray<Diagnostic> Diagnostics { get; }
      public Document Document { get; }
      public TextSpan Span { get; }

      public void RegisterCodeFix(CodeAction action, Diagnostic diagnostic);
      public void RegisterCodeFix(CodeAction action, IEnumerable<Diagnostic> diagnostics);
      public void RegisterCodeFix(CodeAction action, ImmutableArray<Diagnostic> diagnostics);

    public struct Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext

      public CodeRefactoringContext(Document document, TextSpan span, Action<CodeAction> registerRefactoring, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public Document Document { get; }
      public TextSpan Span { get; }

      public void RegisterRefactoring(CodeAction action);

    public struct Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext

      public CodeBlockAnalysisContext(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public SyntaxNode CodeBlock { get; }
      public AnalyzerOptions Options { get; }
      public ISymbol OwningSymbol { get; }
      public SemanticModel SemanticModel { get; }

      public void ReportDiagnostic(Diagnostic diagnostic);

    public struct Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext

      public CompilationAnalysisContext(Compilation compilation, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public Compilation Compilation { get; }
      public AnalyzerOptions Options { get; }

      public void ReportDiagnostic(Diagnostic diagnostic);
      public bool TryGetValue<TValue>(SourceText text, SourceTextValueProvider<TValue> valueProvider, out TValue value);
      public bool TryGetValue<TValue>(SyntaxTree tree, SyntaxTreeValueProvider<TValue> valueProvider, out TValue value);

    public struct Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext

      public OperationAnalysisContext(IOperation operation, ISymbol containingSymbol, Compilation compilation, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public Compilation Compilation { get; }
      public ISymbol ContainingSymbol { get; }
      public IOperation Operation { get; }
      public AnalyzerOptions Options { get; }

      public void ReportDiagnostic(Diagnostic diagnostic);

    public struct Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext

      public OperationBlockAnalysisContext(ImmutableArray<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public Compilation Compilation { get; }
      public ImmutableArray<IOperation> OperationBlocks { get; }
      public AnalyzerOptions Options { get; }
      public ISymbol OwningSymbol { get; }

      public void ReportDiagnostic(Diagnostic diagnostic);

    public struct Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext

      public SemanticModelAnalysisContext(SemanticModel semanticModel, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public AnalyzerOptions Options { get; }
      public SemanticModel SemanticModel { get; }

      public void ReportDiagnostic(Diagnostic diagnostic);

    public struct Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext

      public SymbolAnalysisContext(ISymbol symbol, Compilation compilation, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public Compilation Compilation { get; }
      public AnalyzerOptions Options { get; }
      public ISymbol Symbol { get; }

      public void ReportDiagnostic(Diagnostic diagnostic);

    public struct Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext

      public SyntaxNodeAnalysisContext(SyntaxNode node, SemanticModel semanticModel, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
      public SyntaxNodeAnalysisContext(SyntaxNode node, ISymbol containingSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public Compilation Compilation { get; }
      public ISymbol ContainingSymbol { get; }
      public SyntaxNode Node { get; }
      public AnalyzerOptions Options { get; }
      public SemanticModel SemanticModel { get; }

      public void ReportDiagnostic(Diagnostic diagnostic);

    public struct Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext

      public SyntaxTreeAnalysisContext(SyntaxTree tree, AnalyzerOptions options, Action<Diagnostic> reportDiagnostic, Func<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);

      public CancellationToken CancellationToken { get; }
      public AnalyzerOptions Options { get; }
      public SyntaxTree Tree { get; }

      public void ReportDiagnostic(Diagnostic diagnostic);

    public struct Microsoft.CodeAnalysis.Differencing.Edit<TNode> : IEquatable<Edit<TNode>>

      public EditKind Kind { get; }
      public TNode NewNode { get; }
      public TNode OldNode { get; }

      public override bool Equals(object obj);
      public bool Equals(Edit<TNode> other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.Editing.DeclarationModifiers : IEquatable<DeclarationModifiers>

      public static DeclarationModifiers Abstract { get; }
      public static DeclarationModifiers Async { get; }
      public static DeclarationModifiers Const { get; }
      public bool IsAbstract { get; }
      public bool IsAsync { get; }
      public bool IsConst { get; }
      public bool IsNew { get; }
      public bool IsOverride { get; }
      public bool IsPartial { get; }
      public bool IsReadOnly { get; }
      public bool IsSealed { get; }
      public bool IsStatic { get; }
      public bool IsUnsafe { get; }
      public bool IsVirtual { get; }
      public bool IsWithEvents { get; }
      public bool IsWriteOnly { get; }
      public static DeclarationModifiers New { get; }
      public static DeclarationModifiers None { get; }
      public static DeclarationModifiers Override { get; }
      public static DeclarationModifiers Partial { get; }
      public static DeclarationModifiers ReadOnly { get; }
      public static DeclarationModifiers Sealed { get; }
      public static DeclarationModifiers Static { get; }
      public static DeclarationModifiers Unsafe { get; }
      public static DeclarationModifiers Virtual { get; }
      public static DeclarationModifiers WithEvents { get; }
      public static DeclarationModifiers WriteOnly { get; }

      public bool Equals(DeclarationModifiers modifiers);
      public override bool Equals(object obj);
      public static DeclarationModifiers From(ISymbol symbol);
      public override int GetHashCode();
      public override string ToString();
      public static bool TryParse(string value, out DeclarationModifiers modifiers);
      public DeclarationModifiers WithAsync(bool isAsync);
      public DeclarationModifiers WithIsAbstract(bool isAbstract);
      public DeclarationModifiers WithIsConst(bool isConst);
      public DeclarationModifiers WithIsNew(bool isNew);
      public DeclarationModifiers WithIsOverride(bool isOverride);
      public DeclarationModifiers WithIsReadOnly(bool isReadOnly);
      public DeclarationModifiers WithIsSealed(bool isSealed);
      public DeclarationModifiers WithIsStatic(bool isStatic);
      public DeclarationModifiers WithIsUnsafe(bool isUnsafe);
      public DeclarationModifiers WithIsVirtual(bool isVirtual);
      public DeclarationModifiers WithIsWriteOnly(bool isWriteOnly);
      public DeclarationModifiers WithPartial(bool isPartial);
      public DeclarationModifiers WithWithEvents(bool withEvents);

      public static DeclarationModifiers operator +(DeclarationModifiers left, DeclarationModifiers right);
      public static DeclarationModifiers operator &(DeclarationModifiers left, DeclarationModifiers right);
      public static DeclarationModifiers operator |(DeclarationModifiers left, DeclarationModifiers right);
      public static bool operator ==(DeclarationModifiers left, DeclarationModifiers right);
      public static bool operator !=(DeclarationModifiers left, DeclarationModifiers right);
      public static DeclarationModifiers operator -(DeclarationModifiers left, DeclarationModifiers right);

    public struct Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation

      public static EditAndContinueMethodDebugInformation Create(ImmutableArray<byte> compressedSlotMap, ImmutableArray<byte> compressedLambdaMap);

    public struct Microsoft.CodeAnalysis.Emit.SemanticEdit : IEquatable<SemanticEdit>

      public SemanticEdit(SemanticEditKind kind, ISymbol oldSymbol, ISymbol newSymbol, Func<SyntaxNode, SyntaxNode> syntaxMap = null, bool preserveLocalVariables = false);

      public SemanticEditKind Kind { get; }
      public ISymbol NewSymbol { get; }
      public ISymbol OldSymbol { get; }
      public bool PreserveLocalVariables { get; }
      public Func<SyntaxNode, SyntaxNode> SyntaxMap { get; }

      public override bool Equals(object obj);
      public bool Equals(SemanticEdit other);
      public override int GetHashCode();

    public struct Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation : IComparable<ReferenceLocation>, IEquatable<ReferenceLocation>

      public IAliasSymbol Alias { get; }
      public CandidateReason CandidateReason { get; }
      public Document Document { get; }
      public bool IsCandidateLocation { get; }
      public bool IsImplicit { get; }
      public Location Location { get; }

      public int CompareTo(ReferenceLocation other);
      public override bool Equals(object obj);
      public bool Equals(ReferenceLocation other);
      public override int GetHashCode();

      public static bool operator ==(ReferenceLocation left, ReferenceLocation right);
      public static bool operator !=(ReferenceLocation left, ReferenceLocation right);

    public struct Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo

      public ISymbol CalledSymbol { get; }
      public ISymbol CallingSymbol { get; }
      public bool IsDirect { get; }
      public IEnumerable<Location> Locations { get; }

    public struct Microsoft.CodeAnalysis.Options.OptionKey : IEquatable<OptionKey>

      public OptionKey(IOption option, string language = null);

      public string Language { get; }
      public IOption Option { get; }

      public override bool Equals(object obj);
      public bool Equals(OptionKey other);
      public override int GetHashCode();

      public static bool operator ==(OptionKey left, OptionKey right);
      public static bool operator !=(OptionKey left, OptionKey right);

    public struct Microsoft.CodeAnalysis.Text.LinePosition : IComparable<LinePosition>, IEquatable<LinePosition>

      public LinePosition(int line, int character);

      public int Character { get; }
      public int Line { get; }
      public static LinePosition Zero { get; }

      public int CompareTo(LinePosition other);
      public override bool Equals(object obj);
      public bool Equals(LinePosition other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(LinePosition left, LinePosition right);
      public static bool operator >(LinePosition left, LinePosition right);
      public static bool operator >=(LinePosition left, LinePosition right);
      public static bool operator !=(LinePosition left, LinePosition right);
      public static bool operator <(LinePosition left, LinePosition right);
      public static bool operator <=(LinePosition left, LinePosition right);

    public struct Microsoft.CodeAnalysis.Text.LinePositionSpan : IEquatable<LinePositionSpan>

      public LinePositionSpan(LinePosition start, LinePosition end);

      public LinePosition End { get; }
      public LinePosition Start { get; }

      public override bool Equals(object obj);
      public bool Equals(LinePositionSpan other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(LinePositionSpan left, LinePositionSpan right);
      public static bool operator !=(LinePositionSpan left, LinePositionSpan right);

    public struct Microsoft.CodeAnalysis.Text.TextChange : IEquatable<TextChange>

      public TextChange(TextSpan span, string newText);

      public string NewText { get; }
      public static IReadOnlyList<TextChange> NoChanges { get; }
      public TextSpan Span { get; }

      public override bool Equals(object obj);
      public bool Equals(TextChange other);
      public override int GetHashCode();
      public override string ToString();

      public static implicit operator TextChangeRange(TextChange change);

      public static bool operator ==(TextChange left, TextChange right);
      public static bool operator !=(TextChange left, TextChange right);

    public struct Microsoft.CodeAnalysis.Text.TextChangeRange : IEquatable<TextChangeRange>

      public TextChangeRange(TextSpan span, int newLength);

      public int NewLength { get; }
      public static IReadOnlyList<TextChangeRange> NoChanges { get; }
      public TextSpan Span { get; }

      public static TextChangeRange Collapse(IEnumerable<TextChangeRange> changes);
      public override bool Equals(object obj);
      public bool Equals(TextChangeRange other);
      public override int GetHashCode();

      public static bool operator ==(TextChangeRange left, TextChangeRange right);
      public static bool operator !=(TextChangeRange left, TextChangeRange right);

    public struct Microsoft.CodeAnalysis.Text.TextLine : IEquatable<TextLine>

      public int End { get; }
      public int EndIncludingLineBreak { get; }
      public int LineNumber { get; }
      public TextSpan Span { get; }
      public TextSpan SpanIncludingLineBreak { get; }
      public int Start { get; }
      public SourceText Text { get; }

      public override bool Equals(object obj);
      public bool Equals(TextLine other);
      public static TextLine FromSpan(SourceText text, TextSpan span);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(TextLine left, TextLine right);
      public static bool operator !=(TextLine left, TextLine right);

    public struct Microsoft.CodeAnalysis.Text.TextLineCollection.Enumerator : IDisposable, IEnumerator, IEnumerator<TextLine>

      public TextLine Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();

    public struct Microsoft.CodeAnalysis.Text.TextSpan : IComparable<TextSpan>, IEquatable<TextSpan>

      public TextSpan(int start, int length);

      public int End { get; }
      public bool IsEmpty { get; }
      public int Length { get; }
      public int Start { get; }

      public int CompareTo(TextSpan other);
      public bool Contains(int position);
      public bool Contains(TextSpan span);
      public override bool Equals(object obj);
      public bool Equals(TextSpan other);
      public static TextSpan FromBounds(int start, int end);
      public override int GetHashCode();
      public TextSpan? Intersection(TextSpan span);
      public bool IntersectsWith(int position);
      public bool IntersectsWith(TextSpan span);
      public TextSpan? Overlap(TextSpan span);
      public bool OverlapsWith(TextSpan span);
      public override string ToString();

      public static bool operator ==(TextSpan left, TextSpan right);
      public static bool operator !=(TextSpan left, TextSpan right);

    public readonly struct Roslynator.ExtensionMethodSymbolInfo : IEquatable<ExtensionMethodSymbolInfo>

      public bool IsReduced { get; }
      public IMethodSymbol ReducedSymbol { get; }
      public IMethodSymbol ReducedSymbolOrSymbol { get; }
      public IMethodSymbol Symbol { get; }

      public override bool Equals(object obj);
      public bool Equals(ExtensionMethodSymbolInfo other);
      public override int GetHashCode();

      public static bool operator ==(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2);
      public static bool operator !=(in ExtensionMethodSymbolInfo info1, in ExtensionMethodSymbolInfo info2);

    public readonly struct Roslynator.MetadataName : IEquatable<MetadataName>

      public MetadataName(IEnumerable<string> containingNamespaces, string name);
      public MetadataName(ImmutableArray<string> containingNamespaces, string name);
      public MetadataName(IEnumerable<string> containingNamespaces, IEnumerable<string> containingTypes, string name);
      public MetadataName(ImmutableArray<string> containingNamespaces, ImmutableArray<string> containingTypes, string name);

      public ImmutableArray<string> ContainingNamespaces { get; }
      public ImmutableArray<string> ContainingTypes { get; }
      public bool IsDefault { get; }
      public string Name { get; }

      public override bool Equals(object obj);
      public bool Equals(MetadataName other);
      public override int GetHashCode();
      public static MetadataName Parse(string name);
      public override string ToString();
      public static bool TryParse(string name, out MetadataName metadataName);

      public static bool operator ==(in MetadataName metadataName1, in MetadataName metadataName2);
      public static bool operator !=(in MetadataName metadataName1, in MetadataName metadataName2);

    public struct Roslynator.SeparatedSyntaxListSelection<TNode>.Enumerator

      public TNode Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

    public struct Roslynator.SyntaxListSelection<TNode>.Enumerator

      public TNode Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

    public readonly struct Roslynator.CSharp.ExpressionChain : IEquatable<ExpressionChain>, IEnumerable<ExpressionSyntax>

      public BinaryExpressionSyntax BinaryExpression { get; }
      public TextSpan? Span { get; }

      public override bool Equals(object obj);
      public bool Equals(ExpressionChain other);
      public ExpressionChain.Enumerator GetEnumerator();
      public override int GetHashCode();
      public ExpressionChain.Reversed Reverse();
      public override string ToString();

      public static bool operator ==(in ExpressionChain info1, in ExpressionChain info2);
      public static bool operator !=(in ExpressionChain info1, in ExpressionChain info2);

    public struct Roslynator.CSharp.ExpressionChain.Enumerator

      public ExpressionSyntax Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

    public readonly struct Roslynator.CSharp.ExpressionChain.Reversed : IEquatable<ExpressionChain.Reversed>, IEnumerable<ExpressionSyntax>

      public Reversed(in ExpressionChain chain);

      public override bool Equals(object obj);
      public bool Equals(ExpressionChain.Reversed other);
      public ExpressionChain.Reversed.Enumerator GetEnumerator();
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2);
      public static bool operator !=(in ExpressionChain.Reversed reversed1, in ExpressionChain.Reversed reversed2);

    public struct Roslynator.CSharp.ExpressionChain.Reversed.Enumerator

      public ExpressionSyntax Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

    public readonly struct Roslynator.CSharp.IfStatementCascade : IEquatable<IfStatementCascade>, IEnumerable<IfStatementOrElseClause>

      public IfStatementSyntax IfStatement { get; }

      public override bool Equals(object obj);
      public bool Equals(IfStatementCascade other);
      public IfStatementCascade.Enumerator GetEnumerator();
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in IfStatementCascade cascade1, in IfStatementCascade cascade2);
      public static bool operator !=(in IfStatementCascade cascade1, in IfStatementCascade cascade2);

    public struct Roslynator.CSharp.IfStatementCascade.Enumerator

      public IfStatementOrElseClause Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

    public readonly struct Roslynator.CSharp.IfStatementCascadeInfo : IEquatable<IfStatementCascadeInfo>

      public IfStatementCascadeInfo(IfStatementSyntax ifStatement);

      public int Count { get; }
      public bool EndsWithElse { get; }
      public bool EndsWithIf { get; }
      public IfStatementSyntax IfStatement { get; }
      public bool IsSimpleIf { get; }
      public bool IsSimpleIfElse { get; }
      public IfStatementOrElseClause Last { get; }

      public override bool Equals(object obj);
      public bool Equals(IfStatementCascadeInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2);
      public static bool operator !=(in IfStatementCascadeInfo info1, in IfStatementCascadeInfo info2);

    public readonly struct Roslynator.CSharp.IfStatementOrElseClause : IEquatable<IfStatementOrElseClause>

      public IfStatementOrElseClause(ElseClauseSyntax elseClause);
      public IfStatementOrElseClause(IfStatementSyntax ifStatement);

      public TextSpan FullSpan { get; }
      public bool IsElse { get; }
      public bool IsIf { get; }
      public SyntaxKind Kind { get; }
      public SyntaxNode Parent { get; }
      public TextSpan Span { get; }
      public StatementSyntax Statement { get; }

      public ElseClauseSyntax AsElse();
      public IfStatementSyntax AsIf();
      public override bool Equals(object obj);
      public bool Equals(IfStatementOrElseClause other);
      public override int GetHashCode();
      public override string ToString();

      public static implicit operator IfStatementOrElseClause(IfStatementSyntax ifStatement);
      public static implicit operator IfStatementSyntax(in IfStatementOrElseClause ifOrElse);
      public static implicit operator IfStatementOrElseClause(ElseClauseSyntax elseClause);
      public static implicit operator ElseClauseSyntax(in IfStatementOrElseClause ifOrElse);

      public static bool operator ==(in IfStatementOrElseClause left, in IfStatementOrElseClause right);
      public static bool operator !=(in IfStatementOrElseClause left, in IfStatementOrElseClause right);

    public readonly struct Roslynator.CSharp.Syntax.AsExpressionInfo : IEquatable<AsExpressionInfo>

      public BinaryExpressionSyntax AsExpression { get; }
      public ExpressionSyntax Expression { get; }
      public SyntaxToken OperatorToken { get; }
      public bool Success { get; }
      public TypeSyntax Type { get; }

      public override bool Equals(object obj);
      public bool Equals(AsExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in AsExpressionInfo info1, in AsExpressionInfo info2);
      public static bool operator !=(in AsExpressionInfo info1, in AsExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.AssignmentExpressionInfo : IEquatable<AssignmentExpressionInfo>

      public AssignmentExpressionSyntax AssignmentExpression { get; }
      public SyntaxKind Kind { get; }
      public ExpressionSyntax Left { get; }
      public SyntaxToken OperatorToken { get; }
      public ExpressionSyntax Right { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(AssignmentExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2);
      public static bool operator !=(in AssignmentExpressionInfo info1, in AssignmentExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.BinaryExpressionInfo : IEquatable<BinaryExpressionInfo>

      public BinaryExpressionSyntax BinaryExpression { get; }
      public SyntaxKind Kind { get; }
      public ExpressionSyntax Left { get; }
      public SyntaxToken OperatorToken { get; }
      public ExpressionSyntax Right { get; }
      public bool Success { get; }

      public ExpressionChain AsChain();
      public override bool Equals(object obj);
      public bool Equals(BinaryExpressionInfo other);
      public IEnumerable<ExpressionSyntax> Expressions(bool leftToRight = false);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2);
      public static bool operator !=(in BinaryExpressionInfo info1, in BinaryExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.ConditionalExpressionInfo : IEquatable<ConditionalExpressionInfo>

      public SyntaxToken ColonToken { get; }
      public ExpressionSyntax Condition { get; }
      public ConditionalExpressionSyntax ConditionalExpression { get; }
      public SyntaxToken QuestionToken { get; }
      public bool Success { get; }
      public ExpressionSyntax WhenFalse { get; }
      public ExpressionSyntax WhenTrue { get; }

      public override bool Equals(object obj);
      public bool Equals(ConditionalExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2);
      public static bool operator !=(in ConditionalExpressionInfo info1, in ConditionalExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.GenericInfo : IEquatable<GenericInfo>

      public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
      public SyntaxKind Kind { get; }
      public SyntaxNode Node { get; }
      public bool Success { get; }
      public TypeParameterListSyntax TypeParameterList { get; }
      public SeparatedSyntaxList<TypeParameterSyntax> TypeParameters { get; }

      public override bool Equals(object obj);
      public bool Equals(GenericInfo other);
      public TypeParameterConstraintClauseSyntax FindConstraintClause(string typeParameterName);
      public TypeParameterSyntax FindTypeParameter(string name);
      public override int GetHashCode();
      public GenericInfo RemoveAllConstraintClauses();
      public GenericInfo RemoveConstraintClause(TypeParameterConstraintClauseSyntax constraintClause);
      public GenericInfo RemoveTypeParameter(TypeParameterSyntax typeParameter);
      public override string ToString();
      public GenericInfo WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
      public GenericInfo WithTypeParameterList(TypeParameterListSyntax typeParameterList);

      public static bool operator ==(in GenericInfo info1, in GenericInfo info2);
      public static bool operator !=(in GenericInfo info1, in GenericInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.IsExpressionInfo : IEquatable<IsExpressionInfo>

      public ExpressionSyntax Expression { get; }
      public BinaryExpressionSyntax IsExpression { get; }
      public SyntaxToken OperatorToken { get; }
      public bool Success { get; }
      public TypeSyntax Type { get; }

      public override bool Equals(object obj);
      public bool Equals(IsExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in IsExpressionInfo info1, in IsExpressionInfo info2);
      public static bool operator !=(in IsExpressionInfo info1, in IsExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.LocalDeclarationStatementInfo : IEquatable<LocalDeclarationStatementInfo>

      public VariableDeclarationSyntax Declaration { get; }
      public SyntaxTokenList Modifiers { get; }
      public SyntaxToken SemicolonToken { get; }
      public LocalDeclarationStatementSyntax Statement { get; }
      public bool Success { get; }
      public TypeSyntax Type { get; }
      public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get; }

      public override bool Equals(object obj);
      public bool Equals(LocalDeclarationStatementInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2);
      public static bool operator !=(in LocalDeclarationStatementInfo info1, in LocalDeclarationStatementInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.MemberDeclarationListInfo : IEquatable<MemberDeclarationListInfo>, IReadOnlyList<MemberDeclarationSyntax>

      public int Count { get; }
      public SyntaxList<MemberDeclarationSyntax> Members { get; }
      public SyntaxNode Parent { get; }
      public bool Success { get; }

      public MemberDeclarationSyntax this[int index] { get; }

      public MemberDeclarationListInfo Add(MemberDeclarationSyntax member);
      public MemberDeclarationListInfo AddRange(IEnumerable<MemberDeclarationSyntax> members);
      public bool Any();
      public override bool Equals(object obj);
      public bool Equals(MemberDeclarationListInfo other);
      public MemberDeclarationSyntax First();
      public MemberDeclarationSyntax FirstOrDefault();
      public SyntaxList<MemberDeclarationSyntax>.Enumerator GetEnumerator();
      public override int GetHashCode();
      public int IndexOf(MemberDeclarationSyntax member);
      public int IndexOf(Func<MemberDeclarationSyntax, bool> predicate);
      public MemberDeclarationListInfo Insert(int index, MemberDeclarationSyntax member);
      public MemberDeclarationListInfo InsertRange(int index, IEnumerable<MemberDeclarationSyntax> members);
      public MemberDeclarationSyntax Last();
      public int LastIndexOf(MemberDeclarationSyntax member);
      public int LastIndexOf(Func<MemberDeclarationSyntax, bool> predicate);
      public MemberDeclarationSyntax LastOrDefault();
      public MemberDeclarationListInfo Remove(MemberDeclarationSyntax member);
      public MemberDeclarationListInfo RemoveAt(int index);
      public MemberDeclarationListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
      public MemberDeclarationListInfo Replace(MemberDeclarationSyntax memberInList, MemberDeclarationSyntax newMember);
      public MemberDeclarationListInfo ReplaceAt(int index, MemberDeclarationSyntax newMember);
      public MemberDeclarationListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
      public MemberDeclarationListInfo ReplaceRange(MemberDeclarationSyntax memberInList, IEnumerable<MemberDeclarationSyntax> newMembers);
      public override string ToString();
      public MemberDeclarationListInfo WithMembers(IEnumerable<MemberDeclarationSyntax> members);
      public MemberDeclarationListInfo WithMembers(SyntaxList<MemberDeclarationSyntax> members);

      public static bool operator ==(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2);
      public static bool operator !=(in MemberDeclarationListInfo info1, in MemberDeclarationListInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.ModifierListInfo : IEquatable<ModifierListInfo>

      public Accessibility ExplicitAccessibility { get; }
      public bool IsAbstract { get; }
      public bool IsAsync { get; }
      public bool IsConst { get; }
      public bool IsExtern { get; }
      public bool IsIn { get; }
      public bool IsNew { get; }
      public bool IsOut { get; }
      public bool IsOverride { get; }
      public bool IsParams { get; }
      public bool IsPartial { get; }
      public bool IsReadOnly { get; }
      public bool IsRef { get; }
      public bool IsSealed { get; }
      public bool IsStatic { get; }
      public bool IsUnsafe { get; }
      public bool IsVirtual { get; }
      public bool IsVolatile { get; }
      public SyntaxTokenList Modifiers { get; }
      public SyntaxNode Parent { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(ModifierListInfo other);
      public ModifierFilter GetFilter();
      public override int GetHashCode();
      public override string ToString();
      public ModifierListInfo WithExplicitAccessibility(Accessibility newAccessibility, IComparer<SyntaxKind> comparer = null);
      public ModifierListInfo WithModifiers(SyntaxTokenList modifiers);
      public ModifierListInfo WithoutExplicitAccessibility();

      public static bool operator ==(in ModifierListInfo info1, in ModifierListInfo info2);
      public static bool operator !=(in ModifierListInfo info1, in ModifierListInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.NullCheckExpressionInfo : IEquatable<NullCheckExpressionInfo>

      public ExpressionSyntax Expression { get; }
      public bool IsCheckingNotNull { get; }
      public bool IsCheckingNull { get; }
      public ExpressionSyntax NullCheckExpression { get; }
      public NullCheckStyles Style { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(NullCheckExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2);
      public static bool operator !=(in NullCheckExpressionInfo info1, in NullCheckExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.RegionInfo : IEquatable<RegionInfo>

      public RegionDirectiveTriviaSyntax Directive { get; }
      public EndRegionDirectiveTriviaSyntax EndDirective { get; }
      public TextSpan FullSpan { get; }
      public bool IsEmpty { get; }
      public TextSpan Span { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(RegionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in RegionInfo info1, in RegionInfo info2);
      public static bool operator !=(in RegionInfo info1, in RegionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.SimpleAssignmentExpressionInfo : IEquatable<SimpleAssignmentExpressionInfo>

      public AssignmentExpressionSyntax AssignmentExpression { get; }
      public ExpressionSyntax Left { get; }
      public SyntaxToken OperatorToken { get; }
      public ExpressionSyntax Right { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(SimpleAssignmentExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2);
      public static bool operator !=(in SimpleAssignmentExpressionInfo info1, in SimpleAssignmentExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.SimpleAssignmentStatementInfo : IEquatable<SimpleAssignmentStatementInfo>

      public AssignmentExpressionSyntax AssignmentExpression { get; }
      public ExpressionSyntax Left { get; }
      public SyntaxToken OperatorToken { get; }
      public ExpressionSyntax Right { get; }
      public ExpressionStatementSyntax Statement { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(SimpleAssignmentStatementInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2);
      public static bool operator !=(in SimpleAssignmentStatementInfo info1, in SimpleAssignmentStatementInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.SimpleIfElseInfo : IEquatable<SimpleIfElseInfo>

      public ExpressionSyntax Condition { get; }
      public ElseClauseSyntax Else { get; }
      public IfStatementSyntax IfStatement { get; }
      public bool Success { get; }
      public StatementSyntax WhenFalse { get; }
      public StatementSyntax WhenTrue { get; }

      public override bool Equals(object obj);
      public bool Equals(SimpleIfElseInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2);
      public static bool operator !=(in SimpleIfElseInfo info1, in SimpleIfElseInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.SimpleIfStatementInfo : IEquatable<SimpleIfStatementInfo>

      public ExpressionSyntax Condition { get; }
      public IfStatementSyntax IfStatement { get; }
      public StatementSyntax Statement { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(SimpleIfStatementInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2);
      public static bool operator !=(in SimpleIfStatementInfo info1, in SimpleIfStatementInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.SimpleMemberInvocationExpressionInfo : IEquatable<SimpleMemberInvocationExpressionInfo>

      public ArgumentListSyntax ArgumentList { get; }
      public SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
      public ExpressionSyntax Expression { get; }
      public InvocationExpressionSyntax InvocationExpression { get; }
      public MemberAccessExpressionSyntax MemberAccessExpression { get; }
      public SimpleNameSyntax Name { get; }
      public string NameText { get; }
      public SyntaxToken OperatorToken { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(SimpleMemberInvocationExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2);
      public static bool operator !=(in SimpleMemberInvocationExpressionInfo info1, in SimpleMemberInvocationExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.SimpleMemberInvocationStatementInfo : IEquatable<SimpleMemberInvocationStatementInfo>

      public ArgumentListSyntax ArgumentList { get; }
      public SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
      public ExpressionSyntax Expression { get; }
      public InvocationExpressionSyntax InvocationExpression { get; }
      public MemberAccessExpressionSyntax MemberAccessExpression { get; }
      public SimpleNameSyntax Name { get; }
      public string NameText { get; }
      public ExpressionStatementSyntax Statement { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(SimpleMemberInvocationStatementInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2);
      public static bool operator !=(in SimpleMemberInvocationStatementInfo info1, in SimpleMemberInvocationStatementInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.SingleLocalDeclarationStatementInfo : IEquatable<SingleLocalDeclarationStatementInfo>

      public VariableDeclarationSyntax Declaration { get; }
      public VariableDeclaratorSyntax Declarator { get; }
      public SyntaxToken EqualsToken { get; }
      public SyntaxToken Identifier { get; }
      public string IdentifierText { get; }
      public EqualsValueClauseSyntax Initializer { get; }
      public SyntaxTokenList Modifiers { get; }
      public SyntaxToken SemicolonToken { get; }
      public LocalDeclarationStatementSyntax Statement { get; }
      public bool Success { get; }
      public TypeSyntax Type { get; }
      public ExpressionSyntax Value { get; }

      public override bool Equals(object obj);
      public bool Equals(SingleLocalDeclarationStatementInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2);
      public static bool operator !=(in SingleLocalDeclarationStatementInfo info1, in SingleLocalDeclarationStatementInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.SingleParameterLambdaExpressionInfo : IEquatable<SingleParameterLambdaExpressionInfo>

      public CSharpSyntaxNode Body { get; }
      public bool IsParenthesizedLambda { get; }
      public bool IsSimpleLambda { get; }
      public LambdaExpressionSyntax LambdaExpression { get; }
      public ParameterSyntax Parameter { get; }
      public ParameterListSyntax ParameterList { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(SingleParameterLambdaExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2);
      public static bool operator !=(in SingleParameterLambdaExpressionInfo info1, in SingleParameterLambdaExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.StatementListInfo : IEquatable<StatementListInfo>, IReadOnlyList<StatementSyntax>

      public int Count { get; }
      public bool IsParentBlock { get; }
      public bool IsParentSwitchSection { get; }
      public SyntaxNode Parent { get; }
      public BlockSyntax ParentAsBlock { get; }
      public SwitchSectionSyntax ParentAsSwitchSection { get; }
      public SyntaxList<StatementSyntax> Statements { get; }
      public bool Success { get; }

      public StatementSyntax this[int index] { get; }

      public StatementListInfo Add(StatementSyntax statement);
      public StatementListInfo AddRange(IEnumerable<StatementSyntax> statements);
      public bool Any();
      public override bool Equals(object obj);
      public bool Equals(StatementListInfo other);
      public StatementSyntax First();
      public StatementSyntax FirstOrDefault();
      public SyntaxList<StatementSyntax>.Enumerator GetEnumerator();
      public override int GetHashCode();
      public int IndexOf(Func<StatementSyntax, bool> predicate);
      public int IndexOf(StatementSyntax statement);
      public StatementListInfo Insert(int index, StatementSyntax statement);
      public StatementListInfo InsertRange(int index, IEnumerable<StatementSyntax> statements);
      public StatementSyntax Last();
      public int LastIndexOf(Func<StatementSyntax, bool> predicate);
      public int LastIndexOf(StatementSyntax statement);
      public StatementSyntax LastOrDefault();
      public StatementListInfo Remove(StatementSyntax statement);
      public StatementListInfo RemoveAt(int index);
      public StatementListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
      public StatementListInfo Replace(StatementSyntax statementInList, StatementSyntax newStatement);
      public StatementListInfo ReplaceAt(int index, StatementSyntax newStatement);
      public StatementListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
      public StatementListInfo ReplaceRange(StatementSyntax statementInList, IEnumerable<StatementSyntax> newStatements);
      public override string ToString();
      public StatementListInfo WithStatements(IEnumerable<StatementSyntax> statements);
      public StatementListInfo WithStatements(SyntaxList<StatementSyntax> statements);

      public static bool operator ==(in StatementListInfo info1, in StatementListInfo info2);
      public static bool operator !=(in StatementListInfo info1, in StatementListInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.StringConcatenationExpressionInfo : IEquatable<StringConcatenationExpressionInfo>

      public BinaryExpressionSyntax BinaryExpression { get; }
      public bool Success { get; }

      public ExpressionChain AsChain();
      public override bool Equals(object obj);
      public bool Equals(StringConcatenationExpressionInfo other);
      public IEnumerable<ExpressionSyntax> Expressions(bool leftToRight = false);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2);
      public static bool operator !=(in StringConcatenationExpressionInfo info1, in StringConcatenationExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.StringLiteralExpressionInfo : IEquatable<StringLiteralExpressionInfo>

      public bool ContainsEscapeSequence { get; }
      public bool ContainsLinefeed { get; }
      public LiteralExpressionSyntax Expression { get; }
      public string InnerText { get; }
      public bool IsRegular { get; }
      public bool IsVerbatim { get; }
      public bool Success { get; }
      public string Text { get; }
      public SyntaxToken Token { get; }
      public string ValueText { get; }

      public override bool Equals(object obj);
      public bool Equals(StringLiteralExpressionInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2);
      public static bool operator !=(in StringLiteralExpressionInfo info1, in StringLiteralExpressionInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.UsingDirectiveListInfo : IEquatable<UsingDirectiveListInfo>, IReadOnlyList<UsingDirectiveSyntax>

      public int Count { get; }
      public SyntaxNode Parent { get; }
      public bool Success { get; }
      public SyntaxList<UsingDirectiveSyntax> Usings { get; }

      public UsingDirectiveSyntax this[int index] { get; }

      public UsingDirectiveListInfo Add(UsingDirectiveSyntax usingDirective);
      public UsingDirectiveListInfo AddRange(IEnumerable<UsingDirectiveSyntax> usings);
      public bool Any();
      public override bool Equals(object obj);
      public bool Equals(UsingDirectiveListInfo other);
      public UsingDirectiveSyntax First();
      public UsingDirectiveSyntax FirstOrDefault();
      public SyntaxList<UsingDirectiveSyntax>.Enumerator GetEnumerator();
      public override int GetHashCode();
      public int IndexOf(Func<UsingDirectiveSyntax, bool> predicate);
      public int IndexOf(UsingDirectiveSyntax usingDirective);
      public UsingDirectiveListInfo Insert(int index, UsingDirectiveSyntax usingDirective);
      public UsingDirectiveListInfo InsertRange(int index, IEnumerable<UsingDirectiveSyntax> usings);
      public UsingDirectiveSyntax Last();
      public int LastIndexOf(Func<UsingDirectiveSyntax, bool> predicate);
      public int LastIndexOf(UsingDirectiveSyntax usingDirective);
      public UsingDirectiveSyntax LastOrDefault();
      public UsingDirectiveListInfo Remove(UsingDirectiveSyntax usingDirective);
      public UsingDirectiveListInfo RemoveAt(int index);
      public UsingDirectiveListInfo RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
      public UsingDirectiveListInfo Replace(UsingDirectiveSyntax usingInLine, UsingDirectiveSyntax newUsingDirective);
      public UsingDirectiveListInfo ReplaceAt(int index, UsingDirectiveSyntax newUsingDirective);
      public UsingDirectiveListInfo ReplaceNode(SyntaxNode oldNode, SyntaxNode newNode);
      public UsingDirectiveListInfo ReplaceRange(UsingDirectiveSyntax usingInLine, IEnumerable<UsingDirectiveSyntax> newUsingDirectives);
      public override string ToString();
      public UsingDirectiveListInfo WithUsings(IEnumerable<UsingDirectiveSyntax> usings);
      public UsingDirectiveListInfo WithUsings(SyntaxList<UsingDirectiveSyntax> usings);

      public static bool operator ==(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2);
      public static bool operator !=(in UsingDirectiveListInfo info1, in UsingDirectiveListInfo info2);

    public readonly struct Roslynator.CSharp.Syntax.XmlElementInfo : IEquatable<XmlElementInfo>

      public XmlNodeSyntax Element { get; }
      public bool IsEmptyElement { get; }
      public SyntaxKind Kind { get; }
      public string LocalName { get; }
      public bool Success { get; }

      public override bool Equals(object obj);
      public bool Equals(XmlElementInfo other);
      public override int GetHashCode();
      public override string ToString();

      public static bool operator ==(in XmlElementInfo info1, in XmlElementInfo info2);
      public static bool operator !=(in XmlElementInfo info1, in XmlElementInfo info2);

    public struct Roslynator.Text.TextLineCollectionSelection.Enumerator

      public TextLine Current { get; }

      public override bool Equals(object obj);
      public override int GetHashCode();
      public bool MoveNext();
      public void Reset();

  public abstract class System.Collections.Generic.EqualityComparer<T> : IEqualityComparer, IEqualityComparer<T>

    public sealed class Roslynator.MetadataNameEqualityComparer<TSymbol> : EqualityComparer<TSymbol> where TSymbol : ISymbol

      public static MetadataNameEqualityComparer<TSymbol> Instance { get; }

      public override bool Equals(TSymbol x, TSymbol y);
      public override int GetHashCode(TSymbol obj);

  public abstract class Microsoft.CodeAnalysis.AdditionalText

    protected AdditionalText();

    public abstract string Path { get; }

    public abstract SourceText GetText(CancellationToken cancellationToken = default);

  public sealed class Microsoft.CodeAnalysis.AssemblyIdentity : IEquatable<AssemblyIdentity>

    public AssemblyIdentity(string name, Version version = null, string cultureName = null, ImmutableArray<byte> publicKeyOrToken = default, bool hasPublicKey = false, bool isRetargetable = false, AssemblyContentType contentType = Default);

    public AssemblyContentType ContentType { get; }
    public string CultureName { get; }
    public AssemblyNameFlags Flags { get; }
    public bool HasPublicKey { get; }
    public bool IsRetargetable { get; }
    public bool IsStrongName { get; }
    public string Name { get; }
    public ImmutableArray<byte> PublicKey { get; }
    public ImmutableArray<byte> PublicKeyToken { get; }
    public Version Version { get; }

    public bool Equals(AssemblyIdentity obj);
    public override bool Equals(object obj);
    public static AssemblyIdentity FromAssemblyDefinition(Assembly assembly);
    public string GetDisplayName(bool fullKey = false);
    public override int GetHashCode();
    public override string ToString();
    public static bool TryParseDisplayName(string displayName, out AssemblyIdentity identity);
    public static bool TryParseDisplayName(string displayName, out AssemblyIdentity identity, out AssemblyIdentityParts parts);

    public static bool operator ==(AssemblyIdentity left, AssemblyIdentity right);
    public static bool operator !=(AssemblyIdentity left, AssemblyIdentity right);

  public class Microsoft.CodeAnalysis.AssemblyIdentityComparer

    public static StringComparer CultureComparer { get; }
    public static AssemblyIdentityComparer Default { get; }
    public static StringComparer SimpleNameComparer { get; }

    public AssemblyIdentityComparer.ComparisonResult Compare(AssemblyIdentity reference, AssemblyIdentity definition);
    public bool ReferenceMatchesDefinition(AssemblyIdentity reference, AssemblyIdentity definition);
    public bool ReferenceMatchesDefinition(string referenceDisplayName, AssemblyIdentity definition);

    public sealed class Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer : AssemblyIdentityComparer

      public static DesktopAssemblyIdentityComparer Default { get; }

      public static DesktopAssemblyIdentityComparer LoadFromXml(Stream input);

  public abstract class Microsoft.CodeAnalysis.AttributeData

    protected AttributeData();

    public SyntaxReference ApplicationSyntaxReference { get; }
    public INamedTypeSymbol AttributeClass { get; }
    public IMethodSymbol AttributeConstructor { get; }
    protected abstract SyntaxReference CommonApplicationSyntaxReference { get; }
    protected abstract INamedTypeSymbol CommonAttributeClass { get; }
    protected abstract IMethodSymbol CommonAttributeConstructor { get; }
    protected internal abstract ImmutableArray<TypedConstant> CommonConstructorArguments { get; }
    protected internal abstract ImmutableArray<KeyValuePair<string, TypedConstant>> CommonNamedArguments { get; }
    public ImmutableArray<TypedConstant> ConstructorArguments { get; }
    public ImmutableArray<KeyValuePair<string, TypedConstant>> NamedArguments { get; }

  public abstract class Microsoft.CodeAnalysis.CommandLineArguments

    public ImmutableArray<CommandLineSourceFile> AdditionalFiles { get; }
    public ImmutableArray<CommandLineAnalyzerReference> AnalyzerReferences { get; }
    public string AppConfigPath { get; }
    public string BaseDirectory { get; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; }
    public string CompilationName { get; }
    public CompilationOptions CompilationOptions { get; }
    protected abstract CompilationOptions CompilationOptionsCore { get; }
    public bool DisplayHelp { get; }
    public bool DisplayLogo { get; }
    public bool DisplayVersion { get; }
    public string DocumentationPath { get; }
    public ImmutableArray<CommandLineSourceFile> EmbeddedFiles { get; }
    public EmitOptions EmitOptions { get; }
    public bool EmitPdb { get; }
    public Encoding Encoding { get; }
    public string ErrorLogPath { get; }
    public ImmutableArray<Diagnostic> Errors { get; }
    public bool InteractiveMode { get; }
    public ImmutableArray<string> KeyFileSearchPaths { get; }
    public ImmutableArray<ResourceDescription> ManifestResources { get; }
    public ImmutableArray<CommandLineReference> MetadataReferences { get; }
    public bool NoWin32Manifest { get; }
    public string OutputDirectory { get; }
    public string OutputFileName { get; }
    public string OutputRefFilePath { get; }
    public ParseOptions ParseOptions { get; }
    protected abstract ParseOptions ParseOptionsCore { get; }
    public ImmutableArray<KeyValuePair<string, string>> PathMap { get; }
    public string PdbPath { get; }
    public CultureInfo PreferredUILang { get; }
    public bool PrintFullPaths { get; }
    public ImmutableArray<string> ReferencePaths { get; }
    public bool ReportAnalyzer { get; }
    public string RuleSetPath { get; }
    public ImmutableArray<string> ScriptArguments { get; }
    public ImmutableArray<CommandLineSourceFile> SourceFiles { get; }
    public string SourceLink { get; }
    public ImmutableArray<string> SourcePaths { get; }
    public string TouchedFilesPath { get; }
    public bool Utf8Output { get; }
    public string Win32Icon { get; }
    public string Win32Manifest { get; }
    public string Win32ResourceFile { get; }

    public IEnumerable<AnalyzerReference> ResolveAnalyzerReferences(IAnalyzerAssemblyLoader analyzerLoader);
    public IEnumerable<MetadataReference> ResolveMetadataReferences(MetadataReferenceResolver metadataResolver);

    public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments : CommandLineArguments

      public CSharpCompilationOptions CompilationOptions { get; }
      protected override CompilationOptions CompilationOptionsCore { get; }
      public CSharpParseOptions ParseOptions { get; }
      protected override ParseOptions ParseOptionsCore { get; }

  public abstract class Microsoft.CodeAnalysis.CommandLineParser

    protected abstract string RegularFileExtension { get; }
    protected abstract string ScriptFileExtension { get; }

    public CommandLineArguments Parse(IEnumerable<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories);
    protected ImmutableArray<KeyValuePair<string, string>> ParsePathMap(string pathMap, IList<Diagnostic> errors);
    public static IEnumerable<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments);

    public class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser : CommandLineParser

      public static CSharpCommandLineParser Default { get; }
      protected override string RegularFileExtension { get; }
      protected override string ScriptFileExtension { get; }

      public CSharpCommandLineArguments Parse(IEnumerable<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories = null);
      public static IEnumerable<string> ParseConditionalCompilationSymbols(string value, out IEnumerable<Diagnostic> diagnostics);

  public abstract class Microsoft.CodeAnalysis.Compilation

    public IAssemblySymbol Assembly { get; }
    public string AssemblyName { get; }
    protected abstract IAssemblySymbol CommonAssembly { get; }
    protected abstract ITypeSymbol CommonDynamicType { get; }
    protected abstract INamespaceSymbol CommonGlobalNamespace { get; }
    protected abstract INamedTypeSymbol CommonObjectType { get; }
    protected abstract CompilationOptions CommonOptions { get; }
    protected abstract INamedTypeSymbol CommonScriptClass { get; }
    protected abstract IModuleSymbol CommonSourceModule { get; }
    protected abstract IEnumerable<SyntaxTree> CommonSyntaxTrees { get; }
    public abstract ImmutableArray<MetadataReference> DirectiveReferences { get; }
    public ITypeSymbol DynamicType { get; }
    public ImmutableArray<MetadataReference> ExternalReferences { get; }
    public INamespaceSymbol GlobalNamespace { get; }
    public abstract bool IsCaseSensitive { get; }
    public abstract string Language { get; }
    public INamedTypeSymbol ObjectType { get; }
    public CompilationOptions Options { get; }
    public abstract IEnumerable<AssemblyIdentity> ReferencedAssemblyNames { get; }
    public IEnumerable<MetadataReference> References { get; }
    public INamedTypeSymbol ScriptClass { get; }
    public ScriptCompilationInfo ScriptCompilationInfo { get; }
    public IModuleSymbol SourceModule { get; }
    public IEnumerable<SyntaxTree> SyntaxTrees { get; }

    public Compilation AddReferences(params MetadataReference[] references);
    public Compilation AddReferences(IEnumerable<MetadataReference> references);
    public Compilation AddSyntaxTrees(params SyntaxTree[] trees);
    public Compilation AddSyntaxTrees(IEnumerable<SyntaxTree> trees);
    protected abstract void AppendDefaultVersionResource(Stream resourceStream);
    protected static void CheckTupleElementLocations(int cardinality, ImmutableArray<Location> elementLocations);
    protected static ImmutableArray<string> CheckTupleElementNames(int cardinality, ImmutableArray<string> elementNames);
    public Compilation Clone();
    protected abstract Compilation CommonAddSyntaxTrees(IEnumerable<SyntaxTree> trees);
    protected INamedTypeSymbol CommonBindScriptClass();
    protected abstract Compilation CommonClone();
    protected abstract bool CommonContainsSyntaxTree(SyntaxTree syntaxTree);
    protected abstract INamedTypeSymbol CommonCreateAnonymousTypeSymbol(ImmutableArray<ITypeSymbol> memberTypes, ImmutableArray<string> memberNames, ImmutableArray<Location> memberLocations, ImmutableArray<bool> memberIsReadOnly);
    protected abstract IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    protected abstract INamespaceSymbol CommonCreateErrorNamespaceSymbol(INamespaceSymbol container, string name);
    protected abstract INamedTypeSymbol CommonCreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
    protected abstract IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType);
    protected abstract INamedTypeSymbol CommonCreateTupleTypeSymbol(ImmutableArray<ITypeSymbol> elementTypes, ImmutableArray<string> elementNames, ImmutableArray<Location> elementLocations);
    protected abstract INamedTypeSymbol CommonCreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray<string> elementNames, ImmutableArray<Location> elementLocations);
    protected abstract ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference);
    protected abstract INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    protected abstract IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken);
    protected abstract SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    protected abstract INamedTypeSymbol CommonGetSpecialType(SpecialType specialType);
    protected abstract INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName);
    protected abstract Compilation CommonRemoveAllSyntaxTrees();
    protected abstract Compilation CommonRemoveSyntaxTrees(IEnumerable<SyntaxTree> trees);
    protected abstract Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    protected abstract Compilation CommonWithAssemblyName(string outputName);
    protected abstract Compilation CommonWithOptions(CompilationOptions options);
    protected abstract Compilation CommonWithReferences(IEnumerable<MetadataReference> newReferences);
    protected abstract Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info);
    public abstract bool ContainsSymbolsWithName(Func<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default);
    public bool ContainsSyntaxTree(SyntaxTree syntaxTree);
    public INamedTypeSymbol CreateAnonymousTypeSymbol(ImmutableArray<ITypeSymbol> memberTypes, ImmutableArray<string> memberNames, ImmutableArray<bool> memberIsReadOnly = default, ImmutableArray<Location> memberLocations = default);
    public IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank = 1);
    public Stream CreateDefaultWin32Resources(bool versionResource, bool noManifest, Stream manifestContents, Stream iconInIcoFormat);
    public INamespaceSymbol CreateErrorNamespaceSymbol(INamespaceSymbol container, string name);
    public INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
    public IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public INamedTypeSymbol CreateTupleTypeSymbol(ImmutableArray<ITypeSymbol> elementTypes, ImmutableArray<string> elementNames = default, ImmutableArray<Location> elementLocations = default);
    public INamedTypeSymbol CreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray<string> elementNames = default, ImmutableArray<Location> elementLocations = default);
    public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable<ResourceDescription> manifestResources, EmitOptions options, CancellationToken cancellationToken);
    public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CancellationToken cancellationToken);
    public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable<EmbeddedText> embeddedTexts, CancellationToken cancellationToken);
    public EmitResult Emit(Stream peStream, Stream pdbStream = null, Stream xmlDocumentationStream = null, Stream win32Resources = null, IEnumerable<ResourceDescription> manifestResources = null, EmitOptions options = null, IMethodSymbol debugEntryPoint = null, Stream sourceLinkStream = null, IEnumerable<EmbeddedText> embeddedTexts = null, Stream metadataPEStream = null, CancellationToken cancellationToken = default);
    public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable<SemanticEdit> edits, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken = default);
    public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable<SemanticEdit> edits, Func<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken = default);
    public ISymbol GetAssemblyOrModuleSymbol(MetadataReference reference);
    public INamespaceSymbol GetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    public abstract ImmutableArray<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken = default);
    public abstract ImmutableArray<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default);
    public IMethodSymbol GetEntryPoint(CancellationToken cancellationToken);
    public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol);
    public abstract ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken = default);
    public abstract ImmutableArray<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken = default);
    public static string GetRequiredLanguageVersion(Diagnostic diagnostic);
    public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility = false);
    public INamedTypeSymbol GetSpecialType(SpecialType specialType);
    public abstract IEnumerable<ISymbol> GetSymbolsWithName(Func<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default);
    public INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    public ImmutableArray<AssemblyIdentity> GetUnreferencedAssemblyIdentities(Diagnostic diagnostic);
    public Compilation RemoveAllReferences();
    public Compilation RemoveAllSyntaxTrees();
    public Compilation RemoveReferences(params MetadataReference[] references);
    public Compilation RemoveReferences(IEnumerable<MetadataReference> references);
    public Compilation RemoveSyntaxTrees(params SyntaxTree[] trees);
    public Compilation RemoveSyntaxTrees(IEnumerable<SyntaxTree> trees);
    public Compilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference);
    public Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    protected static IReadOnlyDictionary<string, string> SyntaxTreeCommonFeatures(IEnumerable<SyntaxTree> trees);
    public abstract CompilationReference ToMetadataReference(ImmutableArray<string> aliases = default, bool embedInteropTypes = false);
    public Compilation WithAssemblyName(string assemblyName);
    public Compilation WithOptions(CompilationOptions options);
    public Compilation WithReferences(IEnumerable<MetadataReference> newReferences);
    public Compilation WithReferences(params MetadataReference[] newReferences);
    public Compilation WithScriptCompilationInfo(ScriptCompilationInfo info);

    public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCompilation : Compilation

      protected override IAssemblySymbol CommonAssembly { get; }
      protected override ITypeSymbol CommonDynamicType { get; }
      protected override INamespaceSymbol CommonGlobalNamespace { get; }
      protected override INamedTypeSymbol CommonObjectType { get; }
      protected override CompilationOptions CommonOptions { get; }
      protected override INamedTypeSymbol CommonScriptClass { get; }
      protected override IModuleSymbol CommonSourceModule { get; }
      protected override IEnumerable<SyntaxTree> CommonSyntaxTrees { get; }
      public override ImmutableArray<MetadataReference> DirectiveReferences { get; }
      public override bool IsCaseSensitive { get; }
      public override string Language { get; }
      public LanguageVersion LanguageVersion { get; }
      public CSharpCompilationOptions Options { get; }
      public override IEnumerable<AssemblyIdentity> ReferencedAssemblyNames { get; }
      public CSharpScriptCompilationInfo ScriptCompilationInfo { get; }
      public ImmutableArray<SyntaxTree> SyntaxTrees { get; }

      public CSharpCompilation AddReferences(params MetadataReference[] references);
      public CSharpCompilation AddReferences(IEnumerable<MetadataReference> references);
      public CSharpCompilation AddSyntaxTrees(params SyntaxTree[] trees);
      public CSharpCompilation AddSyntaxTrees(IEnumerable<SyntaxTree> trees);
      protected override void AppendDefaultVersionResource(Stream resourceStream);
      public Conversion ClassifyConversion(ITypeSymbol source, ITypeSymbol destination);
      public CSharpCompilation Clone();
      protected override Compilation CommonAddSyntaxTrees(IEnumerable<SyntaxTree> trees);
      protected override Compilation CommonClone();
      protected override bool CommonContainsSyntaxTree(SyntaxTree syntaxTree);
      protected override INamedTypeSymbol CommonCreateAnonymousTypeSymbol(ImmutableArray<ITypeSymbol> memberTypes, ImmutableArray<string> memberNames, ImmutableArray<Location> memberLocations, ImmutableArray<bool> memberIsReadOnly);
      protected override IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
      protected override INamespaceSymbol CommonCreateErrorNamespaceSymbol(INamespaceSymbol container, string name);
      protected override INamedTypeSymbol CommonCreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
      protected override IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType);
      protected override INamedTypeSymbol CommonCreateTupleTypeSymbol(ImmutableArray<ITypeSymbol> elementTypes, ImmutableArray<string> elementNames, ImmutableArray<Location> elementLocations);
      protected override INamedTypeSymbol CommonCreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray<string> elementNames, ImmutableArray<Location> elementLocations);
      protected override ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference);
      protected override INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol);
      protected override IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken);
      protected override SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
      protected override INamedTypeSymbol CommonGetSpecialType(SpecialType specialType);
      protected override INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName);
      protected override Compilation CommonRemoveAllSyntaxTrees();
      protected override Compilation CommonRemoveSyntaxTrees(IEnumerable<SyntaxTree> trees);
      protected override Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
      protected override Compilation CommonWithAssemblyName(string assemblyName);
      protected override Compilation CommonWithOptions(CompilationOptions options);
      protected override Compilation CommonWithReferences(IEnumerable<MetadataReference> newReferences);
      protected override Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info);
      public override bool ContainsSymbolsWithName(Func<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default);
      public bool ContainsSyntaxTree(SyntaxTree syntaxTree);
      public static CSharpCompilation Create(string assemblyName, IEnumerable<SyntaxTree> syntaxTrees = null, IEnumerable<MetadataReference> references = null, CSharpCompilationOptions options = null);
      public static CSharpCompilation CreateScriptCompilation(string assemblyName, SyntaxTree syntaxTree = null, IEnumerable<MetadataReference> references = null, CSharpCompilationOptions options = null, CSharpCompilation previousScriptCompilation = null, Type returnType = null, Type globalsType = null);
      public override ImmutableArray<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken = default);
      public override ImmutableArray<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default);
      public MetadataReference GetDirectiveReference(ReferenceDirectiveTriviaSyntax directive);
      public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol);
      public override ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken = default);
      public override ImmutableArray<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken = default);
      public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
      public override IEnumerable<ISymbol> GetSymbolsWithName(Func<string, bool> predicate, SymbolFilter filter = TypeAndMember, CancellationToken cancellationToken = default);
      public CSharpCompilation RemoveAllReferences();
      public CSharpCompilation RemoveAllSyntaxTrees();
      public CSharpCompilation RemoveReferences(params MetadataReference[] references);
      public CSharpCompilation RemoveReferences(IEnumerable<MetadataReference> references);
      public CSharpCompilation RemoveSyntaxTrees(params SyntaxTree[] trees);
      public CSharpCompilation RemoveSyntaxTrees(IEnumerable<SyntaxTree> trees);
      public CSharpCompilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference);
      public CSharpCompilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
      public override CompilationReference ToMetadataReference(ImmutableArray<string> aliases = default, bool embedInteropTypes = false);
      public CSharpCompilation WithAssemblyName(string assemblyName);
      public CSharpCompilation WithOptions(CSharpCompilationOptions options);
      public CSharpCompilation WithReferences(IEnumerable<MetadataReference> references);
      public CSharpCompilation WithReferences(params MetadataReference[] references);
      public CSharpCompilation WithScriptCompilationInfo(CSharpScriptCompilationInfo info);

  public abstract class Microsoft.CodeAnalysis.CompilationOptions

    public AssemblyIdentityComparer AssemblyIdentityComparer { get; protected set; }
    public bool CheckOverflow { get; protected set; }
    public bool ConcurrentBuild { get; protected set; }
    public string CryptoKeyContainer { get; protected set; }
    public string CryptoKeyFile { get; protected set; }
    public ImmutableArray<byte> CryptoPublicKey { get; protected set; }
    public bool? DelaySign { get; protected set; }
    public bool Deterministic { get; protected set; }
    public ImmutableArray<Diagnostic> Errors { get; }
    protected internal ImmutableArray<string> Features { get; protected set; }
    public ReportDiagnostic GeneralDiagnosticOption { get; protected set; }
    public abstract string Language { get; }
    public string MainTypeName { get; protected set; }
    public MetadataReferenceResolver MetadataReferenceResolver { get; protected set; }
    public string ModuleName { get; protected set; }
    public OptimizationLevel OptimizationLevel { get; protected set; }
    public OutputKind OutputKind { get; protected set; }
    public Platform Platform { get; protected set; }
    public bool PublicSign { get; protected set; }
    public bool ReportSuppressedDiagnostics { get; protected set; }
    public string ScriptClassName { get; protected set; }
    public SourceReferenceResolver SourceReferenceResolver { get; protected set; }
    public ImmutableDictionary<string, ReportDiagnostic> SpecificDiagnosticOptions { get; protected set; }
    public StrongNameProvider StrongNameProvider { get; protected set; }
    public int WarningLevel { get; protected set; }
    public XmlReferenceResolver XmlReferenceResolver { get; protected set; }

    protected abstract CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    protected abstract CompilationOptions CommonWithCheckOverflow(bool checkOverflow);
    protected abstract CompilationOptions CommonWithConcurrentBuild(bool concurrent);
    protected abstract CompilationOptions CommonWithCryptoKeyContainer(string cryptoKeyContainer);
    protected abstract CompilationOptions CommonWithCryptoKeyFile(string cryptoKeyFile);
    protected abstract CompilationOptions CommonWithCryptoPublicKey(ImmutableArray<byte> cryptoPublicKey);
    protected abstract CompilationOptions CommonWithDelaySign(bool? delaySign);
    protected abstract CompilationOptions CommonWithDeterministic(bool deterministic);
    protected abstract CompilationOptions CommonWithFeatures(ImmutableArray<string> features);
    protected abstract CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic generalDiagnosticOption);
    protected abstract CompilationOptions CommonWithMainTypeName(string mainTypeName);
    protected abstract CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    protected abstract CompilationOptions CommonWithModuleName(string moduleName);
    protected abstract CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value);
    protected abstract CompilationOptions CommonWithOutputKind(OutputKind kind);
    protected abstract CompilationOptions CommonWithPlatform(Platform platform);
    protected abstract CompilationOptions CommonWithPublicSign(bool publicSign);
    protected abstract CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics);
    protected abstract CompilationOptions CommonWithScriptClassName(string scriptClassName);
    protected abstract CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver);
    protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> specificDiagnosticOptions);
    protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions);
    protected abstract CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider);
    protected abstract CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver);
    public override abstract bool Equals(object obj);
    protected bool EqualsHelper(CompilationOptions other);
    public override abstract int GetHashCode();
    protected int GetHashCodeHelper();
    public CompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    public CompilationOptions WithConcurrentBuild(bool concurrent);
    public CompilationOptions WithCryptoKeyContainer(string cryptoKeyContainer);
    public CompilationOptions WithCryptoKeyFile(string cryptoKeyFile);
    public CompilationOptions WithCryptoPublicKey(ImmutableArray<byte> cryptoPublicKey);
    public CompilationOptions WithDelaySign(bool? delaySign);
    public CompilationOptions WithDeterministic(bool deterministic);
    public CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value);
    public CompilationOptions WithMainTypeName(string mainTypeName);
    public CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    public CompilationOptions WithModuleName(string moduleName);
    public CompilationOptions WithOptimizationLevel(OptimizationLevel value);
    public CompilationOptions WithOutputKind(OutputKind kind);
    public CompilationOptions WithOverflowChecks(bool checkOverflow);
    public CompilationOptions WithPlatform(Platform platform);
    public CompilationOptions WithPublicSign(bool publicSign);
    public CompilationOptions WithReportSuppressedDiagnostics(bool value);
    public CompilationOptions WithScriptClassName(string scriptClassName);
    public CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver);
    public CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> value);
    public CompilationOptions WithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> value);
    public CompilationOptions WithStrongNameProvider(StrongNameProvider provider);
    public CompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver);

    public static bool operator ==(CompilationOptions left, CompilationOptions right);
    public static bool operator !=(CompilationOptions left, CompilationOptions right);

    public sealed class Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions : CompilationOptions, IEquatable<CSharpCompilationOptions>

      public CSharpCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
      public CSharpCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
      public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, IEnumerable<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
      public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics = false, string moduleName = null, string mainTypeName = null, string scriptClassName = null, IEnumerable<string> usings = null, OptimizationLevel optimizationLevel = Debug, bool checkOverflow = false, bool allowUnsafe = false, string cryptoKeyContainer = null, string cryptoKeyFile = null, ImmutableArray<byte> cryptoPublicKey = default, bool? delaySign = null, Platform platform = AnyCpu, ReportDiagnostic generalDiagnosticOption = Default, int warningLevel = 4, IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions = null, bool concurrentBuild = true, bool deterministic = false, XmlReferenceResolver xmlReferenceResolver = null, SourceReferenceResolver sourceReferenceResolver = null, MetadataReferenceResolver metadataReferenceResolver = null, AssemblyIdentityComparer assemblyIdentityComparer = null, StrongNameProvider strongNameProvider = null, bool publicSign = false);

      public bool AllowUnsafe { get; }
      public override string Language { get; }
      public ImmutableArray<string> Usings { get; }

      protected override CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
      protected override CompilationOptions CommonWithCheckOverflow(bool checkOverflow);
      protected override CompilationOptions CommonWithConcurrentBuild(bool concurrent);
      protected override CompilationOptions CommonWithCryptoKeyContainer(string cryptoKeyContainer);
      protected override CompilationOptions CommonWithCryptoKeyFile(string cryptoKeyFile);
      protected override CompilationOptions CommonWithCryptoPublicKey(ImmutableArray<byte> cryptoPublicKey);
      protected override CompilationOptions CommonWithDelaySign(bool? delaySign);
      protected override CompilationOptions CommonWithDeterministic(bool deterministic);
      protected override CompilationOptions CommonWithFeatures(ImmutableArray<string> features);
      protected override CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic value);
      protected override CompilationOptions CommonWithMainTypeName(string mainTypeName);
      protected override CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver);
      protected override CompilationOptions CommonWithModuleName(string moduleName);
      protected override CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value);
      protected override CompilationOptions CommonWithOutputKind(OutputKind kind);
      protected override CompilationOptions CommonWithPlatform(Platform platform);
      protected override CompilationOptions CommonWithPublicSign(bool publicSign);
      protected override CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics);
      protected override CompilationOptions CommonWithScriptClassName(string scriptClassName);
      protected override CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver);
      protected override CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> specificDiagnosticOptions);
      protected override CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions);
      protected override CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider);
      protected override CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver);
      public override bool Equals(object obj);
      public bool Equals(CSharpCompilationOptions other);
      public override int GetHashCode();
      public CSharpCompilationOptions WithAllowUnsafe(bool enabled);
      public CSharpCompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
      public CSharpCompilationOptions WithConcurrentBuild(bool concurrentBuild);
      public CSharpCompilationOptions WithCryptoKeyContainer(string name);
      public CSharpCompilationOptions WithCryptoKeyFile(string path);
      public CSharpCompilationOptions WithCryptoPublicKey(ImmutableArray<byte> value);
      public CSharpCompilationOptions WithDelaySign(bool? value);
      public CSharpCompilationOptions WithDeterministic(bool deterministic);
      public CSharpCompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value);
      public CSharpCompilationOptions WithMainTypeName(string name);
      public CSharpCompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver);
      public CSharpCompilationOptions WithModuleName(string moduleName);
      public CSharpCompilationOptions WithOptimizationLevel(OptimizationLevel value);
      public CSharpCompilationOptions WithOutputKind(OutputKind kind);
      public CSharpCompilationOptions WithOverflowChecks(bool enabled);
      public CSharpCompilationOptions WithPlatform(Platform platform);
      public CSharpCompilationOptions WithPublicSign(bool publicSign);
      public CSharpCompilationOptions WithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics);
      public CSharpCompilationOptions WithScriptClassName(string name);
      public CSharpCompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver);
      public CSharpCompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> values);
      public CSharpCompilationOptions WithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> values);
      public CSharpCompilationOptions WithStrongNameProvider(StrongNameProvider provider);
      public CSharpCompilationOptions WithUsings(ImmutableArray<string> usings);
      public CSharpCompilationOptions WithUsings(IEnumerable<string> usings);
      public CSharpCompilationOptions WithUsings(params string[] usings);
      public CSharpCompilationOptions WithWarningLevel(int warningLevel);
      public CSharpCompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver);

  public abstract class Microsoft.CodeAnalysis.ControlFlowAnalysis

    protected ControlFlowAnalysis();

    public abstract bool EndPointIsReachable { get; }
    public abstract ImmutableArray<SyntaxNode> EntryPoints { get; }
    public abstract ImmutableArray<SyntaxNode> ExitPoints { get; }
    public abstract ImmutableArray<SyntaxNode> ReturnStatements { get; }
    public abstract bool StartPointIsReachable { get; }
    public abstract bool Succeeded { get; }

  public abstract class Microsoft.CodeAnalysis.CustomModifier : ICustomModifier

    protected CustomModifier();

    public abstract bool IsOptional { get; }
    public abstract INamedTypeSymbol Modifier { get; }

  public abstract class Microsoft.CodeAnalysis.DataFlowAnalysis

    protected DataFlowAnalysis();

    public abstract ImmutableArray<ISymbol> AlwaysAssigned { get; }
    public abstract ImmutableArray<ISymbol> Captured { get; }
    public abstract ImmutableArray<ISymbol> DataFlowsIn { get; }
    public abstract ImmutableArray<ISymbol> DataFlowsOut { get; }
    public abstract ImmutableArray<ISymbol> ReadInside { get; }
    public abstract ImmutableArray<ISymbol> ReadOutside { get; }
    public abstract bool Succeeded { get; }
    public abstract ImmutableArray<ISymbol> UnsafeAddressTaken { get; }
    public abstract ImmutableArray<ISymbol> VariablesDeclared { get; }
    public abstract ImmutableArray<ISymbol> WrittenInside { get; }
    public abstract ImmutableArray<ISymbol> WrittenOutside { get; }

  public abstract class Microsoft.CodeAnalysis.Diagnostic : IEquatable<Diagnostic>, IFormattable

    protected Diagnostic();

    public abstract IReadOnlyList<Location> AdditionalLocations { get; }
    public virtual DiagnosticSeverity DefaultSeverity { get; }
    public abstract DiagnosticDescriptor Descriptor { get; }
    public abstract string Id { get; }
    public abstract bool IsSuppressed { get; }
    public bool IsWarningAsError { get; }
    public abstract Location Location { get; }
    public virtual ImmutableDictionary<string, string> Properties { get; }
    public abstract DiagnosticSeverity Severity { get; }
    public abstract int WarningLevel { get; }

    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, params object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, LocalizableString title = null, LocalizableString description = null, string helpLink = null, Location location = null, IEnumerable<Location> additionalLocations = null, IEnumerable<string> customTags = null, ImmutableDictionary<string, string> properties = null);
    public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, bool isSuppressed, LocalizableString title = null, LocalizableString description = null, string helpLink = null, Location location = null, IEnumerable<Location> additionalLocations = null, IEnumerable<string> customTags = null, ImmutableDictionary<string, string> properties = null);
    public override abstract bool Equals(object obj);
    public abstract bool Equals(Diagnostic obj);
    public override abstract int GetHashCode();
    public abstract string GetMessage(IFormatProvider formatProvider = null);
    public SuppressionInfo GetSuppressionInfo(Compilation compilation);
    public override string ToString();

  public sealed class Microsoft.CodeAnalysis.DiagnosticDescriptor : IEquatable<DiagnosticDescriptor>

    public DiagnosticDescriptor(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description = null, string helpLinkUri = null, params string[] customTags);
    public DiagnosticDescriptor(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description = null, string helpLinkUri = null, params string[] customTags);

    public string Category { get; }
    public IEnumerable<string> CustomTags { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    public LocalizableString Description { get; }
    public string HelpLinkUri { get; }
    public string Id { get; }
    public bool IsEnabledByDefault { get; }
    public LocalizableString MessageFormat { get; }
    public LocalizableString Title { get; }

    public override bool Equals(object obj);
    public bool Equals(DiagnosticDescriptor other);
    public ReportDiagnostic GetEffectiveSeverity(CompilationOptions compilationOptions);
    public override int GetHashCode();

  public class Microsoft.CodeAnalysis.DiagnosticFormatter

    public DiagnosticFormatter();

    public virtual string Format(Diagnostic diagnostic, IFormatProvider formatter = null);

    public class Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFormatter : DiagnosticFormatter

      public static CSharpDiagnosticFormatter Instance { get; }

  public sealed class Microsoft.CodeAnalysis.DllImportData : IPlatformInvokeInformation

    public bool? BestFitMapping { get; }
    public CallingConvention CallingConvention { get; }
    public CharSet CharacterSet { get; }
    public string EntryPointName { get; }
    public bool ExactSpelling { get; }
    public string ModuleName { get; }
    public bool SetLastError { get; }
    public bool? ThrowOnUnmappableCharacter { get; }

  public sealed class Microsoft.CodeAnalysis.DocumentId : IEquatable<DocumentId>, IObjectWritable

    public Guid Id { get; }
    public ProjectId ProjectId { get; }

    public static DocumentId CreateFromSerialized(ProjectId projectId, Guid id, string debugName = null);
    public static DocumentId CreateNewId(ProjectId projectId, string debugName = null);
    public override bool Equals(object obj);
    public bool Equals(DocumentId other);
    public override int GetHashCode();
    public override string ToString();

    public static bool operator ==(DocumentId left, DocumentId right);
    public static bool operator !=(DocumentId left, DocumentId right);

  public sealed class Microsoft.CodeAnalysis.DocumentInfo

    public string FilePath { get; }
    public IReadOnlyList<string> Folders { get; }
    public DocumentId Id { get; }
    public bool IsGenerated { get; }
    public string Name { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public TextLoader TextLoader { get; }

    public static DocumentInfo Create(DocumentId id, string name, IEnumerable<string> folders = null, SourceCodeKind sourceCodeKind = Regular, TextLoader loader = null, string filePath = null, bool isGenerated = false);
    public DocumentInfo WithFilePath(string filePath);
    public DocumentInfo WithFolders(IEnumerable<string> folders);
    public DocumentInfo WithId(DocumentId id);
    public DocumentInfo WithName(string name);
    public DocumentInfo WithSourceCodeKind(SourceCodeKind kind);
    public DocumentInfo WithTextLoader(TextLoader loader);

  public abstract class Microsoft.CodeAnalysis.DocumentationProvider

    protected DocumentationProvider();

    public static DocumentationProvider Default { get; }

    public override abstract bool Equals(object obj);
    protected internal abstract string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken = default);
    public override abstract int GetHashCode();

    public abstract class Microsoft.CodeAnalysis.XmlDocumentationProvider : DocumentationProvider

      protected XmlDocumentationProvider();

      public static XmlDocumentationProvider CreateFromBytes(byte[] xmlDocCommentBytes);
      public static XmlDocumentationProvider CreateFromFile(string xmlDocCommentFilePath);
      protected override string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken = default);
      protected abstract Stream GetSourceStream(CancellationToken cancellationToken);

  public sealed class Microsoft.CodeAnalysis.EmbeddedText

    public ImmutableArray<byte> Checksum { get; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; }
    public string FilePath { get; }

    public static EmbeddedText FromBytes(string filePath, ArraySegment<byte> bytes, SourceHashAlgorithm checksumAlgorithm = Sha1);
    public static EmbeddedText FromSource(string filePath, SourceText text);
    public static EmbeddedText FromStream(string filePath, Stream stream, SourceHashAlgorithm checksumAlgorithm = Sha1);

  public abstract class Microsoft.CodeAnalysis.LocalizableString : IEquatable<LocalizableString>, IFormattable

    protected LocalizableString();

    public event EventHandler<Exception> OnException;

    protected abstract bool AreEqual(object other);
    public override sealed bool Equals(object other);
    public bool Equals(LocalizableString other);
    protected abstract int GetHash();
    public override sealed int GetHashCode();
    protected abstract string GetText(IFormatProvider formatProvider);
    public override sealed string ToString();
    public string ToString(IFormatProvider formatProvider);

    public static explicit operator string(LocalizableString localizableResource);
    public static implicit operator LocalizableString(string fixedResource);

    public sealed class Microsoft.CodeAnalysis.LocalizableResourceString : LocalizableString, IObjectWritable

      public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource);
      public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource, params string[] formatArguments);

      protected override bool AreEqual(object other);
      protected override int GetHash();
      protected override string GetText(IFormatProvider formatProvider);

  public abstract class Microsoft.CodeAnalysis.Location

    public bool IsInMetadata { get; }
    public bool IsInSource { get; }
    public abstract LocationKind Kind { get; }
    public virtual IModuleSymbol MetadataModule { get; }
    public static Location None { get; }
    public virtual TextSpan SourceSpan { get; }
    public virtual SyntaxTree SourceTree { get; }

    public static Location Create(SyntaxTree syntaxTree, TextSpan textSpan);
    public static Location Create(string filePath, TextSpan textSpan, LinePositionSpan lineSpan);
    public override abstract bool Equals(object obj);
    protected virtual string GetDebuggerDisplay();
    public override abstract int GetHashCode();
    public virtual FileLinePositionSpan GetLineSpan();
    public virtual FileLinePositionSpan GetMappedLineSpan();
    public override string ToString();

    public static bool operator ==(Location left, Location right);
    public static bool operator !=(Location left, Location right);

  public abstract class Microsoft.CodeAnalysis.Metadata : IDisposable

    public MetadataId Id { get; }
    public abstract MetadataImageKind Kind { get; }

    protected abstract Metadata CommonCopy();
    public Metadata Copy();
    public abstract void Dispose();

    public sealed class Microsoft.CodeAnalysis.AssemblyMetadata : Metadata

      public override MetadataImageKind Kind { get; }

      protected override Metadata CommonCopy();
      public static AssemblyMetadata Create(ModuleMetadata module);
      public static AssemblyMetadata Create(ImmutableArray<ModuleMetadata> modules);
      public static AssemblyMetadata Create(IEnumerable<ModuleMetadata> modules);
      public static AssemblyMetadata Create(params ModuleMetadata[] modules);
      public static AssemblyMetadata CreateFromFile(string path);
      public static AssemblyMetadata CreateFromImage(ImmutableArray<byte> peImage);
      public static AssemblyMetadata CreateFromImage(IEnumerable<byte> peImage);
      public static AssemblyMetadata CreateFromStream(Stream peStream, bool leaveOpen = false);
      public static AssemblyMetadata CreateFromStream(Stream peStream, PEStreamOptions options);
      public override void Dispose();
      public ImmutableArray<ModuleMetadata> GetModules();
      public PortableExecutableReference GetReference(DocumentationProvider documentation = null, ImmutableArray<string> aliases = default, bool embedInteropTypes = false, string filePath = null, string display = null);

    public sealed class Microsoft.CodeAnalysis.ModuleMetadata : Metadata

      public override MetadataImageKind Kind { get; }
      public string Name { get; }

      protected override Metadata CommonCopy();
      public static ModuleMetadata CreateFromFile(string path);
      public static ModuleMetadata CreateFromImage(IEnumerable<byte> peImage);
      public static ModuleMetadata CreateFromImage(ImmutableArray<byte> peImage);
      public static ModuleMetadata CreateFromImage(IntPtr peImage, int size);
      public static ModuleMetadata CreateFromMetadata(IntPtr metadata, int size);
      public static ModuleMetadata CreateFromStream(Stream peStream, bool leaveOpen = false);
      public static ModuleMetadata CreateFromStream(Stream peStream, PEStreamOptions options);
      public override void Dispose();
      public MetadataReader GetMetadataReader();
      public ImmutableArray<string> GetModuleNames();
      public Guid GetModuleVersionId();
      public PortableExecutableReference GetReference(DocumentationProvider documentation = null, string filePath = null, string display = null);

  public sealed class Microsoft.CodeAnalysis.MetadataId

  public abstract class Microsoft.CodeAnalysis.MetadataReference

    protected MetadataReference(MetadataReferenceProperties properties);

    public virtual string Display { get; }
    public MetadataReferenceProperties Properties { get; }

    public static MetadataReference CreateFromAssembly(Assembly assembly);
    public static MetadataReference CreateFromAssembly(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation = null);
    public static PortableExecutableReference CreateFromFile(string path, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null);
    public static PortableExecutableReference CreateFromImage(ImmutableArray<byte> peImage, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null);
    public static PortableExecutableReference CreateFromImage(IEnumerable<byte> peImage, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null);
    public static PortableExecutableReference CreateFromStream(Stream peStream, MetadataReferenceProperties properties = default, DocumentationProvider documentation = null, string filePath = null);
    public MetadataReference WithAliases(IEnumerable<string> aliases);
    public MetadataReference WithAliases(ImmutableArray<string> aliases);
    public MetadataReference WithEmbedInteropTypes(bool value);
    public MetadataReference WithProperties(MetadataReferenceProperties properties);

    public abstract class Microsoft.CodeAnalysis.CompilationReference : MetadataReference, IEquatable<CompilationReference>

      public Compilation Compilation { get; }
      public override string Display { get; }

      public override bool Equals(object obj);
      public bool Equals(CompilationReference other);
      public override int GetHashCode();
      public CompilationReference WithAliases(IEnumerable<string> aliases);
      public CompilationReference WithAliases(ImmutableArray<string> aliases);
      public CompilationReference WithEmbedInteropTypes(bool value);
      public CompilationReference WithProperties(MetadataReferenceProperties properties);

    public abstract class Microsoft.CodeAnalysis.PortableExecutableReference : MetadataReference

      protected PortableExecutableReference(MetadataReferenceProperties properties, string fullPath = null, DocumentationProvider initialDocumentation = null);

      public override string Display { get; }
      public string FilePath { get; }

      protected abstract DocumentationProvider CreateDocumentationProvider();
      public Metadata GetMetadata();
      public MetadataId GetMetadataId();
      protected abstract Metadata GetMetadataImpl();
      public PortableExecutableReference WithAliases(IEnumerable<string> aliases);
      public PortableExecutableReference WithAliases(ImmutableArray<string> aliases);
      public PortableExecutableReference WithEmbedInteropTypes(bool value);
      public PortableExecutableReference WithProperties(MetadataReferenceProperties properties);
      protected abstract PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties);

    public sealed class Microsoft.CodeAnalysis.UnresolvedMetadataReference : MetadataReference

      public override string Display { get; }
      public string Reference { get; }

  public abstract class Microsoft.CodeAnalysis.MetadataReferenceResolver

    protected MetadataReferenceResolver();

    public virtual bool ResolveMissingAssemblies { get; }

    public override abstract bool Equals(object other);
    public override abstract int GetHashCode();
    public virtual PortableExecutableReference ResolveMissingAssembly(MetadataReference definition, AssemblyIdentity referenceIdentity);
    public abstract ImmutableArray<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);

  public abstract class Microsoft.CodeAnalysis.ParseOptions

    public DocumentationMode DocumentationMode { get; protected set; }
    public ImmutableArray<Diagnostic> Errors { get; }
    public abstract IReadOnlyDictionary<string, string> Features { get; }
    public SourceCodeKind Kind { get; protected set; }
    public abstract string Language { get; }
    public abstract IEnumerable<string> PreprocessorSymbolNames { get; }
    public SourceCodeKind SpecifiedKind { get; protected set; }

    protected abstract ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode);
    protected abstract ParseOptions CommonWithFeatures(IEnumerable<KeyValuePair<string, string>> features);
    public abstract ParseOptions CommonWithKind(SourceCodeKind kind);
    public override abstract bool Equals(object obj);
    protected bool EqualsHelper(ParseOptions other);
    public override abstract int GetHashCode();
    protected int GetHashCodeHelper();
    public ParseOptions WithDocumentationMode(DocumentationMode documentationMode);
    public ParseOptions WithFeatures(IEnumerable<KeyValuePair<string, string>> features);
    public ParseOptions WithKind(SourceCodeKind kind);

    public static bool operator ==(ParseOptions left, ParseOptions right);
    public static bool operator !=(ParseOptions left, ParseOptions right);

    public sealed class Microsoft.CodeAnalysis.CSharp.CSharpParseOptions : ParseOptions, IEquatable<CSharpParseOptions>

      public CSharpParseOptions(LanguageVersion languageVersion = Default, DocumentationMode documentationMode = Parse, SourceCodeKind kind = Regular, IEnumerable<string> preprocessorSymbols = null);

      public static CSharpParseOptions Default { get; }
      public override IReadOnlyDictionary<string, string> Features { get; }
      public override string Language { get; }
      public LanguageVersion LanguageVersion { get; }
      public override IEnumerable<string> PreprocessorSymbolNames { get; }
      public LanguageVersion SpecifiedLanguageVersion { get; }

      protected override ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode);
      protected override ParseOptions CommonWithFeatures(IEnumerable<KeyValuePair<string, string>> features);
      public override ParseOptions CommonWithKind(SourceCodeKind kind);
      public override bool Equals(object obj);
      public bool Equals(CSharpParseOptions other);
      public override int GetHashCode();
      public CSharpParseOptions WithDocumentationMode(DocumentationMode documentationMode);
      public CSharpParseOptions WithFeatures(IEnumerable<KeyValuePair<string, string>> features);
      public CSharpParseOptions WithKind(SourceCodeKind kind);
      public CSharpParseOptions WithLanguageVersion(LanguageVersion version);
      public CSharpParseOptions WithPreprocessorSymbols(IEnumerable<string> preprocessorSymbols);
      public CSharpParseOptions WithPreprocessorSymbols(params string[] preprocessorSymbols);
      public CSharpParseOptions WithPreprocessorSymbols(ImmutableArray<string> symbols);

  public class Microsoft.CodeAnalysis.Project

    public IReadOnlyList<DocumentId> AdditionalDocumentIds { get; }
    public IEnumerable<TextDocument> AdditionalDocuments { get; }
    public IReadOnlyList<ProjectReference> AllProjectReferences { get; }
    public AnalyzerOptions AnalyzerOptions { get; }
    public IReadOnlyList<AnalyzerReference> AnalyzerReferences { get; }
    public string AssemblyName { get; }
    public CompilationOptions CompilationOptions { get; }
    public IReadOnlyList<DocumentId> DocumentIds { get; }
    public IEnumerable<Document> Documents { get; }
    public string FilePath { get; }
    public bool HasDocuments { get; }
    public ProjectId Id { get; }
    public bool IsSubmission { get; }
    public string Language { get; }
    public HostLanguageServices LanguageServices { get; }
    public IReadOnlyList<MetadataReference> MetadataReferences { get; }
    public string Name { get; }
    public string OutputFilePath { get; }
    public ParseOptions ParseOptions { get; }
    public IEnumerable<ProjectReference> ProjectReferences { get; }
    public Solution Solution { get; }
    public bool SupportsCompilation { get; }
    public VersionStamp Version { get; }

    public TextDocument AddAdditionalDocument(string name, SourceText text, IEnumerable<string> folders = null, string filePath = null);
    public TextDocument AddAdditionalDocument(string name, string text, IEnumerable<string> folders = null, string filePath = null);
    public Project AddAnalyzerReference(AnalyzerReference analyzerReference);
    public Project AddAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferences);
    public Document AddDocument(string name, SyntaxNode syntaxRoot, IEnumerable<string> folders = null, string filePath = null);
    public Document AddDocument(string name, SourceText text, IEnumerable<string> folders = null, string filePath = null);
    public Document AddDocument(string name, string text, IEnumerable<string> folders = null, string filePath = null);
    public Project AddMetadataReference(MetadataReference metadataReference);
    public Project AddMetadataReferences(IEnumerable<MetadataReference> metadataReferences);
    public Project AddProjectReference(ProjectReference projectReference);
    public Project AddProjectReferences(IEnumerable<ProjectReference> projectReferences);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public bool ContainsDocument(DocumentId documentId);
    public TextDocument GetAdditionalDocument(DocumentId documentId);
    public ProjectChanges GetChanges(Project oldProject);
    public Task<Compilation> GetCompilationAsync(CancellationToken cancellationToken = default);
    public Task<VersionStamp> GetDependentSemanticVersionAsync(CancellationToken cancellationToken = default);
    public Task<VersionStamp> GetDependentVersionAsync(CancellationToken cancellationToken = default);
    public Document GetDocument(DocumentId documentId);
    public Document GetDocument(SyntaxTree syntaxTree);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree);
    public Task<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken = default);
    public Task<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken = default);
    public Project RemoveAdditionalDocument(DocumentId documentId);
    public Project RemoveAnalyzerReference(AnalyzerReference analyzerReference);
    public Project RemoveDocument(DocumentId documentId);
    public Project RemoveMetadataReference(MetadataReference metadataReference);
    public Project RemoveProjectReference(ProjectReference projectReference);
    public bool TryGetCompilation(out Compilation compilation);
    public Project WithAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferencs);
    public Project WithAssemblyName(string assemblyName);
    public Project WithCompilationOptions(CompilationOptions options);
    public Project WithMetadataReferences(IEnumerable<MetadataReference> metadataReferences);
    public Project WithParseOptions(ParseOptions options);
    public Project WithProjectReferences(IEnumerable<ProjectReference> projectReferences);

  public class Microsoft.CodeAnalysis.ProjectDependencyGraph

    public IEnumerable<IEnumerable<ProjectId>> GetDependencySets(CancellationToken cancellationToken = default);
    public IImmutableSet<ProjectId> GetProjectsThatDirectlyDependOnThisProject(ProjectId projectId);
    public IImmutableSet<ProjectId> GetProjectsThatThisProjectDirectlyDependsOn(ProjectId projectId);
    public IImmutableSet<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn(ProjectId projectId);
    public IEnumerable<ProjectId> GetProjectsThatTransitivelyDependOnThisProject(ProjectId projectId);
    public IEnumerable<ProjectId> GetTopologicallySortedProjects(CancellationToken cancellationToken = default);

  public sealed class Microsoft.CodeAnalysis.ProjectId : IEquatable<ProjectId>, IObjectWritable

    public Guid Id { get; }

    public static ProjectId CreateFromSerialized(Guid id, string debugName = null);
    public static ProjectId CreateNewId(string debugName = null);
    public override bool Equals(object obj);
    public bool Equals(ProjectId other);
    public override int GetHashCode();
    public override string ToString();

    public static bool operator ==(ProjectId left, ProjectId right);
    public static bool operator !=(ProjectId left, ProjectId right);

  public sealed class Microsoft.CodeAnalysis.ProjectInfo

    public IReadOnlyList<DocumentInfo> AdditionalDocuments { get; }
    public IReadOnlyList<AnalyzerReference> AnalyzerReferences { get; }
    public string AssemblyName { get; }
    public CompilationOptions CompilationOptions { get; }
    public IReadOnlyList<DocumentInfo> Documents { get; }
    public string FilePath { get; }
    public Type HostObjectType { get; }
    public ProjectId Id { get; }
    public bool IsSubmission { get; }
    public string Language { get; }
    public IReadOnlyList<MetadataReference> MetadataReferences { get; }
    public string Name { get; }
    public string OutputFilePath { get; }
    public ParseOptions ParseOptions { get; }
    public IReadOnlyList<ProjectReference> ProjectReferences { get; }
    public VersionStamp Version { get; }

    public static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath = null, string outputFilePath = null, CompilationOptions compilationOptions = null, ParseOptions parseOptions = null, IEnumerable<DocumentInfo> documents = null, IEnumerable<ProjectReference> projectReferences = null, IEnumerable<MetadataReference> metadataReferences = null, IEnumerable<AnalyzerReference> analyzerReferences = null, IEnumerable<DocumentInfo> additionalDocuments = null, bool isSubmission = false, Type hostObjectType = null);
    public ProjectInfo WithAdditionalDocuments(IEnumerable<DocumentInfo> additionalDocuments);
    public ProjectInfo WithAnalyzerReferences(IEnumerable<AnalyzerReference> analyzerReferences);
    public ProjectInfo WithAssemblyName(string assemblyName);
    public ProjectInfo WithCompilationOptions(CompilationOptions compilationOptions);
    public ProjectInfo WithDocuments(IEnumerable<DocumentInfo> documents);
    public ProjectInfo WithFilePath(string filePath);
    public ProjectInfo WithMetadataReferences(IEnumerable<MetadataReference> metadataReferences);
    public ProjectInfo WithName(string name);
    public ProjectInfo WithOutputFilePath(string outputFilePath);
    public ProjectInfo WithParseOptions(ParseOptions parseOptions);
    public ProjectInfo WithProjectReferences(IEnumerable<ProjectReference> projectReferences);
    public ProjectInfo WithVersion(VersionStamp version);

  public sealed class Microsoft.CodeAnalysis.ProjectReference : IEquatable<ProjectReference>

    public ProjectReference(ProjectId projectId, ImmutableArray<string> aliases = default, bool embedInteropTypes = false);

    public ImmutableArray<string> Aliases { get; }
    public bool EmbedInteropTypes { get; }
    public ProjectId ProjectId { get; }

    public override bool Equals(object obj);
    public bool Equals(ProjectReference reference);
    public override int GetHashCode();

    public static bool operator ==(ProjectReference left, ProjectReference right);
    public static bool operator !=(ProjectReference left, ProjectReference right);

  public sealed class Microsoft.CodeAnalysis.ResourceDescription : IFileReference

    public ResourceDescription(string resourceName, Func<Stream> dataProvider, bool isPublic);
    public ResourceDescription(string resourceName, string fileName, Func<Stream> dataProvider, bool isPublic);

  public class Microsoft.CodeAnalysis.RuleSet

    public RuleSet(string filePath, ReportDiagnostic generalOption, ImmutableDictionary<string, ReportDiagnostic> specificOptions, ImmutableArray<RuleSetInclude> includes);

    public string FilePath { get; }
    public ReportDiagnostic GeneralDiagnosticOption { get; }
    public ImmutableArray<RuleSetInclude> Includes { get; }
    public ImmutableDictionary<string, ReportDiagnostic> SpecificDiagnosticOptions { get; }

    public static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(string rulesetFileFullPath, out Dictionary<string, ReportDiagnostic> specificDiagnosticOptions);
    public static ImmutableArray<string> GetEffectiveIncludesFromFile(string filePath);
    public static RuleSet LoadEffectiveRuleSetFromFile(string filePath);
    public RuleSet WithEffectiveAction(ReportDiagnostic action);

  public class Microsoft.CodeAnalysis.RuleSetInclude

    public RuleSetInclude(string includePath, ReportDiagnostic action);

    public ReportDiagnostic Action { get; }
    public string IncludePath { get; }

    public RuleSet LoadRuleSet(RuleSet parent);

  public abstract class Microsoft.CodeAnalysis.ScriptCompilationInfo

    public Type GlobalsType { get; }
    public Compilation PreviousScriptCompilation { get; }
    public Type ReturnType { get; }

    public ScriptCompilationInfo WithPreviousScriptCompilation(Compilation compilation);

    public sealed class Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo : ScriptCompilationInfo

      public CSharpCompilation PreviousScriptCompilation { get; }

      public CSharpScriptCompilationInfo WithPreviousScriptCompilation(CSharpCompilation compilation);

  public abstract class Microsoft.CodeAnalysis.SemanticModel

    protected SemanticModel();

    public Compilation Compilation { get; }
    protected abstract Compilation CompilationCore { get; }
    public virtual bool IgnoresAccessibility { get; }
    public abstract bool IsSpeculativeSemanticModel { get; }
    public abstract string Language { get; }
    public abstract int OriginalPositionForSpeculation { get; }
    public SemanticModel ParentModel { get; }
    protected abstract SemanticModel ParentModelCore { get; }
    public SyntaxTree SyntaxTree { get; }
    protected abstract SyntaxTree SyntaxTreeCore { get; }

    protected abstract ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode statement);
    protected abstract ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected abstract DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode statementOrExpression);
    protected abstract DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected abstract IAliasSymbol GetAliasInfoCore(SyntaxNode nameSyntax, CancellationToken cancellationToken = default);
    public Optional<object> GetConstantValue(SyntaxNode node, CancellationToken cancellationToken = default);
    protected abstract Optional<object> GetConstantValueCore(SyntaxNode node, CancellationToken cancellationToken = default);
    public abstract ImmutableArray<Diagnostic> GetDeclarationDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default);
    protected abstract ISymbol GetDeclaredSymbolCore(SyntaxNode declaration, CancellationToken cancellationToken = default);
    protected abstract ImmutableArray<ISymbol> GetDeclaredSymbolsCore(SyntaxNode declaration, CancellationToken cancellationToken = default);
    public abstract ImmutableArray<Diagnostic> GetDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default);
    public ISymbol GetEnclosingSymbol(int position, CancellationToken cancellationToken = default);
    protected abstract ISymbol GetEnclosingSymbolCore(int position, CancellationToken cancellationToken = default);
    protected abstract ImmutableArray<ISymbol> GetMemberGroupCore(SyntaxNode node, CancellationToken cancellationToken = default);
    public abstract ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default);
    public IOperation GetOperation(SyntaxNode node, CancellationToken cancellationToken = default);
    protected abstract IOperation GetOperationCore(SyntaxNode node, CancellationToken cancellationToken);
    public PreprocessingSymbolInfo GetPreprocessingSymbolInfo(SyntaxNode nameSyntax);
    protected abstract PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(SyntaxNode nameSyntax);
    protected abstract IAliasSymbol GetSpeculativeAliasInfoCore(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    protected abstract SymbolInfo GetSpeculativeSymbolInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected abstract TypeInfo GetSpeculativeTypeInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected abstract SymbolInfo GetSymbolInfoCore(SyntaxNode node, CancellationToken cancellationToken = default);
    public abstract ImmutableArray<Diagnostic> GetSyntaxDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default);
    protected internal virtual SyntaxNode GetTopmostNodeForDiagnosticAnalysis(ISymbol symbol, SyntaxNode declaringSyntax);
    protected abstract TypeInfo GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken = default);
    public bool IsAccessible(int position, ISymbol symbol);
    protected abstract bool IsAccessibleCore(int position, ISymbol symbol);
    public bool IsEventUsableAsField(int position, IEventSymbol eventSymbol);
    protected abstract bool IsEventUsableAsFieldCore(int position, IEventSymbol eventSymbol);
    public ImmutableArray<ISymbol> LookupBaseMembers(int position, string name = null);
    protected abstract ImmutableArray<ISymbol> LookupBaseMembersCore(int position, string name);
    public ImmutableArray<ISymbol> LookupLabels(int position, string name = null);
    protected abstract ImmutableArray<ISymbol> LookupLabelsCore(int position, string name);
    public ImmutableArray<ISymbol> LookupNamespacesAndTypes(int position, INamespaceOrTypeSymbol container = null, string name = null);
    protected abstract ImmutableArray<ISymbol> LookupNamespacesAndTypesCore(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray<ISymbol> LookupStaticMembers(int position, INamespaceOrTypeSymbol container = null, string name = null);
    protected abstract ImmutableArray<ISymbol> LookupStaticMembersCore(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray<ISymbol> LookupSymbols(int position, INamespaceOrTypeSymbol container = null, string name = null, bool includeReducedExtensionMethods = false);
    protected abstract ImmutableArray<ISymbol> LookupSymbolsCore(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);

  public class Microsoft.CodeAnalysis.Solution

    public string FilePath { get; }
    public SolutionId Id { get; }
    public OptionSet Options { get; }
    public IReadOnlyList<ProjectId> ProjectIds { get; }
    public IEnumerable<Project> Projects { get; }
    public VersionStamp Version { get; }
    public Workspace Workspace { get; }

    public Solution AddAdditionalDocument(DocumentInfo documentInfo);
    public Solution AddAdditionalDocument(DocumentId documentId, string name, string text, IEnumerable<string> folders = null, string filePath = null);
    public Solution AddAdditionalDocument(DocumentId documentId, string name, SourceText text, IEnumerable<string> folders = null, string filePath = null);
    public Solution AddAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public Solution AddAnalyzerReferences(ProjectId projectId, IEnumerable<AnalyzerReference> analyzerReferences);
    public Solution AddDocument(DocumentInfo documentInfo);
    public Solution AddDocument(DocumentId documentId, string name, TextLoader loader, IEnumerable<string> folders = null);
    public Solution AddDocument(DocumentId documentId, string name, string text, IEnumerable<string> folders = null, string filePath = null);
    public Solution AddDocument(DocumentId documentId, string name, SourceText text, IEnumerable<string> folders = null, string filePath = null, bool isGenerated = false);
    public Solution AddDocument(DocumentId documentId, string name, SyntaxNode syntaxRoot, IEnumerable<string> folders = null, string filePath = null, bool isGenerated = false, PreservationMode preservationMode = PreserveValue);
    public Solution AddMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public Solution AddMetadataReferences(ProjectId projectId, IEnumerable<MetadataReference> metadataReferences);
    public Solution AddProject(ProjectInfo projectInfo);
    public Project AddProject(string name, string assemblyName, string language);
    public Solution AddProject(ProjectId projectId, string name, string assemblyName, string language);
    public Solution AddProjectReference(ProjectId projectId, ProjectReference projectReference);
    public Solution AddProjectReferences(ProjectId projectId, IEnumerable<ProjectReference> projectReferences);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsProject(ProjectId projectId);
    public TextDocument GetAdditionalDocument(DocumentId documentId);
    public SolutionChanges GetChanges(Solution oldSolution);
    public Document GetDocument(DocumentId documentId);
    public Document GetDocument(SyntaxTree syntaxTree);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree, ProjectId projectId);
    public ImmutableArray<DocumentId> GetDocumentIdsWithFilePath(string filePath);
    public Solution GetIsolatedSolution();
    public VersionStamp GetLatestProjectVersion();
    public Project GetProject(ProjectId projectId);
    public Project GetProject(IAssemblySymbol assemblySymbol, CancellationToken cancellationToken = default);
    public ProjectDependencyGraph GetProjectDependencyGraph();
    public Solution RemoveAdditionalDocument(DocumentId documentId);
    public Solution RemoveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public Solution RemoveDocument(DocumentId documentId);
    public Solution RemoveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public Solution RemoveProject(ProjectId projectId);
    public Solution RemoveProjectReference(ProjectId projectId, ProjectReference projectReference);
    public Solution WithAdditionalDocumentText(DocumentId documentId, SourceText text, PreservationMode mode = PreserveValue);
    public Solution WithAdditionalDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode = PreserveValue);
    public Solution WithAdditionalDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    public Solution WithDocumentFilePath(DocumentId documentId, string filePath);
    public Solution WithDocumentFolders(DocumentId documentId, IEnumerable<string> folders);
    public Solution WithDocumentName(DocumentId documentId, string name);
    public Solution WithDocumentSourceCodeKind(DocumentId documentId, SourceCodeKind sourceCodeKind);
    public Solution WithDocumentSyntaxRoot(DocumentId documentId, SyntaxNode root, PreservationMode mode = PreserveValue);
    public Solution WithDocumentText(DocumentId documentId, SourceText text, PreservationMode mode = PreserveValue);
    public Solution WithDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode = PreserveValue);
    public Solution WithDocumentText(IEnumerable<DocumentId> documentIds, SourceText text, PreservationMode mode = PreserveValue);
    public Solution WithDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    public Solution WithProjectAnalyzerReferences(ProjectId projectId, IEnumerable<AnalyzerReference> analyzerReferences);
    public Solution WithProjectAssemblyName(ProjectId projectId, string assemblyName);
    public Solution WithProjectCompilationOptions(ProjectId projectId, CompilationOptions options);
    public Solution WithProjectFilePath(ProjectId projectId, string filePath);
    public Solution WithProjectMetadataReferences(ProjectId projectId, IEnumerable<MetadataReference> metadataReferences);
    public Solution WithProjectName(ProjectId projectId, string name);
    public Solution WithProjectOutputFilePath(ProjectId projectId, string outputFilePath);
    public Solution WithProjectParseOptions(ProjectId projectId, ParseOptions options);
    public Solution WithProjectReferences(ProjectId projectId, IEnumerable<ProjectReference> projectReferences);

  public sealed class Microsoft.CodeAnalysis.SolutionId : IEquatable<SolutionId>, IObjectWritable

    public Guid Id { get; }

    public static SolutionId CreateFromSerialized(Guid id, string debugName = null);
    public static SolutionId CreateNewId(string debugName = null);
    public override bool Equals(object obj);
    public bool Equals(SolutionId other);
    public override int GetHashCode();

    public static bool operator ==(SolutionId left, SolutionId right);
    public static bool operator !=(SolutionId left, SolutionId right);

  public sealed class Microsoft.CodeAnalysis.SolutionInfo

    public string FilePath { get; }
    public SolutionId Id { get; }
    public IReadOnlyList<ProjectInfo> Projects { get; }
    public VersionStamp Version { get; }

    public static SolutionInfo Create(SolutionId id, VersionStamp version, string filePath = null, IEnumerable<ProjectInfo> projects = null);

  public abstract class Microsoft.CodeAnalysis.SourceReferenceResolver

    protected SourceReferenceResolver();

    public override abstract bool Equals(object other);
    public override abstract int GetHashCode();
    public abstract string NormalizePath(string path, string baseFilePath);
    public abstract Stream OpenRead(string resolvedPath);
    public virtual SourceText ReadText(string resolvedPath);
    public abstract string ResolveReference(string path, string baseFilePath);

    public class Microsoft.CodeAnalysis.SourceFileResolver : SourceReferenceResolver, IEquatable<SourceFileResolver>

      public SourceFileResolver(IEnumerable<string> searchPaths, string baseDirectory);
      public SourceFileResolver(ImmutableArray<string> searchPaths, string baseDirectory);
      public SourceFileResolver(ImmutableArray<string> searchPaths, string baseDirectory, ImmutableArray<KeyValuePair<string, string>> pathMap);

      public string BaseDirectory { get; }
      public static SourceFileResolver Default { get; }
      public ImmutableArray<KeyValuePair<string, string>> PathMap { get; }
      public ImmutableArray<string> SearchPaths { get; }

      public override bool Equals(object obj);
      public bool Equals(SourceFileResolver other);
      protected virtual bool FileExists(string resolvedPath);
      public override int GetHashCode();
      public override string NormalizePath(string path, string baseFilePath);
      public override Stream OpenRead(string resolvedPath);
      public override string ResolveReference(string path, string baseFilePath);

  public abstract class Microsoft.CodeAnalysis.StrongNameProvider

    protected StrongNameProvider();

    public override abstract bool Equals(object other);
    public override abstract int GetHashCode();

    public class Microsoft.CodeAnalysis.DesktopStrongNameProvider : StrongNameProvider

      public DesktopStrongNameProvider(ImmutableArray<string> keyFileSearchPaths);
      public DesktopStrongNameProvider(ImmutableArray<string> keyFileSearchPaths = default, string tempPath = null);

      public override bool Equals(object obj);
      public override int GetHashCode();

  public class Microsoft.CodeAnalysis.SymbolDisplayFormat

    public SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle = Omitted, SymbolDisplayTypeQualificationStyle typeQualificationStyle = NameOnly, SymbolDisplayGenericsOptions genericsOptions = None, SymbolDisplayMemberOptions memberOptions = None, SymbolDisplayDelegateStyle delegateStyle = NameOnly, SymbolDisplayExtensionMethodStyle extensionMethodStyle = Default, SymbolDisplayParameterOptions parameterOptions = None, SymbolDisplayPropertyStyle propertyStyle = NameOnly, SymbolDisplayLocalOptions localOptions = None, SymbolDisplayKindOptions kindOptions = None, SymbolDisplayMiscellaneousOptions miscellaneousOptions = None);

    public static SymbolDisplayFormat CSharpErrorMessageFormat { get; }
    public static SymbolDisplayFormat CSharpShortErrorMessageFormat { get; }
    public SymbolDisplayDelegateStyle DelegateStyle { get; }
    public SymbolDisplayExtensionMethodStyle ExtensionMethodStyle { get; }
    public static SymbolDisplayFormat FullyQualifiedFormat { get; }
    public SymbolDisplayGenericsOptions GenericsOptions { get; }
    public SymbolDisplayGlobalNamespaceStyle GlobalNamespaceStyle { get; }
    public SymbolDisplayKindOptions KindOptions { get; }
    public SymbolDisplayLocalOptions LocalOptions { get; }
    public SymbolDisplayMemberOptions MemberOptions { get; }
    public static SymbolDisplayFormat MinimallyQualifiedFormat { get; }
    public SymbolDisplayMiscellaneousOptions MiscellaneousOptions { get; }
    public SymbolDisplayParameterOptions ParameterOptions { get; }
    public SymbolDisplayPropertyStyle PropertyStyle { get; }
    public SymbolDisplayTypeQualificationStyle TypeQualificationStyle { get; }
    public static SymbolDisplayFormat VisualBasicErrorMessageFormat { get; }
    public static SymbolDisplayFormat VisualBasicShortErrorMessageFormat { get; }

    public SymbolDisplayFormat AddGenericsOptions(SymbolDisplayGenericsOptions options);
    public SymbolDisplayFormat AddKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat AddLocalOptions(SymbolDisplayLocalOptions options);
    public SymbolDisplayFormat AddMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options);
    public SymbolDisplayFormat AddParameterOptions(SymbolDisplayParameterOptions options);
    public SymbolDisplayFormat RemoveGenericsOptions(SymbolDisplayGenericsOptions options);
    public SymbolDisplayFormat RemoveKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat RemoveLocalOptions(SymbolDisplayLocalOptions options);
    public SymbolDisplayFormat RemoveMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat RemoveMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options);
    public SymbolDisplayFormat RemoveParameterOptions(SymbolDisplayParameterOptions options);
    public SymbolDisplayFormat WithGenericsOptions(SymbolDisplayGenericsOptions options);
    public SymbolDisplayFormat WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle style);
    public SymbolDisplayFormat WithKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat WithLocalOptions(SymbolDisplayLocalOptions options);
    public SymbolDisplayFormat WithMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options);
    public SymbolDisplayFormat WithParameterOptions(SymbolDisplayParameterOptions options);

  public abstract class Microsoft.CodeAnalysis.SymbolVisitor

    protected SymbolVisitor();

    public virtual void DefaultVisit(ISymbol symbol);
    public virtual void Visit(ISymbol symbol);
    public virtual void VisitAlias(IAliasSymbol symbol);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    public virtual void VisitAssembly(IAssemblySymbol symbol);
    public virtual void VisitDiscard(IDiscardSymbol symbol);
    public virtual void VisitDynamicType(IDynamicTypeSymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    public virtual void VisitField(IFieldSymbol symbol);
    public virtual void VisitLabel(ILabelSymbol symbol);
    public virtual void VisitLocal(ILocalSymbol symbol);
    public virtual void VisitMethod(IMethodSymbol symbol);
    public virtual void VisitModule(IModuleSymbol symbol);
    public virtual void VisitNamedType(INamedTypeSymbol symbol);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    public virtual void VisitParameter(IParameterSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    public virtual void VisitRangeVariable(IRangeVariableSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);

  public abstract class Microsoft.CodeAnalysis.SymbolVisitor<TResult>

    protected SymbolVisitor();

    public virtual TResult DefaultVisit(ISymbol symbol);
    public virtual TResult Visit(ISymbol symbol);
    public virtual TResult VisitAlias(IAliasSymbol symbol);
    public virtual TResult VisitArrayType(IArrayTypeSymbol symbol);
    public virtual TResult VisitAssembly(IAssemblySymbol symbol);
    public virtual TResult VisitDiscard(IDiscardSymbol symbol);
    public virtual TResult VisitDynamicType(IDynamicTypeSymbol symbol);
    public virtual TResult VisitEvent(IEventSymbol symbol);
    public virtual TResult VisitField(IFieldSymbol symbol);
    public virtual TResult VisitLabel(ILabelSymbol symbol);
    public virtual TResult VisitLocal(ILocalSymbol symbol);
    public virtual TResult VisitMethod(IMethodSymbol symbol);
    public virtual TResult VisitModule(IModuleSymbol symbol);
    public virtual TResult VisitNamedType(INamedTypeSymbol symbol);
    public virtual TResult VisitNamespace(INamespaceSymbol symbol);
    public virtual TResult VisitParameter(IParameterSymbol symbol);
    public virtual TResult VisitPointerType(IPointerTypeSymbol symbol);
    public virtual TResult VisitProperty(IPropertySymbol symbol);
    public virtual TResult VisitRangeVariable(IRangeVariableSymbol symbol);
    public virtual TResult VisitTypeParameter(ITypeParameterSymbol symbol);

  public sealed class Microsoft.CodeAnalysis.SyntaxAnnotation : IEquatable<SyntaxAnnotation>, IObjectWritable

    public SyntaxAnnotation();
    public SyntaxAnnotation(string kind);
    public SyntaxAnnotation(string kind, string data);

    public string Data { get; }
    public static SyntaxAnnotation ElasticAnnotation { get; }
    public string Kind { get; }

    public override bool Equals(object obj);
    public bool Equals(SyntaxAnnotation other);
    public override int GetHashCode();

    public static bool operator ==(SyntaxAnnotation left, SyntaxAnnotation right);
    public static bool operator !=(SyntaxAnnotation left, SyntaxAnnotation right);

  public abstract class Microsoft.CodeAnalysis.SyntaxNode

    public bool ContainsAnnotations { get; }
    public bool ContainsDiagnostics { get; }
    public bool ContainsDirectives { get; }
    public bool ContainsSkippedText { get; }
    public TextSpan FullSpan { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasStructuredTrivia { get; }
    public bool HasTrailingTrivia { get; }
    public bool IsMissing { get; }
    public bool IsStructuredTrivia { get; }
    protected string KindText { get; }
    public abstract string Language { get; }
    public SyntaxNode Parent { get; }
    public virtual SyntaxTrivia ParentTrivia { get; }
    public int RawKind { get; }
    public TextSpan Span { get; }
    public int SpanStart { get; }
    public SyntaxTree SyntaxTree { get; }
    protected abstract SyntaxTree SyntaxTreeCore { get; }

    public IEnumerable<SyntaxNode> Ancestors(bool ascendOutOfTrivia = true);
    public IEnumerable<SyntaxNode> AncestorsAndSelf(bool ascendOutOfTrivia = true);
    public IEnumerable<SyntaxNode> ChildNodes();
    public ChildSyntaxList ChildNodesAndTokens();
    public virtual SyntaxNodeOrToken ChildThatContainsPosition(int position);
    public IEnumerable<SyntaxToken> ChildTokens();
    public bool Contains(SyntaxNode node);
    public T CopyAnnotationsTo<T>(T node) where T : SyntaxNode;
    public IEnumerable<SyntaxNode> DescendantNodes(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxNode> DescendantNodes(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxNode> DescendantNodesAndSelf(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxNode> DescendantNodesAndSelf(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokens(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokens(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxToken> DescendantTokens(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxToken> DescendantTokens(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxTrivia> DescendantTrivia(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    public IEnumerable<SyntaxTrivia> DescendantTrivia(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false);
    protected virtual bool EquivalentToCore(SyntaxNode other);
    public SyntaxNode FindNode(TextSpan span, bool findInsideTrivia = false, bool getInnermostNodeForTie = false);
    public SyntaxToken FindToken(int position, bool findInsideTrivia = false);
    protected virtual SyntaxToken FindTokenCore(int position, bool findInsideTrivia);
    protected virtual SyntaxToken FindTokenCore(int position, Func<SyntaxTrivia, bool> stepInto);
    public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false);
    public SyntaxTrivia FindTrivia(int position, Func<SyntaxTrivia, bool> stepInto);
    protected virtual SyntaxTrivia FindTriviaCore(int position, bool findInsideTrivia);
    public TNode FirstAncestorOrSelf<TNode>(Func<TNode, bool> predicate = null, bool ascendOutOfTrivia = true) where TNode : SyntaxNode;
    public IEnumerable<SyntaxNode> GetAnnotatedNodes(string annotationKind);
    public IEnumerable<SyntaxNode> GetAnnotatedNodes(SyntaxAnnotation syntaxAnnotation);
    public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxAnnotation annotation);
    public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(string annotationKind);
    public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(params string[] annotationKinds);
    public IEnumerable<SyntaxToken> GetAnnotatedTokens(string annotationKind);
    public IEnumerable<SyntaxToken> GetAnnotatedTokens(SyntaxAnnotation syntaxAnnotation);
    public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(SyntaxAnnotation annotation);
    public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(string annotationKind);
    public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(params string[] annotationKinds);
    public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable<SyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds);
    public IEnumerable<Diagnostic> GetDiagnostics();
    public SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false);
    public SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false);
    public SyntaxTriviaList GetLeadingTrivia();
    public Location GetLocation();
    protected T GetRed<T>(ref T field, int slot) where T : SyntaxNode;
    protected T GetRedAtZero<T>(ref T field) where T : SyntaxNode;
    public SyntaxReference GetReference();
    public SourceText GetText(Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1);
    public SyntaxTriviaList GetTrailingTrivia();
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(IEnumerable<string> annotationKinds);
    protected internal abstract SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable<SyntaxNode> nodesToInsert, bool insertBefore);
    protected internal abstract SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable<SyntaxToken> newTokens, bool insertBefore);
    protected internal abstract SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable<SyntaxTrivia> newTrivia, bool insertBefore);
    public bool IsEquivalentTo(SyntaxNode other);
    public bool IsEquivalentTo(SyntaxNode node, bool topLevel = false);
    protected abstract bool IsEquivalentToCore(SyntaxNode node, bool topLevel = false);
    public bool IsPartOfStructuredTrivia();
    protected internal abstract SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia);
    protected internal abstract SyntaxNode RemoveNodesCore(IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options);
    protected internal abstract SyntaxNode ReplaceCore<TNode>(IEnumerable<TNode> nodes = null, Func<TNode, TNode, SyntaxNode> computeReplacementNode = null, IEnumerable<SyntaxToken> tokens = null, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken = null, IEnumerable<SyntaxTrivia> trivia = null, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia = null) where TNode : SyntaxNode;
    protected internal abstract SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable<SyntaxNode> replacementNodes);
    protected internal abstract SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable<SyntaxToken> newTokens);
    protected internal abstract SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable<SyntaxTrivia> newTrivia);
    public virtual void SerializeTo(Stream stream, CancellationToken cancellationToken = default);
    public virtual string ToFullString();
    public override string ToString();
    public virtual void WriteTo(TextWriter writer);

    public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode : SyntaxNode, IMessageSerializable

      public override string Language { get; }
      protected override SyntaxTree SyntaxTreeCore { get; }

      public abstract void Accept(CSharpSyntaxVisitor visitor);
      public abstract TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
      public static SyntaxNode DeserializeFrom(Stream stream, CancellationToken cancellationToken = default);
      protected override bool EquivalentToCore(SyntaxNode other);
      public SyntaxToken FindToken(int position, bool findInsideTrivia = false);
      public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false);
      public SyntaxTrivia FindTrivia(int position, Func<SyntaxTrivia, bool> stepInto);
      public IEnumerable<Diagnostic> GetDiagnostics();
      public DirectiveTriviaSyntax GetFirstDirective(Func<DirectiveTriviaSyntax, bool> predicate = null);
      public SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false);
      public DirectiveTriviaSyntax GetLastDirective(Func<DirectiveTriviaSyntax, bool> predicate = null);
      public SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false);
      public SyntaxTriviaList GetLeadingTrivia();
      public Location GetLocation();
      public SyntaxTriviaList GetTrailingTrivia();
      protected internal override SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable<SyntaxNode> nodesToInsert, bool insertBefore);
      protected internal override SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable<SyntaxToken> newTokens, bool insertBefore);
      protected internal override SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable<SyntaxTrivia> newTrivia, bool insertBefore);
      protected override bool IsEquivalentToCore(SyntaxNode node, bool topLevel = false);
      public SyntaxKind Kind();
      protected internal override SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia);
      protected internal override SyntaxNode RemoveNodesCore(IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options);
      protected internal override SyntaxNode ReplaceCore<TNode>(IEnumerable<TNode> nodes = null, Func<TNode, TNode, SyntaxNode> computeReplacementNode = null, IEnumerable<SyntaxToken> tokens = null, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken = null, IEnumerable<SyntaxTrivia> trivia = null, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia = null) where TNode : SyntaxNode;
      protected internal override SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable<SyntaxNode> replacementNodes);
      protected internal override SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable<SyntaxToken> newTokens);
      protected internal override SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable<SyntaxTrivia> newTrivia);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax : CSharpSyntaxNode

        public SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public BlockSyntax Body { get; }
        public ArrowExpressionClauseSyntax ExpressionBody { get; }
        public SyntaxToken Keyword { get; }
        public SyntaxTokenList Modifiers { get; }
        public SyntaxToken SemicolonToken { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public AccessorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
        public AccessorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items);
        public AccessorDeclarationSyntax AddModifiers(params SyntaxToken[] items);
        public AccessorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken);
        public AccessorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
        public AccessorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
        public AccessorDeclarationSyntax WithBody(BlockSyntax body);
        public AccessorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
        public AccessorDeclarationSyntax WithKeyword(SyntaxToken keyword);
        public AccessorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
        public AccessorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax : CSharpSyntaxNode

        public SyntaxList<AccessorDeclarationSyntax> Accessors { get; }
        public SyntaxToken CloseBraceToken { get; }
        public SyntaxToken OpenBraceToken { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public AccessorListSyntax AddAccessors(params AccessorDeclarationSyntax[] items);
        public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken);
        public AccessorListSyntax WithAccessors(SyntaxList<AccessorDeclarationSyntax> accessors);
        public AccessorListSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
        public AccessorListSyntax WithOpenBraceToken(SyntaxToken openBraceToken);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode

        public ExpressionSyntax Expression { get; }
        public NameEqualsSyntax NameEquals { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
        public AnonymousObjectMemberDeclaratorSyntax WithExpression(ExpressionSyntax expression);
        public AnonymousObjectMemberDeclaratorSyntax WithNameEquals(NameEqualsSyntax nameEquals);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax : CSharpSyntaxNode

        public ExpressionSyntax Expression { get; }
        public NameColonSyntax NameColon { get; }
        public SyntaxToken RefOrOutKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression);
        public ArgumentSyntax WithExpression(ExpressionSyntax expression);
        public ArgumentSyntax WithNameColon(NameColonSyntax nameColon);
        public ArgumentSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax : CSharpSyntaxNode

        public SyntaxToken CloseBracketToken { get; }
        public SyntaxToken OpenBracketToken { get; }
        public int Rank { get; }
        public SeparatedSyntaxList<ExpressionSyntax> Sizes { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public ArrayRankSpecifierSyntax AddSizes(params ExpressionSyntax[] items);
        public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken);
        public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
        public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
        public ArrayRankSpecifierSyntax WithSizes(SeparatedSyntaxList<ExpressionSyntax> sizes);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax : CSharpSyntaxNode

        public SyntaxToken ArrowToken { get; }
        public ExpressionSyntax Expression { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression);
        public ArrowExpressionClauseSyntax WithArrowToken(SyntaxToken arrowToken);
        public ArrowExpressionClauseSyntax WithExpression(ExpressionSyntax expression);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax : CSharpSyntaxNode

        public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments { get; }
        public SyntaxToken CloseParenToken { get; }
        public SyntaxToken OpenParenToken { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public AttributeArgumentListSyntax AddArguments(params AttributeArgumentSyntax[] items);
        public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken);
        public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList<AttributeArgumentSyntax> arguments);
        public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
        public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax : CSharpSyntaxNode

        public ExpressionSyntax Expression { get; }
        public NameColonSyntax NameColon { get; }
        public NameEqualsSyntax NameEquals { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression);
        public AttributeArgumentSyntax WithExpression(ExpressionSyntax expression);
        public AttributeArgumentSyntax WithNameColon(NameColonSyntax nameColon);
        public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax nameEquals);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax : CSharpSyntaxNode

        public SeparatedSyntaxList<AttributeSyntax> Attributes { get; }
        public SyntaxToken CloseBracketToken { get; }
        public SyntaxToken OpenBracketToken { get; }
        public AttributeTargetSpecifierSyntax Target { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public AttributeListSyntax AddAttributes(params AttributeSyntax[] items);
        public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken);
        public AttributeListSyntax WithAttributes(SeparatedSyntaxList<AttributeSyntax> attributes);
        public AttributeListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
        public AttributeListSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
        public AttributeListSyntax WithTarget(AttributeTargetSpecifierSyntax target);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax : CSharpSyntaxNode

        public AttributeArgumentListSyntax ArgumentList { get; }
        public NameSyntax Name { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public AttributeSyntax AddArgumentListArguments(params AttributeArgumentSyntax[] items);
        public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList);
        public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax argumentList);
        public AttributeSyntax WithName(NameSyntax name);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax : CSharpSyntaxNode

        public SyntaxToken ColonToken { get; }
        public SyntaxToken Identifier { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken);
        public AttributeTargetSpecifierSyntax WithColonToken(SyntaxToken colonToken);
        public AttributeTargetSpecifierSyntax WithIdentifier(SyntaxToken identifier);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax : CSharpSyntaxNode

        public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax : BaseArgumentListSyntax

          public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken OpenParenToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ArgumentListSyntax AddArguments(params ArgumentSyntax[] items);
          public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
          public ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments);
          public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax : BaseArgumentListSyntax

          public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
          public SyntaxToken CloseBracketToken { get; }
          public SyntaxToken OpenBracketToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public BracketedArgumentListSyntax AddArguments(params ArgumentSyntax[] items);
          public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken);
          public BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments);
          public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
          public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax : CSharpSyntaxNode

        public abstract SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax

          public SyntaxToken CloseBracketToken { get; }
          public SyntaxToken OpenBracketToken { get; }
          public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public CrefBracketedParameterListSyntax AddParameters(params CrefParameterSyntax[] items);
          public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken);
          public CrefBracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
          public CrefBracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
          public CrefBracketedParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax : BaseCrefParameterListSyntax

          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken OpenParenToken { get; }
          public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public CrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items);
          public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken);
          public CrefParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public CrefParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public CrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax : CSharpSyntaxNode

        public SyntaxToken ColonToken { get; }
        public SeparatedSyntaxList<BaseTypeSyntax> Types { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public BaseListSyntax AddTypes(params BaseTypeSyntax[] items);
        public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types);
        public BaseListSyntax WithColonToken(SyntaxToken colonToken);
        public BaseListSyntax WithTypes(SeparatedSyntaxList<BaseTypeSyntax> types);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax : CSharpSyntaxNode

        public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax : BaseParameterListSyntax

          public SyntaxToken CloseBracketToken { get; }
          public SyntaxToken OpenBracketToken { get; }
          public override SeparatedSyntaxList<ParameterSyntax> Parameters { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public BracketedParameterListSyntax AddParameters(params ParameterSyntax[] items);
          public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken);
          public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
          public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
          public BracketedParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax : BaseParameterListSyntax

          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken OpenParenToken { get; }
          public override SeparatedSyntaxList<ParameterSyntax> Parameters { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ParameterListSyntax AddParameters(params ParameterSyntax[] items);
          public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken);
          public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax : CSharpSyntaxNode

        public abstract TypeSyntax Type { get; }

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax : BaseTypeSyntax

          public override TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public SimpleBaseTypeSyntax Update(TypeSyntax type);
          public SimpleBaseTypeSyntax WithType(TypeSyntax type);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax : CSharpSyntaxNode

        public BlockSyntax Block { get; }
        public SyntaxToken CatchKeyword { get; }
        public CatchDeclarationSyntax Declaration { get; }
        public CatchFilterClauseSyntax Filter { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public CatchClauseSyntax AddBlockStatements(params StatementSyntax[] items);
        public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
        public CatchClauseSyntax WithBlock(BlockSyntax block);
        public CatchClauseSyntax WithCatchKeyword(SyntaxToken catchKeyword);
        public CatchClauseSyntax WithDeclaration(CatchDeclarationSyntax declaration);
        public CatchClauseSyntax WithFilter(CatchFilterClauseSyntax filter);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax : CSharpSyntaxNode

        public SyntaxToken CloseParenToken { get; }
        public SyntaxToken Identifier { get; }
        public SyntaxToken OpenParenToken { get; }
        public TypeSyntax Type { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken);
        public CatchDeclarationSyntax WithCloseParenToken(SyntaxToken closeParenToken);
        public CatchDeclarationSyntax WithIdentifier(SyntaxToken identifier);
        public CatchDeclarationSyntax WithOpenParenToken(SyntaxToken openParenToken);
        public CatchDeclarationSyntax WithType(TypeSyntax type);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax : CSharpSyntaxNode

        public SyntaxToken CloseParenToken { get; }
        public ExpressionSyntax FilterExpression { get; }
        public SyntaxToken OpenParenToken { get; }
        public SyntaxToken WhenKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken);
        public CatchFilterClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken);
        public CatchFilterClauseSyntax WithFilterExpression(ExpressionSyntax filterExpression);
        public CatchFilterClauseSyntax WithOpenParenToken(SyntaxToken openParenToken);
        public CatchFilterClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax : CSharpSyntaxNode, ICompilationUnitSyntax

        public SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public SyntaxToken EndOfFileToken { get; }
        public SyntaxList<ExternAliasDirectiveSyntax> Externs { get; }
        public SyntaxList<MemberDeclarationSyntax> Members { get; }
        public SyntaxList<UsingDirectiveSyntax> Usings { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public CompilationUnitSyntax AddAttributeLists(params AttributeListSyntax[] items);
        public CompilationUnitSyntax AddExterns(params ExternAliasDirectiveSyntax[] items);
        public CompilationUnitSyntax AddMembers(params MemberDeclarationSyntax[] items);
        public CompilationUnitSyntax AddUsings(params UsingDirectiveSyntax[] items);
        public IList<LoadDirectiveTriviaSyntax> GetLoadDirectives();
        public IList<ReferenceDirectiveTriviaSyntax> GetReferenceDirectives();
        public CompilationUnitSyntax Update(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken);
        public CompilationUnitSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
        public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken);
        public CompilationUnitSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs);
        public CompilationUnitSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members);
        public CompilationUnitSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax : CSharpSyntaxNode

        public ArgumentListSyntax ArgumentList { get; }
        public SyntaxToken ColonToken { get; }
        public SyntaxToken ThisOrBaseKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public ConstructorInitializerSyntax AddArgumentListArguments(params ArgumentSyntax[] items);
        public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList);
        public ConstructorInitializerSyntax WithArgumentList(ArgumentListSyntax argumentList);
        public ConstructorInitializerSyntax WithColonToken(SyntaxToken colonToken);
        public ConstructorInitializerSyntax WithThisOrBaseKeyword(SyntaxToken thisOrBaseKeyword);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax : CSharpSyntaxNode

        public SyntaxToken RefOrOutKeyword { get; }
        public TypeSyntax Type { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public CrefParameterSyntax Update(SyntaxToken refOrOutKeyword, TypeSyntax type);
        public CrefParameterSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword);
        public CrefParameterSyntax WithType(TypeSyntax type);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax : CSharpSyntaxNode

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax : CrefSyntax

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax : MemberCrefSyntax

            public SyntaxToken ImplicitOrExplicitKeyword { get; }
            public SyntaxToken OperatorKeyword { get; }
            public CrefParameterListSyntax Parameters { get; }
            public TypeSyntax Type { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ConversionOperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items);
            public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
            public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword);
            public ConversionOperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
            public ConversionOperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters);
            public ConversionOperatorMemberCrefSyntax WithType(TypeSyntax type);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax : MemberCrefSyntax

            public CrefBracketedParameterListSyntax Parameters { get; }
            public SyntaxToken ThisKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public IndexerMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items);
            public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters);
            public IndexerMemberCrefSyntax WithParameters(CrefBracketedParameterListSyntax parameters);
            public IndexerMemberCrefSyntax WithThisKeyword(SyntaxToken thisKeyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax : MemberCrefSyntax

            public TypeSyntax Name { get; }
            public CrefParameterListSyntax Parameters { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public NameMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items);
            public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters);
            public NameMemberCrefSyntax WithName(TypeSyntax name);
            public NameMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax : MemberCrefSyntax

            public SyntaxToken OperatorKeyword { get; }
            public SyntaxToken OperatorToken { get; }
            public CrefParameterListSyntax Parameters { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public OperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items);
            public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters);
            public OperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
            public OperatorMemberCrefSyntax WithOperatorToken(SyntaxToken operatorToken);
            public OperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax : CrefSyntax

          public TypeSyntax Container { get; }
          public SyntaxToken DotToken { get; }
          public MemberCrefSyntax Member { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member);
          public QualifiedCrefSyntax WithContainer(TypeSyntax container);
          public QualifiedCrefSyntax WithDotToken(SyntaxToken dotToken);
          public QualifiedCrefSyntax WithMember(MemberCrefSyntax member);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax : CrefSyntax

          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public TypeCrefSyntax Update(TypeSyntax type);
          public TypeCrefSyntax WithType(TypeSyntax type);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax : CSharpSyntaxNode

        public SyntaxToken ElseKeyword { get; }
        public StatementSyntax Statement { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement);
        public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword);
        public ElseClauseSyntax WithStatement(StatementSyntax statement);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax : CSharpSyntaxNode

        public SyntaxToken EqualsToken { get; }
        public ExpressionSyntax Value { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value);
        public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken);
        public EqualsValueClauseSyntax WithValue(ExpressionSyntax value);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode

        public SyntaxToken DotToken { get; }
        public NameSyntax Name { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken);
        public ExplicitInterfaceSpecifierSyntax WithDotToken(SyntaxToken dotToken);
        public ExplicitInterfaceSpecifierSyntax WithName(NameSyntax name);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax : CSharpSyntaxNode

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax : ExpressionSyntax

          public abstract SyntaxToken AsyncKeyword { get; }
          public abstract CSharpSyntaxNode Body { get; }

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax

            public override SyntaxToken AsyncKeyword { get; }
            public BlockSyntax Block { get; }
            public override CSharpSyntaxNode Body { get; }
            public SyntaxToken DelegateKeyword { get; }
            public ParameterListSyntax ParameterList { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public AnonymousMethodExpressionSyntax AddBlockStatements(params StatementSyntax[] items);
            public AnonymousMethodExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items);
            public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body);
            public AnonymousMethodExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword);
            public AnonymousMethodExpressionSyntax WithBlock(BlockSyntax block);
            public AnonymousMethodExpressionSyntax WithBody(CSharpSyntaxNode body);
            public AnonymousMethodExpressionSyntax WithDelegateKeyword(SyntaxToken delegateKeyword);
            public AnonymousMethodExpressionSyntax WithParameterList(ParameterListSyntax parameterList);

          public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax

            public abstract SyntaxToken ArrowToken { get; }

            public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax

              public override SyntaxToken ArrowToken { get; }
              public override SyntaxToken AsyncKeyword { get; }
              public override CSharpSyntaxNode Body { get; }
              public ParameterListSyntax ParameterList { get; }

              public override void Accept(CSharpSyntaxVisitor visitor);
              public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
              public ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items);
              public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body);
              public ParenthesizedLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken);
              public ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword);
              public ParenthesizedLambdaExpressionSyntax WithBody(CSharpSyntaxNode body);
              public ParenthesizedLambdaExpressionSyntax WithParameterList(ParameterListSyntax parameterList);

            public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax : LambdaExpressionSyntax

              public override SyntaxToken ArrowToken { get; }
              public override SyntaxToken AsyncKeyword { get; }
              public override CSharpSyntaxNode Body { get; }
              public ParameterSyntax Parameter { get; }

              public override void Accept(CSharpSyntaxVisitor visitor);
              public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
              public SimpleLambdaExpressionSyntax AddParameterAttributeLists(params AttributeListSyntax[] items);
              public SimpleLambdaExpressionSyntax AddParameterModifiers(params SyntaxToken[] items);
              public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body);
              public SimpleLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken);
              public SimpleLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword);
              public SimpleLambdaExpressionSyntax WithBody(CSharpSyntaxNode body);
              public SimpleLambdaExpressionSyntax WithParameter(ParameterSyntax parameter);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseBraceToken { get; }
          public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers { get; }
          public SyntaxToken NewKeyword { get; }
          public SyntaxToken OpenBraceToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public AnonymousObjectCreationExpressionSyntax AddInitializers(params AnonymousObjectMemberDeclaratorSyntax[] items);
          public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken);
          public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
          public AnonymousObjectCreationExpressionSyntax WithInitializers(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers);
          public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
          public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax : ExpressionSyntax

          public InitializerExpressionSyntax Initializer { get; }
          public SyntaxToken NewKeyword { get; }
          public ArrayTypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params ArrayRankSpecifierSyntax[] items);
          public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
          public ArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer);
          public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
          public ArrayCreationExpressionSyntax WithType(ArrayTypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Left { get; }
          public SyntaxToken OperatorToken { get; }
          public ExpressionSyntax Right { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
          public AssignmentExpressionSyntax WithLeft(ExpressionSyntax left);
          public AssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
          public AssignmentExpressionSyntax WithRight(ExpressionSyntax right);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax : ExpressionSyntax

          public SyntaxToken AwaitKeyword { get; }
          public ExpressionSyntax Expression { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression);
          public AwaitExpressionSyntax WithAwaitKeyword(SyntaxToken awaitKeyword);
          public AwaitExpressionSyntax WithExpression(ExpressionSyntax expression);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Left { get; }
          public SyntaxToken OperatorToken { get; }
          public ExpressionSyntax Right { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
          public BinaryExpressionSyntax WithLeft(ExpressionSyntax left);
          public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
          public BinaryExpressionSyntax WithRight(ExpressionSyntax right);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken OpenParenToken { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression);
          public CastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public CastExpressionSyntax WithExpression(ExpressionSyntax expression);
          public CastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public CastExpressionSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken Keyword { get; }
          public SyntaxToken OpenParenToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
          public CheckedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public CheckedExpressionSyntax WithExpression(ExpressionSyntax expression);
          public CheckedExpressionSyntax WithKeyword(SyntaxToken keyword);
          public CheckedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken OperatorToken { get; }
          public ExpressionSyntax WhenNotNull { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull);
          public ConditionalAccessExpressionSyntax WithExpression(ExpressionSyntax expression);
          public ConditionalAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
          public ConditionalAccessExpressionSyntax WithWhenNotNull(ExpressionSyntax whenNotNull);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax : ExpressionSyntax

          public SyntaxToken ColonToken { get; }
          public ExpressionSyntax Condition { get; }
          public SyntaxToken QuestionToken { get; }
          public ExpressionSyntax WhenFalse { get; }
          public ExpressionSyntax WhenTrue { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse);
          public ConditionalExpressionSyntax WithColonToken(SyntaxToken colonToken);
          public ConditionalExpressionSyntax WithCondition(ExpressionSyntax condition);
          public ConditionalExpressionSyntax WithQuestionToken(SyntaxToken questionToken);
          public ConditionalExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse);
          public ConditionalExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax : ExpressionSyntax

          public VariableDesignationSyntax Designation { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public DeclarationExpressionSyntax Update(TypeSyntax type, VariableDesignationSyntax designation);
          public DeclarationExpressionSyntax WithDesignation(VariableDesignationSyntax designation);
          public DeclarationExpressionSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken Keyword { get; }
          public SyntaxToken OpenParenToken { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
          public DefaultExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public DefaultExpressionSyntax WithKeyword(SyntaxToken keyword);
          public DefaultExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public DefaultExpressionSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax : ExpressionSyntax

          public BracketedArgumentListSyntax ArgumentList { get; }
          public ExpressionSyntax Expression { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ElementAccessExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items);
          public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList);
          public ElementAccessExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList);
          public ElementAccessExpressionSyntax WithExpression(ExpressionSyntax expression);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax : ExpressionSyntax

          public BracketedArgumentListSyntax ArgumentList { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ElementBindingExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items);
          public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList);
          public ElementBindingExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseBracketToken { get; }
          public SyntaxTokenList Commas { get; }
          public InitializerExpressionSyntax Initializer { get; }
          public SyntaxToken NewKeyword { get; }
          public SyntaxToken OpenBracketToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ImplicitArrayCreationExpressionSyntax AddCommas(params SyntaxToken[] items);
          public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items);
          public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer);
          public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
          public ImplicitArrayCreationExpressionSyntax WithCommas(SyntaxTokenList commas);
          public ImplicitArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer);
          public ImplicitArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
          public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax : ExpressionSyntax

          public BracketedArgumentListSyntax ArgumentList { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ImplicitElementAccessSyntax AddArgumentListArguments(params ArgumentSyntax[] items);
          public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList);
          public ImplicitElementAccessSyntax WithArgumentList(BracketedArgumentListSyntax argumentList);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseBraceToken { get; }
          public SeparatedSyntaxList<ExpressionSyntax> Expressions { get; }
          public SyntaxToken OpenBraceToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public InitializerExpressionSyntax AddExpressions(params ExpressionSyntax[] items);
          public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
          public InitializerExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
          public InitializerExpressionSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions);
          public InitializerExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken);

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax : ExpressionSyntax

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax : InstanceExpressionSyntax

            public SyntaxToken Token { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public BaseExpressionSyntax Update(SyntaxToken token);
            public BaseExpressionSyntax WithToken(SyntaxToken token);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax : InstanceExpressionSyntax

            public SyntaxToken Token { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ThisExpressionSyntax Update(SyntaxToken token);
            public ThisExpressionSyntax WithToken(SyntaxToken token);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax : ExpressionSyntax

          public SyntaxList<InterpolatedStringContentSyntax> Contents { get; }
          public SyntaxToken StringEndToken { get; }
          public SyntaxToken StringStartToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public InterpolatedStringExpressionSyntax AddContents(params InterpolatedStringContentSyntax[] items);
          public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken);
          public InterpolatedStringExpressionSyntax WithContents(SyntaxList<InterpolatedStringContentSyntax> contents);
          public InterpolatedStringExpressionSyntax WithStringEndToken(SyntaxToken stringEndToken);
          public InterpolatedStringExpressionSyntax WithStringStartToken(SyntaxToken stringStartToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax : ExpressionSyntax

          public ArgumentListSyntax ArgumentList { get; }
          public ExpressionSyntax Expression { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items);
          public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList);
          public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList);
          public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken IsKeyword { get; }
          public PatternSyntax Pattern { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern);
          public IsPatternExpressionSyntax WithExpression(ExpressionSyntax expression);
          public IsPatternExpressionSyntax WithIsKeyword(SyntaxToken isKeyword);
          public IsPatternExpressionSyntax WithPattern(PatternSyntax pattern);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax : ExpressionSyntax

          public SyntaxToken Token { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public LiteralExpressionSyntax Update(SyntaxToken token);
          public LiteralExpressionSyntax WithToken(SyntaxToken token);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken Keyword { get; }
          public SyntaxToken OpenParenToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
          public MakeRefExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public MakeRefExpressionSyntax WithExpression(ExpressionSyntax expression);
          public MakeRefExpressionSyntax WithKeyword(SyntaxToken keyword);
          public MakeRefExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Expression { get; }
          public SimpleNameSyntax Name { get; }
          public SyntaxToken OperatorToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
          public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression);
          public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name);
          public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax : ExpressionSyntax

          public SimpleNameSyntax Name { get; }
          public SyntaxToken OperatorToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name);
          public MemberBindingExpressionSyntax WithName(SimpleNameSyntax name);
          public MemberBindingExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax : ExpressionSyntax

          public ArgumentListSyntax ArgumentList { get; }
          public InitializerExpressionSyntax Initializer { get; }
          public SyntaxToken NewKeyword { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items);
          public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
          public ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList);
          public ObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer);
          public ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
          public ObjectCreationExpressionSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax : ExpressionSyntax

          public SyntaxToken OmittedArraySizeExpressionToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken);
          public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken OpenParenToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
          public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression);
          public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Operand { get; }
          public SyntaxToken OperatorToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken);
          public PostfixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand);
          public PostfixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Operand { get; }
          public SyntaxToken OperatorToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand);
          public PrefixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand);
          public PrefixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax : ExpressionSyntax

          public QueryBodySyntax Body { get; }
          public FromClauseSyntax FromClause { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public QueryExpressionSyntax AddBodyClauses(params QueryClauseSyntax[] items);
          public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body);
          public QueryExpressionSyntax WithBody(QueryBodySyntax body);
          public QueryExpressionSyntax WithFromClause(FromClauseSyntax fromClause);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken RefKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public RefExpressionSyntax Update(SyntaxToken refKeyword, ExpressionSyntax expression);
          public RefExpressionSyntax WithExpression(ExpressionSyntax expression);
          public RefExpressionSyntax WithRefKeyword(SyntaxToken refKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken Keyword { get; }
          public SyntaxToken OpenParenToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
          public RefTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public RefTypeExpressionSyntax WithExpression(ExpressionSyntax expression);
          public RefTypeExpressionSyntax WithKeyword(SyntaxToken keyword);
          public RefTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken Comma { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken Keyword { get; }
          public SyntaxToken OpenParenToken { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken);
          public RefValueExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public RefValueExpressionSyntax WithComma(SyntaxToken comma);
          public RefValueExpressionSyntax WithExpression(ExpressionSyntax expression);
          public RefValueExpressionSyntax WithKeyword(SyntaxToken keyword);
          public RefValueExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public RefValueExpressionSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken Keyword { get; }
          public SyntaxToken OpenParenToken { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
          public SizeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public SizeOfExpressionSyntax WithKeyword(SyntaxToken keyword);
          public SizeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public SizeOfExpressionSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax : ExpressionSyntax

          public SyntaxToken StackAllocKeyword { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type);
          public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword);
          public StackAllocArrayCreationExpressionSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax : ExpressionSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken ThrowKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ThrowExpressionSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression);
          public ThrowExpressionSyntax WithExpression(ExpressionSyntax expression);
          public ThrowExpressionSyntax WithThrowKeyword(SyntaxToken throwKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax : ExpressionSyntax

          public SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken OpenParenToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public TupleExpressionSyntax AddArguments(params ArgumentSyntax[] items);
          public TupleExpressionSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
          public TupleExpressionSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments);
          public TupleExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public TupleExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax : ExpressionSyntax

          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken Keyword { get; }
          public SyntaxToken OpenParenToken { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
          public TypeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public TypeOfExpressionSyntax WithKeyword(SyntaxToken keyword);
          public TypeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public TypeOfExpressionSyntax WithType(TypeSyntax type);

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax : ExpressionSyntax

          public bool IsVar { get; }

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax : TypeSyntax

            public TypeSyntax ElementType { get; }
            public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ArrayTypeSyntax AddRankSpecifiers(params ArrayRankSpecifierSyntax[] items);
            public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers);
            public ArrayTypeSyntax WithElementType(TypeSyntax elementType);
            public ArrayTypeSyntax WithRankSpecifiers(SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers);

          public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax : TypeSyntax

            public int Arity { get; }

            public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax : NameSyntax

              public IdentifierNameSyntax Alias { get; }
              public SyntaxToken ColonColonToken { get; }
              public SimpleNameSyntax Name { get; }

              public override void Accept(CSharpSyntaxVisitor visitor);
              public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
              public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name);
              public AliasQualifiedNameSyntax WithAlias(IdentifierNameSyntax alias);
              public AliasQualifiedNameSyntax WithColonColonToken(SyntaxToken colonColonToken);
              public AliasQualifiedNameSyntax WithName(SimpleNameSyntax name);

            public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax : NameSyntax

              public SyntaxToken DotToken { get; }
              public NameSyntax Left { get; }
              public SimpleNameSyntax Right { get; }

              public override void Accept(CSharpSyntaxVisitor visitor);
              public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
              public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
              public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken);
              public QualifiedNameSyntax WithLeft(NameSyntax left);
              public QualifiedNameSyntax WithRight(SimpleNameSyntax right);

            public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax : NameSyntax

              public abstract SyntaxToken Identifier { get; }

              public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax : SimpleNameSyntax

                public override SyntaxToken Identifier { get; }
                public bool IsUnboundGenericName { get; }
                public TypeArgumentListSyntax TypeArgumentList { get; }

                public override void Accept(CSharpSyntaxVisitor visitor);
                public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
                public GenericNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items);
                public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
                public GenericNameSyntax WithIdentifier(SyntaxToken identifier);
                public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList);

              public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax : SimpleNameSyntax

                public override SyntaxToken Identifier { get; }

                public override void Accept(CSharpSyntaxVisitor visitor);
                public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
                public IdentifierNameSyntax Update(SyntaxToken identifier);
                public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax : TypeSyntax

            public TypeSyntax ElementType { get; }
            public SyntaxToken QuestionToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken);
            public NullableTypeSyntax WithElementType(TypeSyntax elementType);
            public NullableTypeSyntax WithQuestionToken(SyntaxToken questionToken);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax : TypeSyntax

            public SyntaxToken OmittedTypeArgumentToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken);
            public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(SyntaxToken omittedTypeArgumentToken);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax : TypeSyntax

            public SyntaxToken AsteriskToken { get; }
            public TypeSyntax ElementType { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken);
            public PointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken);
            public PointerTypeSyntax WithElementType(TypeSyntax elementType);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax : TypeSyntax

            public SyntaxToken Keyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public PredefinedTypeSyntax Update(SyntaxToken keyword);
            public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax : TypeSyntax

            public SyntaxToken RefKeyword { get; }
            public TypeSyntax Type { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public RefTypeSyntax Update(SyntaxToken refKeyword, TypeSyntax type);
            public RefTypeSyntax WithRefKeyword(SyntaxToken refKeyword);
            public RefTypeSyntax WithType(TypeSyntax type);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax : TypeSyntax

            public SyntaxToken CloseParenToken { get; }
            public SeparatedSyntaxList<TupleElementSyntax> Elements { get; }
            public SyntaxToken OpenParenToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public TupleTypeSyntax AddElements(params TupleElementSyntax[] items);
            public TupleTypeSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken);
            public TupleTypeSyntax WithCloseParenToken(SyntaxToken closeParenToken);
            public TupleTypeSyntax WithElements(SeparatedSyntaxList<TupleElementSyntax> elements);
            public TupleTypeSyntax WithOpenParenToken(SyntaxToken openParenToken);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax : CSharpSyntaxNode

        public SyntaxToken AliasKeyword { get; }
        public SyntaxToken ExternKeyword { get; }
        public SyntaxToken Identifier { get; }
        public SyntaxToken SemicolonToken { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken);
        public ExternAliasDirectiveSyntax WithAliasKeyword(SyntaxToken aliasKeyword);
        public ExternAliasDirectiveSyntax WithExternKeyword(SyntaxToken externKeyword);
        public ExternAliasDirectiveSyntax WithIdentifier(SyntaxToken identifier);
        public ExternAliasDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax : CSharpSyntaxNode

        public BlockSyntax Block { get; }
        public SyntaxToken FinallyKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public FinallyClauseSyntax AddBlockStatements(params StatementSyntax[] items);
        public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block);
        public FinallyClauseSyntax WithBlock(BlockSyntax block);
        public FinallyClauseSyntax WithFinallyKeyword(SyntaxToken finallyKeyword);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax : CSharpSyntaxNode

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax : InterpolatedStringContentSyntax

          public SyntaxToken TextToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public InterpolatedStringTextSyntax Update(SyntaxToken textToken);
          public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax : InterpolatedStringContentSyntax

          public InterpolationAlignmentClauseSyntax AlignmentClause { get; }
          public SyntaxToken CloseBraceToken { get; }
          public ExpressionSyntax Expression { get; }
          public InterpolationFormatClauseSyntax FormatClause { get; }
          public SyntaxToken OpenBraceToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
          public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax alignmentClause);
          public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
          public InterpolationSyntax WithExpression(ExpressionSyntax expression);
          public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax formatClause);
          public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax : CSharpSyntaxNode

        public SyntaxToken CommaToken { get; }
        public ExpressionSyntax Value { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value);
        public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken);
        public InterpolationAlignmentClauseSyntax WithValue(ExpressionSyntax value);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax : CSharpSyntaxNode

        public SyntaxToken ColonToken { get; }
        public SyntaxToken FormatStringToken { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken);
        public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken);
        public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax : CSharpSyntaxNode

        public SyntaxToken Identifier { get; }
        public SyntaxToken IntoKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier);
        public JoinIntoClauseSyntax WithIdentifier(SyntaxToken identifier);
        public JoinIntoClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax : CSharpSyntaxNode

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax : MemberDeclarationSyntax

          public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }
          public abstract VariableDeclarationSyntax Declaration { get; }
          public abstract SyntaxTokenList Modifiers { get; }
          public abstract SyntaxToken SemicolonToken { get; }

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax

            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override VariableDeclarationSyntax Declaration { get; }
            public SyntaxToken EventKeyword { get; }
            public override SyntaxTokenList Modifiers { get; }
            public override SyntaxToken SemicolonToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public EventFieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public EventFieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items);
            public EventFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public EventFieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
            public EventFieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public EventFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration);
            public EventFieldDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword);
            public EventFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public EventFieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax : BaseFieldDeclarationSyntax

            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override VariableDeclarationSyntax Declaration { get; }
            public override SyntaxTokenList Modifiers { get; }
            public override SyntaxToken SemicolonToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public FieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public FieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items);
            public FieldDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public FieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
            public FieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public FieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration);
            public FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public FieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax : MemberDeclarationSyntax

          public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }
          public abstract BlockSyntax Body { get; }
          public abstract ArrowExpressionClauseSyntax ExpressionBody { get; }
          public abstract SyntaxTokenList Modifiers { get; }
          public abstract ParameterListSyntax ParameterList { get; }
          public abstract SyntaxToken SemicolonToken { get; }

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax

            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override BlockSyntax Body { get; }
            public override ArrowExpressionClauseSyntax ExpressionBody { get; }
            public SyntaxToken Identifier { get; }
            public ConstructorInitializerSyntax Initializer { get; }
            public override SyntaxTokenList Modifiers { get; }
            public override ParameterListSyntax ParameterList { get; }
            public override SyntaxToken SemicolonToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ConstructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public ConstructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items);
            public ConstructorDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public ConstructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items);
            public ConstructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken);
            public ConstructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
            public ConstructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public ConstructorDeclarationSyntax WithBody(BlockSyntax body);
            public ConstructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
            public ConstructorDeclarationSyntax WithIdentifier(SyntaxToken identifier);
            public ConstructorDeclarationSyntax WithInitializer(ConstructorInitializerSyntax initializer);
            public ConstructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public ConstructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
            public ConstructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax

            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override BlockSyntax Body { get; }
            public override ArrowExpressionClauseSyntax ExpressionBody { get; }
            public SyntaxToken ImplicitOrExplicitKeyword { get; }
            public override SyntaxTokenList Modifiers { get; }
            public SyntaxToken OperatorKeyword { get; }
            public override ParameterListSyntax ParameterList { get; }
            public override SyntaxToken SemicolonToken { get; }
            public TypeSyntax Type { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ConversionOperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public ConversionOperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items);
            public ConversionOperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public ConversionOperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items);
            public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
            public ConversionOperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public ConversionOperatorDeclarationSyntax WithBody(BlockSyntax body);
            public ConversionOperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
            public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword);
            public ConversionOperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public ConversionOperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
            public ConversionOperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
            public ConversionOperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
            public ConversionOperatorDeclarationSyntax WithType(TypeSyntax type);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax : BaseMethodDeclarationSyntax

            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override BlockSyntax Body { get; }
            public override ArrowExpressionClauseSyntax ExpressionBody { get; }
            public SyntaxToken Identifier { get; }
            public override SyntaxTokenList Modifiers { get; }
            public override ParameterListSyntax ParameterList { get; }
            public override SyntaxToken SemicolonToken { get; }
            public SyntaxToken TildeToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public DestructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public DestructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items);
            public DestructorDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public DestructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items);
            public DestructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
            public DestructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
            public DestructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public DestructorDeclarationSyntax WithBody(BlockSyntax body);
            public DestructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
            public DestructorDeclarationSyntax WithIdentifier(SyntaxToken identifier);
            public DestructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public DestructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
            public DestructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
            public DestructorDeclarationSyntax WithTildeToken(SyntaxToken tildeToken);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax : BaseMethodDeclarationSyntax

            public int Arity { get; }
            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override BlockSyntax Body { get; }
            public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
            public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
            public override ArrowExpressionClauseSyntax ExpressionBody { get; }
            public SyntaxToken Identifier { get; }
            public override SyntaxTokenList Modifiers { get; }
            public override ParameterListSyntax ParameterList { get; }
            public TypeSyntax ReturnType { get; }
            public override SyntaxToken SemicolonToken { get; }
            public TypeParameterListSyntax TypeParameterList { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public MethodDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public MethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items);
            public MethodDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items);
            public MethodDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public MethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items);
            public MethodDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items);
            public MethodDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
            public MethodDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public MethodDeclarationSyntax WithBody(BlockSyntax body);
            public MethodDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
            public MethodDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);
            public MethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
            public MethodDeclarationSyntax WithIdentifier(SyntaxToken identifier);
            public MethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public MethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
            public MethodDeclarationSyntax WithReturnType(TypeSyntax returnType);
            public MethodDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
            public MethodDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax : BaseMethodDeclarationSyntax

            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override BlockSyntax Body { get; }
            public override ArrowExpressionClauseSyntax ExpressionBody { get; }
            public override SyntaxTokenList Modifiers { get; }
            public SyntaxToken OperatorKeyword { get; }
            public SyntaxToken OperatorToken { get; }
            public override ParameterListSyntax ParameterList { get; }
            public TypeSyntax ReturnType { get; }
            public override SyntaxToken SemicolonToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public OperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public OperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items);
            public OperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public OperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items);
            public OperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
            public OperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public OperatorDeclarationSyntax WithBody(BlockSyntax body);
            public OperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
            public OperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public OperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
            public OperatorDeclarationSyntax WithOperatorToken(SyntaxToken operatorToken);
            public OperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
            public OperatorDeclarationSyntax WithReturnType(TypeSyntax returnType);
            public OperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax : MemberDeclarationSyntax

          public abstract AccessorListSyntax AccessorList { get; }
          public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }
          public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
          public abstract SyntaxTokenList Modifiers { get; }
          public abstract TypeSyntax Type { get; }

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax : BasePropertyDeclarationSyntax

            public override AccessorListSyntax AccessorList { get; }
            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public SyntaxToken EventKeyword { get; }
            public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
            public SyntaxToken Identifier { get; }
            public override SyntaxTokenList Modifiers { get; }
            public override TypeSyntax Type { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public EventDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items);
            public EventDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public EventDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public EventDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
            public EventDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList);
            public EventDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public EventDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword);
            public EventDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);
            public EventDeclarationSyntax WithIdentifier(SyntaxToken identifier);
            public EventDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public EventDeclarationSyntax WithType(TypeSyntax type);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax : BasePropertyDeclarationSyntax

            public override AccessorListSyntax AccessorList { get; }
            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
            public ArrowExpressionClauseSyntax ExpressionBody { get; }
            public override SyntaxTokenList Modifiers { get; }
            public BracketedParameterListSyntax ParameterList { get; }
            public SyntaxToken Semicolon { get; }
            public SyntaxToken SemicolonToken { get; }
            public SyntaxToken ThisKeyword { get; }
            public override TypeSyntax Type { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public IndexerDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items);
            public IndexerDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public IndexerDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public IndexerDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items);
            public IndexerDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
            public IndexerDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList);
            public IndexerDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);
            public IndexerDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
            public IndexerDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public IndexerDeclarationSyntax WithParameterList(BracketedParameterListSyntax parameterList);
            public IndexerDeclarationSyntax WithSemicolon(SyntaxToken semicolon);
            public IndexerDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
            public IndexerDeclarationSyntax WithThisKeyword(SyntaxToken thisKeyword);
            public IndexerDeclarationSyntax WithType(TypeSyntax type);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax : BasePropertyDeclarationSyntax

            public override AccessorListSyntax AccessorList { get; }
            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
            public ArrowExpressionClauseSyntax ExpressionBody { get; }
            public SyntaxToken Identifier { get; }
            public EqualsValueClauseSyntax Initializer { get; }
            public override SyntaxTokenList Modifiers { get; }
            public SyntaxToken Semicolon { get; }
            public SyntaxToken SemicolonToken { get; }
            public override TypeSyntax Type { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public PropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items);
            public PropertyDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public PropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public PropertyDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken);
            public PropertyDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList);
            public PropertyDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);
            public PropertyDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
            public PropertyDeclarationSyntax WithIdentifier(SyntaxToken identifier);
            public PropertyDeclarationSyntax WithInitializer(EqualsValueClauseSyntax initializer);
            public PropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public PropertyDeclarationSyntax WithSemicolon(SyntaxToken semicolon);
            public PropertyDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
            public PropertyDeclarationSyntax WithType(TypeSyntax type);

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax : MemberDeclarationSyntax

          public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }
          public abstract BaseListSyntax BaseList { get; }
          public abstract SyntaxToken CloseBraceToken { get; }
          public abstract SyntaxToken Identifier { get; }
          public abstract SyntaxTokenList Modifiers { get; }
          public abstract SyntaxToken OpenBraceToken { get; }
          public abstract SyntaxToken SemicolonToken { get; }

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax : BaseTypeDeclarationSyntax

            public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
            public override BaseListSyntax BaseList { get; }
            public override SyntaxToken CloseBraceToken { get; }
            public SyntaxToken EnumKeyword { get; }
            public override SyntaxToken Identifier { get; }
            public SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members { get; }
            public override SyntaxTokenList Modifiers { get; }
            public override SyntaxToken OpenBraceToken { get; }
            public override SyntaxToken SemicolonToken { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public EnumDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
            public EnumDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items);
            public EnumDeclarationSyntax AddMembers(params EnumMemberDeclarationSyntax[] items);
            public EnumDeclarationSyntax AddModifiers(params SyntaxToken[] items);
            public EnumDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
            public EnumDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
            public EnumDeclarationSyntax WithBaseList(BaseListSyntax baseList);
            public EnumDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
            public EnumDeclarationSyntax WithEnumKeyword(SyntaxToken enumKeyword);
            public EnumDeclarationSyntax WithIdentifier(SyntaxToken identifier);
            public EnumDeclarationSyntax WithMembers(SeparatedSyntaxList<EnumMemberDeclarationSyntax> members);
            public EnumDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
            public EnumDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
            public EnumDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);

          public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax : BaseTypeDeclarationSyntax

            public int Arity { get; }
            public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
            public abstract SyntaxToken Keyword { get; }
            public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
            public abstract TypeParameterListSyntax TypeParameterList { get; }

            public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax : TypeDeclarationSyntax

              public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
              public override BaseListSyntax BaseList { get; }
              public override SyntaxToken CloseBraceToken { get; }
              public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
              public override SyntaxToken Identifier { get; }
              public override SyntaxToken Keyword { get; }
              public override SyntaxList<MemberDeclarationSyntax> Members { get; }
              public override SyntaxTokenList Modifiers { get; }
              public override SyntaxToken OpenBraceToken { get; }
              public override SyntaxToken SemicolonToken { get; }
              public override TypeParameterListSyntax TypeParameterList { get; }

              public override void Accept(CSharpSyntaxVisitor visitor);
              public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
              public ClassDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
              public ClassDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items);
              public ClassDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items);
              public ClassDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items);
              public ClassDeclarationSyntax AddModifiers(params SyntaxToken[] items);
              public ClassDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items);
              public ClassDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
              public ClassDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
              public ClassDeclarationSyntax WithBaseList(BaseListSyntax baseList);
              public ClassDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
              public ClassDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
              public ClassDeclarationSyntax WithIdentifier(SyntaxToken identifier);
              public ClassDeclarationSyntax WithKeyword(SyntaxToken keyword);
              public ClassDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members);
              public ClassDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
              public ClassDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
              public ClassDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
              public ClassDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);

            public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax : TypeDeclarationSyntax

              public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
              public override BaseListSyntax BaseList { get; }
              public override SyntaxToken CloseBraceToken { get; }
              public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
              public override SyntaxToken Identifier { get; }
              public override SyntaxToken Keyword { get; }
              public override SyntaxList<MemberDeclarationSyntax> Members { get; }
              public override SyntaxTokenList Modifiers { get; }
              public override SyntaxToken OpenBraceToken { get; }
              public override SyntaxToken SemicolonToken { get; }
              public override TypeParameterListSyntax TypeParameterList { get; }

              public override void Accept(CSharpSyntaxVisitor visitor);
              public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
              public InterfaceDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
              public InterfaceDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items);
              public InterfaceDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items);
              public InterfaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items);
              public InterfaceDeclarationSyntax AddModifiers(params SyntaxToken[] items);
              public InterfaceDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items);
              public InterfaceDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
              public InterfaceDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
              public InterfaceDeclarationSyntax WithBaseList(BaseListSyntax baseList);
              public InterfaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
              public InterfaceDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
              public InterfaceDeclarationSyntax WithIdentifier(SyntaxToken identifier);
              public InterfaceDeclarationSyntax WithKeyword(SyntaxToken keyword);
              public InterfaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members);
              public InterfaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
              public InterfaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
              public InterfaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
              public InterfaceDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);

            public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax : TypeDeclarationSyntax

              public override SyntaxList<AttributeListSyntax> AttributeLists { get; }
              public override BaseListSyntax BaseList { get; }
              public override SyntaxToken CloseBraceToken { get; }
              public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
              public override SyntaxToken Identifier { get; }
              public override SyntaxToken Keyword { get; }
              public override SyntaxList<MemberDeclarationSyntax> Members { get; }
              public override SyntaxTokenList Modifiers { get; }
              public override SyntaxToken OpenBraceToken { get; }
              public override SyntaxToken SemicolonToken { get; }
              public override TypeParameterListSyntax TypeParameterList { get; }

              public override void Accept(CSharpSyntaxVisitor visitor);
              public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
              public StructDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
              public StructDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items);
              public StructDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items);
              public StructDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items);
              public StructDeclarationSyntax AddModifiers(params SyntaxToken[] items);
              public StructDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items);
              public StructDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
              public StructDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
              public StructDeclarationSyntax WithBaseList(BaseListSyntax baseList);
              public StructDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
              public StructDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
              public StructDeclarationSyntax WithIdentifier(SyntaxToken identifier);
              public StructDeclarationSyntax WithKeyword(SyntaxToken keyword);
              public StructDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members);
              public StructDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
              public StructDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
              public StructDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
              public StructDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax : MemberDeclarationSyntax

          public int Arity { get; }
          public SyntaxList<AttributeListSyntax> AttributeLists { get; }
          public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
          public SyntaxToken DelegateKeyword { get; }
          public SyntaxToken Identifier { get; }
          public SyntaxTokenList Modifiers { get; }
          public ParameterListSyntax ParameterList { get; }
          public TypeSyntax ReturnType { get; }
          public SyntaxToken SemicolonToken { get; }
          public TypeParameterListSyntax TypeParameterList { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public DelegateDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
          public DelegateDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items);
          public DelegateDeclarationSyntax AddModifiers(params SyntaxToken[] items);
          public DelegateDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items);
          public DelegateDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items);
          public DelegateDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken);
          public DelegateDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
          public DelegateDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
          public DelegateDeclarationSyntax WithDelegateKeyword(SyntaxToken delegateKeyword);
          public DelegateDeclarationSyntax WithIdentifier(SyntaxToken identifier);
          public DelegateDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
          public DelegateDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
          public DelegateDeclarationSyntax WithReturnType(TypeSyntax returnType);
          public DelegateDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
          public DelegateDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax : MemberDeclarationSyntax

          public SyntaxList<AttributeListSyntax> AttributeLists { get; }
          public EqualsValueClauseSyntax EqualsValue { get; }
          public SyntaxToken Identifier { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public EnumMemberDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items);
          public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue);
          public EnumMemberDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
          public EnumMemberDeclarationSyntax WithEqualsValue(EqualsValueClauseSyntax equalsValue);
          public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax : MemberDeclarationSyntax

          public StatementSyntax Statement { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public GlobalStatementSyntax Update(StatementSyntax statement);
          public GlobalStatementSyntax WithStatement(StatementSyntax statement);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax : MemberDeclarationSyntax

          public SyntaxList<AttributeListSyntax> AttributeLists { get; }
          public SyntaxTokenList Modifiers { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public IncompleteMemberSyntax AddAttributeLists(params AttributeListSyntax[] items);
          public IncompleteMemberSyntax AddModifiers(params SyntaxToken[] items);
          public IncompleteMemberSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type);
          public IncompleteMemberSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
          public IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers);
          public IncompleteMemberSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax : MemberDeclarationSyntax

          public SyntaxToken CloseBraceToken { get; }
          public SyntaxList<ExternAliasDirectiveSyntax> Externs { get; }
          public SyntaxList<MemberDeclarationSyntax> Members { get; }
          public NameSyntax Name { get; }
          public SyntaxToken NamespaceKeyword { get; }
          public SyntaxToken OpenBraceToken { get; }
          public SyntaxToken SemicolonToken { get; }
          public SyntaxList<UsingDirectiveSyntax> Usings { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public NamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items);
          public NamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items);
          public NamespaceDeclarationSyntax AddUsings(params UsingDirectiveSyntax[] items);
          public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
          public NamespaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
          public NamespaceDeclarationSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs);
          public NamespaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members);
          public NamespaceDeclarationSyntax WithName(NameSyntax name);
          public NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword);
          public NamespaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
          public NamespaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
          public NamespaceDeclarationSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax : CSharpSyntaxNode

        public SyntaxToken ColonToken { get; }
        public IdentifierNameSyntax Name { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken);
        public NameColonSyntax WithColonToken(SyntaxToken colonToken);
        public NameColonSyntax WithName(IdentifierNameSyntax name);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax : CSharpSyntaxNode

        public SyntaxToken EqualsToken { get; }
        public IdentifierNameSyntax Name { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken);
        public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken);
        public NameEqualsSyntax WithName(IdentifierNameSyntax name);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax : CSharpSyntaxNode

        public SyntaxToken AscendingOrDescendingKeyword { get; }
        public ExpressionSyntax Expression { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
        public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword);
        public OrderingSyntax WithExpression(ExpressionSyntax expression);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax : CSharpSyntaxNode

        public SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public EqualsValueClauseSyntax Default { get; }
        public SyntaxToken Identifier { get; }
        public SyntaxTokenList Modifiers { get; }
        public TypeSyntax Type { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public ParameterSyntax AddAttributeLists(params AttributeListSyntax[] items);
        public ParameterSyntax AddModifiers(params SyntaxToken[] items);
        public ParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default);
        public ParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
        public ParameterSyntax WithDefault(EqualsValueClauseSyntax @default);
        public ParameterSyntax WithIdentifier(SyntaxToken identifier);
        public ParameterSyntax WithModifiers(SyntaxTokenList modifiers);
        public ParameterSyntax WithType(TypeSyntax type);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax : CSharpSyntaxNode

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax : PatternSyntax

          public ExpressionSyntax Expression { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ConstantPatternSyntax Update(ExpressionSyntax expression);
          public ConstantPatternSyntax WithExpression(ExpressionSyntax expression);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax : PatternSyntax

          public VariableDesignationSyntax Designation { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public DeclarationPatternSyntax Update(TypeSyntax type, VariableDesignationSyntax designation);
          public DeclarationPatternSyntax WithDesignation(VariableDesignationSyntax designation);
          public DeclarationPatternSyntax WithType(TypeSyntax type);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax : CSharpSyntaxNode

        public SyntaxList<QueryClauseSyntax> Clauses { get; }
        public QueryContinuationSyntax Continuation { get; }
        public SelectOrGroupClauseSyntax SelectOrGroup { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public QueryBodySyntax AddClauses(params QueryClauseSyntax[] items);
        public QueryBodySyntax Update(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation);
        public QueryBodySyntax WithClauses(SyntaxList<QueryClauseSyntax> clauses);
        public QueryBodySyntax WithContinuation(QueryContinuationSyntax continuation);
        public QueryBodySyntax WithSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax : CSharpSyntaxNode

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax : QueryClauseSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken FromKeyword { get; }
          public SyntaxToken Identifier { get; }
          public SyntaxToken InKeyword { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression);
          public FromClauseSyntax WithExpression(ExpressionSyntax expression);
          public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword);
          public FromClauseSyntax WithIdentifier(SyntaxToken identifier);
          public FromClauseSyntax WithInKeyword(SyntaxToken inKeyword);
          public FromClauseSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax : QueryClauseSyntax

          public SyntaxToken EqualsKeyword { get; }
          public SyntaxToken Identifier { get; }
          public ExpressionSyntax InExpression { get; }
          public SyntaxToken InKeyword { get; }
          public JoinIntoClauseSyntax Into { get; }
          public SyntaxToken JoinKeyword { get; }
          public ExpressionSyntax LeftExpression { get; }
          public SyntaxToken OnKeyword { get; }
          public ExpressionSyntax RightExpression { get; }
          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
          public JoinClauseSyntax WithEqualsKeyword(SyntaxToken equalsKeyword);
          public JoinClauseSyntax WithIdentifier(SyntaxToken identifier);
          public JoinClauseSyntax WithInExpression(ExpressionSyntax inExpression);
          public JoinClauseSyntax WithInKeyword(SyntaxToken inKeyword);
          public JoinClauseSyntax WithInto(JoinIntoClauseSyntax into);
          public JoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword);
          public JoinClauseSyntax WithLeftExpression(ExpressionSyntax leftExpression);
          public JoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword);
          public JoinClauseSyntax WithRightExpression(ExpressionSyntax rightExpression);
          public JoinClauseSyntax WithType(TypeSyntax type);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax : QueryClauseSyntax

          public SyntaxToken EqualsToken { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken Identifier { get; }
          public SyntaxToken LetKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression);
          public LetClauseSyntax WithEqualsToken(SyntaxToken equalsToken);
          public LetClauseSyntax WithExpression(ExpressionSyntax expression);
          public LetClauseSyntax WithIdentifier(SyntaxToken identifier);
          public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax : QueryClauseSyntax

          public SyntaxToken OrderByKeyword { get; }
          public SeparatedSyntaxList<OrderingSyntax> Orderings { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public OrderByClauseSyntax AddOrderings(params OrderingSyntax[] items);
          public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings);
          public OrderByClauseSyntax WithOrderByKeyword(SyntaxToken orderByKeyword);
          public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList<OrderingSyntax> orderings);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax : QueryClauseSyntax

          public ExpressionSyntax Condition { get; }
          public SyntaxToken WhereKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition);
          public WhereClauseSyntax WithCondition(ExpressionSyntax condition);
          public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax : CSharpSyntaxNode

        public QueryBodySyntax Body { get; }
        public SyntaxToken Identifier { get; }
        public SyntaxToken IntoKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public QueryContinuationSyntax AddBodyClauses(params QueryClauseSyntax[] items);
        public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body);
        public QueryContinuationSyntax WithBody(QueryBodySyntax body);
        public QueryContinuationSyntax WithIdentifier(SyntaxToken identifier);
        public QueryContinuationSyntax WithIntoKeyword(SyntaxToken intoKeyword);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax : CSharpSyntaxNode

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax : SelectOrGroupClauseSyntax

          public ExpressionSyntax ByExpression { get; }
          public SyntaxToken ByKeyword { get; }
          public ExpressionSyntax GroupExpression { get; }
          public SyntaxToken GroupKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression);
          public GroupClauseSyntax WithByExpression(ExpressionSyntax byExpression);
          public GroupClauseSyntax WithByKeyword(SyntaxToken byKeyword);
          public GroupClauseSyntax WithGroupExpression(ExpressionSyntax groupExpression);
          public GroupClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax : SelectOrGroupClauseSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken SelectKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression);
          public SelectClauseSyntax WithExpression(ExpressionSyntax expression);
          public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax : CSharpSyntaxNode

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax : StatementSyntax

          public SyntaxToken CloseBraceToken { get; }
          public SyntaxToken OpenBraceToken { get; }
          public SyntaxList<StatementSyntax> Statements { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public BlockSyntax AddStatements(params StatementSyntax[] items);
          public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken);
          public BlockSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
          public BlockSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
          public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax : StatementSyntax

          public SyntaxToken BreakKeyword { get; }
          public SyntaxToken SemicolonToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken);
          public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword);
          public BreakStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax : StatementSyntax

          public BlockSyntax Block { get; }
          public SyntaxToken Keyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public CheckedStatementSyntax AddBlockStatements(params StatementSyntax[] items);
          public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block);
          public CheckedStatementSyntax WithBlock(BlockSyntax block);
          public CheckedStatementSyntax WithKeyword(SyntaxToken keyword);

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax : StatementSyntax

          public abstract SyntaxToken CloseParenToken { get; }
          public abstract ExpressionSyntax Expression { get; }
          public abstract SyntaxToken ForEachKeyword { get; }
          public abstract SyntaxToken InKeyword { get; }
          public abstract SyntaxToken OpenParenToken { get; }
          public abstract StatementSyntax Statement { get; }

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax : CommonForEachStatementSyntax

            public override SyntaxToken CloseParenToken { get; }
            public override ExpressionSyntax Expression { get; }
            public override SyntaxToken ForEachKeyword { get; }
            public SyntaxToken Identifier { get; }
            public override SyntaxToken InKeyword { get; }
            public override SyntaxToken OpenParenToken { get; }
            public override StatementSyntax Statement { get; }
            public TypeSyntax Type { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
            public ForEachStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
            public ForEachStatementSyntax WithExpression(ExpressionSyntax expression);
            public ForEachStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword);
            public ForEachStatementSyntax WithIdentifier(SyntaxToken identifier);
            public ForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword);
            public ForEachStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
            public ForEachStatementSyntax WithStatement(StatementSyntax statement);
            public ForEachStatementSyntax WithType(TypeSyntax type);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax : CommonForEachStatementSyntax

            public override SyntaxToken CloseParenToken { get; }
            public override ExpressionSyntax Expression { get; }
            public override SyntaxToken ForEachKeyword { get; }
            public override SyntaxToken InKeyword { get; }
            public override SyntaxToken OpenParenToken { get; }
            public override StatementSyntax Statement { get; }
            public ExpressionSyntax Variable { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ForEachVariableStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
            public ForEachVariableStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
            public ForEachVariableStatementSyntax WithExpression(ExpressionSyntax expression);
            public ForEachVariableStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword);
            public ForEachVariableStatementSyntax WithInKeyword(SyntaxToken inKeyword);
            public ForEachVariableStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
            public ForEachVariableStatementSyntax WithStatement(StatementSyntax statement);
            public ForEachVariableStatementSyntax WithVariable(ExpressionSyntax variable);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax : StatementSyntax

          public SyntaxToken ContinueKeyword { get; }
          public SyntaxToken SemicolonToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken);
          public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword);
          public ContinueStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax : StatementSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Condition { get; }
          public SyntaxToken DoKeyword { get; }
          public SyntaxToken OpenParenToken { get; }
          public SyntaxToken SemicolonToken { get; }
          public StatementSyntax Statement { get; }
          public SyntaxToken WhileKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken);
          public DoStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public DoStatementSyntax WithCondition(ExpressionSyntax condition);
          public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword);
          public DoStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public DoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
          public DoStatementSyntax WithStatement(StatementSyntax statement);
          public DoStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax : StatementSyntax

          public SyntaxToken SemicolonToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public EmptyStatementSyntax Update(SyntaxToken semicolonToken);
          public EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax : StatementSyntax

          public bool AllowsAnyExpression { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken SemicolonToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken);
          public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression);
          public ExpressionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax : StatementSyntax

          public SyntaxToken CloseParenToken { get; }
          public VariableDeclarationSyntax Declaration { get; }
          public SyntaxToken FixedKeyword { get; }
          public SyntaxToken OpenParenToken { get; }
          public StatementSyntax Statement { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public FixedStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items);
          public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement);
          public FixedStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public FixedStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration);
          public FixedStatementSyntax WithFixedKeyword(SyntaxToken fixedKeyword);
          public FixedStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public FixedStatementSyntax WithStatement(StatementSyntax statement);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax : StatementSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Condition { get; }
          public VariableDeclarationSyntax Declaration { get; }
          public SyntaxToken FirstSemicolonToken { get; }
          public SyntaxToken ForKeyword { get; }
          public SeparatedSyntaxList<ExpressionSyntax> Incrementors { get; }
          public SeparatedSyntaxList<ExpressionSyntax> Initializers { get; }
          public SyntaxToken OpenParenToken { get; }
          public SyntaxToken SecondSemicolonToken { get; }
          public StatementSyntax Statement { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ForStatementSyntax AddIncrementors(params ExpressionSyntax[] items);
          public ForStatementSyntax AddInitializers(params ExpressionSyntax[] items);
          public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement);
          public ForStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public ForStatementSyntax WithCondition(ExpressionSyntax condition);
          public ForStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration);
          public ForStatementSyntax WithFirstSemicolonToken(SyntaxToken firstSemicolonToken);
          public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword);
          public ForStatementSyntax WithIncrementors(SeparatedSyntaxList<ExpressionSyntax> incrementors);
          public ForStatementSyntax WithInitializers(SeparatedSyntaxList<ExpressionSyntax> initializers);
          public ForStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public ForStatementSyntax WithSecondSemicolonToken(SyntaxToken secondSemicolonToken);
          public ForStatementSyntax WithStatement(StatementSyntax statement);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax : StatementSyntax

          public SyntaxToken CaseOrDefaultKeyword { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken GotoKeyword { get; }
          public SyntaxToken SemicolonToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
          public GotoStatementSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword);
          public GotoStatementSyntax WithExpression(ExpressionSyntax expression);
          public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword);
          public GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax : StatementSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Condition { get; }
          public ElseClauseSyntax Else { get; }
          public SyntaxToken IfKeyword { get; }
          public SyntaxToken OpenParenToken { get; }
          public StatementSyntax Statement { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else);
          public IfStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public IfStatementSyntax WithCondition(ExpressionSyntax condition);
          public IfStatementSyntax WithElse(ElseClauseSyntax @else);
          public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword);
          public IfStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public IfStatementSyntax WithStatement(StatementSyntax statement);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax : StatementSyntax

          public SyntaxToken ColonToken { get; }
          public SyntaxToken Identifier { get; }
          public StatementSyntax Statement { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement);
          public LabeledStatementSyntax WithColonToken(SyntaxToken colonToken);
          public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier);
          public LabeledStatementSyntax WithStatement(StatementSyntax statement);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax : StatementSyntax

          public VariableDeclarationSyntax Declaration { get; }
          public bool IsConst { get; }
          public SyntaxTokenList Modifiers { get; }
          public SyntaxToken SemicolonToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public LocalDeclarationStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items);
          public LocalDeclarationStatementSyntax AddModifiers(params SyntaxToken[] items);
          public LocalDeclarationStatementSyntax Update(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
          public LocalDeclarationStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration);
          public LocalDeclarationStatementSyntax WithModifiers(SyntaxTokenList modifiers);
          public LocalDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax : StatementSyntax

          public BlockSyntax Body { get; }
          public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
          public ArrowExpressionClauseSyntax ExpressionBody { get; }
          public SyntaxToken Identifier { get; }
          public SyntaxTokenList Modifiers { get; }
          public ParameterListSyntax ParameterList { get; }
          public TypeSyntax ReturnType { get; }
          public SyntaxToken SemicolonToken { get; }
          public TypeParameterListSyntax TypeParameterList { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public LocalFunctionStatementSyntax AddBodyStatements(params StatementSyntax[] items);
          public LocalFunctionStatementSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items);
          public LocalFunctionStatementSyntax AddModifiers(params SyntaxToken[] items);
          public LocalFunctionStatementSyntax AddParameterListParameters(params ParameterSyntax[] items);
          public LocalFunctionStatementSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items);
          public LocalFunctionStatementSyntax Update(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
          public LocalFunctionStatementSyntax WithBody(BlockSyntax body);
          public LocalFunctionStatementSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
          public LocalFunctionStatementSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
          public LocalFunctionStatementSyntax WithIdentifier(SyntaxToken identifier);
          public LocalFunctionStatementSyntax WithModifiers(SyntaxTokenList modifiers);
          public LocalFunctionStatementSyntax WithParameterList(ParameterListSyntax parameterList);
          public LocalFunctionStatementSyntax WithReturnType(TypeSyntax returnType);
          public LocalFunctionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
          public LocalFunctionStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax : StatementSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken LockKeyword { get; }
          public SyntaxToken OpenParenToken { get; }
          public StatementSyntax Statement { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
          public LockStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public LockStatementSyntax WithExpression(ExpressionSyntax expression);
          public LockStatementSyntax WithLockKeyword(SyntaxToken lockKeyword);
          public LockStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public LockStatementSyntax WithStatement(StatementSyntax statement);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax : StatementSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken ReturnKeyword { get; }
          public SyntaxToken SemicolonToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
          public ReturnStatementSyntax WithExpression(ExpressionSyntax expression);
          public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword);
          public ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax : StatementSyntax

          public SyntaxToken CloseBraceToken { get; }
          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken OpenBraceToken { get; }
          public SyntaxToken OpenParenToken { get; }
          public SyntaxList<SwitchSectionSyntax> Sections { get; }
          public SyntaxToken SwitchKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public SwitchStatementSyntax AddSections(params SwitchSectionSyntax[] items);
          public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken);
          public SwitchStatementSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
          public SwitchStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public SwitchStatementSyntax WithExpression(ExpressionSyntax expression);
          public SwitchStatementSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
          public SwitchStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public SwitchStatementSyntax WithSections(SyntaxList<SwitchSectionSyntax> sections);
          public SwitchStatementSyntax WithSwitchKeyword(SyntaxToken switchKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax : StatementSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken SemicolonToken { get; }
          public SyntaxToken ThrowKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
          public ThrowStatementSyntax WithExpression(ExpressionSyntax expression);
          public ThrowStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
          public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax : StatementSyntax

          public BlockSyntax Block { get; }
          public SyntaxList<CatchClauseSyntax> Catches { get; }
          public FinallyClauseSyntax Finally { get; }
          public SyntaxToken TryKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public TryStatementSyntax AddBlockStatements(params StatementSyntax[] items);
          public TryStatementSyntax AddCatches(params CatchClauseSyntax[] items);
          public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally);
          public TryStatementSyntax WithBlock(BlockSyntax block);
          public TryStatementSyntax WithCatches(SyntaxList<CatchClauseSyntax> catches);
          public TryStatementSyntax WithFinally(FinallyClauseSyntax @finally);
          public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax : StatementSyntax

          public BlockSyntax Block { get; }
          public SyntaxToken UnsafeKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public UnsafeStatementSyntax AddBlockStatements(params StatementSyntax[] items);
          public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block);
          public UnsafeStatementSyntax WithBlock(BlockSyntax block);
          public UnsafeStatementSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax : StatementSyntax

          public SyntaxToken CloseParenToken { get; }
          public VariableDeclarationSyntax Declaration { get; }
          public ExpressionSyntax Expression { get; }
          public SyntaxToken OpenParenToken { get; }
          public StatementSyntax Statement { get; }
          public SyntaxToken UsingKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
          public UsingStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public UsingStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration);
          public UsingStatementSyntax WithExpression(ExpressionSyntax expression);
          public UsingStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public UsingStatementSyntax WithStatement(StatementSyntax statement);
          public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax : StatementSyntax

          public SyntaxToken CloseParenToken { get; }
          public ExpressionSyntax Condition { get; }
          public SyntaxToken OpenParenToken { get; }
          public StatementSyntax Statement { get; }
          public SyntaxToken WhileKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement);
          public WhileStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public WhileStatementSyntax WithCondition(ExpressionSyntax condition);
          public WhileStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public WhileStatementSyntax WithStatement(StatementSyntax statement);
          public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax : StatementSyntax

          public ExpressionSyntax Expression { get; }
          public SyntaxToken ReturnOrBreakKeyword { get; }
          public SyntaxToken SemicolonToken { get; }
          public SyntaxToken YieldKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
          public YieldStatementSyntax WithExpression(ExpressionSyntax expression);
          public YieldStatementSyntax WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword);
          public YieldStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
          public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax : CSharpSyntaxNode, IStructuredTriviaSyntax

        public override SyntaxTrivia ParentTrivia { get; }

        public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax : StructuredTriviaSyntax

          public SyntaxToken DirectiveNameToken { get; }
          public abstract SyntaxToken EndOfDirectiveToken { get; }
          public abstract SyntaxToken HashToken { get; }
          public abstract bool IsActive { get; }

          public DirectiveTriviaSyntax GetNextDirective(Func<DirectiveTriviaSyntax, bool> predicate = null);
          public DirectiveTriviaSyntax GetPreviousDirective(Func<DirectiveTriviaSyntax, bool> predicate = null);
          public List<DirectiveTriviaSyntax> GetRelatedDirectives();

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public override SyntaxToken HashToken { get; }
            public SyntaxToken Identifier { get; }
            public override bool IsActive { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive);
            public BadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public BadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public BadDirectiveTriviaSyntax WithIdentifier(SyntaxToken identifier);
            public BadDirectiveTriviaSyntax WithIsActive(bool isActive);

          public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public abstract bool BranchTaken { get; }

            public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax

              public abstract ExpressionSyntax Condition { get; }
              public abstract bool ConditionValue { get; }

              public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax

                public override bool BranchTaken { get; }
                public override ExpressionSyntax Condition { get; }
                public override bool ConditionValue { get; }
                public SyntaxToken ElifKeyword { get; }
                public override SyntaxToken EndOfDirectiveToken { get; }
                public override SyntaxToken HashToken { get; }
                public override bool IsActive { get; }

                public override void Accept(CSharpSyntaxVisitor visitor);
                public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
                public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
                public ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken);
                public ElifDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition);
                public ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue);
                public ElifDirectiveTriviaSyntax WithElifKeyword(SyntaxToken elifKeyword);
                public ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
                public ElifDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
                public ElifDirectiveTriviaSyntax WithIsActive(bool isActive);

              public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax

                public override bool BranchTaken { get; }
                public override ExpressionSyntax Condition { get; }
                public override bool ConditionValue { get; }
                public override SyntaxToken EndOfDirectiveToken { get; }
                public override SyntaxToken HashToken { get; }
                public SyntaxToken IfKeyword { get; }
                public override bool IsActive { get; }

                public override void Accept(CSharpSyntaxVisitor visitor);
                public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
                public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
                public IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken);
                public IfDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition);
                public IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue);
                public IfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
                public IfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
                public IfDirectiveTriviaSyntax WithIfKeyword(SyntaxToken ifKeyword);
                public IfDirectiveTriviaSyntax WithIsActive(bool isActive);

            public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax

              public override bool BranchTaken { get; }
              public SyntaxToken ElseKeyword { get; }
              public override SyntaxToken EndOfDirectiveToken { get; }
              public override SyntaxToken HashToken { get; }
              public override bool IsActive { get; }

              public override void Accept(CSharpSyntaxVisitor visitor);
              public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
              public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken);
              public ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken);
              public ElseDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword);
              public ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
              public ElseDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
              public ElseDirectiveTriviaSyntax WithIsActive(bool isActive);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public SyntaxToken DefineKeyword { get; }
            public override SyntaxToken EndOfDirectiveToken { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken Name { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
            public DefineDirectiveTriviaSyntax WithDefineKeyword(SyntaxToken defineKeyword);
            public DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public DefineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public DefineDirectiveTriviaSyntax WithIsActive(bool isActive);
            public DefineDirectiveTriviaSyntax WithName(SyntaxToken name);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public SyntaxToken EndIfKeyword { get; }
            public override SyntaxToken EndOfDirectiveToken { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
            public EndIfDirectiveTriviaSyntax WithEndIfKeyword(SyntaxToken endIfKeyword);
            public EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public EndIfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public EndIfDirectiveTriviaSyntax WithIsActive(bool isActive);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public SyntaxToken EndRegionKeyword { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
            public EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(SyntaxToken endRegionKeyword);
            public EndRegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public SyntaxToken ErrorKeyword { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
            public ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public ErrorDirectiveTriviaSyntax WithErrorKeyword(SyntaxToken errorKeyword);
            public ErrorDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public ErrorDirectiveTriviaSyntax WithIsActive(bool isActive);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public SyntaxToken File { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken Line { get; }
            public SyntaxToken LineKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
            public LineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public LineDirectiveTriviaSyntax WithFile(SyntaxToken file);
            public LineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public LineDirectiveTriviaSyntax WithIsActive(bool isActive);
            public LineDirectiveTriviaSyntax WithLine(SyntaxToken line);
            public LineDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public SyntaxToken File { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken LoadKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
            public LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public LoadDirectiveTriviaSyntax WithFile(SyntaxToken file);
            public LoadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public LoadDirectiveTriviaSyntax WithIsActive(bool isActive);
            public LoadDirectiveTriviaSyntax WithLoadKeyword(SyntaxToken loadKeyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public SyntaxToken Bytes { get; }
            public SyntaxToken ChecksumKeyword { get; }
            public override SyntaxToken EndOfDirectiveToken { get; }
            public SyntaxToken File { get; }
            public SyntaxToken Guid { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken PragmaKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive);
            public PragmaChecksumDirectiveTriviaSyntax WithBytes(SyntaxToken bytes);
            public PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(SyntaxToken checksumKeyword);
            public PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public PragmaChecksumDirectiveTriviaSyntax WithFile(SyntaxToken file);
            public PragmaChecksumDirectiveTriviaSyntax WithGuid(SyntaxToken guid);
            public PragmaChecksumDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive);
            public PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public SyntaxToken DisableOrRestoreKeyword { get; }
            public override SyntaxToken EndOfDirectiveToken { get; }
            public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken PragmaKeyword { get; }
            public SyntaxToken WarningKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public PragmaWarningDirectiveTriviaSyntax AddErrorCodes(params ExpressionSyntax[] items);
            public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive);
            public PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(SyntaxToken disableOrRestoreKeyword);
            public PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public PragmaWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList<ExpressionSyntax> errorCodes);
            public PragmaWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive);
            public PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword);
            public PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public SyntaxToken File { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken ReferenceKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
            public ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public ReferenceDirectiveTriviaSyntax WithFile(SyntaxToken file);
            public ReferenceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive);
            public ReferenceDirectiveTriviaSyntax WithReferenceKeyword(SyntaxToken referenceKeyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken RegionKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
            public RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public RegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public RegionDirectiveTriviaSyntax WithIsActive(bool isActive);
            public RegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public SyntaxToken ExclamationToken { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive);
            public ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public ShebangDirectiveTriviaSyntax WithExclamationToken(SyntaxToken exclamationToken);
            public ShebangDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public ShebangDirectiveTriviaSyntax WithIsActive(bool isActive);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken Name { get; }
            public SyntaxToken UndefKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
            public UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public UndefDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public UndefDirectiveTriviaSyntax WithIsActive(bool isActive);
            public UndefDirectiveTriviaSyntax WithName(SyntaxToken name);
            public UndefDirectiveTriviaSyntax WithUndefKeyword(SyntaxToken undefKeyword);

          public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax

            public override SyntaxToken EndOfDirectiveToken { get; }
            public override SyntaxToken HashToken { get; }
            public override bool IsActive { get; }
            public SyntaxToken WarningKeyword { get; }

            public override void Accept(CSharpSyntaxVisitor visitor);
            public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
            public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
            public WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
            public WarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
            public WarningDirectiveTriviaSyntax WithIsActive(bool isActive);
            public WarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax : StructuredTriviaSyntax

          public SyntaxList<XmlNodeSyntax> Content { get; }
          public SyntaxToken EndOfComment { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public DocumentationCommentTriviaSyntax AddContent(params XmlNodeSyntax[] items);
          public DocumentationCommentTriviaSyntax Update(SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment);
          public DocumentationCommentTriviaSyntax WithContent(SyntaxList<XmlNodeSyntax> content);
          public DocumentationCommentTriviaSyntax WithEndOfComment(SyntaxToken endOfComment);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax : StructuredTriviaSyntax, ISkippedTokensTriviaSyntax

          public SyntaxTokenList Tokens { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items);
          public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens);
          public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax : CSharpSyntaxNode

        public abstract SyntaxToken ColonToken { get; }
        public abstract SyntaxToken Keyword { get; }

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax : SwitchLabelSyntax

          public override SyntaxToken ColonToken { get; }
          public override SyntaxToken Keyword { get; }
          public PatternSyntax Pattern { get; }
          public WhenClauseSyntax WhenClause { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken);
          public CasePatternSwitchLabelSyntax WithColonToken(SyntaxToken colonToken);
          public CasePatternSwitchLabelSyntax WithKeyword(SyntaxToken keyword);
          public CasePatternSwitchLabelSyntax WithPattern(PatternSyntax pattern);
          public CasePatternSwitchLabelSyntax WithWhenClause(WhenClauseSyntax whenClause);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax : SwitchLabelSyntax

          public override SyntaxToken ColonToken { get; }
          public override SyntaxToken Keyword { get; }
          public ExpressionSyntax Value { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken);
          public CaseSwitchLabelSyntax WithColonToken(SyntaxToken colonToken);
          public CaseSwitchLabelSyntax WithKeyword(SyntaxToken keyword);
          public CaseSwitchLabelSyntax WithValue(ExpressionSyntax value);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax : SwitchLabelSyntax

          public override SyntaxToken ColonToken { get; }
          public override SyntaxToken Keyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken);
          public DefaultSwitchLabelSyntax WithColonToken(SyntaxToken colonToken);
          public DefaultSwitchLabelSyntax WithKeyword(SyntaxToken keyword);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax : CSharpSyntaxNode

        public SyntaxList<SwitchLabelSyntax> Labels { get; }
        public SyntaxList<StatementSyntax> Statements { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public SwitchSectionSyntax AddLabels(params SwitchLabelSyntax[] items);
        public SwitchSectionSyntax AddStatements(params StatementSyntax[] items);
        public SwitchSectionSyntax Update(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements);
        public SwitchSectionSyntax WithLabels(SyntaxList<SwitchLabelSyntax> labels);
        public SwitchSectionSyntax WithStatements(SyntaxList<StatementSyntax> statements);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax : CSharpSyntaxNode

        public SyntaxToken Identifier { get; }
        public TypeSyntax Type { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public TupleElementSyntax Update(TypeSyntax type, SyntaxToken identifier);
        public TupleElementSyntax WithIdentifier(SyntaxToken identifier);
        public TupleElementSyntax WithType(TypeSyntax type);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax : CSharpSyntaxNode

        public SeparatedSyntaxList<TypeSyntax> Arguments { get; }
        public SyntaxToken GreaterThanToken { get; }
        public SyntaxToken LessThanToken { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public TypeArgumentListSyntax AddArguments(params TypeSyntax[] items);
        public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken);
        public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList<TypeSyntax> arguments);
        public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
        public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax : CSharpSyntaxNode

        public SyntaxToken ColonToken { get; }
        public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints { get; }
        public IdentifierNameSyntax Name { get; }
        public SyntaxToken WhereKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public TypeParameterConstraintClauseSyntax AddConstraints(params TypeParameterConstraintSyntax[] items);
        public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints);
        public TypeParameterConstraintClauseSyntax WithColonToken(SyntaxToken colonToken);
        public TypeParameterConstraintClauseSyntax WithConstraints(SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints);
        public TypeParameterConstraintClauseSyntax WithName(IdentifierNameSyntax name);
        public TypeParameterConstraintClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax : CSharpSyntaxNode

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax

          public SyntaxToken ClassOrStructKeyword { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword);
          public ClassOrStructConstraintSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax : TypeParameterConstraintSyntax

          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken NewKeyword { get; }
          public SyntaxToken OpenParenToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken);
          public ConstructorConstraintSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public ConstructorConstraintSyntax WithNewKeyword(SyntaxToken newKeyword);
          public ConstructorConstraintSyntax WithOpenParenToken(SyntaxToken openParenToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax : TypeParameterConstraintSyntax

          public TypeSyntax Type { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public TypeConstraintSyntax Update(TypeSyntax type);
          public TypeConstraintSyntax WithType(TypeSyntax type);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax : CSharpSyntaxNode

        public SyntaxToken GreaterThanToken { get; }
        public SyntaxToken LessThanToken { get; }
        public SeparatedSyntaxList<TypeParameterSyntax> Parameters { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public TypeParameterListSyntax AddParameters(params TypeParameterSyntax[] items);
        public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken);
        public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
        public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken);
        public TypeParameterListSyntax WithParameters(SeparatedSyntaxList<TypeParameterSyntax> parameters);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax : CSharpSyntaxNode

        public SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public SyntaxToken Identifier { get; }
        public SyntaxToken VarianceKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public TypeParameterSyntax AddAttributeLists(params AttributeListSyntax[] items);
        public TypeParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier);
        public TypeParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists);
        public TypeParameterSyntax WithIdentifier(SyntaxToken identifier);
        public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax : CSharpSyntaxNode

        public NameEqualsSyntax Alias { get; }
        public NameSyntax Name { get; }
        public SyntaxToken SemicolonToken { get; }
        public SyntaxToken StaticKeyword { get; }
        public SyntaxToken UsingKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken);
        public UsingDirectiveSyntax WithAlias(NameEqualsSyntax alias);
        public UsingDirectiveSyntax WithName(NameSyntax name);
        public UsingDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken);
        public UsingDirectiveSyntax WithStaticKeyword(SyntaxToken staticKeyword);
        public UsingDirectiveSyntax WithUsingKeyword(SyntaxToken usingKeyword);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax : CSharpSyntaxNode

        public TypeSyntax Type { get; }
        public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public VariableDeclarationSyntax AddVariables(params VariableDeclaratorSyntax[] items);
        public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables);
        public VariableDeclarationSyntax WithType(TypeSyntax type);
        public VariableDeclarationSyntax WithVariables(SeparatedSyntaxList<VariableDeclaratorSyntax> variables);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax : CSharpSyntaxNode

        public BracketedArgumentListSyntax ArgumentList { get; }
        public SyntaxToken Identifier { get; }
        public EqualsValueClauseSyntax Initializer { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public VariableDeclaratorSyntax AddArgumentListArguments(params ArgumentSyntax[] items);
        public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer);
        public VariableDeclaratorSyntax WithArgumentList(BracketedArgumentListSyntax argumentList);
        public VariableDeclaratorSyntax WithIdentifier(SyntaxToken identifier);
        public VariableDeclaratorSyntax WithInitializer(EqualsValueClauseSyntax initializer);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax : CSharpSyntaxNode

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax : VariableDesignationSyntax

          public SyntaxToken UnderscoreToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public DiscardDesignationSyntax Update(SyntaxToken underscoreToken);
          public DiscardDesignationSyntax WithUnderscoreToken(SyntaxToken underscoreToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax

          public SyntaxToken CloseParenToken { get; }
          public SyntaxToken OpenParenToken { get; }
          public SeparatedSyntaxList<VariableDesignationSyntax> Variables { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public ParenthesizedVariableDesignationSyntax AddVariables(params VariableDesignationSyntax[] items);
          public ParenthesizedVariableDesignationSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken);
          public ParenthesizedVariableDesignationSyntax WithCloseParenToken(SyntaxToken closeParenToken);
          public ParenthesizedVariableDesignationSyntax WithOpenParenToken(SyntaxToken openParenToken);
          public ParenthesizedVariableDesignationSyntax WithVariables(SeparatedSyntaxList<VariableDesignationSyntax> variables);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax : VariableDesignationSyntax

          public SyntaxToken Identifier { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public SingleVariableDesignationSyntax Update(SyntaxToken identifier);
          public SingleVariableDesignationSyntax WithIdentifier(SyntaxToken identifier);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax : CSharpSyntaxNode

        public ExpressionSyntax Condition { get; }
        public SyntaxToken WhenKeyword { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition);
        public WhenClauseSyntax WithCondition(ExpressionSyntax condition);
        public WhenClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax : CSharpSyntaxNode

        public abstract SyntaxToken EndQuoteToken { get; }
        public abstract SyntaxToken EqualsToken { get; }
        public abstract XmlNameSyntax Name { get; }
        public abstract SyntaxToken StartQuoteToken { get; }

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax : XmlAttributeSyntax

          public CrefSyntax Cref { get; }
          public override SyntaxToken EndQuoteToken { get; }
          public override SyntaxToken EqualsToken { get; }
          public override XmlNameSyntax Name { get; }
          public override SyntaxToken StartQuoteToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
          public XmlCrefAttributeSyntax WithCref(CrefSyntax cref);
          public XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
          public XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
          public XmlCrefAttributeSyntax WithName(XmlNameSyntax name);
          public XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax : XmlAttributeSyntax

          public override SyntaxToken EndQuoteToken { get; }
          public override SyntaxToken EqualsToken { get; }
          public IdentifierNameSyntax Identifier { get; }
          public override XmlNameSyntax Name { get; }
          public override SyntaxToken StartQuoteToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
          public XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
          public XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
          public XmlNameAttributeSyntax WithIdentifier(IdentifierNameSyntax identifier);
          public XmlNameAttributeSyntax WithName(XmlNameSyntax name);
          public XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax : XmlAttributeSyntax

          public override SyntaxToken EndQuoteToken { get; }
          public override SyntaxToken EqualsToken { get; }
          public override XmlNameSyntax Name { get; }
          public override SyntaxToken StartQuoteToken { get; }
          public SyntaxTokenList TextTokens { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlTextAttributeSyntax AddTextTokens(params SyntaxToken[] items);
          public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken);
          public XmlTextAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
          public XmlTextAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
          public XmlTextAttributeSyntax WithName(XmlNameSyntax name);
          public XmlTextAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);
          public XmlTextAttributeSyntax WithTextTokens(SyntaxTokenList textTokens);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax : CSharpSyntaxNode

        public SyntaxToken GreaterThanToken { get; }
        public SyntaxToken LessThanSlashToken { get; }
        public XmlNameSyntax Name { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
        public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
        public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken);
        public XmlElementEndTagSyntax WithName(XmlNameSyntax name);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax : CSharpSyntaxNode

        public SyntaxList<XmlAttributeSyntax> Attributes { get; }
        public SyntaxToken GreaterThanToken { get; }
        public SyntaxToken LessThanToken { get; }
        public XmlNameSyntax Name { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public XmlElementStartTagSyntax AddAttributes(params XmlAttributeSyntax[] items);
        public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken);
        public XmlElementStartTagSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes);
        public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
        public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken);
        public XmlElementStartTagSyntax WithName(XmlNameSyntax name);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax : CSharpSyntaxNode

        public SyntaxToken LocalName { get; }
        public XmlPrefixSyntax Prefix { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName);
        public XmlNameSyntax WithLocalName(SyntaxToken localName);
        public XmlNameSyntax WithPrefix(XmlPrefixSyntax prefix);

      public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax : CSharpSyntaxNode

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax : XmlNodeSyntax

          public SyntaxToken EndCDataToken { get; }
          public SyntaxToken StartCDataToken { get; }
          public SyntaxTokenList TextTokens { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlCDataSectionSyntax AddTextTokens(params SyntaxToken[] items);
          public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken);
          public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken);
          public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken);
          public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax : XmlNodeSyntax

          public SyntaxToken LessThanExclamationMinusMinusToken { get; }
          public SyntaxToken MinusMinusGreaterThanToken { get; }
          public SyntaxTokenList TextTokens { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlCommentSyntax AddTextTokens(params SyntaxToken[] items);
          public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken);
          public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken);
          public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken);
          public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax : XmlNodeSyntax

          public SyntaxList<XmlNodeSyntax> Content { get; }
          public XmlElementEndTagSyntax EndTag { get; }
          public XmlElementStartTagSyntax StartTag { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlElementSyntax AddContent(params XmlNodeSyntax[] items);
          public XmlElementSyntax AddStartTagAttributes(params XmlAttributeSyntax[] items);
          public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
          public XmlElementSyntax WithContent(SyntaxList<XmlNodeSyntax> content);
          public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag);
          public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax : XmlNodeSyntax

          public SyntaxList<XmlAttributeSyntax> Attributes { get; }
          public SyntaxToken LessThanToken { get; }
          public XmlNameSyntax Name { get; }
          public SyntaxToken SlashGreaterThanToken { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlEmptyElementSyntax AddAttributes(params XmlAttributeSyntax[] items);
          public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken);
          public XmlEmptyElementSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes);
          public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken);
          public XmlEmptyElementSyntax WithName(XmlNameSyntax name);
          public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax : XmlNodeSyntax

          public SyntaxToken EndProcessingInstructionToken { get; }
          public XmlNameSyntax Name { get; }
          public SyntaxToken StartProcessingInstructionToken { get; }
          public SyntaxTokenList TextTokens { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlProcessingInstructionSyntax AddTextTokens(params SyntaxToken[] items);
          public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken);
          public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken);
          public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name);
          public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken);
          public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens);

        public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax : XmlNodeSyntax

          public SyntaxTokenList TextTokens { get; }

          public override void Accept(CSharpSyntaxVisitor visitor);
          public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
          public XmlTextSyntax AddTextTokens(params SyntaxToken[] items);
          public XmlTextSyntax Update(SyntaxTokenList textTokens);
          public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens);

      public sealed class Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax : CSharpSyntaxNode

        public SyntaxToken ColonToken { get; }
        public SyntaxToken Prefix { get; }

        public override void Accept(CSharpSyntaxVisitor visitor);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken);
        public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken);
        public XmlPrefixSyntax WithPrefix(SyntaxToken prefix);

  public abstract class Microsoft.CodeAnalysis.SyntaxReference

    protected SyntaxReference();

    public abstract TextSpan Span { get; }
    public abstract SyntaxTree SyntaxTree { get; }

    public abstract SyntaxNode GetSyntax(CancellationToken cancellationToken = default);
    public virtual Task<SyntaxNode> GetSyntaxAsync(CancellationToken cancellationToken = default);

  public abstract class Microsoft.CodeAnalysis.SyntaxTree

    protected SyntaxTree();

    public abstract Encoding Encoding { get; }
    public abstract string FilePath { get; }
    public abstract bool HasCompilationUnitRoot { get; }
    public abstract int Length { get; }
    public ParseOptions Options { get; }
    protected abstract ParseOptions OptionsCore { get; }

    public abstract IList<TextSpan> GetChangedSpans(SyntaxTree syntaxTree);
    public abstract IList<TextChange> GetChanges(SyntaxTree oldTree);
    public abstract IEnumerable<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default);
    public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxNode node);
    public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken);
    public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxToken token);
    public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxTrivia trivia);
    public abstract FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default);
    public virtual LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken = default);
    public abstract Location GetLocation(TextSpan span);
    public abstract FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken = default);
    public abstract SyntaxReference GetReference(SyntaxNode node);
    public SyntaxNode GetRoot(CancellationToken cancellationToken = default);
    public Task<SyntaxNode> GetRootAsync(CancellationToken cancellationToken = default);
    protected abstract Task<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken);
    protected abstract SyntaxNode GetRootCore(CancellationToken cancellationToken);
    public abstract SourceText GetText(CancellationToken cancellationToken = default);
    public virtual Task<SourceText> GetTextAsync(CancellationToken cancellationToken = default);
    public abstract bool HasHiddenRegions();
    public abstract bool IsEquivalentTo(SyntaxTree tree, bool topLevel = false);
    public override string ToString();
    public bool TryGetRoot(out SyntaxNode root);
    protected abstract bool TryGetRootCore(out SyntaxNode root);
    public abstract bool TryGetText(out SourceText text);
    public abstract SyntaxTree WithChangedText(SourceText newText);
    public abstract SyntaxTree WithFilePath(string path);
    public abstract SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options);

    public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree : SyntaxTree

      protected CSharpSyntaxTree();

      public abstract CSharpParseOptions Options { get; }
      protected override ParseOptions OptionsCore { get; }

      protected T CloneNodeAsRoot<T>(T node) where T : CSharpSyntaxNode;
      public static SyntaxTree Create(CSharpSyntaxNode root, CSharpParseOptions options = null, string path = "", Encoding encoding = null);
      public override IList<TextSpan> GetChangedSpans(SyntaxTree oldTree);
      public override IList<TextChange> GetChanges(SyntaxTree oldTree);
      public CompilationUnitSyntax GetCompilationUnitRoot(CancellationToken cancellationToken = default);
      public override IEnumerable<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default);
      public override IEnumerable<Diagnostic> GetDiagnostics(SyntaxNode node);
      public override IEnumerable<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken);
      public override IEnumerable<Diagnostic> GetDiagnostics(SyntaxToken token);
      public override IEnumerable<Diagnostic> GetDiagnostics(SyntaxTrivia trivia);
      public override FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default);
      public override LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken = default);
      public override Location GetLocation(TextSpan span);
      public override FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken = default);
      public abstract CSharpSyntaxNode GetRoot(CancellationToken cancellationToken = default);
      public virtual Task<CSharpSyntaxNode> GetRootAsync(CancellationToken cancellationToken = default);
      protected override Task<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken);
      protected override SyntaxNode GetRootCore(CancellationToken cancellationToken);
      public override bool HasHiddenRegions();
      public override bool IsEquivalentTo(SyntaxTree tree, bool topLevel = false);
      public static SyntaxTree ParseText(SourceText text, CSharpParseOptions options = null, string path = "", CancellationToken cancellationToken = default);
      public static SyntaxTree ParseText(string text, CSharpParseOptions options = null, string path = "", Encoding encoding = null, CancellationToken cancellationToken = default);
      public abstract bool TryGetRoot(out CSharpSyntaxNode root);
      protected override bool TryGetRootCore(out SyntaxNode root);
      public override SyntaxTree WithChangedText(SourceText newText);

  public abstract class Microsoft.CodeAnalysis.SyntaxWalker

    protected SyntaxWalker(SyntaxWalkerDepth depth = Node);

    protected SyntaxWalkerDepth Depth { get; }

    public virtual void Visit(SyntaxNode node);
    protected virtual void VisitToken(SyntaxToken token);
    protected virtual void VisitTrivia(SyntaxTrivia trivia);

  public sealed class Microsoft.CodeAnalysis.TextAndVersion

    public string FilePath { get; }
    public SourceText Text { get; }
    public VersionStamp Version { get; }

    public static TextAndVersion Create(SourceText text, VersionStamp version, string filePath = null);

  public class Microsoft.CodeAnalysis.TextDocument

    protected TextDocument();

    public string FilePath { get; }
    public IReadOnlyList<string> Folders { get; }
    public DocumentId Id { get; }
    public string Name { get; }
    public Project Project { get; protected set; }

    public Task<SourceText> GetTextAsync(CancellationToken cancellationToken = default);
    public Task<VersionStamp> GetTextVersionAsync(CancellationToken cancellationToken = default);
    public bool TryGetText(out SourceText text);
    public bool TryGetTextVersion(out VersionStamp version);

    public class Microsoft.CodeAnalysis.Document : TextDocument

      public SourceCodeKind SourceCodeKind { get; }
      public bool SupportsSemanticModel { get; }
      public bool SupportsSyntaxTree { get; }

      public ImmutableArray<DocumentId> GetLinkedDocumentIds();
      public Task<DocumentOptionSet> GetOptionsAsync(CancellationToken cancellationToken = default);
      public Task<SemanticModel> GetSemanticModelAsync(CancellationToken cancellationToken = default);
      public Task<SyntaxNode> GetSyntaxRootAsync(CancellationToken cancellationToken = default);
      public Task<SyntaxTree> GetSyntaxTreeAsync(CancellationToken cancellationToken = default);
      public Task<VersionStamp> GetSyntaxVersionAsync(CancellationToken cancellationToken = default);
      public Task<IEnumerable<TextChange>> GetTextChangesAsync(Document oldDocument, CancellationToken cancellationToken = default);
      public bool TryGetSemanticModel(out SemanticModel semanticModel);
      public bool TryGetSyntaxRoot(out SyntaxNode root);
      public bool TryGetSyntaxTree(out SyntaxTree syntaxTree);
      public bool TryGetSyntaxVersion(out VersionStamp version);
      public Document WithFilePath(string filePath);
      public Document WithFolders(IEnumerable<string> folders);
      public Document WithName(string name);
      public Document WithSourceCodeKind(SourceCodeKind kind);
      public Document WithSyntaxRoot(SyntaxNode root);
      public Document WithText(SourceText text);

  public abstract class Microsoft.CodeAnalysis.TextLoader

    protected TextLoader();

    public static TextLoader From(TextAndVersion textAndVersion);
    public static TextLoader From(SourceTextContainer container, VersionStamp version, string filePath = null);
    public abstract Task<TextAndVersion> LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);

  public abstract class Microsoft.CodeAnalysis.Workspace : IDisposable

    protected Workspace(HostServices host, string workspaceKind);

    public event EventHandler<DocumentActiveContextChangedEventArgs> DocumentActiveContextChanged;
    public event EventHandler<DocumentEventArgs> DocumentClosed;
    public event EventHandler<DocumentEventArgs> DocumentOpened;
    public event EventHandler<WorkspaceChangeEventArgs> WorkspaceChanged;
    public event EventHandler<WorkspaceDiagnosticEventArgs> WorkspaceFailed;

    public virtual bool CanOpenDocuments { get; }
    public Solution CurrentSolution { get; }
    public string Kind { get; }
    public OptionSet Options { get; set; }
    protected internal virtual bool PartialSemanticsEnabled { get; }
    public HostWorkspaceServices Services { get; }

    protected virtual Project AdjustReloadedProject(Project oldProject, Project reloadedProject);
    protected virtual Solution AdjustReloadedSolution(Solution oldSolution, Solution reloadedSolution);
    protected virtual void ApplyAdditionalDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyAdditionalDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyAdditionalDocumentTextChanged(DocumentId id, SourceText text);
    protected virtual void ApplyAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected virtual void ApplyAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
    protected virtual void ApplyCompilationOptionsChanged(ProjectId projectId, CompilationOptions options);
    protected virtual void ApplyDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyDocumentInfoChanged(DocumentId id, DocumentInfo info);
    protected virtual void ApplyDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyDocumentTextChanged(DocumentId id, SourceText text);
    protected virtual void ApplyMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyParseOptionsChanged(ProjectId projectId, ParseOptions options);
    protected virtual void ApplyProjectAdded(ProjectInfo project);
    protected virtual void ApplyProjectChanges(ProjectChanges projectChanges);
    protected virtual void ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyProjectRemoved(ProjectId projectId);
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    protected virtual bool CanApplyParseOptionChange(ParseOptions oldOptions, ParseOptions newOptions, Project project);
    protected void CheckAdditionalDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckAdditionalDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected void CheckCanOpenDocuments();
    protected virtual void CheckDocumentCanBeRemoved(DocumentId documentId);
    protected void CheckDocumentIsClosed(DocumentId documentId);
    protected void CheckDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected void CheckDocumentIsOpen(DocumentId documentId);
    protected virtual void CheckProjectCanBeRemoved(ProjectId projectId);
    protected void CheckProjectDoesNotContainOpenDocuments(ProjectId projectId);
    protected void CheckProjectDoesNotHaveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    protected void CheckProjectDoesNotHaveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    protected void CheckProjectDoesNotHaveProjectReference(ProjectId fromProjectId, ProjectReference projectReference);
    protected void CheckProjectDoesNotHaveTransitiveProjectReference(ProjectId fromProjectId, ProjectId toProjectId);
    protected void CheckProjectHasAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    protected void CheckProjectHasMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    protected void CheckProjectHasProjectReference(ProjectId fromProjectId, ProjectReference projectReference);
    protected void CheckProjectIsInCurrentSolution(ProjectId projectId);
    protected void CheckProjectIsNotInCurrentSolution(ProjectId projectId);
    protected void CheckSolutionIsEmpty();
    protected virtual void ClearDocumentData(DocumentId documentId);
    protected void ClearOpenDocument(DocumentId documentId, bool isSolutionClosing = false);
    protected virtual void ClearProjectData(ProjectId projectId);
    protected void ClearSolution();
    protected virtual void ClearSolutionData();
    public virtual void CloseAdditionalDocument(DocumentId documentId);
    public virtual void CloseDocument(DocumentId documentId);
    protected internal Solution CreateSolution(SolutionId id);
    protected internal Solution CreateSolution(SolutionInfo solutionInfo);
    public void Dispose();
    protected virtual void Dispose(bool finalize);
    protected virtual string GetAdditionalDocumentName(DocumentId documentId);
    public virtual DocumentId GetDocumentIdInCurrentContext(SourceTextContainer container);
    protected virtual string GetDocumentName(DocumentId documentId);
    public virtual IEnumerable<DocumentId> GetOpenDocumentIds(ProjectId projectId = null);
    protected virtual string GetProjectName(ProjectId projectId);
    public virtual IEnumerable<DocumentId> GetRelatedDocumentIds(SourceTextContainer container);
    public static WorkspaceRegistration GetWorkspaceRegistration(SourceTextContainer textContainer);
    public virtual bool IsDocumentOpen(DocumentId documentId);
    protected internal void OnAdditionalDocumentAdded(DocumentInfo documentInfo);
    protected internal void OnAdditionalDocumentClosed(DocumentId documentId, TextLoader reloader);
    protected internal void OnAdditionalDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext = true);
    protected internal void OnAdditionalDocumentRemoved(DocumentId documentId);
    protected internal void OnAdditionalDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    protected internal void OnAdditionalDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    protected internal void OnAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected internal void OnAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
    protected internal void OnAssemblyNameChanged(ProjectId projectId, string assemblyName);
    protected internal void OnCompilationOptionsChanged(ProjectId projectId, CompilationOptions options);
    protected internal void OnDocumentAdded(DocumentInfo documentInfo);
    protected internal void OnDocumentClosed(DocumentId documentId, TextLoader reloader, bool updateActiveContext = false);
    protected virtual void OnDocumentClosing(DocumentId documentId);
    protected void OnDocumentContextUpdated(DocumentId documentId);
    protected internal void OnDocumentInfoChanged(DocumentId documentId, DocumentInfo newInfo);
    protected internal void OnDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext = true);
    protected internal void OnDocumentReloaded(DocumentInfo newDocumentInfo);
    protected internal void OnDocumentRemoved(DocumentId documentId);
    protected internal void OnDocumentSourceCodeKindChanged(DocumentId documentId, SourceCodeKind sourceCodeKind);
    protected virtual void OnDocumentTextChanged(Document document);
    protected internal void OnDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    protected internal void OnDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    protected internal void OnMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected internal void OnMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    protected internal void OnOutputFilePathChanged(ProjectId projectId, string outputFilePath);
    protected internal void OnParseOptionsChanged(ProjectId projectId, ParseOptions options);
    protected internal void OnProjectAdded(ProjectInfo projectInfo);
    protected internal void OnProjectNameChanged(ProjectId projectId, string name, string filePath);
    protected internal void OnProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected internal void OnProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected internal virtual void OnProjectReloaded(ProjectInfo reloadedProjectInfo);
    protected internal virtual void OnProjectRemoved(ProjectId projectId);
    protected internal void OnSolutionAdded(SolutionInfo solutionInfo);
    protected internal void OnSolutionReloaded(SolutionInfo reloadedSolutionInfo);
    protected internal void OnSolutionRemoved();
    protected internal virtual void OnWorkspaceFailed(WorkspaceDiagnostic diagnostic);
    public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate = true);
    public virtual void OpenDocument(DocumentId documentId, bool activate = true);
    protected Task RaiseDocumentActiveContextChangedEventAsync(Document document);
    protected Task RaiseDocumentActiveContextChangedEventAsync(SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId);
    protected Task RaiseDocumentClosedEventAsync(Document document);
    protected Task RaiseDocumentOpenedEventAsync(Document document);
    protected Task RaiseWorkspaceChangedEventAsync(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId = null, DocumentId documentId = null);
    protected void RegisterText(SourceTextContainer textContainer);
    protected internal Task ScheduleTask(Action action, string taskName = "Workspace.Task");
    protected internal Task<T> ScheduleTask<T>(Func<T> func, string taskName = "Workspace.Task");
    protected Solution SetCurrentSolution(Solution solution);
    public virtual bool TryApplyChanges(Solution newSolution);
    public static bool TryGetWorkspace(SourceTextContainer textContainer, out Workspace workspace);
    protected void UnregisterText(SourceTextContainer textContainer);
    protected void UpdateReferencesAfterAdd();

    public sealed class Microsoft.CodeAnalysis.AdhocWorkspace : Workspace

      public AdhocWorkspace();
      public AdhocWorkspace(HostServices host, string workspaceKind = "Custom");

      public override bool CanOpenDocuments { get; }

      public Document AddDocument(DocumentInfo documentInfo);
      public Document AddDocument(ProjectId projectId, string name, SourceText text);
      public Project AddProject(ProjectInfo projectInfo);
      public Project AddProject(string name, string language);
      public void AddProjects(IEnumerable<ProjectInfo> projectInfos);
      public Solution AddSolution(SolutionInfo solutionInfo);
      public override bool CanApplyChange(ApplyChangesKind feature);
      public void ClearSolution();
      public override void CloseAdditionalDocument(DocumentId documentId);
      public override void CloseDocument(DocumentId documentId);
      public override void OpenAdditionalDocument(DocumentId documentId, bool activate = true);
      public override void OpenDocument(DocumentId documentId, bool activate = true);

  public class Microsoft.CodeAnalysis.WorkspaceDiagnostic

    public WorkspaceDiagnostic(WorkspaceDiagnosticKind kind, string message);

    public WorkspaceDiagnosticKind Kind { get; }
    public string Message { get; }

    public override string ToString();

    public class Microsoft.CodeAnalysis.DocumentDiagnostic : WorkspaceDiagnostic

      public DocumentDiagnostic(WorkspaceDiagnosticKind kind, string message, DocumentId documentId);

      public DocumentId DocumentId { get; }

    public class Microsoft.CodeAnalysis.ProjectDiagnostic : WorkspaceDiagnostic

      public ProjectDiagnostic(WorkspaceDiagnosticKind kind, string message, ProjectId projectId);

      public ProjectId ProjectId { get; }

  public sealed class Microsoft.CodeAnalysis.WorkspaceRegistration

    public event EventHandler WorkspaceChanged;

    public Workspace Workspace { get; }

  public abstract class Microsoft.CodeAnalysis.XmlReferenceResolver

    protected XmlReferenceResolver();

    public override abstract bool Equals(object other);
    public override abstract int GetHashCode();
    public abstract Stream OpenRead(string resolvedPath);
    public abstract string ResolveReference(string path, string baseFilePath);

    public class Microsoft.CodeAnalysis.XmlFileResolver : XmlReferenceResolver

      public XmlFileResolver(string baseDirectory);

      public string BaseDirectory { get; }
      public static XmlFileResolver Default { get; }

      public override bool Equals(object obj);
      protected virtual bool FileExists(string resolvedPath);
      public override int GetHashCode();
      public override Stream OpenRead(string resolvedPath);
      public override string ResolveReference(string path, string baseFilePath);

  public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor

    protected CSharpSyntaxVisitor();

    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void Visit(SyntaxNode node);
    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual void VisitAccessorList(AccessorListSyntax node);
    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
    public virtual void VisitArgument(ArgumentSyntax node);
    public virtual void VisitArgumentList(ArgumentListSyntax node);
    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual void VisitArrayType(ArrayTypeSyntax node);
    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual void VisitAttribute(AttributeSyntax node);
    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node);
    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node);
    public virtual void VisitAttributeList(AttributeListSyntax node);
    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual void VisitBaseExpression(BaseExpressionSyntax node);
    public virtual void VisitBaseList(BaseListSyntax node);
    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual void VisitBlock(BlockSyntax node);
    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node);
    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual void VisitBreakStatement(BreakStatementSyntax node);
    public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node);
    public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
    public virtual void VisitCastExpression(CastExpressionSyntax node);
    public virtual void VisitCatchClause(CatchClauseSyntax node);
    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node);
    public virtual void VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node);
    public virtual void VisitConstantPattern(ConstantPatternSyntax node);
    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node);
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual void VisitContinueStatement(ContinueStatementSyntax node);
    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
    public virtual void VisitCrefParameter(CrefParameterSyntax node);
    public virtual void VisitCrefParameterList(CrefParameterListSyntax node);
    public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node);
    public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node);
    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
    public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual void VisitDiscardDesignation(DiscardDesignationSyntax node);
    public virtual void VisitDoStatement(DoStatementSyntax node);
    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node);
    public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
    public virtual void VisitElseClause(ElseClauseSyntax node);
    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual void VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node);
    public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
    public virtual void VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual void VisitFinallyClause(FinallyClauseSyntax node);
    public virtual void VisitFixedStatement(FixedStatementSyntax node);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node);
    public virtual void VisitForStatement(ForStatementSyntax node);
    public virtual void VisitFromClause(FromClauseSyntax node);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual void VisitGotoStatement(GotoStatementSyntax node);
    public virtual void VisitGroupClause(GroupClauseSyntax node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual void VisitIfStatement(IfStatementSyntax node);
    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
    public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node);
    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual void VisitInterpolation(InterpolationSyntax node);
    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node);
    public virtual void VisitJoinClause(JoinClauseSyntax node);
    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node);
    public virtual void VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual void VisitLetClause(LetClauseSyntax node);
    public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
    public virtual void VisitLockStatement(LockStatementSyntax node);
    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node);
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual void VisitNameColon(NameColonSyntax node);
    public virtual void VisitNameEquals(NameEqualsSyntax node);
    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual void VisitNullableType(NullableTypeSyntax node);
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
    public virtual void VisitOrderByClause(OrderByClauseSyntax node);
    public virtual void VisitOrdering(OrderingSyntax node);
    public virtual void VisitParameter(ParameterSyntax node);
    public virtual void VisitParameterList(ParameterListSyntax node);
    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node);
    public virtual void VisitPointerType(PointerTypeSyntax node);
    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
    public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
    public virtual void VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual void VisitQualifiedName(QualifiedNameSyntax node);
    public virtual void VisitQueryBody(QueryBodySyntax node);
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual void VisitQueryExpression(QueryExpressionSyntax node);
    public virtual void VisitRefExpression(RefExpressionSyntax node);
    public virtual void VisitRefType(RefTypeSyntax node);
    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node);
    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual void VisitReturnStatement(ReturnStatementSyntax node);
    public virtual void VisitSelectClause(SelectClauseSyntax node);
    public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual void VisitSingleVariableDesignation(SingleVariableDesignationSyntax node);
    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual void VisitSwitchSection(SwitchSectionSyntax node);
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual void VisitThisExpression(ThisExpressionSyntax node);
    public virtual void VisitThrowExpression(ThrowExpressionSyntax node);
    public virtual void VisitThrowStatement(ThrowStatementSyntax node);
    public virtual void VisitTryStatement(TryStatementSyntax node);
    public virtual void VisitTupleElement(TupleElementSyntax node);
    public virtual void VisitTupleExpression(TupleExpressionSyntax node);
    public virtual void VisitTupleType(TupleTypeSyntax node);
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual void VisitTypeCref(TypeCrefSyntax node);
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual void VisitTypeParameter(TypeParameterSyntax node);
    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual void VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual void VisitUsingStatement(UsingStatementSyntax node);
    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node);
    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
    public virtual void VisitWhenClause(WhenClauseSyntax node);
    public virtual void VisitWhereClause(WhereClauseSyntax node);
    public virtual void VisitWhileStatement(WhileStatementSyntax node);
    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual void VisitXmlComment(XmlCommentSyntax node);
    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual void VisitXmlElement(XmlElementSyntax node);
    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual void VisitXmlName(XmlNameSyntax node);
    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual void VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual void VisitXmlText(XmlTextSyntax node);
    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    public virtual void VisitYieldStatement(YieldStatementSyntax node);

    public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker : CSharpSyntaxVisitor

      protected CSharpSyntaxWalker(SyntaxWalkerDepth depth = Node);

      protected SyntaxWalkerDepth Depth { get; }

      public override void DefaultVisit(SyntaxNode node);
      public override void Visit(SyntaxNode node);
      public virtual void VisitLeadingTrivia(SyntaxToken token);
      public virtual void VisitToken(SyntaxToken token);
      public virtual void VisitTrailingTrivia(SyntaxToken token);
      public virtual void VisitTrivia(SyntaxTrivia trivia);

  public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult>

    protected CSharpSyntaxVisitor();

    public virtual TResult DefaultVisit(SyntaxNode node);
    public virtual TResult Visit(SyntaxNode node);
    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual TResult VisitAccessorList(AccessorListSyntax node);
    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
    public virtual TResult VisitArgument(ArgumentSyntax node);
    public virtual TResult VisitArgumentList(ArgumentListSyntax node);
    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual TResult VisitArrayType(ArrayTypeSyntax node);
    public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual TResult VisitAttribute(AttributeSyntax node);
    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node);
    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node);
    public virtual TResult VisitAttributeList(AttributeListSyntax node);
    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node);
    public virtual TResult VisitBaseList(BaseListSyntax node);
    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual TResult VisitBlock(BlockSyntax node);
    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node);
    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual TResult VisitBreakStatement(BreakStatementSyntax node);
    public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node);
    public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
    public virtual TResult VisitCastExpression(CastExpressionSyntax node);
    public virtual TResult VisitCatchClause(CatchClauseSyntax node);
    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node);
    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node);
    public virtual TResult VisitConstantPattern(ConstantPatternSyntax node);
    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node);
    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node);
    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
    public virtual TResult VisitCrefParameter(CrefParameterSyntax node);
    public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node);
    public virtual TResult VisitDeclarationExpression(DeclarationExpressionSyntax node);
    public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node);
    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
    public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual TResult VisitDiscardDesignation(DiscardDesignationSyntax node);
    public virtual TResult VisitDoStatement(DoStatementSyntax node);
    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node);
    public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
    public virtual TResult VisitElseClause(ElseClauseSyntax node);
    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node);
    public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node);
    public virtual TResult VisitFixedStatement(FixedStatementSyntax node);
    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node);
    public virtual TResult VisitForEachVariableStatement(ForEachVariableStatementSyntax node);
    public virtual TResult VisitForStatement(ForStatementSyntax node);
    public virtual TResult VisitFromClause(FromClauseSyntax node);
    public virtual TResult VisitGenericName(GenericNameSyntax node);
    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual TResult VisitGotoStatement(GotoStatementSyntax node);
    public virtual TResult VisitGroupClause(GroupClauseSyntax node);
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node);
    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual TResult VisitIfStatement(IfStatementSyntax node);
    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
    public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node);
    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual TResult VisitInterpolation(InterpolationSyntax node);
    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node);
    public virtual TResult VisitJoinClause(JoinClauseSyntax node);
    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node);
    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual TResult VisitLetClause(LetClauseSyntax node);
    public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
    public virtual TResult VisitLockStatement(LockStatementSyntax node);
    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node);
    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual TResult VisitNameColon(NameColonSyntax node);
    public virtual TResult VisitNameEquals(NameEqualsSyntax node);
    public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual TResult VisitNullableType(NullableTypeSyntax node);
    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node);
    public virtual TResult VisitOrdering(OrderingSyntax node);
    public virtual TResult VisitParameter(ParameterSyntax node);
    public virtual TResult VisitParameterList(ParameterListSyntax node);
    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual TResult VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node);
    public virtual TResult VisitPointerType(PointerTypeSyntax node);
    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
    public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node);
    public virtual TResult VisitQueryBody(QueryBodySyntax node);
    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node);
    public virtual TResult VisitRefExpression(RefExpressionSyntax node);
    public virtual TResult VisitRefType(RefTypeSyntax node);
    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node);
    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node);
    public virtual TResult VisitSelectClause(SelectClauseSyntax node);
    public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
    public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual TResult VisitSingleVariableDesignation(SingleVariableDesignationSyntax node);
    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node);
    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual TResult VisitThisExpression(ThisExpressionSyntax node);
    public virtual TResult VisitThrowExpression(ThrowExpressionSyntax node);
    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node);
    public virtual TResult VisitTryStatement(TryStatementSyntax node);
    public virtual TResult VisitTupleElement(TupleElementSyntax node);
    public virtual TResult VisitTupleExpression(TupleExpressionSyntax node);
    public virtual TResult VisitTupleType(TupleTypeSyntax node);
    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual TResult VisitTypeCref(TypeCrefSyntax node);
    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual TResult VisitTypeParameter(TypeParameterSyntax node);
    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual TResult VisitUsingStatement(UsingStatementSyntax node);
    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node);
    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
    public virtual TResult VisitWhenClause(WhenClauseSyntax node);
    public virtual TResult VisitWhereClause(WhereClauseSyntax node);
    public virtual TResult VisitWhileStatement(WhileStatementSyntax node);
    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual TResult VisitXmlComment(XmlCommentSyntax node);
    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual TResult VisitXmlElement(XmlElementSyntax node);
    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual TResult VisitXmlName(XmlNameSyntax node);
    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual TResult VisitXmlText(XmlTextSyntax node);
    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    public virtual TResult VisitYieldStatement(YieldStatementSyntax node);

    public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter : CSharpSyntaxVisitor<SyntaxNode>

      public CSharpSyntaxRewriter(bool visitIntoStructuredTrivia = false);

      public virtual bool VisitIntoStructuredTrivia { get; }

      public override SyntaxNode Visit(SyntaxNode node);
      public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node);
      public override SyntaxNode VisitAccessorList(AccessorListSyntax node);
      public override SyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
      public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
      public override SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
      public override SyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
      public override SyntaxNode VisitArgument(ArgumentSyntax node);
      public override SyntaxNode VisitArgumentList(ArgumentListSyntax node);
      public override SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
      public override SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
      public override SyntaxNode VisitArrayType(ArrayTypeSyntax node);
      public override SyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
      public override SyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node);
      public override SyntaxNode VisitAttribute(AttributeSyntax node);
      public override SyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node);
      public override SyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node);
      public override SyntaxNode VisitAttributeList(AttributeListSyntax node);
      public override SyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
      public override SyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node);
      public override SyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
      public override SyntaxNode VisitBaseExpression(BaseExpressionSyntax node);
      public override SyntaxNode VisitBaseList(BaseListSyntax node);
      public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
      public override SyntaxNode VisitBlock(BlockSyntax node);
      public override SyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node);
      public override SyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node);
      public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node);
      public override SyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node);
      public override SyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
      public override SyntaxNode VisitCastExpression(CastExpressionSyntax node);
      public override SyntaxNode VisitCatchClause(CatchClauseSyntax node);
      public override SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node);
      public override SyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node);
      public override SyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node);
      public override SyntaxNode VisitCheckedStatement(CheckedStatementSyntax node);
      public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node);
      public override SyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
      public override SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node);
      public override SyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
      public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node);
      public override SyntaxNode VisitConstantPattern(ConstantPatternSyntax node);
      public override SyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node);
      public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
      public override SyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node);
      public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node);
      public override SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
      public override SyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
      public override SyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
      public override SyntaxNode VisitCrefParameter(CrefParameterSyntax node);
      public override SyntaxNode VisitCrefParameterList(CrefParameterListSyntax node);
      public override SyntaxNode VisitDeclarationExpression(DeclarationExpressionSyntax node);
      public override SyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node);
      public override SyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node);
      public override SyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
      public override SyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
      public override SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node);
      public override SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node);
      public override SyntaxNode VisitDiscardDesignation(DiscardDesignationSyntax node);
      public override SyntaxNode VisitDoStatement(DoStatementSyntax node);
      public override SyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
      public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node);
      public override SyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node);
      public override SyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
      public override SyntaxNode VisitElseClause(ElseClauseSyntax node);
      public override SyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
      public override SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node);
      public override SyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
      public override SyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
      public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node);
      public override SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
      public override SyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node);
      public override SyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
      public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node);
      public override SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
      public override SyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
      public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node);
      public override SyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
      public override SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node);
      public override SyntaxNode VisitFinallyClause(FinallyClauseSyntax node);
      public override SyntaxNode VisitFixedStatement(FixedStatementSyntax node);
      public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node);
      public override SyntaxNode VisitForEachVariableStatement(ForEachVariableStatementSyntax node);
      public override SyntaxNode VisitForStatement(ForStatementSyntax node);
      public override SyntaxNode VisitFromClause(FromClauseSyntax node);
      public override SyntaxNode VisitGenericName(GenericNameSyntax node);
      public override SyntaxNode VisitGlobalStatement(GlobalStatementSyntax node);
      public override SyntaxNode VisitGotoStatement(GotoStatementSyntax node);
      public override SyntaxNode VisitGroupClause(GroupClauseSyntax node);
      public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node);
      public override SyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
      public override SyntaxNode VisitIfStatement(IfStatementSyntax node);
      public override SyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
      public override SyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
      public override SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node);
      public override SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node);
      public override SyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
      public override SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node);
      public override SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
      public override SyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
      public override SyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
      public override SyntaxNode VisitInterpolation(InterpolationSyntax node);
      public override SyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
      public override SyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
      public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
      public override SyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node);
      public override SyntaxNode VisitJoinClause(JoinClauseSyntax node);
      public override SyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node);
      public override SyntaxNode VisitLabeledStatement(LabeledStatementSyntax node);
      public override SyntaxNode VisitLetClause(LetClauseSyntax node);
      public override SyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
      public virtual SyntaxTokenList VisitList(SyntaxTokenList list);
      public virtual SyntaxTriviaList VisitList(SyntaxTriviaList list);
      public virtual SyntaxList<TNode> VisitList<TNode>(SyntaxList<TNode> list) where TNode : SyntaxNode;
      public virtual SeparatedSyntaxList<TNode> VisitList<TNode>(SeparatedSyntaxList<TNode> list) where TNode : SyntaxNode;
      public virtual SyntaxTrivia VisitListElement(SyntaxTrivia element);
      public virtual TNode VisitListElement<TNode>(TNode node) where TNode : SyntaxNode;
      public virtual SyntaxToken VisitListSeparator(SyntaxToken separator);
      public override SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node);
      public override SyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
      public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
      public override SyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node);
      public override SyntaxNode VisitLockStatement(LockStatementSyntax node);
      public override SyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node);
      public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
      public override SyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
      public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node);
      public override SyntaxNode VisitNameColon(NameColonSyntax node);
      public override SyntaxNode VisitNameEquals(NameEqualsSyntax node);
      public override SyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node);
      public override SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
      public override SyntaxNode VisitNullableType(NullableTypeSyntax node);
      public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
      public override SyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
      public override SyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
      public override SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node);
      public override SyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
      public override SyntaxNode VisitOrderByClause(OrderByClauseSyntax node);
      public override SyntaxNode VisitOrdering(OrderingSyntax node);
      public override SyntaxNode VisitParameter(ParameterSyntax node);
      public override SyntaxNode VisitParameterList(ParameterListSyntax node);
      public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
      public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
      public override SyntaxNode VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node);
      public override SyntaxNode VisitPointerType(PointerTypeSyntax node);
      public override SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
      public override SyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
      public override SyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
      public override SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node);
      public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
      public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node);
      public override SyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node);
      public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node);
      public override SyntaxNode VisitQueryBody(QueryBodySyntax node);
      public override SyntaxNode VisitQueryContinuation(QueryContinuationSyntax node);
      public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node);
      public override SyntaxNode VisitRefExpression(RefExpressionSyntax node);
      public override SyntaxNode VisitRefType(RefTypeSyntax node);
      public override SyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node);
      public override SyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node);
      public override SyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
      public override SyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
      public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node);
      public override SyntaxNode VisitSelectClause(SelectClauseSyntax node);
      public override SyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
      public override SyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node);
      public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
      public override SyntaxNode VisitSingleVariableDesignation(SingleVariableDesignationSyntax node);
      public override SyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node);
      public override SyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
      public override SyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
      public override SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node);
      public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node);
      public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node);
      public override SyntaxNode VisitThisExpression(ThisExpressionSyntax node);
      public override SyntaxNode VisitThrowExpression(ThrowExpressionSyntax node);
      public override SyntaxNode VisitThrowStatement(ThrowStatementSyntax node);
      public virtual SyntaxToken VisitToken(SyntaxToken token);
      public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia);
      public override SyntaxNode VisitTryStatement(TryStatementSyntax node);
      public override SyntaxNode VisitTupleElement(TupleElementSyntax node);
      public override SyntaxNode VisitTupleExpression(TupleExpressionSyntax node);
      public override SyntaxNode VisitTupleType(TupleTypeSyntax node);
      public override SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node);
      public override SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node);
      public override SyntaxNode VisitTypeCref(TypeCrefSyntax node);
      public override SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node);
      public override SyntaxNode VisitTypeParameter(TypeParameterSyntax node);
      public override SyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
      public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node);
      public override SyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
      public override SyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node);
      public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node);
      public override SyntaxNode VisitUsingStatement(UsingStatementSyntax node);
      public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node);
      public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node);
      public override SyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
      public override SyntaxNode VisitWhenClause(WhenClauseSyntax node);
      public override SyntaxNode VisitWhereClause(WhereClauseSyntax node);
      public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node);
      public override SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node);
      public override SyntaxNode VisitXmlComment(XmlCommentSyntax node);
      public override SyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
      public override SyntaxNode VisitXmlElement(XmlElementSyntax node);
      public override SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node);
      public override SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node);
      public override SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node);
      public override SyntaxNode VisitXmlName(XmlNameSyntax node);
      public override SyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node);
      public override SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node);
      public override SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
      public override SyntaxNode VisitXmlText(XmlTextSyntax node);
      public override SyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node);
      public override SyntaxNode VisitYieldStatement(YieldStatementSyntax node);

  public abstract class Microsoft.CodeAnalysis.CodeActions.CodeAction

    protected CodeAction();

    public virtual string EquivalenceKey { get; }
    public virtual ImmutableArray<string> Tags { get; }
    public abstract string Title { get; }

    protected virtual Task<IEnumerable<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
    protected virtual Task<IEnumerable<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
    public static CodeAction Create(string title, Func<CancellationToken, Task<Document>> createChangedDocument, string equivalenceKey = null);
    public static CodeAction Create(string title, Func<CancellationToken, Task<Solution>> createChangedSolution, string equivalenceKey = null);
    protected virtual Task<Document> GetChangedDocumentAsync(CancellationToken cancellationToken);
    protected virtual Task<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken);
    public Task<ImmutableArray<CodeActionOperation>> GetOperationsAsync(CancellationToken cancellationToken);
    public Task<ImmutableArray<CodeActionOperation>> GetPreviewOperationsAsync(CancellationToken cancellationToken);
    protected Task<ImmutableArray<CodeActionOperation>> PostProcessAsync(IEnumerable<CodeActionOperation> operations, CancellationToken cancellationToken);
    protected Task<Solution> PostProcessChangesAsync(Solution changedSolution, CancellationToken cancellationToken);
    protected virtual Task<Document> PostProcessChangesAsync(Document document, CancellationToken cancellationToken);

    public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions : CodeAction

      protected CodeActionWithOptions();

      protected override Task<IEnumerable<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
      protected abstract Task<IEnumerable<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken);
      public Task<IEnumerable<CodeActionOperation>> GetOperationsAsync(object options, CancellationToken cancellationToken);
      public abstract object GetOptions(CancellationToken cancellationToken);

  public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionOperation

    protected CodeActionOperation();

    public virtual string Title { get; }

    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);

    public sealed class Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation : CodeActionOperation

      public ApplyChangesOperation(Solution changedSolution);

      public Solution ChangedSolution { get; }

      public override void Apply(Workspace workspace, CancellationToken cancellationToken);

    public sealed class Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation : CodeActionOperation

      public OpenDocumentOperation(DocumentId documentId, bool activateIfAlreadyOpen = false);

      public DocumentId DocumentId { get; }

      public override void Apply(Workspace workspace, CancellationToken cancellationToken);

    public abstract class Microsoft.CodeAnalysis.CodeActions.PreviewOperation : CodeActionOperation

      protected PreviewOperation();

      public abstract Task<object> GetPreviewAsync(CancellationToken cancellationToken);

  public abstract class Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider

    protected CodeFixProvider();

    public abstract ImmutableArray<string> FixableDiagnosticIds { get; }

    public virtual FixAllProvider GetFixAllProvider();
    public abstract Task RegisterCodeFixesAsync(CodeFixContext context);

  public class Microsoft.CodeAnalysis.CodeFixes.FixAllContext

    public FixAllContext(Document document, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable<string> diagnosticIds, FixAllContext.DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    public FixAllContext(Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable<string> diagnosticIds, FixAllContext.DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);

    public CancellationToken CancellationToken { get; }
    public string CodeActionEquivalenceKey { get; }
    public CodeFixProvider CodeFixProvider { get; }
    public ImmutableHashSet<string> DiagnosticIds { get; }
    public Document Document { get; }
    public Project Project { get; }
    public FixAllScope Scope { get; }
    public Solution Solution { get; }

    public Task<ImmutableArray<Diagnostic>> GetAllDiagnosticsAsync(Project project);
    public Task<ImmutableArray<Diagnostic>> GetDocumentDiagnosticsAsync(Document document);
    public Task<ImmutableArray<Diagnostic>> GetProjectDiagnosticsAsync(Project project);
    public FixAllContext WithCancellationToken(CancellationToken cancellationToken);

  public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider

    protected DiagnosticProvider();

    public abstract Task<IEnumerable<Diagnostic>> GetAllDiagnosticsAsync(Project project, CancellationToken cancellationToken);
    public abstract Task<IEnumerable<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, CancellationToken cancellationToken);
    public abstract Task<IEnumerable<Diagnostic>> GetProjectDiagnosticsAsync(Project project, CancellationToken cancellationToken);

  public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllProvider

    protected FixAllProvider();

    public abstract Task<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    public virtual IEnumerable<string> GetSupportedFixAllDiagnosticIds(CodeFixProvider originalCodeFixProvider);
    public virtual IEnumerable<FixAllScope> GetSupportedFixAllScopes();

  public abstract class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider

    protected CodeRefactoringProvider();

    public abstract Task ComputeRefactoringsAsync(CodeRefactoringContext context);

  public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption<T> : IEquatable<CodeStyleOption<T>>, ICodeStyleOption

    public CodeStyleOption(T value, NotificationOption notification);

    public static CodeStyleOption<T> Default { get; }
    public NotificationOption Notification { get; set; }
    public T Value { get; set; }

    public override bool Equals(object obj);
    public bool Equals(CodeStyleOption<T> other);
    public static CodeStyleOption<T> FromXElement(XElement element);
    public override int GetHashCode();
    public XElement ToXElement();

  public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions

    public static readonly PerLanguageOption<CodeStyleOption<bool>> PreferIntrinsicPredefinedTypeKeywordInDeclaration;
    public static readonly PerLanguageOption<CodeStyleOption<bool>> PreferIntrinsicPredefinedTypeKeywordInMemberAccess;
    public static readonly PerLanguageOption<CodeStyleOption<bool>> QualifyEventAccess;
    public static readonly PerLanguageOption<CodeStyleOption<bool>> QualifyFieldAccess;
    public static readonly PerLanguageOption<CodeStyleOption<bool>> QualifyMethodAccess;
    public static readonly PerLanguageOption<CodeStyleOption<bool>> QualifyPropertyAccess;

    public CodeStyleOptions();

  public class Microsoft.CodeAnalysis.CodeStyle.NotificationOption

    public static readonly NotificationOption Error;
    public static readonly NotificationOption None;
    public static readonly NotificationOption Suggestion;
    public static readonly NotificationOption Warning;

    public string Name { get; set; }
    public DiagnosticSeverity Value { get; set; }

    public override string ToString();

  public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalysisContext

    protected AnalysisContext();

    public virtual void ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags analysisMode);
    public virtual void EnableConcurrentExecution();
    public abstract void RegisterCodeBlockAction(Action<CodeBlockAnalysisContext> action);
    public abstract void RegisterCodeBlockStartAction<TLanguageKindEnum>(Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action) where TLanguageKindEnum : struct;
    public abstract void RegisterCompilationAction(Action<CompilationAnalysisContext> action);
    public abstract void RegisterCompilationStartAction(Action<CompilationStartAnalysisContext> action);
    public void RegisterOperationAction(Action<OperationAnalysisContext> action, params OperationKind[] operationKinds);
    public virtual void RegisterOperationAction(Action<OperationAnalysisContext> action, ImmutableArray<OperationKind> operationKinds);
    public virtual void RegisterOperationBlockAction(Action<OperationBlockAnalysisContext> action);
    public virtual void RegisterOperationBlockStartAction(Action<OperationBlockStartAnalysisContext> action);
    public abstract void RegisterSemanticModelAction(Action<SemanticModelAnalysisContext> action);
    public void RegisterSymbolAction(Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds);
    public abstract void RegisterSymbolAction(Action<SymbolAnalysisContext> action, ImmutableArray<SymbolKind> symbolKinds);
    public void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds) where TLanguageKindEnum : struct;
    public abstract void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, ImmutableArray<TLanguageKindEnum> syntaxKinds) where TLanguageKindEnum : struct;
    public abstract void RegisterSyntaxTreeAction(Action<SyntaxTreeAnalysisContext> action);
    public bool TryGetValue<TValue>(SourceText text, SourceTextValueProvider<TValue> valueProvider, out TValue value);

  public class Microsoft.CodeAnalysis.Diagnostics.AnalysisResult

    public ImmutableDictionary<DiagnosticAnalyzer, AnalyzerTelemetryInfo> AnalyzerTelemetryInfo { get; }
    public ImmutableArray<DiagnosticAnalyzer> Analyzers { get; }
    public ImmutableDictionary<DiagnosticAnalyzer, ImmutableArray<Diagnostic>> CompilationDiagnostics { get; }
    public ImmutableDictionary<SyntaxTree, ImmutableDictionary<DiagnosticAnalyzer, ImmutableArray<Diagnostic>>> SemanticDiagnostics { get; }
    public ImmutableDictionary<SyntaxTree, ImmutableDictionary<DiagnosticAnalyzer, ImmutableArray<Diagnostic>>> SyntaxDiagnostics { get; }

    public ImmutableArray<Diagnostic> GetAllDiagnostics();
    public ImmutableArray<Diagnostic> GetAllDiagnostics(DiagnosticAnalyzer analyzer);

  public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions

    public AnalyzerOptions(ImmutableArray<AdditionalText> additionalFiles);

    public ImmutableArray<AdditionalText> AdditionalFiles { get; }

    public override bool Equals(object obj);
    public override int GetHashCode();
    public AnalyzerOptions WithAdditionalFiles(ImmutableArray<AdditionalText> additionalFiles);

  public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference

    protected AnalyzerReference();

    public virtual string Display { get; }
    public abstract string FullPath { get; }
    public abstract object Id { get; }

    public abstract ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language);
    public abstract ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();

    public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference : AnalyzerReference, IEquatable<AnalyzerReference>

      public AnalyzerFileReference(string fullPath, IAnalyzerAssemblyLoader assemblyLoader);

      public event EventHandler<AnalyzerLoadFailureEventArgs> AnalyzerLoadFailed;

      public override string Display { get; }
      public override string FullPath { get; }
      public override object Id { get; }

      public override bool Equals(object obj);
      public bool Equals(AnalyzerReference other);
      public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language);
      public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
      public Assembly GetAssembly();
      public override int GetHashCode();

    public sealed class Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference : AnalyzerReference

      public AnalyzerImageReference(ImmutableArray<DiagnosticAnalyzer> analyzers, string fullPath = null, string display = null);

      public override string Display { get; }
      public override string FullPath { get; }
      public override object Id { get; }

      public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language);
      public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();

    public sealed class Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference : AnalyzerReference

      public UnresolvedAnalyzerReference(string unresolvedPath);

      public override string Display { get; }
      public override string FullPath { get; }
      public override object Id { get; }

      public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language);
      public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();

  public abstract class Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext<TLanguageKindEnum> where TLanguageKindEnum : struct

    protected CodeBlockStartAnalysisContext(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, CancellationToken cancellationToken);

    public CancellationToken CancellationToken { get; }
    public SyntaxNode CodeBlock { get; }
    public AnalyzerOptions Options { get; }
    public ISymbol OwningSymbol { get; }
    public SemanticModel SemanticModel { get; }

    public abstract void RegisterCodeBlockEndAction(Action<CodeBlockAnalysisContext> action);
    public void RegisterSyntaxNodeAction(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds);
    public abstract void RegisterSyntaxNodeAction(Action<SyntaxNodeAnalysisContext> action, ImmutableArray<TLanguageKindEnum> syntaxKinds);

  public abstract class Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext

    protected CompilationStartAnalysisContext(Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken);

    public CancellationToken CancellationToken { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }

    public abstract void RegisterCodeBlockAction(Action<CodeBlockAnalysisContext> action);
    public abstract void RegisterCodeBlockStartAction<TLanguageKindEnum>(Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action) where TLanguageKindEnum : struct;
    public abstract void RegisterCompilationEndAction(Action<CompilationAnalysisContext> action);
    public void RegisterOperationAction(Action<OperationAnalysisContext> action, params OperationKind[] operationKinds);
    public virtual void RegisterOperationAction(Action<OperationAnalysisContext> action, ImmutableArray<OperationKind> operationKinds);
    public virtual void RegisterOperationBlockAction(Action<OperationBlockAnalysisContext> action);
    public virtual void RegisterOperationBlockStartAction(Action<OperationBlockStartAnalysisContext> action);
    public abstract void RegisterSemanticModelAction(Action<SemanticModelAnalysisContext> action);
    public void RegisterSymbolAction(Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds);
    public abstract void RegisterSymbolAction(Action<SymbolAnalysisContext> action, ImmutableArray<SymbolKind> symbolKinds);
    public void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds) where TLanguageKindEnum : struct;
    public abstract void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, ImmutableArray<TLanguageKindEnum> syntaxKinds) where TLanguageKindEnum : struct;
    public abstract void RegisterSyntaxTreeAction(Action<SyntaxTreeAnalysisContext> action);
    public bool TryGetValue<TValue>(SourceText text, SourceTextValueProvider<TValue> valueProvider, out TValue value);
    public bool TryGetValue<TValue>(SyntaxTree tree, SyntaxTreeValueProvider<TValue> valueProvider, out TValue value);

  public class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers

    public CompilationWithAnalyzers(Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions);
    public CompilationWithAnalyzers(Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, CancellationToken cancellationToken);

    public CompilationWithAnalyzersOptions AnalysisOptions { get; }
    public ImmutableArray<DiagnosticAnalyzer> Analyzers { get; }
    public CancellationToken CancellationToken { get; }
    public Compilation Compilation { get; }

    public static void ClearAnalyzerState(ImmutableArray<DiagnosticAnalyzer> analyzers);
    public Task<ImmutableArray<Diagnostic>> GetAllDiagnosticsAsync();
    public Task<ImmutableArray<Diagnostic>> GetAllDiagnosticsAsync(CancellationToken cancellationToken);
    public Task<AnalysisResult> GetAnalysisResultAsync(CancellationToken cancellationToken);
    public Task<AnalysisResult> GetAnalysisResultAsync(ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync(CancellationToken cancellationToken);
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync(ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerDiagnosticsAsync();
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerDiagnosticsAsync(CancellationToken cancellationToken);
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerDiagnosticsAsync(ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync(SemanticModel model, TextSpan? filterSpan, CancellationToken cancellationToken);
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync(SemanticModel model, TextSpan? filterSpan, ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync(SyntaxTree tree, CancellationToken cancellationToken);
    public Task<ImmutableArray<Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync(SyntaxTree tree, ImmutableArray<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    public Task<AnalyzerTelemetryInfo> GetAnalyzerTelemetryInfoAsync(DiagnosticAnalyzer analyzer, CancellationToken cancellationToken);
    public static IEnumerable<Diagnostic> GetEffectiveDiagnostics(IEnumerable<Diagnostic> diagnostics, Compilation compilation);
    public static IEnumerable<Diagnostic> GetEffectiveDiagnostics(ImmutableArray<Diagnostic> diagnostics, Compilation compilation);
    public static bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, Action<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException = null);

  public sealed class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions

    public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime);
    public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics);
    public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics, Func<Exception, bool> analyzerExceptionFilter);

    public Func<Exception, bool> AnalyzerExceptionFilter { get; }
    public bool ConcurrentAnalysis { get; }
    public bool LogAnalyzerExecutionTime { get; }
    public Action<Exception, DiagnosticAnalyzer, Diagnostic> OnAnalyzerException { get; }
    public AnalyzerOptions Options { get; }
    public bool ReportSuppressedDiagnostics { get; }

  public abstract class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer

    protected DiagnosticAnalyzer();

    public abstract ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; }

    public override sealed bool Equals(object obj);
    public override sealed int GetHashCode();
    public abstract void Initialize(AnalysisContext context);
    public override sealed string ToString();

  public abstract class Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext

    protected OperationBlockStartAnalysisContext(ImmutableArray<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken);

    public CancellationToken CancellationToken { get; }
    public Compilation Compilation { get; }
    public ImmutableArray<IOperation> OperationBlocks { get; }
    public AnalyzerOptions Options { get; }
    public ISymbol OwningSymbol { get; }

    public void RegisterOperationAction(Action<OperationAnalysisContext> action, params OperationKind[] operationKinds);
    public abstract void RegisterOperationAction(Action<OperationAnalysisContext> action, ImmutableArray<OperationKind> operationKinds);
    public abstract void RegisterOperationBlockEndAction(Action<OperationBlockAnalysisContext> action);

  public sealed class Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider<TValue>

    public SourceTextValueProvider(Func<SourceText, TValue> computeValue, IEqualityComparer<SourceText> sourceTextComparer = null);

  public sealed class Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo

    public AttributeData Attribute { get; }
    public string Id { get; }

  public sealed class Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider<TValue>

    public SyntaxTreeValueProvider(Func<SyntaxTree, TValue> computeValue, IEqualityComparer<SyntaxTree> syntaxTreeComparer = null);

  public sealed class Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo

    public AnalyzerTelemetryInfo();

    public int CodeBlockActionsCount { get; set; }
    public int CodeBlockEndActionsCount { get; set; }
    public int CodeBlockStartActionsCount { get; set; }
    public int CompilationActionsCount { get; set; }
    public int CompilationEndActionsCount { get; set; }
    public int CompilationStartActionsCount { get; set; }
    public TimeSpan ExecutionTime { get; set; }
    public int OperationActionsCount { get; set; }
    public int OperationBlockActionsCount { get; set; }
    public int OperationBlockEndActionsCount { get; set; }
    public int OperationBlockStartActionsCount { get; set; }
    public int SemanticModelActionsCount { get; set; }
    public int SymbolActionsCount { get; set; }
    public int SyntaxNodeActionsCount { get; set; }
    public int SyntaxTreeActionsCount { get; set; }

  public sealed class Microsoft.CodeAnalysis.Differencing.EditScript<TNode>

    public ImmutableArray<Edit<TNode>> Edits { get; }
    public Match<TNode> Match { get; }

  public sealed class Microsoft.CodeAnalysis.Differencing.Match<TNode>

    public TreeComparer<TNode> Comparer { get; }
    public IReadOnlyDictionary<TNode, TNode> Matches { get; }
    public TNode NewRoot { get; }
    public TNode OldRoot { get; }
    public IReadOnlyDictionary<TNode, TNode> ReverseMatches { get; }

    public IEnumerable<Edit<TNode>> GetSequenceEdits(IEnumerable<TNode> oldNodes, IEnumerable<TNode> newNodes);
    public EditScript<TNode> GetTreeEdits();
    public bool TryGetNewNode(TNode oldNode, out TNode newNode);
    public bool TryGetOldNode(TNode newNode, out TNode oldNode);

  public abstract class Microsoft.CodeAnalysis.Differencing.TreeComparer<TNode>

    protected TreeComparer();

    protected internal abstract int LabelCount { get; }

    public EditScript<TNode> ComputeEditScript(TNode oldRoot, TNode newRoot);
    public Match<TNode> ComputeMatch(TNode oldRoot, TNode newRoot, IEnumerable<KeyValuePair<TNode, TNode>> knownMatches = null);
    protected internal abstract IEnumerable<TNode> GetChildren(TNode node);
    protected internal abstract IEnumerable<TNode> GetDescendants(TNode node);
    public abstract double GetDistance(TNode oldNode, TNode newNode);
    protected internal abstract int GetLabel(TNode node);
    protected internal abstract TextSpan GetSpan(TNode node);
    protected internal abstract int TiedToAncestor(int label);
    protected internal abstract bool TreesEqual(TNode oldNode, TNode newNode);
    protected internal abstract bool TryGetParent(TNode node, out TNode parent);
    public abstract bool ValuesEqual(TNode oldNode, TNode newNode);

  public class Microsoft.CodeAnalysis.Editing.SolutionEditor

    public SolutionEditor(Solution solution);

    public Solution OriginalSolution { get; }

    public Solution GetChangedSolution();
    public Task<DocumentEditor> GetDocumentEditorAsync(DocumentId id, CancellationToken cancellationToken = default);

  public sealed class Microsoft.CodeAnalysis.Editing.SymbolEditor

    public Solution ChangedSolution { get; }
    public Solution OriginalSolution { get; }

    public static SymbolEditor Create(Document document);
    public static SymbolEditor Create(Solution solution);
    public Task<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default);
    public Task<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default);
    public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default);
    public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default);
    public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default);
    public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default);
    public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, SymbolEditor.AsyncDeclarationEditAction editAction, CancellationToken cancellationToken = default);
    public Task<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, SymbolEditor.DeclarationEditAction editAction, CancellationToken cancellationToken = default);
    public IEnumerable<Document> GetChangedDocuments();
    public Task<IReadOnlyList<SyntaxNode>> GetCurrentDeclarationsAsync(ISymbol symbol, CancellationToken cancellationToken = default);
    public Task<ISymbol> GetCurrentSymbolAsync(ISymbol symbol, CancellationToken cancellationToken = default);

  public class Microsoft.CodeAnalysis.Editing.SyntaxEditor

    public SyntaxEditor(SyntaxNode root, Workspace workspace);

    public SyntaxGenerator Generator { get; }
    public SyntaxNode OriginalRoot { get; }

    public SyntaxNode GetChangedRoot();
    public void InsertAfter(SyntaxNode node, SyntaxNode newNode);
    public void InsertAfter(SyntaxNode node, IEnumerable<SyntaxNode> newNodes);
    public void InsertBefore(SyntaxNode node, SyntaxNode newNode);
    public void InsertBefore(SyntaxNode node, IEnumerable<SyntaxNode> newNodes);
    public void RemoveNode(SyntaxNode node);
    public void RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    public void ReplaceNode(SyntaxNode node, Func<SyntaxNode, SyntaxGenerator, SyntaxNode> computeReplacement);
    public void ReplaceNode(SyntaxNode node, SyntaxNode newNode);
    public void TrackNode(SyntaxNode node);

    public class Microsoft.CodeAnalysis.Editing.DocumentEditor : SyntaxEditor

      public Document OriginalDocument { get; }
      public SemanticModel SemanticModel { get; }

      public static Task<DocumentEditor> CreateAsync(Document document, CancellationToken cancellationToken = default);
      public Document GetChangedDocument();

  public abstract class Microsoft.CodeAnalysis.Editing.SyntaxGenerator : ILanguageService

    public static SyntaxRemoveOptions DefaultRemoveOptions;

    protected SyntaxGenerator();

    public SyntaxNode AddAccessors(SyntaxNode declaration, IEnumerable<SyntaxNode> accessors);
    public SyntaxNode AddAttributeArguments(SyntaxNode attributeDeclaration, IEnumerable<SyntaxNode> attributeArguments);
    public SyntaxNode AddAttributes(SyntaxNode declaration, IEnumerable<SyntaxNode> attributes);
    public SyntaxNode AddAttributes(SyntaxNode declaration, params SyntaxNode[] attributes);
    public abstract SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType);
    public abstract SyntaxNode AddEventHandler(SyntaxNode @event, SyntaxNode handler);
    public abstract SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType);
    public SyntaxNode AddMembers(SyntaxNode declaration, IEnumerable<SyntaxNode> members);
    public SyntaxNode AddMembers(SyntaxNode declaration, params SyntaxNode[] members);
    public SyntaxNode AddNamespaceImports(SyntaxNode declaration, IEnumerable<SyntaxNode> imports);
    public SyntaxNode AddNamespaceImports(SyntaxNode declaration, params SyntaxNode[] imports);
    public SyntaxNode AddParameters(SyntaxNode declaration, IEnumerable<SyntaxNode> parameters);
    public SyntaxNode AddReturnAttributes(SyntaxNode declaration, IEnumerable<SyntaxNode> attributes);
    public SyntaxNode AddReturnAttributes(SyntaxNode declaration, params SyntaxNode[] attributes);
    public SyntaxNode AddSwitchSections(SyntaxNode switchStatement, IEnumerable<SyntaxNode> switchSections);
    public SyntaxNode Argument(SyntaxNode expression);
    public SyntaxNode Argument(RefKind refKind, SyntaxNode expression);
    public abstract SyntaxNode Argument(string name, RefKind refKind, SyntaxNode expression);
    public abstract SyntaxNode ArrayCreationExpression(SyntaxNode elementType, IEnumerable<SyntaxNode> elements);
    public abstract SyntaxNode ArrayCreationExpression(SyntaxNode elementType, SyntaxNode size);
    public abstract SyntaxNode ArrayTypeExpression(SyntaxNode type);
    public SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType);
    public abstract SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName);
    public SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType);
    public abstract SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName);
    public abstract SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right);
    public SyntaxNode Attribute(AttributeData attribute);
    public abstract SyntaxNode Attribute(SyntaxNode name, IEnumerable<SyntaxNode> attributeArguments = null);
    public SyntaxNode Attribute(string name, IEnumerable<SyntaxNode> attributeArguments = null);
    public SyntaxNode Attribute(string name, params SyntaxNode[] attributeArguments);
    public SyntaxNode AttributeArgument(SyntaxNode expression);
    public abstract SyntaxNode AttributeArgument(string name, SyntaxNode expression);
    public abstract SyntaxNode AwaitExpression(SyntaxNode expression);
    public abstract SyntaxNode BaseExpression();
    public abstract SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode BitwiseNotExpression(SyntaxNode operand);
    public abstract SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression);
    public SyntaxNode CastExpression(ITypeSymbol type, SyntaxNode expression);
    public abstract SyntaxNode CatchClause(SyntaxNode type, string identifier, IEnumerable<SyntaxNode> statements);
    public SyntaxNode CatchClause(ITypeSymbol type, string identifier, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode ClassDeclaration(string name, IEnumerable<string> typeParameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, SyntaxNode baseType = null, IEnumerable<SyntaxNode> interfaceTypes = null, IEnumerable<SyntaxNode> members = null);
    public abstract TNode ClearTrivia<TNode>(TNode node) where TNode : SyntaxNode;
    public abstract SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode CompilationUnit(IEnumerable<SyntaxNode> declarations);
    public SyntaxNode CompilationUnit(params SyntaxNode[] declarations);
    public abstract SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse);
    public SyntaxNode ConstructorDeclaration(IMethodSymbol constructorMethod, IEnumerable<SyntaxNode> baseConstructorArguments = null, IEnumerable<SyntaxNode> statements = null);
    public abstract SyntaxNode ConstructorDeclaration(string containingTypeName = null, IEnumerable<SyntaxNode> parameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> baseConstructorArguments = null, IEnumerable<SyntaxNode> statements = null);
    public abstract SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression);
    public SyntaxNode ConvertExpression(ITypeSymbol type, SyntaxNode expression);
    public SyntaxNode CustomEventDeclaration(IEventSymbol symbol, IEnumerable<SyntaxNode> addAccessorStatements = null, IEnumerable<SyntaxNode> removeAccessorStatements = null);
    public abstract SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> parameters = null, IEnumerable<SyntaxNode> addAccessorStatements = null, IEnumerable<SyntaxNode> removeAccessorStatements = null);
    public SyntaxNode Declaration(ISymbol symbol);
    public abstract SyntaxNode DefaultExpression(SyntaxNode type);
    public abstract SyntaxNode DefaultExpression(ITypeSymbol type);
    public abstract SyntaxNode DefaultSwitchSection(IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode DelegateDeclaration(string name, IEnumerable<SyntaxNode> parameters = null, IEnumerable<string> typeParameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default);
    public abstract SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right);
    public SyntaxNode DottedName(string dottedName);
    public abstract SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable<SyntaxNode> arguments);
    public SyntaxNode ElementAccessExpression(SyntaxNode expression, params SyntaxNode[] arguments);
    public abstract SyntaxNode EnumDeclaration(string name, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> members = null);
    public abstract SyntaxNode EnumMember(string name, SyntaxNode expression = null);
    public SyntaxNode EventDeclaration(IEventSymbol symbol);
    public abstract SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default);
    public abstract SyntaxNode ExitSwitchStatement();
    public abstract SyntaxNode ExpressionStatement(SyntaxNode expression);
    public SyntaxNode FalseLiteralExpression();
    public SyntaxNode FieldDeclaration(IFieldSymbol field);
    public SyntaxNode FieldDeclaration(IFieldSymbol field, SyntaxNode initializer);
    public abstract SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, SyntaxNode initializer = null);
    public abstract SyntaxNode GenericName(string identifier, IEnumerable<SyntaxNode> typeArguments);
    public SyntaxNode GenericName(string identifier, IEnumerable<ITypeSymbol> typeArguments);
    public SyntaxNode GenericName(string identifier, params SyntaxNode[] typeArguments);
    public SyntaxNode GenericName(string identifier, params ITypeSymbol[] typeArguments);
    public abstract Accessibility GetAccessibility(SyntaxNode declaration);
    public SyntaxNode GetAccessor(SyntaxNode declaration, DeclarationKind kind);
    public abstract IReadOnlyList<SyntaxNode> GetAccessors(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetAttributeArguments(SyntaxNode attributeDeclaration);
    public abstract IReadOnlyList<SyntaxNode> GetAttributes(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetBaseAndInterfaceTypes(SyntaxNode declaration);
    public SyntaxNode GetDeclaration(SyntaxNode node);
    public SyntaxNode GetDeclaration(SyntaxNode node, DeclarationKind kind);
    public abstract DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    public abstract SyntaxNode GetExpression(SyntaxNode declaration);
    public static SyntaxGenerator GetGenerator(Document document);
    public static SyntaxGenerator GetGenerator(Project project);
    public static SyntaxGenerator GetGenerator(Workspace workspace, string language);
    public abstract IReadOnlyList<SyntaxNode> GetGetAccessorStatements(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetMembers(SyntaxNode declaration);
    public abstract DeclarationModifiers GetModifiers(SyntaxNode declaration);
    public abstract string GetName(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetNamespaceImports(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetParameters(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetReturnAttributes(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetSetAccessorStatements(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetStatements(SyntaxNode declaration);
    public abstract IReadOnlyList<SyntaxNode> GetSwitchSections(SyntaxNode switchStatement);
    public abstract SyntaxNode GetType(SyntaxNode declaration);
    public abstract SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode IdentifierName(string identifier);
    public SyntaxNode IfStatement(SyntaxNode condition, IEnumerable<SyntaxNode> trueStatements, SyntaxNode falseStatement);
    public abstract SyntaxNode IfStatement(SyntaxNode condition, IEnumerable<SyntaxNode> trueStatements, IEnumerable<SyntaxNode> falseStatements = null);
    protected int IndexOf<T>(IReadOnlyList<T> list, T element);
    public SyntaxNode IndexerDeclaration(IPropertySymbol indexer, IEnumerable<SyntaxNode> getAccessorStatements = null, IEnumerable<SyntaxNode> setAccessorStatements = null);
    public abstract SyntaxNode IndexerDeclaration(IEnumerable<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> getAccessorStatements = null, IEnumerable<SyntaxNode> setAccessorStatements = null);
    public abstract SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> accessors);
    public abstract SyntaxNode InsertAttributeArguments(SyntaxNode attributeDeclaration, int index, IEnumerable<SyntaxNode> attributeArguments);
    public abstract SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> attributes);
    public SyntaxNode InsertAttributes(SyntaxNode declaration, int index, params SyntaxNode[] attributes);
    public abstract SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> members);
    public SyntaxNode InsertMembers(SyntaxNode declaration, int index, params SyntaxNode[] members);
    public abstract SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> imports);
    public SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, params SyntaxNode[] imports);
    public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode node, IEnumerable<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode node, IEnumerable<SyntaxNode> newDeclarations);
    public abstract SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> parameters);
    public abstract SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable<SyntaxNode> attributes);
    public SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, params SyntaxNode[] attributes);
    public abstract SyntaxNode InsertSwitchSections(SyntaxNode switchStatement, int index, IEnumerable<SyntaxNode> switchSections);
    public abstract SyntaxNode InterfaceDeclaration(string name, IEnumerable<string> typeParameters = null, Accessibility accessibility = NotApplicable, IEnumerable<SyntaxNode> interfaceTypes = null, IEnumerable<SyntaxNode> members = null);
    public abstract SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable<SyntaxNode> arguments);
    public SyntaxNode InvocationExpression(SyntaxNode expression, params SyntaxNode[] arguments);
    public abstract SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type);
    public SyntaxNode IsTypeExpression(SyntaxNode expression, ITypeSymbol type);
    public abstract SyntaxNode LambdaParameter(string identifier, SyntaxNode type = null);
    public SyntaxNode LambdaParameter(string identifier, ITypeSymbol type);
    public abstract SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode LiteralExpression(object value);
    public SyntaxNode LocalDeclarationStatement(string name, SyntaxNode initializer);
    public abstract SyntaxNode LocalDeclarationStatement(SyntaxNode type, string identifier, SyntaxNode initializer = null, bool isConst = false);
    public SyntaxNode LocalDeclarationStatement(ITypeSymbol type, string name, SyntaxNode initializer = null, bool isConst = false);
    public abstract SyntaxNode LockStatement(SyntaxNode expression, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode LogicalNotExpression(SyntaxNode expression);
    public abstract SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode MemberAccessExpression(SyntaxNode expression, SyntaxNode memberName);
    public SyntaxNode MemberAccessExpression(SyntaxNode expression, string memberName);
    public SyntaxNode MethodDeclaration(IMethodSymbol method, IEnumerable<SyntaxNode> statements = null);
    public abstract SyntaxNode MethodDeclaration(string name, IEnumerable<SyntaxNode> parameters = null, IEnumerable<string> typeParameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> statements = null);
    public abstract SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode NameOfExpression(SyntaxNode expression);
    public abstract SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable<SyntaxNode> declarations);
    public SyntaxNode NamespaceDeclaration(SyntaxNode name, params SyntaxNode[] declarations);
    public SyntaxNode NamespaceDeclaration(string name, IEnumerable<SyntaxNode> declarations);
    public SyntaxNode NamespaceDeclaration(string name, params SyntaxNode[] declarations);
    public abstract SyntaxNode NamespaceImportDeclaration(SyntaxNode name);
    public SyntaxNode NamespaceImportDeclaration(string name);
    public abstract SyntaxNode NegateExpression(SyntaxNode expression);
    public SyntaxNode NullLiteralExpression();
    public abstract SyntaxNode NullableTypeExpression(SyntaxNode type);
    public abstract SyntaxNode ObjectCreationExpression(SyntaxNode namedType, IEnumerable<SyntaxNode> arguments);
    public SyntaxNode ObjectCreationExpression(ITypeSymbol type, IEnumerable<SyntaxNode> arguments);
    public SyntaxNode ObjectCreationExpression(SyntaxNode type, params SyntaxNode[] arguments);
    public SyntaxNode ObjectCreationExpression(ITypeSymbol type, params SyntaxNode[] arguments);
    public SyntaxNode OperatorDeclaration(IMethodSymbol method, IEnumerable<SyntaxNode> statements = null);
    public virtual SyntaxNode OperatorDeclaration(OperatorKind kind, IEnumerable<SyntaxNode> parameters = null, SyntaxNode returnType = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> statements = null);
    public SyntaxNode ParameterDeclaration(IParameterSymbol symbol, SyntaxNode initializer = null);
    public abstract SyntaxNode ParameterDeclaration(string name, SyntaxNode type = null, SyntaxNode initializer = null, RefKind refKind = None);
    protected static SyntaxNode PreserveTrivia<TNode>(TNode node, Func<TNode, SyntaxNode> nodeChanger) where TNode : SyntaxNode;
    public SyntaxNode PropertyDeclaration(IPropertySymbol property, IEnumerable<SyntaxNode> getAccessorStatements = null, IEnumerable<SyntaxNode> setAccessorStatements = null);
    public abstract SyntaxNode PropertyDeclaration(string name, SyntaxNode type, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> getAccessorStatements = null, IEnumerable<SyntaxNode> setAccessorStatements = null);
    public abstract SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public SyntaxNode RemoveAllAttributes(SyntaxNode declaration);
    public abstract SyntaxNode RemoveEventHandler(SyntaxNode @event, SyntaxNode handler);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options);
    public SyntaxNode RemoveNodes(SyntaxNode root, IEnumerable<SyntaxNode> declarations);
    protected static SeparatedSyntaxList<TNode> RemoveRange<TNode>(SeparatedSyntaxList<TNode> list, int offset, int count) where TNode : SyntaxNode;
    protected static SyntaxList<TNode> RemoveRange<TNode>(SyntaxList<TNode> list, int offset, int count) where TNode : SyntaxNode;
    public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode node, SyntaxNode newDeclaration);
    protected static SyntaxNode ReplaceRange(SyntaxNode root, SyntaxNode node, IEnumerable<SyntaxNode> replacements);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxNode original, SyntaxNode replacement);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxToken original, SyntaxToken replacement);
    protected static SyntaxNode ReplaceWithTrivia<TNode>(SyntaxNode root, TNode original, Func<TNode, SyntaxNode> replacer) where TNode : SyntaxNode;
    public abstract SyntaxNode ReturnStatement(SyntaxNode expression = null);
    public abstract SyntaxNode StructDeclaration(string name, IEnumerable<string> typeParameters = null, Accessibility accessibility = NotApplicable, DeclarationModifiers modifiers = default, IEnumerable<SyntaxNode> interfaceTypes = null, IEnumerable<SyntaxNode> members = null);
    public abstract SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right);
    public SyntaxNode SwitchSection(SyntaxNode caseExpression, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode SwitchSection(IEnumerable<SyntaxNode> caseExpressions, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable<SyntaxNode> sections);
    public SyntaxNode SwitchStatement(SyntaxNode expression, params SyntaxNode[] sections);
    public abstract SyntaxNode ThisExpression();
    public abstract SyntaxNode ThrowExpression(SyntaxNode expression);
    public abstract SyntaxNode ThrowStatement(SyntaxNode expression = null);
    public SyntaxNode TrueLiteralExpression();
    public abstract SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type);
    public SyntaxNode TryCastExpression(SyntaxNode expression, ITypeSymbol type);
    public SyntaxNode TryCatchStatement(IEnumerable<SyntaxNode> tryStatements, params SyntaxNode[] catchClauses);
    public abstract SyntaxNode TryCatchStatement(IEnumerable<SyntaxNode> tryStatements, IEnumerable<SyntaxNode> catchClauses, IEnumerable<SyntaxNode> finallyStatements = null);
    public SyntaxNode TryFinallyStatement(IEnumerable<SyntaxNode> tryStatements, IEnumerable<SyntaxNode> finallyStatements);
    public abstract SyntaxNode TypeExpression(SpecialType specialType);
    public abstract SyntaxNode TypeExpression(ITypeSymbol typeSymbol);
    public SyntaxNode TypeExpression(ITypeSymbol typeSymbol, bool addImport);
    public abstract SyntaxNode TypeOfExpression(SyntaxNode type);
    public abstract SyntaxNode TypedConstantExpression(TypedConstant value);
    public abstract SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable<SyntaxNode> statements);
    public SyntaxNode UsingStatement(string name, SyntaxNode expression, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode UsingStatement(SyntaxNode type, string name, SyntaxNode expression, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public SyntaxNode ValueReturningLambdaExpression(SyntaxNode expression);
    public SyntaxNode ValueReturningLambdaExpression(IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode ValueReturningLambdaExpression(IEnumerable<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public abstract SyntaxNode ValueReturningLambdaExpression(IEnumerable<SyntaxNode> lambdaParameters, IEnumerable<SyntaxNode> statements);
    public SyntaxNode ValueReturningLambdaExpression(string parameterName, SyntaxNode expression);
    public SyntaxNode ValueReturningLambdaExpression(string parameterName, IEnumerable<SyntaxNode> statements);
    public SyntaxNode VoidReturningLambdaExpression(SyntaxNode expression);
    public SyntaxNode VoidReturningLambdaExpression(IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode VoidReturningLambdaExpression(IEnumerable<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public abstract SyntaxNode VoidReturningLambdaExpression(IEnumerable<SyntaxNode> lambdaParameters, IEnumerable<SyntaxNode> statements);
    public SyntaxNode VoidReturningLambdaExpression(string parameterName, SyntaxNode expression);
    public SyntaxNode VoidReturningLambdaExpression(string parameterName, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility);
    public abstract SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression);
    public abstract SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers);
    public abstract SyntaxNode WithName(SyntaxNode declaration, string name);
    public abstract SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable<SyntaxNode> statements);
    public abstract SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type);
    public abstract SyntaxNode WithTypeArguments(SyntaxNode expression, IEnumerable<SyntaxNode> typeArguments);
    public SyntaxNode WithTypeArguments(SyntaxNode expression, params SyntaxNode[] typeArguments);
    public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, params SyntaxNode[] types);
    public abstract SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable<SyntaxNode> types = null);
    public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, params SyntaxNode[] types);
    public abstract SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable<string> typeParameters);
    public SyntaxNode WithTypeParameters(SyntaxNode declaration, params string[] typeParameters);

  public sealed class Microsoft.CodeAnalysis.Emit.EmitBaseline

    public ModuleMetadata OriginalMetadata { get; }

    public static EmitBaseline CreateInitialBaseline(ModuleMetadata module, Func<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider);

  public sealed class Microsoft.CodeAnalysis.Emit.EmitOptions : IEquatable<EmitOptions>

    public EmitOptions(bool metadataOnly, DebugInformationFormat debugInformationFormat, string pdbFilePath, string outputNameOverride, int fileAlignment, ulong baseAddress, bool highEntropyVirtualAddressSpace, SubsystemVersion subsystemVersion, string runtimeMetadataVersion, bool tolerateErrors, bool includePrivateMembers);
    public EmitOptions(bool metadataOnly = false, DebugInformationFormat debugInformationFormat = (DebugInformationFormat)0, string pdbFilePath = null, string outputNameOverride = null, int fileAlignment = 0, ulong baseAddress = 0, bool highEntropyVirtualAddressSpace = false, SubsystemVersion subsystemVersion = default, string runtimeMetadataVersion = null, bool tolerateErrors = false, bool includePrivateMembers = true, ImmutableArray<InstrumentationKind> instrumentationKinds = default);

    public ulong BaseAddress { get; }
    public DebugInformationFormat DebugInformationFormat { get; }
    public bool EmitMetadataOnly { get; }
    public int FileAlignment { get; }
    public bool HighEntropyVirtualAddressSpace { get; }
    public bool IncludePrivateMembers { get; }
    public ImmutableArray<InstrumentationKind> InstrumentationKinds { get; }
    public string OutputNameOverride { get; }
    public string PdbFilePath { get; }
    public string RuntimeMetadataVersion { get; }
    public SubsystemVersion SubsystemVersion { get; }
    public bool TolerateErrors { get; }

    public override bool Equals(object obj);
    public bool Equals(EmitOptions other);
    public override int GetHashCode();
    public EmitOptions WithBaseAddress(ulong value);
    public EmitOptions WithDebugInformationFormat(DebugInformationFormat format);
    public EmitOptions WithEmitMetadataOnly(bool value);
    public EmitOptions WithFileAlignment(int value);
    public EmitOptions WithHighEntropyVirtualAddressSpace(bool value);
    public EmitOptions WithIncludePrivateMembers(bool value);
    public EmitOptions WithInstrumentationKinds(ImmutableArray<InstrumentationKind> instrumentationKinds);
    public EmitOptions WithOutputNameOverride(string outputName);
    public EmitOptions WithPdbFilePath(string path);
    public EmitOptions WithRuntimeMetadataVersion(string version);
    public EmitOptions WithSubsystemVersion(SubsystemVersion subsystemVersion);
    public EmitOptions WithTolerateErrors(bool value);

    public static bool operator ==(EmitOptions left, EmitOptions right);
    public static bool operator !=(EmitOptions left, EmitOptions right);

  public class Microsoft.CodeAnalysis.Emit.EmitResult

    public ImmutableArray<Diagnostic> Diagnostics { get; }
    public bool Success { get; }

    protected virtual string GetDebuggerDisplay();

    public sealed class Microsoft.CodeAnalysis.Emit.EmitDifferenceResult : EmitResult

      public EmitBaseline Baseline { get; }

  public class Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol

    public ISymbol Definition { get; }
    public IEnumerable<ReferenceLocation> Locations { get; }

  public abstract class Microsoft.CodeAnalysis.Host.HostLanguageServices

    protected HostLanguageServices();

    public abstract string Language { get; }
    public abstract HostWorkspaceServices WorkspaceServices { get; }

    public TLanguageService GetRequiredService<TLanguageService>() where TLanguageService : ILanguageService;
    public abstract TLanguageService GetService<TLanguageService>() where TLanguageService : ILanguageService;

  public abstract class Microsoft.CodeAnalysis.Host.HostServices

    protected HostServices();

    protected internal abstract HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);

    public class Microsoft.CodeAnalysis.Host.Mef.MefHostServices : HostServices, IMefHostExportProvider

      public MefHostServices(CompositionContext compositionContext);

      public static ImmutableArray<Assembly> DefaultAssemblies { get; }
      public static MefHostServices DefaultHost { get; }

      public static MefHostServices Create(IEnumerable<Assembly> assemblies);
      public static MefHostServices Create(CompositionContext compositionContext);
      protected internal override HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);

  public abstract class Microsoft.CodeAnalysis.Host.HostWorkspaceServices

    protected HostWorkspaceServices();

    public abstract HostServices HostServices { get; }
    public virtual IPersistentStorageService PersistentStorage { get; }
    public virtual IEnumerable<string> SupportedLanguages { get; }
    public virtual ITemporaryStorageService TemporaryStorage { get; }
    public abstract Workspace Workspace { get; }

    public abstract IEnumerable<TLanguageService> FindLanguageServices<TLanguageService>(HostWorkspaceServices.MetadataFilter filter);
    public virtual HostLanguageServices GetLanguageServices(string languageName);
    public TWorkspaceService GetRequiredService<TWorkspaceService>() where TWorkspaceService : IWorkspaceService;
    public abstract TWorkspaceService GetService<TWorkspaceService>() where TWorkspaceService : IWorkspaceService;
    public virtual bool IsSupported(string languageName);

  public class Microsoft.CodeAnalysis.Options.Option<T> : IOption

    public Option(string feature, string name);
    public Option(string feature, string name, T defaultValue);
    public Option(string feature, string name, T defaultValue, params OptionStorageLocation[] storageLocations);

    public T DefaultValue { get; }
    public string Feature { get; }
    public string Name { get; }
    public ImmutableArray<OptionStorageLocation> StorageLocations { get; }
    public Type Type { get; }

    public override string ToString();

    public static implicit operator OptionKey(Option<T> option);

  public abstract class Microsoft.CodeAnalysis.Options.OptionSet

    protected OptionSet();

    public abstract object GetOption(OptionKey optionKey);
    public T GetOption<T>(Option<T> option);
    public T GetOption<T>(PerLanguageOption<T> option, string language);
    public abstract OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    public OptionSet WithChangedOption<T>(Option<T> option, T value);
    public OptionSet WithChangedOption<T>(PerLanguageOption<T> option, string language, T value);

    public sealed class Microsoft.CodeAnalysis.Options.DocumentOptionSet : OptionSet

      public override object GetOption(OptionKey optionKey);
      public T GetOption<T>(PerLanguageOption<T> option);
      public override OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);

  public abstract class Microsoft.CodeAnalysis.Options.OptionStorageLocation

    protected OptionStorageLocation();

  public class Microsoft.CodeAnalysis.Options.PerLanguageOption<T> : IOption

    public PerLanguageOption(string feature, string name, T defaultValue);
    public PerLanguageOption(string feature, string name, T defaultValue, params OptionStorageLocation[] storageLocations);

    public T DefaultValue { get; }
    public string Feature { get; }
    public string Name { get; }
    public ImmutableArray<OptionStorageLocation> StorageLocations { get; }
    public Type Type { get; }

    public override string ToString();

  public abstract class Microsoft.CodeAnalysis.Semantics.OperationVisitor

    protected OperationVisitor();

    public virtual void DefaultVisit(IOperation operation);
    public virtual void Visit(IOperation operation);
    public virtual void VisitAddressOfExpression(IAddressOfExpression operation);
    public virtual void VisitArgument(IArgument operation);
    public virtual void VisitArrayCreationExpression(IArrayCreationExpression operation);
    public virtual void VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation);
    public virtual void VisitArrayInitializer(IArrayInitializer operation);
    public virtual void VisitAssignmentExpression(IAssignmentExpression operation);
    public virtual void VisitAwaitExpression(IAwaitExpression operation);
    public virtual void VisitBinaryOperatorExpression(IBinaryOperatorExpression operation);
    public virtual void VisitBlockStatement(IBlockStatement operation);
    public virtual void VisitBranchStatement(IBranchStatement operation);
    public virtual void VisitCatchClause(ICatchClause operation);
    public virtual void VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation);
    public virtual void VisitConditionalAccessExpression(IConditionalAccessExpression operation);
    public virtual void VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation);
    public virtual void VisitConditionalChoiceExpression(IConditionalChoiceExpression operation);
    public virtual void VisitConversionExpression(IConversionExpression operation);
    public virtual void VisitDefaultValueExpression(IDefaultValueExpression operation);
    public virtual void VisitEmptyStatement(IEmptyStatement operation);
    public virtual void VisitEndStatement(IEndStatement operation);
    public virtual void VisitEventAssignmentExpression(IEventAssignmentExpression operation);
    public virtual void VisitEventReferenceExpression(IEventReferenceExpression operation);
    public virtual void VisitExpressionStatement(IExpressionStatement operation);
    public virtual void VisitFieldInitializer(IFieldInitializer operation);
    public virtual void VisitFieldReferenceExpression(IFieldReferenceExpression operation);
    public virtual void VisitFixedStatement(IFixedStatement operation);
    public virtual void VisitForEachLoopStatement(IForEachLoopStatement operation);
    public virtual void VisitForLoopStatement(IForLoopStatement operation);
    public virtual void VisitIfStatement(IIfStatement operation);
    public virtual void VisitIncrementExpression(IIncrementExpression operation);
    public virtual void VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation);
    public virtual void VisitInstanceReferenceExpression(IInstanceReferenceExpression operation);
    public virtual void VisitInvalidExpression(IInvalidExpression operation);
    public virtual void VisitInvalidStatement(IInvalidStatement operation);
    public virtual void VisitInvocationExpression(IInvocationExpression operation);
    public virtual void VisitIsTypeExpression(IIsTypeExpression operation);
    public virtual void VisitLabelStatement(ILabelStatement operation);
    public virtual void VisitLambdaExpression(ILambdaExpression operation);
    public virtual void VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation);
    public virtual void VisitLiteralExpression(ILiteralExpression operation);
    public virtual void VisitLocalReferenceExpression(ILocalReferenceExpression operation);
    public virtual void VisitLockStatement(ILockStatement operation);
    public virtual void VisitMethodBindingExpression(IMethodBindingExpression operation);
    public virtual void VisitNullCoalescingExpression(INullCoalescingExpression operation);
    public virtual void VisitObjectCreationExpression(IObjectCreationExpression operation);
    public virtual void VisitOmittedArgumentExpression(IOmittedArgumentExpression operation);
    public virtual void VisitParameterInitializer(IParameterInitializer operation);
    public virtual void VisitParameterReferenceExpression(IParameterReferenceExpression operation);
    public virtual void VisitParenthesizedExpression(IParenthesizedExpression operation);
    public virtual void VisitPlaceholderExpression(IPlaceholderExpression operation);
    public virtual void VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation);
    public virtual void VisitPropertyInitializer(IPropertyInitializer operation);
    public virtual void VisitPropertyReferenceExpression(IPropertyReferenceExpression operation);
    public virtual void VisitRangeCaseClause(IRangeCaseClause operation);
    public virtual void VisitRelationalCaseClause(IRelationalCaseClause operation);
    public virtual void VisitReturnStatement(IReturnStatement operation);
    public virtual void VisitSingleValueCaseClause(ISingleValueCaseClause operation);
    public virtual void VisitSizeOfExpression(ISizeOfExpression operation);
    public virtual void VisitStopStatement(IStopStatement operation);
    public virtual void VisitSwitchCase(ISwitchCase operation);
    public virtual void VisitSwitchStatement(ISwitchStatement operation);
    public virtual void VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation);
    public virtual void VisitThrowStatement(IThrowStatement operation);
    public virtual void VisitTryStatement(ITryStatement operation);
    public virtual void VisitTypeOfExpression(ITypeOfExpression operation);
    public virtual void VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation);
    public virtual void VisitUnaryOperatorExpression(IUnaryOperatorExpression operation);
    public virtual void VisitUnboundLambdaExpression(IUnboundLambdaExpression operation);
    public virtual void VisitUsingStatement(IUsingStatement operation);
    public virtual void VisitVariableDeclaration(IVariableDeclaration operation);
    public virtual void VisitVariableDeclarationStatement(IVariableDeclarationStatement operation);
    public virtual void VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation);
    public virtual void VisitWithStatement(IWithStatement operation);
    public virtual void VisitYieldBreakStatement(IReturnStatement operation);

    public abstract class Microsoft.CodeAnalysis.Semantics.OperationWalker : OperationVisitor

      protected OperationWalker();

      public override void Visit(IOperation operation);
      public override void VisitAddressOfExpression(IAddressOfExpression operation);
      public override void VisitArgument(IArgument operation);
      public override void VisitArrayCreationExpression(IArrayCreationExpression operation);
      public override void VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation);
      public override void VisitArrayInitializer(IArrayInitializer operation);
      public override void VisitAssignmentExpression(IAssignmentExpression operation);
      public override void VisitAwaitExpression(IAwaitExpression operation);
      public override void VisitBinaryOperatorExpression(IBinaryOperatorExpression operation);
      public override void VisitBlockStatement(IBlockStatement operation);
      public override void VisitBranchStatement(IBranchStatement operation);
      public override void VisitCatchClause(ICatchClause operation);
      public override void VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation);
      public override void VisitConditionalAccessExpression(IConditionalAccessExpression operation);
      public override void VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation);
      public override void VisitConditionalChoiceExpression(IConditionalChoiceExpression operation);
      public override void VisitConversionExpression(IConversionExpression operation);
      public override void VisitDefaultValueExpression(IDefaultValueExpression operation);
      public override void VisitEmptyStatement(IEmptyStatement operation);
      public override void VisitEndStatement(IEndStatement operation);
      public override void VisitEventAssignmentExpression(IEventAssignmentExpression operation);
      public override void VisitEventReferenceExpression(IEventReferenceExpression operation);
      public override void VisitExpressionStatement(IExpressionStatement operation);
      public override void VisitFieldInitializer(IFieldInitializer operation);
      public override void VisitFieldReferenceExpression(IFieldReferenceExpression operation);
      public override void VisitFixedStatement(IFixedStatement operation);
      public override void VisitForEachLoopStatement(IForEachLoopStatement operation);
      public override void VisitForLoopStatement(IForLoopStatement operation);
      public override void VisitIfStatement(IIfStatement operation);
      public override void VisitIncrementExpression(IIncrementExpression operation);
      public override void VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation);
      public override void VisitInstanceReferenceExpression(IInstanceReferenceExpression operation);
      public override void VisitInvalidExpression(IInvalidExpression operation);
      public override void VisitInvalidStatement(IInvalidStatement operation);
      public override void VisitInvocationExpression(IInvocationExpression operation);
      public override void VisitIsTypeExpression(IIsTypeExpression operation);
      public override void VisitLabelStatement(ILabelStatement operation);
      public override void VisitLambdaExpression(ILambdaExpression operation);
      public override void VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation);
      public override void VisitLiteralExpression(ILiteralExpression operation);
      public override void VisitLocalReferenceExpression(ILocalReferenceExpression operation);
      public override void VisitLockStatement(ILockStatement operation);
      public override void VisitMethodBindingExpression(IMethodBindingExpression operation);
      public override void VisitNullCoalescingExpression(INullCoalescingExpression operation);
      public override void VisitObjectCreationExpression(IObjectCreationExpression operation);
      public override void VisitOmittedArgumentExpression(IOmittedArgumentExpression operation);
      public override void VisitParameterInitializer(IParameterInitializer operation);
      public override void VisitParameterReferenceExpression(IParameterReferenceExpression operation);
      public override void VisitParenthesizedExpression(IParenthesizedExpression operation);
      public override void VisitPlaceholderExpression(IPlaceholderExpression operation);
      public override void VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation);
      public override void VisitPropertyInitializer(IPropertyInitializer operation);
      public override void VisitPropertyReferenceExpression(IPropertyReferenceExpression operation);
      public override void VisitRangeCaseClause(IRangeCaseClause operation);
      public override void VisitRelationalCaseClause(IRelationalCaseClause operation);
      public override void VisitReturnStatement(IReturnStatement operation);
      public override void VisitSingleValueCaseClause(ISingleValueCaseClause operation);
      public override void VisitSizeOfExpression(ISizeOfExpression operation);
      public override void VisitStopStatement(IStopStatement operation);
      public override void VisitSwitchCase(ISwitchCase operation);
      public override void VisitSwitchStatement(ISwitchStatement operation);
      public override void VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation);
      public override void VisitThrowStatement(IThrowStatement operation);
      public override void VisitTryStatement(ITryStatement operation);
      public override void VisitTypeOfExpression(ITypeOfExpression operation);
      public override void VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation);
      public override void VisitUnaryOperatorExpression(IUnaryOperatorExpression operation);
      public override void VisitUnboundLambdaExpression(IUnboundLambdaExpression operation);
      public override void VisitUsingStatement(IUsingStatement operation);
      public override void VisitVariableDeclaration(IVariableDeclaration operation);
      public override void VisitVariableDeclarationStatement(IVariableDeclarationStatement operation);
      public override void VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation);
      public override void VisitWithStatement(IWithStatement operation);
      public override void VisitYieldBreakStatement(IReturnStatement operation);

  public abstract class Microsoft.CodeAnalysis.Semantics.OperationVisitor<TArgument, TResult>

    protected OperationVisitor();

    public virtual TResult DefaultVisit(IOperation operation, TArgument argument);
    public virtual TResult Visit(IOperation operation, TArgument argument);
    public virtual TResult VisitAddressOfExpression(IAddressOfExpression operation, TArgument argument);
    public virtual TResult VisitArgument(IArgument operation, TArgument argument);
    public virtual TResult VisitArrayCreationExpression(IArrayCreationExpression operation, TArgument argument);
    public virtual TResult VisitArrayElementReferenceExpression(IArrayElementReferenceExpression operation, TArgument argument);
    public virtual TResult VisitArrayInitializer(IArrayInitializer operation, TArgument argument);
    public virtual TResult VisitAssignmentExpression(IAssignmentExpression operation, TArgument argument);
    public virtual TResult VisitAwaitExpression(IAwaitExpression operation, TArgument argument);
    public virtual TResult VisitBinaryOperatorExpression(IBinaryOperatorExpression operation, TArgument argument);
    public virtual TResult VisitBlockStatement(IBlockStatement operation, TArgument argument);
    public virtual TResult VisitBranchStatement(IBranchStatement operation, TArgument argument);
    public virtual TResult VisitCatchClause(ICatchClause operation, TArgument argument);
    public virtual TResult VisitCompoundAssignmentExpression(ICompoundAssignmentExpression operation, TArgument argument);
    public virtual TResult VisitConditionalAccessExpression(IConditionalAccessExpression operation, TArgument argument);
    public virtual TResult VisitConditionalAccessInstanceExpression(IConditionalAccessInstanceExpression operation, TArgument argument);
    public virtual TResult VisitConditionalChoiceExpression(IConditionalChoiceExpression operation, TArgument argument);
    public virtual TResult VisitConversionExpression(IConversionExpression operation, TArgument argument);
    public virtual TResult VisitDefaultValueExpression(IDefaultValueExpression operation, TArgument argument);
    public virtual TResult VisitEmptyStatement(IEmptyStatement operation, TArgument argument);
    public virtual TResult VisitEndStatement(IEndStatement operation, TArgument argument);
    public virtual TResult VisitEventAssignmentExpression(IEventAssignmentExpression operation, TArgument argument);
    public virtual TResult VisitEventReferenceExpression(IEventReferenceExpression operation, TArgument argument);
    public virtual TResult VisitExpressionStatement(IExpressionStatement operation, TArgument argument);
    public virtual TResult VisitFieldInitializer(IFieldInitializer operation, TArgument argument);
    public virtual TResult VisitFieldReferenceExpression(IFieldReferenceExpression operation, TArgument argument);
    public virtual TResult VisitFixedStatement(IFixedStatement operation, TArgument argument);
    public virtual TResult VisitForEachLoopStatement(IForEachLoopStatement operation, TArgument argument);
    public virtual TResult VisitForLoopStatement(IForLoopStatement operation, TArgument argument);
    public virtual TResult VisitIfStatement(IIfStatement operation, TArgument argument);
    public virtual TResult VisitIncrementExpression(IIncrementExpression operation, TArgument argument);
    public virtual TResult VisitIndexedPropertyReferenceExpression(IIndexedPropertyReferenceExpression operation, TArgument argument);
    public virtual TResult VisitInstanceReferenceExpression(IInstanceReferenceExpression operation, TArgument argument);
    public virtual TResult VisitInvalidExpression(IInvalidExpression operation, TArgument argument);
    public virtual TResult VisitInvalidStatement(IInvalidStatement operation, TArgument argument);
    public virtual TResult VisitInvocationExpression(IInvocationExpression operation, TArgument argument);
    public virtual TResult VisitIsTypeExpression(IIsTypeExpression operation, TArgument argument);
    public virtual TResult VisitLabelStatement(ILabelStatement operation, TArgument argument);
    public virtual TResult VisitLambdaExpression(ILambdaExpression operation, TArgument argument);
    public virtual TResult VisitLateBoundMemberReferenceExpression(ILateBoundMemberReferenceExpression operation, TArgument argument);
    public virtual TResult VisitLiteralExpression(ILiteralExpression operation, TArgument argument);
    public virtual TResult VisitLocalReferenceExpression(ILocalReferenceExpression operation, TArgument argument);
    public virtual TResult VisitLockStatement(ILockStatement operation, TArgument argument);
    public virtual TResult VisitMethodBindingExpression(IMethodBindingExpression operation, TArgument argument);
    public virtual TResult VisitNullCoalescingExpression(INullCoalescingExpression operation, TArgument argument);
    public virtual TResult VisitObjectCreationExpression(IObjectCreationExpression operation, TArgument argument);
    public virtual TResult VisitOmittedArgumentExpression(IOmittedArgumentExpression operation, TArgument argument);
    public virtual TResult VisitParameterInitializer(IParameterInitializer operation, TArgument argument);
    public virtual TResult VisitParameterReferenceExpression(IParameterReferenceExpression operation, TArgument argument);
    public virtual TResult VisitParenthesizedExpression(IParenthesizedExpression operation, TArgument argument);
    public virtual TResult VisitPlaceholderExpression(IPlaceholderExpression operation, TArgument argument);
    public virtual TResult VisitPointerIndirectionReferenceExpression(IPointerIndirectionReferenceExpression operation, TArgument argument);
    public virtual TResult VisitPropertyInitializer(IPropertyInitializer operation, TArgument argument);
    public virtual TResult VisitPropertyReferenceExpression(IPropertyReferenceExpression operation, TArgument argument);
    public virtual TResult VisitRangeCaseClause(IRangeCaseClause operation, TArgument argument);
    public virtual TResult VisitRelationalCaseClause(IRelationalCaseClause operation, TArgument argument);
    public virtual TResult VisitReturnStatement(IReturnStatement operation, TArgument argument);
    public virtual TResult VisitSingleValueCaseClause(ISingleValueCaseClause operation, TArgument argument);
    public virtual TResult VisitSizeOfExpression(ISizeOfExpression operation, TArgument argument);
    public virtual TResult VisitStopStatement(IStopStatement operation, TArgument argument);
    public virtual TResult VisitSwitchCase(ISwitchCase operation, TArgument argument);
    public virtual TResult VisitSwitchStatement(ISwitchStatement operation, TArgument argument);
    public virtual TResult VisitSyntheticLocalReferenceExpression(ISyntheticLocalReferenceExpression operation, TArgument argument);
    public virtual TResult VisitThrowStatement(IThrowStatement operation, TArgument argument);
    public virtual TResult VisitTryStatement(ITryStatement operation, TArgument argument);
    public virtual TResult VisitTypeOfExpression(ITypeOfExpression operation, TArgument argument);
    public virtual TResult VisitTypeParameterObjectCreationExpression(ITypeParameterObjectCreationExpression operation, TArgument argument);
    public virtual TResult VisitUnaryOperatorExpression(IUnaryOperatorExpression operation, TArgument argument);
    public virtual TResult VisitUnboundLambdaExpression(IUnboundLambdaExpression operation, TArgument argument);
    public virtual TResult VisitUsingStatement(IUsingStatement operation, TArgument argument);
    public virtual TResult VisitVariableDeclaration(IVariableDeclaration operation, TArgument argument);
    public virtual TResult VisitVariableDeclarationStatement(IVariableDeclarationStatement operation, TArgument argument);
    public virtual TResult VisitWhileUntilLoopStatement(IWhileUntilLoopStatement operation, TArgument argument);
    public virtual TResult VisitWithStatement(IWithStatement operation, TArgument argument);
    public virtual TResult VisitYieldBreakStatement(IReturnStatement operation, TArgument argument);

  public abstract class Microsoft.CodeAnalysis.Text.SourceText

    protected SourceText(ImmutableArray<byte> checksum = default, SourceHashAlgorithm checksumAlgorithm = Sha1, SourceTextContainer container = null);

    public bool CanBeEmbedded { get; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; }
    public virtual SourceTextContainer Container { get; }
    public abstract Encoding Encoding { get; }
    public abstract int Length { get; }
    public TextLineCollection Lines { get; }

    public abstract char this[int position] { get; }

    public bool ContentEquals(SourceText other);
    protected virtual bool ContentEqualsImpl(SourceText other);
    public abstract void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
    public static SourceText From(string text, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1);
    public static SourceText From(TextReader reader, int length, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1);
    public static SourceText From(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    public static SourceText From(byte[] buffer, int length, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    public static SourceText From(Stream stream, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false);
    public static SourceText From(byte[] buffer, int length, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = Sha1, bool throwIfBinaryDetected = false, bool canBeEmbedded = false);
    public virtual IReadOnlyList<TextChangeRange> GetChangeRanges(SourceText oldText);
    public ImmutableArray<byte> GetChecksum();
    protected virtual TextLineCollection GetLinesCore();
    public virtual SourceText GetSubText(TextSpan span);
    public SourceText GetSubText(int start);
    public virtual IReadOnlyList<TextChange> GetTextChanges(SourceText oldText);
    public SourceText Replace(TextSpan span, string newText);
    public SourceText Replace(int start, int length, string newText);
    public override string ToString();
    public virtual string ToString(TextSpan span);
    public virtual SourceText WithChanges(IEnumerable<TextChange> changes);
    public SourceText WithChanges(params TextChange[] changes);
    public void Write(TextWriter textWriter, CancellationToken cancellationToken = default);
    public virtual void Write(TextWriter writer, TextSpan span, CancellationToken cancellationToken = default);

  public abstract class Microsoft.CodeAnalysis.Text.SourceTextContainer

    protected SourceTextContainer();

    public abstract event EventHandler<TextChangeEventArgs> TextChanged;

    public abstract SourceText CurrentText { get; }

  public abstract class Microsoft.CodeAnalysis.Text.TextLineCollection : IEnumerable<TextLine>, IReadOnlyCollection<TextLine>, IReadOnlyList<TextLine>

    protected TextLineCollection();

    public abstract int Count { get; }

    public abstract TextLine this[int index] { get; }

    public TextLineCollection.Enumerator GetEnumerator();
    public virtual TextLine GetLineFromPosition(int position);
    public virtual LinePosition GetLinePosition(int position);
    public LinePositionSpan GetLinePositionSpan(TextSpan span);
    public int GetPosition(LinePosition position);
    public TextSpan GetTextSpan(LinePositionSpan span);
    public abstract int IndexOf(int position);

  public abstract class Roslynator.NameGenerator

    protected NameGenerator();

    public static NameGenerator Default { get; }

    public static string CreateName(ITypeSymbol typeSymbol, bool firstCharToLower = false);
    public string EnsureUniqueEnumMemberName(string baseName, INamedTypeSymbol enumType, bool isCaseSensitive = true);
    public string EnsureUniqueLocalName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default);
    public string EnsureUniqueMemberName(string baseName, INamedTypeSymbol typeSymbol, bool isCaseSensitive = true);
    public string EnsureUniqueMemberName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true, CancellationToken cancellationToken = default);
    public abstract string EnsureUniqueName(string baseName, IEnumerable<string> reservedNames, bool isCaseSensitive = true);
    public abstract string EnsureUniqueName(string baseName, ImmutableArray<ISymbol> symbols, bool isCaseSensitive = true);
    public string EnsureUniqueName(string baseName, SemanticModel semanticModel, int position, bool isCaseSensitive = true);
    public static bool IsUniqueName(string name, IEnumerable<string> reservedNames, bool isCaseSensitive = true);
    public static bool IsUniqueName(string name, ImmutableArray<ISymbol> symbols, bool isCaseSensitive = true);

  public class Roslynator.SeparatedSyntaxListSelection<TNode> : ISelection<TNode> where TNode : SyntaxNode

    protected SeparatedSyntaxListSelection(SeparatedSyntaxList<TNode> list, TextSpan span, int firstIndex, int lastIndex);

    public int Count { get; }
    public int FirstIndex { get; }
    public int LastIndex { get; }
    public TextSpan OriginalSpan { get; }
    public SeparatedSyntaxList<TNode> UnderlyingList { get; }

    public TNode this[int index] { get; }

    public static SeparatedSyntaxListSelection<TNode> Create(SeparatedSyntaxList<TNode> list, TextSpan span);
    public TNode First();
    public SeparatedSyntaxListSelection<TNode>.Enumerator GetEnumerator();
    public TNode Last();
    public static bool TryCreate(SeparatedSyntaxList<TNode> list, TextSpan span, out SeparatedSyntaxListSelection<TNode> selection);

  public class Roslynator.SyntaxListSelection<TNode> : ISelection<TNode> where TNode : SyntaxNode

    protected SyntaxListSelection(SyntaxList<TNode> list, TextSpan span, int firstIndex, int lastIndex);

    public int Count { get; }
    public int FirstIndex { get; }
    public int LastIndex { get; }
    public TextSpan OriginalSpan { get; }
    public SyntaxList<TNode> UnderlyingList { get; }

    public TNode this[int index] { get; }

    public static SyntaxListSelection<TNode> Create(SyntaxList<TNode> list, TextSpan span);
    public TNode First();
    public SyntaxListSelection<TNode>.Enumerator GetEnumerator();
    public TNode Last();
    public static bool TryCreate(SyntaxList<TNode> list, TextSpan span, out SyntaxListSelection<TNode> selection);

    public sealed class Roslynator.CSharp.MemberDeclarationListSelection : SyntaxListSelection<MemberDeclarationSyntax>

      public SyntaxNode Parent { get; }

      public static MemberDeclarationListSelection Create(CompilationUnitSyntax compilationUnit, TextSpan span);
      public static MemberDeclarationListSelection Create(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span);
      public static MemberDeclarationListSelection Create(TypeDeclarationSyntax typeDeclaration, TextSpan span);
      public static bool TryCreate(NamespaceDeclarationSyntax namespaceDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers);
      public static bool TryCreate(TypeDeclarationSyntax typeDeclaration, TextSpan span, out MemberDeclarationListSelection selectedMembers);

    public sealed class Roslynator.CSharp.StatementListSelection : SyntaxListSelection<StatementSyntax>

      public static StatementListSelection Create(BlockSyntax block, TextSpan span);
      public static StatementListSelection Create(SwitchSectionSyntax switchSection, TextSpan span);
      public static StatementListSelection Create(in StatementListInfo statementsInfo, TextSpan span);
      public static bool TryCreate(BlockSyntax block, TextSpan span, out StatementListSelection selectedStatements);
      public static bool TryCreate(SwitchSectionSyntax switchSection, TextSpan span, out StatementListSelection selectedStatements);

  public abstract class Roslynator.CSharp.ModifierList<TNode> where TNode : SyntaxNode

    public static ModifierList<TNode> Instance { get; }

    public TNode Insert(TNode node, SyntaxKind kind, IComparer<SyntaxKind> comparer = null);
    public TNode Insert(TNode node, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null);
    public TNode Remove(TNode node, SyntaxKind kind);
    public TNode Remove(TNode node, SyntaxToken modifier);
    public TNode RemoveAll(TNode node);
    public TNode RemoveAll(TNode node, Func<SyntaxToken, bool> predicate);
    public TNode RemoveAt(TNode node, int index);

  public class Roslynator.Text.TextLineCollectionSelection : ISelection<TextLine>

    protected TextLineCollectionSelection(TextLineCollection lines, TextSpan span, int firstIndex, int lastIndex);

    public int Count { get; }
    public int FirstIndex { get; }
    public int LastIndex { get; }
    public TextSpan OriginalSpan { get; }
    public TextLineCollection UnderlyingLines { get; }

    public TextLine this[int index] { get; }

    public static TextLineCollectionSelection Create(TextLineCollection lines, TextSpan span);
    public TextLine First();
    public TextLineCollectionSelection.Enumerator GetEnumerator();
    public TextLine Last();
    public static bool TryCreate(TextLineCollection lines, TextSpan span, out TextLineCollectionSelection selectedLines);

  public static class Microsoft.CodeAnalysis.AnnotationExtensions

    public static TNode WithAdditionalAnnotations<TNode>(this TNode node, params SyntaxAnnotation[] annotations) where TNode : SyntaxNode;
    public static TNode WithAdditionalAnnotations<TNode>(this TNode node, IEnumerable<SyntaxAnnotation> annotations) where TNode : SyntaxNode;
    public static TNode WithoutAnnotations<TNode>(this TNode node, string annotationKind) where TNode : SyntaxNode;
    public static TNode WithoutAnnotations<TNode>(this TNode node, params SyntaxAnnotation[] annotations) where TNode : SyntaxNode;
    public static TNode WithoutAnnotations<TNode>(this TNode node, IEnumerable<SyntaxAnnotation> annotations) where TNode : SyntaxNode;

  public static class Microsoft.CodeAnalysis.CSharpExtensions

    public static bool Any(this SyntaxTriviaList list, SyntaxKind kind);
    public static bool Any(this SyntaxTokenList list, SyntaxKind kind);
    public static bool Any<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static int IndexOf(this SyntaxTriviaList list, SyntaxKind kind);
    public static int IndexOf(this SyntaxTokenList list, SyntaxKind kind);
    public static int IndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind);
    public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, SyntaxKind kind);
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind);
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind);

  public static class Microsoft.CodeAnalysis.CaseInsensitiveComparison

    public static StringComparer Comparer { get; }

    public static int Compare(string left, string right);
    public static bool EndsWith(string value, string possibleEnd);
    public static bool Equals(string left, string right);
    public static int GetHashCode(string value);
    public static bool StartsWith(string value, string possibleStart);
    public static void ToLower(StringBuilder builder);
    public static char ToLower(char c);
    public static string ToLower(string value);

  public static class Microsoft.CodeAnalysis.DocumentationCommentId

    public static string CreateDeclarationId(ISymbol symbol);
    public static string CreateReferenceId(ISymbol symbol);
    public static ISymbol GetFirstSymbolForDeclarationId(string id, Compilation compilation);
    public static ISymbol GetFirstSymbolForReferenceId(string id, Compilation compilation);
    public static ImmutableArray<ISymbol> GetSymbolsForDeclarationId(string id, Compilation compilation);
    public static ImmutableArray<ISymbol> GetSymbolsForReferenceId(string id, Compilation compilation);

  public static class Microsoft.CodeAnalysis.FileSystemExtensions

    public static EmitResult Emit(this Compilation compilation, string outputPath, string pdbPath = null, string xmlDocPath = null, string win32ResourcesPath = null, IEnumerable<ResourceDescription> manifestResources = null, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.ISymbolExtensions

    public static IMethodSymbol GetConstructedReducedFrom(this IMethodSymbol method);

  public static class Microsoft.CodeAnalysis.LanguageNames

    public const string CSharp = "C#";
    public const string FSharp = "F#";
    public const string VisualBasic = "Visual Basic";

  public static class Microsoft.CodeAnalysis.ModelExtensions

    public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, SyntaxNode statement);
    public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, SyntaxNode statementOrExpression);
    public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, SyntaxNode nameSyntax, CancellationToken cancellationToken = default);
    public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken = default);
    public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default);
    public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default);
    public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.SymbolDisplayExtensions

    public static string ToDisplayString(this ImmutableArray<SymbolDisplayPart> parts);

  public static class Microsoft.CodeAnalysis.SyntaxNodeExtensions

    public static TNode GetCurrentNode<TNode>(this SyntaxNode root, TNode node) where TNode : SyntaxNode;
    public static IEnumerable<TNode> GetCurrentNodes<TNode>(this SyntaxNode root, TNode node) where TNode : SyntaxNode;
    public static IEnumerable<TNode> GetCurrentNodes<TNode>(this SyntaxNode root, IEnumerable<TNode> nodes) where TNode : SyntaxNode;
    public static TRoot InsertNodesAfter<TRoot>(this TRoot root, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes) where TRoot : SyntaxNode;
    public static TRoot InsertNodesBefore<TRoot>(this TRoot root, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes) where TRoot : SyntaxNode;
    public static TRoot InsertTokensAfter<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens) where TRoot : SyntaxNode;
    public static TRoot InsertTokensBefore<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens) where TRoot : SyntaxNode;
    public static TRoot InsertTriviaAfter<TRoot>(this TRoot root, SyntaxTrivia trivia, IEnumerable<SyntaxTrivia> newTrivia) where TRoot : SyntaxNode;
    public static TRoot InsertTriviaBefore<TRoot>(this TRoot root, SyntaxTrivia trivia, IEnumerable<SyntaxTrivia> newTrivia) where TRoot : SyntaxNode;
    public static TNode NormalizeWhitespace<TNode>(this TNode node, string indentation, bool elasticTrivia) where TNode : SyntaxNode;
    public static TNode NormalizeWhitespace<TNode>(this TNode node, string indentation = "    ", string eol = "\r\n", bool elasticTrivia = false) where TNode : SyntaxNode;
    public static TRoot RemoveNode<TRoot>(this TRoot root, SyntaxNode node, SyntaxRemoveOptions options) where TRoot : SyntaxNode;
    public static TRoot RemoveNodes<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options) where TRoot : SyntaxNode;
    public static TRoot ReplaceNode<TRoot>(this TRoot root, SyntaxNode oldNode, SyntaxNode newNode) where TRoot : SyntaxNode;
    public static TRoot ReplaceNode<TRoot>(this TRoot root, SyntaxNode oldNode, IEnumerable<SyntaxNode> newNodes) where TRoot : SyntaxNode;
    public static TRoot ReplaceNodes<TRoot, TNode>(this TRoot root, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNode) where TRoot : SyntaxNode where TNode : SyntaxNode;
    public static TRoot ReplaceSyntax<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes, Func<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, IEnumerable<SyntaxToken> tokens, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia) where TRoot : SyntaxNode;
    public static TRoot ReplaceToken<TRoot>(this TRoot root, SyntaxToken oldToken, SyntaxToken newToken) where TRoot : SyntaxNode;
    public static TRoot ReplaceToken<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens) where TRoot : SyntaxNode;
    public static TRoot ReplaceTokens<TRoot>(this TRoot root, IEnumerable<SyntaxToken> tokens, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken) where TRoot : SyntaxNode;
    public static TRoot ReplaceTrivia<TRoot>(this TRoot root, SyntaxTrivia oldTrivia, IEnumerable<SyntaxTrivia> newTrivia) where TRoot : SyntaxNode;
    public static TRoot ReplaceTrivia<TRoot>(this TRoot root, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia) where TRoot : SyntaxNode;
    public static TRoot ReplaceTrivia<TRoot>(this TRoot root, SyntaxTrivia trivia, SyntaxTrivia newTrivia) where TRoot : SyntaxNode;
    public static TRoot TrackNodes<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes) where TRoot : SyntaxNode;
    public static TRoot TrackNodes<TRoot>(this TRoot root, params SyntaxNode[] nodes) where TRoot : SyntaxNode;
    public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, SyntaxTriviaList trivia) where TSyntax : SyntaxNode;
    public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, IEnumerable<SyntaxTrivia> trivia) where TSyntax : SyntaxNode;
    public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, params SyntaxTrivia[] trivia) where TSyntax : SyntaxNode;
    public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, SyntaxTriviaList trivia) where TSyntax : SyntaxNode;
    public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, IEnumerable<SyntaxTrivia> trivia) where TSyntax : SyntaxNode;
    public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, params SyntaxTrivia[] trivia) where TSyntax : SyntaxNode;
    public static TSyntax WithTriviaFrom<TSyntax>(this TSyntax syntax, SyntaxNode node) where TSyntax : SyntaxNode;
    public static TSyntax WithoutLeadingTrivia<TSyntax>(this TSyntax node) where TSyntax : SyntaxNode;
    public static TSyntax WithoutTrailingTrivia<TSyntax>(this TSyntax node) where TSyntax : SyntaxNode;
    public static SyntaxToken WithoutTrivia(this SyntaxToken token);
    public static TSyntax WithoutTrivia<TSyntax>(this TSyntax syntax) where TSyntax : SyntaxNode;

  public static class Microsoft.CodeAnalysis.WellKnownDiagnosticTags

    public const string AnalyzerException = "AnalyzerException";
    public const string Build = "Build";
    public const string Compiler = "Compiler";
    public const string EditAndContinue = "EditAndContinue";
    public const string NotConfigurable = "NotConfigurable";
    public const string Telemetry = "Telemetry";
    public const string Unnecessary = "Unnecessary";

  public static class Microsoft.CodeAnalysis.WellKnownMemberNames

    public const string AdditionOperatorName = "op_Addition";
    public const string BitwiseAndOperatorName = "op_BitwiseAnd";
    public const string BitwiseOrOperatorName = "op_BitwiseOr";
    public const string CollectionInitializerAddMethodName = "Add";
    public const string ConcatenateOperatorName = "op_Concatenate";
    public const string CurrentPropertyName = "Current";
    public const string DecrementOperatorName = "op_Decrement";
    public const string DefaultScriptClassName = "Script";
    public const string DelegateBeginInvokeName = "BeginInvoke";
    public const string DelegateEndInvokeName = "EndInvoke";
    public const string DelegateInvokeName = "Invoke";
    public const string DestructorName = "Finalize";
    public const string DivisionOperatorName = "op_Division";
    public const string EntryPointMethodName = "Main";
    public const string EnumBackingFieldName = "value__";
    public const string EqualityOperatorName = "op_Equality";
    public const string ExclusiveOrOperatorName = "op_ExclusiveOr";
    public const string ExplicitConversionName = "op_Explicit";
    public const string ExponentOperatorName = "op_Exponent";
    public const string FalseOperatorName = "op_False";
    public const string GetAwaiter = "GetAwaiter";
    public const string GetEnumeratorMethodName = "GetEnumerator";
    public const string GetResult = "GetResult";
    public const string GreaterThanOperatorName = "op_GreaterThan";
    public const string GreaterThanOrEqualOperatorName = "op_GreaterThanOrEqual";
    public const string ImplicitConversionName = "op_Implicit";
    public const string IncrementOperatorName = "op_Increment";
    public const string Indexer = "this[]";
    public const string InequalityOperatorName = "op_Inequality";
    public const string InstanceConstructorName = ".ctor";
    public const string IntegerDivisionOperatorName = "op_IntegerDivision";
    public const string IsCompleted = "IsCompleted";
    public const string LeftShiftOperatorName = "op_LeftShift";
    public const string LessThanOperatorName = "op_LessThan";
    public const string LessThanOrEqualOperatorName = "op_LessThanOrEqual";
    public const string LikeOperatorName = "op_Like";
    public const string LogicalAndOperatorName = "op_LogicalAnd";
    public const string LogicalNotOperatorName = "op_LogicalNot";
    public const string LogicalOrOperatorName = "op_LogicalOr";
    public const string ModulusOperatorName = "op_Modulus";
    public const string MoveNextMethodName = "MoveNext";
    public const string MultiplyOperatorName = "op_Multiply";
    public const string ObjectEquals = "Equals";
    public const string ObjectGetHashCode = "GetHashCode";
    public const string ObjectToString = "ToString";
    public const string OnCompleted = "OnCompleted";
    public const string OnesComplementOperatorName = "op_OnesComplement";
    public const string RightShiftOperatorName = "op_RightShift";
    public const string StaticConstructorName = ".cctor";
    public const string SubtractionOperatorName = "op_Subtraction";
    public const string TrueOperatorName = "op_True";
    public const string UnaryNegationOperatorName = "op_UnaryNegation";
    public const string UnaryPlusOperatorName = "op_UnaryPlus";
    public const string UnsignedLeftShiftOperatorName = "op_UnsignedLeftShift";
    public const string UnsignedRightShiftOperatorName = "op_UnsignedRightShift";
    public const string ValuePropertyName = "Value";

  public static class Microsoft.CodeAnalysis.WorkspaceKind

    public const string Debugger = "Debugger";
    public const string Host = "Host";
    public const string Interactive = "Interactive";
    public const string MetadataAsSource = "MetadataAsSource";
    public const string MiscellaneousFiles = "MiscellaneousFiles";
    public const string Preview = "Preview";

  public static class Microsoft.CodeAnalysis.CSharp.CSharpExtensions

    public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax statement);
    public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement);
    public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, ExpressionSyntax expression);
    public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax statement);
    public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement);
    public static Conversion ClassifyConversion(this Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    public static Conversion ClassifyConversion(this SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false);
    public static Conversion ClassifyConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false);
    public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken = default);
    public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression);
    public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, CancellationToken cancellationToken = default);
    public static Optional<object> GetConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static Conversion GetConversion(this SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken = default);
    public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken = default);
    public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static INamespaceSymbol GetDeclaredSymbol(this SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IFieldSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IEventSymbol GetDeclaredSymbol(this SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IMethodSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, TupleElementSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static ILabelSymbol GetDeclaredSymbol(this SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IAliasSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken = default);
    public static IPropertySymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken = default);
    public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default);
    public static INamedTypeSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TupleExpressionSyntax declaratorSyntax, CancellationToken cancellationToken = default);
    public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, ArgumentSyntax declaratorSyntax, CancellationToken cancellationToken = default);
    public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, SingleVariableDesignationSyntax designationSyntax, CancellationToken cancellationToken = default);
    public static ILocalSymbol GetDeclaredSymbol(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken = default);
    public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken = default);
    public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken = default);
    public static IRangeVariableSymbol GetDeclaredSymbol(this SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken = default);
    public static ITypeParameterSymbol GetDeclaredSymbol(this SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken = default);
    public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null);
    public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, ForEachStatementSyntax forEachStatement);
    public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel semanticModel, CommonForEachStatementSyntax forEachStatement);
    public static ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static DirectiveTriviaSyntax GetLastDirective(this SyntaxNode node, Func<DirectiveTriviaSyntax, bool> predicate = null);
    public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default);
    public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken = default);
    public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken = default);
    public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption);
    public static Conversion GetSpeculativeConversion(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, AttributeSyntax attribute);
    public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer);
    public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption);
    public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default);
    public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default);
    public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken = default);
    public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken = default);
    public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default);
    public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken = default);
    public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default);
    public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken = default);
    public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items);
    public static bool IsContextualKeyword(this SyntaxToken token);
    public static bool IsKeyword(this SyntaxToken token);
    public static bool IsReservedKeyword(this SyntaxToken token);
    public static bool IsVerbatimIdentifier(this SyntaxToken token);
    public static bool IsVerbatimStringLiteral(this SyntaxToken token);
    public static SyntaxKind Kind(this SyntaxNode node);
    public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken);
    public static SyntaxKind Kind(this SyntaxToken token);
    public static SyntaxKind Kind(this SyntaxTrivia trivia);
    public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia);
    public static SyntaxToken ReplaceTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, AttributeSyntax attribute, out SemanticModel speculativeModel);
    public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, out SemanticModel speculativeModel);
    public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, CrefSyntax crefSyntax, out SemanticModel speculativeModel);
    public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, out SemanticModel speculativeModel);
    public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, out SemanticModel speculativeModel);
    public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, StatementSyntax statement, out SemanticModel speculativeModel);
    public static bool TryGetSpeculativeSemanticModel(this SemanticModel semanticModel, int position, TypeSyntax type, out SemanticModel speculativeModel, SpeculativeBindingOption bindingOption = BindAsExpression);
    public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, out SemanticModel speculativeModel);
    public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, out SemanticModel speculativeModel);
    public static VarianceKind VarianceKindFromToken(this SyntaxToken node);

  public static class Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions

    public static EmitResult Emit(this CSharpCompilation compilation, string outputPath, string pdbPath = null, string xmlDocumentationPath = null, string win32ResourcesPath = null, IEnumerable<ResourceDescription> manifestResources = null, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.CSharp.LanguageVersionFacts

    public static LanguageVersion MapSpecifiedToEffectiveVersion(this LanguageVersion version);
    public static string ToDisplayString(this LanguageVersion version);
    public static bool TryParse(this string version, out LanguageVersion result);

  public static class Microsoft.CodeAnalysis.CSharp.SymbolDisplay

    public static string FormatLiteral(char c, bool quote);
    public static string FormatLiteral(string value, bool quote);
    public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers);
    public static ImmutableArray<SymbolDisplayPart> ToDisplayParts(ISymbol symbol, SymbolDisplayFormat format = null);
    public static string ToDisplayString(ISymbol symbol, SymbolDisplayFormat format = null);
    public static ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
    public static string ToMinimalDisplayString(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);

  public static class Microsoft.CodeAnalysis.CSharp.SyntaxExtensions

    public static SyntaxTriviaList NormalizeWhitespace(this SyntaxTriviaList list, string indentation, bool elasticTrivia);
    public static SyntaxToken NormalizeWhitespace(this SyntaxToken token, string indentation, bool elasticTrivia);
    public static SyntaxTriviaList NormalizeWhitespace(this SyntaxTriviaList list, string indentation = "    ", string eol = "\r\n", bool elasticTrivia = false);
    public static SyntaxToken NormalizeWhitespace(this SyntaxToken token, string indentation = "    ", string eol = "\r\n", bool elasticTrivia = false);
    public static SyntaxTriviaList ToSyntaxTriviaList(this IEnumerable<SyntaxTrivia> sequence);
    public static IndexerDeclarationSyntax Update(this IndexerDeclarationSyntax syntax, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList);
    public static OperatorDeclarationSyntax Update(this OperatorDeclarationSyntax syntax, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax block, SyntaxToken semicolonToken);
    public static MethodDeclarationSyntax Update(this MethodDeclarationSyntax syntax, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax block, SyntaxToken semicolonToken);
    public static SimpleNameSyntax WithIdentifier(this SimpleNameSyntax simpleName, SyntaxToken identifier);

  public static class Microsoft.CodeAnalysis.CSharp.SyntaxFactory

    public static SyntaxTrivia CarriageReturn { get; }
    public static SyntaxTrivia CarriageReturnLineFeed { get; }
    public static SyntaxTrivia ElasticCarriageReturn { get; }
    public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public static SyntaxTrivia ElasticLineFeed { get; }
    public static SyntaxTrivia ElasticMarker { get; }
    public static SyntaxTrivia ElasticSpace { get; }
    public static SyntaxTrivia ElasticTab { get; }
    public static SyntaxTrivia LineFeed { get; }
    public static SyntaxTrivia Space { get; }
    public static SyntaxTrivia Tab { get; }

    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, BlockSyntax body);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static AccessorListSyntax AccessorList(SyntaxList<AccessorDeclarationSyntax> accessors = default);
    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken);
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SimpleNameSyntax name);
    public static AliasQualifiedNameSyntax AliasQualifiedName(string alias, SimpleNameSyntax name);
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name);
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression();
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(CSharpSyntaxNode body);
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers = default);
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken);
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(ExpressionSyntax expression);
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList);
    public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken);
    public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func<SyntaxKind, bool> ignoreChildNode = null);
    public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel);
    public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel);
    public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null) where TNode : SyntaxNode;
    public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, Func<SyntaxKind, bool> ignoreChildNode = null) where TNode : SyntaxNode;
    public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, bool topLevel) where TNode : CSharpSyntaxNode;
    public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, bool topLevel) where TNode : SyntaxNode;
    public static ArgumentSyntax Argument(ExpressionSyntax expression);
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression);
    public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default);
    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SeparatedSyntaxList<ExpressionSyntax> sizes = default);
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken);
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType);
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers);
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(ExpressionSyntax expression);
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression);
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AttributeSyntax Attribute(NameSyntax name);
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList);
    public static AttributeArgumentSyntax AttributeArgument(ExpressionSyntax expression);
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression);
    public static AttributeArgumentListSyntax AttributeArgumentList(SeparatedSyntaxList<AttributeArgumentSyntax> arguments = default);
    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static AttributeListSyntax AttributeList(SeparatedSyntaxList<AttributeSyntax> attributes = default);
    public static AttributeListSyntax AttributeList(AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes);
    public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken);
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier);
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken);
    public static AwaitExpressionSyntax AwaitExpression(ExpressionSyntax expression);
    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression);
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken identifier, bool isActive);
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive);
    public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing);
    public static BaseExpressionSyntax BaseExpression();
    public static BaseExpressionSyntax BaseExpression(SyntaxToken token);
    public static BaseListSyntax BaseList(SeparatedSyntaxList<BaseTypeSyntax> types = default);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types);
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BlockSyntax Block(params StatementSyntax[] statements);
    public static BlockSyntax Block(IEnumerable<StatementSyntax> statements);
    public static BlockSyntax Block(SyntaxList<StatementSyntax> statements = default);
    public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken);
    public static BracketedArgumentListSyntax BracketedArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default);
    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken);
    public static BracketedParameterListSyntax BracketedParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default);
    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public static BreakStatementSyntax BreakStatement();
    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken);
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, SyntaxToken colonToken);
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken);
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken);
    public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value);
    public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value, SyntaxToken colonToken);
    public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken);
    public static CastExpressionSyntax CastExpression(TypeSyntax type, ExpressionSyntax expression);
    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression);
    public static CatchClauseSyntax CatchClause();
    public static CatchClauseSyntax CatchClause(CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type);
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type, SyntaxToken identifier);
    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken);
    public static CatchFilterClauseSyntax CatchFilterClause(ExpressionSyntax filterExpression);
    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken);
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, ExpressionSyntax expression);
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, BlockSyntax block = null);
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxToken identifier);
    public static ClassDeclarationSyntax ClassDeclaration(string identifier);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind);
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword);
    public static SyntaxTrivia Comment(string text);
    public static CompilationUnitSyntax CompilationUnit();
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken);
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, ExpressionSyntax whenNotNull);
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull);
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse);
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse);
    public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression);
    public static ConstructorConstraintSyntax ConstructorConstraint();
    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxToken identifier);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(string identifier);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, ArrowExpressionClauseSyntax expressionBody);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, ArgumentListSyntax argumentList = null);
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList);
    public static ContinueStatementSyntax ContinueStatement();
    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type);
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SeparatedSyntaxList<CrefParameterSyntax> parameters = default);
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public static CrefParameterSyntax CrefParameter(TypeSyntax type);
    public static CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type);
    public static CrefParameterListSyntax CrefParameterList(SeparatedSyntaxList<CrefParameterSyntax> parameters = default);
    public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken);
    public static DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation);
    public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation);
    public static DefaultExpressionSyntax DefaultExpression(TypeSyntax type);
    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel();
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken colonToken);
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken);
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken name, bool isActive);
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive);
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, SyntaxToken identifier);
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, string identifier);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxToken identifier);
    public static DestructorDeclarationSyntax DestructorDeclaration(string identifier);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static SyntaxTrivia DisabledText(string text);
    public static DiscardDesignationSyntax DiscardDesignation();
    public static DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken);
    public static DoStatementSyntax DoStatement(StatementSyntax statement, ExpressionSyntax condition);
    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken);
    public static DocumentationCommentTriviaSyntax DocumentationComment(params XmlNodeSyntax[] content);
    public static SyntaxTrivia DocumentationCommentExterior(string text);
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content = default);
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment);
    public static SyntaxTrivia ElasticEndOfLine(string text);
    public static SyntaxTrivia ElasticWhitespace(string text);
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression);
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList);
    public static ElementBindingExpressionSyntax ElementBindingExpression();
    public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList);
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue);
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public static ElseClauseSyntax ElseClause(StatementSyntax statement);
    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement);
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken);
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken);
    public static EmptyStatementSyntax EmptyStatement();
    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken);
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive);
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static SyntaxTrivia EndOfLine(string text);
    public static SyntaxTrivia EndOfLine(string text, bool elastic);
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive);
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxToken identifier);
    public static EnumDeclarationSyntax EnumDeclaration(string identifier);
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, BaseListSyntax baseList, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members);
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue);
    public static EqualsValueClauseSyntax EqualsValueClause(ExpressionSyntax value);
    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value);
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive);
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, SyntaxToken identifier);
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, string identifier);
    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(VariableDeclarationSyntax declaration);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name);
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken);
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression);
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken identifier);
    public static ExternAliasDirectiveSyntax ExternAliasDirective(string identifier);
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken);
    public static FieldDeclarationSyntax FieldDeclaration(VariableDeclarationSyntax declaration);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static FinallyClauseSyntax FinallyClause(BlockSyntax block = null);
    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block);
    public static FixedStatementSyntax FixedStatement(VariableDeclarationSyntax declaration, StatementSyntax statement);
    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement);
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression, StatementSyntax statement);
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, string identifier, ExpressionSyntax expression, StatementSyntax statement);
    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static ForEachVariableStatementSyntax ForEachVariableStatement(ExpressionSyntax variable, ExpressionSyntax expression, StatementSyntax statement);
    public static ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static ForStatementSyntax ForStatement(StatementSyntax statement);
    public static ForStatementSyntax ForStatement(VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, ExpressionSyntax condition, SeparatedSyntaxList<ExpressionSyntax> incrementors, StatementSyntax statement);
    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement);
    public static FromClauseSyntax FromClause(SyntaxToken identifier, ExpressionSyntax expression);
    public static FromClauseSyntax FromClause(string identifier, ExpressionSyntax expression);
    public static FromClauseSyntax FromClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression);
    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression);
    public static GenericNameSyntax GenericName(SyntaxToken identifier);
    public static GenericNameSyntax GenericName(string identifier);
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
    public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression);
    public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression);
    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement);
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, ExpressionSyntax expression = null);
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression);
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static GroupClauseSyntax GroupClause(ExpressionSyntax groupExpression, ExpressionSyntax byExpression);
    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression);
    public static SyntaxToken Identifier(string text);
    public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing);
    public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing);
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier);
    public static IdentifierNameSyntax IdentifierName(string name);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement);
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement, ElseClauseSyntax @else);
    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else);
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(InitializerExpressionSyntax initializer);
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxTokenList commas, InitializerExpressionSyntax initializer);
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer);
    public static ImplicitElementAccessSyntax ImplicitElementAccess();
    public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList);
    public static IncompleteMemberSyntax IncompleteMember(TypeSyntax type = null);
    public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type);
    public static IndexerDeclarationSyntax IndexerDeclaration(TypeSyntax type);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static IndexerMemberCrefSyntax IndexerMemberCref(CrefBracketedParameterListSyntax parameters = null);
    public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters);
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxToken identifier);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(string identifier);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken);
    public static InterpolatedStringTextSyntax InterpolatedStringText();
    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken);
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression);
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause);
    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value);
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken);
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken);
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression);
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    public static bool IsCompleteSubmission(SyntaxTree tree);
    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, PatternSyntax pattern);
    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern);
    public static JoinClauseSyntax JoinClause(SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression);
    public static JoinClauseSyntax JoinClause(string identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression);
    public static JoinClauseSyntax JoinClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken identifier);
    public static JoinIntoClauseSyntax JoinIntoClause(string identifier);
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier);
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, StatementSyntax statement);
    public static LabeledStatementSyntax LabeledStatement(string identifier, StatementSyntax statement);
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement);
    public static LetClauseSyntax LetClause(SyntaxToken identifier, ExpressionSyntax expression);
    public static LetClauseSyntax LetClause(string identifier, ExpressionSyntax expression);
    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression);
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, bool isActive);
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, SyntaxToken file, bool isActive);
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static SyntaxList<TNode> List<TNode>() where TNode : SyntaxNode;
    public static SyntaxList<TNode> List<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode;
    public static SyntaxToken Literal(int value);
    public static SyntaxToken Literal(uint value);
    public static SyntaxToken Literal(long value);
    public static SyntaxToken Literal(ulong value);
    public static SyntaxToken Literal(float value);
    public static SyntaxToken Literal(double value);
    public static SyntaxToken Literal(decimal value);
    public static SyntaxToken Literal(string value);
    public static SyntaxToken Literal(char value);
    public static SyntaxToken Literal(string text, int value);
    public static SyntaxToken Literal(string text, uint value);
    public static SyntaxToken Literal(string text, long value);
    public static SyntaxToken Literal(string text, ulong value);
    public static SyntaxToken Literal(string text, float value);
    public static SyntaxToken Literal(string text, double value);
    public static SyntaxToken Literal(string text, decimal value);
    public static SyntaxToken Literal(string text, string value);
    public static SyntaxToken Literal(string text, char value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing);
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind);
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token);
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken file, bool isActive);
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(VariableDeclarationSyntax declaration);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, SyntaxToken identifier);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, string identifier);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static LockStatementSyntax LockStatement(ExpressionSyntax expression, StatementSyntax statement);
    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static MakeRefExpressionSyntax MakeRefExpression(ExpressionSyntax expression);
    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static MemberBindingExpressionSyntax MemberBindingExpression(SimpleNameSyntax name);
    public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name);
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, SyntaxToken identifier);
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, string identifier);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, SyntaxToken semicolonToken);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static SyntaxToken MissingToken(SyntaxKind kind);
    public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing);
    public static NameColonSyntax NameColon(IdentifierNameSyntax name);
    public static NameColonSyntax NameColon(string name);
    public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken);
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name);
    public static NameEqualsSyntax NameEquals(string name);
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken);
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name);
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static SyntaxNodeOrTokenList NodeOrTokenList();
    public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable<SyntaxNodeOrToken> nodesAndTokens);
    public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens);
    public static NullableTypeSyntax NullableType(TypeSyntax elementType);
    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression();
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken);
    public static OmittedTypeArgumentSyntax OmittedTypeArgument();
    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken);
    public static OperatorDeclarationSyntax OperatorDeclaration(TypeSyntax returnType, SyntaxToken operatorToken);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken);
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    public static OrderByClauseSyntax OrderByClause(SeparatedSyntaxList<OrderingSyntax> orderings = default);
    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings);
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression);
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    public static ParameterSyntax Parameter(SyntaxToken identifier);
    public static ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default);
    public static ParameterListSyntax ParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default);
    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken);
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression);
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(CSharpSyntaxNode body);
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SeparatedSyntaxList<VariableDesignationSyntax> variables = default);
    public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken);
    public static ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true);
    public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true);
    public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true);
    public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true);
    public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions options = null);
    public static ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true);
    public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0);
    public static NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true);
    public static ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true);
    public static StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions options = null, bool consumeFullText = true);
    public static SyntaxTree ParseSyntaxTree(SourceText text, ParseOptions options = null, string path = "", CancellationToken cancellationToken = default);
    public static SyntaxTree ParseSyntaxTree(string text, ParseOptions options = null, string path = "", Encoding encoding = null, CancellationToken cancellationToken = default);
    public static SyntaxToken ParseToken(string text, int offset = 0);
    public static IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions options = null);
    public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0);
    public static TypeSyntax ParseTypeName(string text, int offset = 0, bool consumeFullText = true);
    public static PointerTypeSyntax PointerType(TypeSyntax elementType);
    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken);
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand);
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, bool isActive);
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive);
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, bool isActive);
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, bool isActive);
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive);
    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword);
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    public static SyntaxTrivia PreprocessingMessage(string text);
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, SyntaxToken identifier);
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, string identifier);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken);
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, MemberCrefSyntax member);
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member);
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SimpleNameSyntax right);
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
    public static QueryBodySyntax QueryBody(SelectOrGroupClauseSyntax selectOrGroup);
    public static QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation);
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken identifier, QueryBodySyntax body);
    public static QueryContinuationSyntax QueryContinuation(string identifier, QueryBodySyntax body);
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body);
    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body);
    public static RefExpressionSyntax RefExpression(ExpressionSyntax expression);
    public static RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression);
    public static RefTypeSyntax RefType(TypeSyntax type);
    public static RefTypeSyntax RefType(SyntaxToken refKeyword, TypeSyntax type);
    public static RefTypeExpressionSyntax RefTypeExpression(ExpressionSyntax expression);
    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static RefValueExpressionSyntax RefValueExpression(ExpressionSyntax expression, TypeSyntax type);
    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken);
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken file, bool isActive);
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive);
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static ReturnStatementSyntax ReturnStatement(ExpressionSyntax expression = null);
    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static SelectClauseSyntax SelectClause(ExpressionSyntax expression);
    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression);
    public static SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : SyntaxNode;
    public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes) where TNode : SyntaxNode;
    public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode;
    public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens) where TNode : SyntaxNode;
    public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(IEnumerable<TNode> nodes, IEnumerable<SyntaxToken> separators) where TNode : SyntaxNode;
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive);
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive);
    public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type);
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, CSharpSyntaxNode body);
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public static SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier);
    public static SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : SyntaxNode;
    public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : SyntaxNode;
    public static SizeOfExpressionSyntax SizeOfExpression(TypeSyntax type);
    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia();
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens);
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(TypeSyntax type);
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type);
    public static StructDeclarationSyntax StructDeclaration(SyntaxToken identifier);
    public static StructDeclarationSyntax StructDeclaration(string identifier);
    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members);
    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static SwitchSectionSyntax SwitchSection();
    public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements);
    public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression);
    public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression, SyntaxList<SwitchSectionSyntax> sections);
    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken);
    public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options = null, string path = "", Encoding encoding = null);
    public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text);
    public static ThisExpressionSyntax ThisExpression();
    public static ThisExpressionSyntax ThisExpression(SyntaxToken token);
    public static ThrowExpressionSyntax ThrowExpression(ExpressionSyntax expression);
    public static ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression);
    public static ThrowStatementSyntax ThrowStatement(ExpressionSyntax expression = null);
    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static SyntaxToken Token(SyntaxKind kind);
    public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing);
    public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing);
    public static SyntaxTokenList TokenList();
    public static SyntaxTokenList TokenList(SyntaxToken token);
    public static SyntaxTokenList TokenList(params SyntaxToken[] tokens);
    public static SyntaxTokenList TokenList(IEnumerable<SyntaxToken> tokens);
    public static SyntaxTrivia Trivia(StructuredTriviaSyntax node);
    public static SyntaxTriviaList TriviaList();
    public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia);
    public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias);
    public static SyntaxTriviaList TriviaList(IEnumerable<SyntaxTrivia> trivias);
    public static TryStatementSyntax TryStatement(SyntaxList<CatchClauseSyntax> catches = default);
    public static TryStatementSyntax TryStatement(BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally);
    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally);
    public static TupleElementSyntax TupleElement(TypeSyntax type);
    public static TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier);
    public static TupleExpressionSyntax TupleExpression(SeparatedSyntaxList<ArgumentSyntax> arguments = default);
    public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static TupleTypeSyntax TupleType(SeparatedSyntaxList<TupleElementSyntax> elements = default);
    public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken);
    public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList<TypeSyntax> arguments = default);
    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken);
    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type);
    public static TypeCrefSyntax TypeCref(TypeSyntax type);
    public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxToken identifier);
    public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, string identifier);
    public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static TypeOfExpressionSyntax TypeOfExpression(TypeSyntax type);
    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static TypeParameterSyntax TypeParameter(SyntaxToken identifier);
    public static TypeParameterSyntax TypeParameter(string identifier);
    public static TypeParameterSyntax TypeParameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints);
    public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList<TypeParameterSyntax> parameters = default);
    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken);
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken name, bool isActive);
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive);
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public static UnsafeStatementSyntax UnsafeStatement(BlockSyntax block = null);
    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block);
    public static UsingDirectiveSyntax UsingDirective(NameSyntax name);
    public static UsingDirectiveSyntax UsingDirective(NameEqualsSyntax alias, NameSyntax name);
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name);
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken);
    public static UsingStatementSyntax UsingStatement(StatementSyntax statement);
    public static UsingStatementSyntax UsingStatement(VariableDeclarationSyntax declaration, ExpressionSyntax expression, StatementSyntax statement);
    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables);
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier);
    public static VariableDeclaratorSyntax VariableDeclarator(string identifier);
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer);
    public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing);
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive);
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static WhenClauseSyntax WhenClause(ExpressionSyntax condition);
    public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition);
    public static WhereClauseSyntax WhereClause(ExpressionSyntax condition);
    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition);
    public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, StatementSyntax statement);
    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement);
    public static SyntaxTrivia Whitespace(string text);
    public static SyntaxTrivia Whitespace(string text, bool elastic);
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxTokenList textTokens = default);
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken);
    public static XmlCommentSyntax XmlComment(SyntaxTokenList textTokens = default);
    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefSyntax cref);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefSyntax cref, SyntaxKind quoteKind);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    public static XmlElementSyntax XmlElement(string localName, SyntaxList<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlElement(XmlNameSyntax name, SyntaxList<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag);
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
    public static XmlElementEndTagSyntax XmlElementEndTag(XmlNameSyntax name);
    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name);
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes);
    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken);
    public static XmlEmptyElementSyntax XmlEmptyElement(string localName);
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name);
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes);
    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken);
    public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static XmlElementSyntax XmlExampleElement(params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlExampleElement(SyntaxList<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlExceptionElement(CrefSyntax cref, params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlExceptionElement(CrefSyntax cref, SyntaxList<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlMultiLineElement(string localName, SyntaxList<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlMultiLineElement(XmlNameSyntax name, SyntaxList<XmlNodeSyntax> content);
    public static XmlNameSyntax XmlName(SyntaxToken localName);
    public static XmlNameSyntax XmlName(string localName);
    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName);
    public static XmlNameAttributeSyntax XmlNameAttribute(string parameterName);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, string identifier, SyntaxToken endQuoteToken);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    public static XmlTextSyntax XmlNewLine(string text);
    public static XmlEmptyElementSyntax XmlNullKeywordElement();
    public static XmlElementSyntax XmlParaElement(params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlParaElement(SyntaxList<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlParamElement(string parameterName, params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlParamElement(string parameterName, SyntaxList<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax XmlParamRefElement(string parameterName);
    public static XmlElementSyntax XmlPermissionElement(CrefSyntax cref, params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlPermissionElement(CrefSyntax cref, SyntaxList<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlPlaceholderElement(params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlPlaceholderElement(SyntaxList<XmlNodeSyntax> content);
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix);
    public static XmlPrefixSyntax XmlPrefix(string prefix);
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken);
    public static XmlEmptyElementSyntax XmlPreliminaryElement();
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name);
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name, SyntaxTokenList textTokens);
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken);
    public static XmlElementSyntax XmlRemarksElement(params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlRemarksElement(SyntaxList<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlReturnsElement(params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlReturnsElement(SyntaxList<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax XmlSeeAlsoElement(CrefSyntax cref);
    public static XmlElementSyntax XmlSeeAlsoElement(Uri linkAddress, SyntaxList<XmlNodeSyntax> linkText);
    public static XmlEmptyElementSyntax XmlSeeElement(CrefSyntax cref);
    public static XmlElementSyntax XmlSummaryElement(params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlSummaryElement(SyntaxList<XmlNodeSyntax> content);
    public static XmlTextSyntax XmlText();
    public static XmlTextSyntax XmlText(params SyntaxToken[] textTokens);
    public static XmlTextSyntax XmlText(SyntaxTokenList textTokens);
    public static XmlTextSyntax XmlText(string value);
    public static XmlTextAttributeSyntax XmlTextAttribute(string name, params SyntaxToken[] textTokens);
    public static XmlTextAttributeSyntax XmlTextAttribute(string name, string value);
    public static XmlTextAttributeSyntax XmlTextAttribute(string name, SyntaxKind quoteKind, SyntaxTokenList textTokens);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxKind quoteKind, SyntaxTokenList textTokens);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken);
    public static SyntaxToken XmlTextLiteral(string value);
    public static SyntaxToken XmlTextLiteral(string text, string value);
    public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static SyntaxToken XmlTextNewLine(string text);
    public static SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment);
    public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static XmlEmptyElementSyntax XmlThreadSafetyElement();
    public static XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance);
    public static XmlElementSyntax XmlValueElement(params XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlValueElement(SyntaxList<XmlNodeSyntax> content);
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, ExpressionSyntax expression = null);
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);

  public static class Microsoft.CodeAnalysis.CSharp.SyntaxFacts

    public static IEqualityComparer<SyntaxKind> EqualityComparer { get; }

    public static SyntaxKind GetAccessorDeclarationKind(SyntaxKind keyword);
    public static SyntaxKind GetAssignmentExpression(SyntaxKind token);
    public static SyntaxKind GetBaseTypeDeclarationKind(SyntaxKind kind);
    public static SyntaxKind GetBinaryExpression(SyntaxKind token);
    public static SyntaxKind GetCheckStatement(SyntaxKind keyword);
    public static SyntaxKind GetContextualKeywordKind(string text);
    public static IEnumerable<SyntaxKind> GetContextualKeywordKinds();
    public static SyntaxKind GetInstanceExpression(SyntaxKind token);
    public static SyntaxKind GetKeywordKind(string text);
    public static IEnumerable<SyntaxKind> GetKeywordKinds();
    public static SyntaxKind GetLiteralExpression(SyntaxKind token);
    public static SyntaxKind GetOperatorKind(string operatorMetadataName);
    public static SyntaxKind GetPostfixUnaryExpression(SyntaxKind token);
    public static SyntaxKind GetPrefixUnaryExpression(SyntaxKind token);
    public static SyntaxKind GetPreprocessorKeywordKind(string text);
    public static IEnumerable<SyntaxKind> GetPreprocessorKeywordKinds();
    public static SyntaxKind GetPrimaryFunction(SyntaxKind keyword);
    public static IEnumerable<SyntaxKind> GetPunctuationKinds();
    public static IEnumerable<SyntaxKind> GetReservedKeywordKinds();
    public static SyntaxKind GetSwitchLabelKind(SyntaxKind keyword);
    public static string GetText(Accessibility accessibility);
    public static string GetText(SyntaxKind kind);
    public static SyntaxKind GetTypeDeclarationKind(SyntaxKind kind);
    public static bool IsAccessibilityModifier(SyntaxKind kind);
    public static bool IsAccessorDeclaration(SyntaxKind kind);
    public static bool IsAccessorDeclarationKeyword(SyntaxKind keyword);
    public static bool IsAliasQualifier(SyntaxNode node);
    public static bool IsAnyOverloadableOperator(SyntaxKind kind);
    public static bool IsAnyToken(SyntaxKind kind);
    public static bool IsAnyUnaryExpression(SyntaxKind token);
    public static bool IsAssignmentExpression(SyntaxKind kind);
    public static bool IsAssignmentExpressionOperatorToken(SyntaxKind token);
    public static bool IsAttributeName(SyntaxNode node);
    public static bool IsAttributeTargetSpecifier(SyntaxKind kind);
    public static bool IsBinaryExpression(SyntaxKind token);
    public static bool IsBinaryExpressionOperatorToken(SyntaxKind token);
    public static bool IsContextualKeyword(SyntaxKind kind);
    public static bool IsDocumentationCommentTrivia(SyntaxKind kind);
    public static bool IsFixedStatementExpression(SyntaxNode node);
    public static bool IsGlobalMemberDeclaration(SyntaxKind kind);
    public static bool IsIdentifierPartCharacter(char ch);
    public static bool IsIdentifierStartCharacter(char ch);
    public static bool IsInNamespaceOrTypeContext(ExpressionSyntax node);
    public static bool IsInTypeOnlyContext(ExpressionSyntax node);
    public static bool IsIndexed(ExpressionSyntax node);
    public static bool IsInstanceExpression(SyntaxKind token);
    public static bool IsInvoked(ExpressionSyntax node);
    public static bool IsKeywordKind(SyntaxKind kind);
    public static bool IsLambdaBody(SyntaxNode node);
    public static bool IsLanguagePunctuation(SyntaxKind kind);
    public static bool IsLiteralExpression(SyntaxKind token);
    public static bool IsName(SyntaxKind kind);
    public static bool IsNamedArgumentName(SyntaxNode node);
    public static bool IsNamespaceAliasQualifier(ExpressionSyntax node);
    public static bool IsNamespaceMemberDeclaration(SyntaxKind kind);
    public static bool IsNewLine(char ch);
    public static bool IsOverloadableBinaryOperator(SyntaxKind kind);
    public static bool IsOverloadableUnaryOperator(SyntaxKind kind);
    public static bool IsPostfixUnaryExpression(SyntaxKind token);
    public static bool IsPostfixUnaryExpressionToken(SyntaxKind token);
    public static bool IsPredefinedType(SyntaxKind kind);
    public static bool IsPrefixUnaryExpression(SyntaxKind token);
    public static bool IsPrefixUnaryExpressionOperatorToken(SyntaxKind token);
    public static bool IsPreprocessorDirective(SyntaxKind kind);
    public static bool IsPreprocessorKeyword(SyntaxKind kind);
    public static bool IsPreprocessorPunctuation(SyntaxKind kind);
    public static bool IsPrimaryFunction(SyntaxKind keyword);
    public static bool IsPunctuation(SyntaxKind kind);
    public static bool IsPunctuationOrKeyword(SyntaxKind kind);
    public static bool IsQueryContextualKeyword(SyntaxKind kind);
    public static bool IsReservedKeyword(SyntaxKind kind);
    public static bool IsReservedTupleElementName(string elementName);
    public static bool IsTrivia(SyntaxKind kind);
    public static bool IsTypeDeclaration(SyntaxKind kind);
    public static bool IsTypeParameterVarianceKeyword(SyntaxKind kind);
    public static bool IsTypeSyntax(SyntaxKind kind);
    public static bool IsUnaryOperatorDeclarationToken(SyntaxKind token);
    public static bool IsValidIdentifier(string name);
    public static bool IsWhitespace(char ch);
    public static string TryGetInferredMemberName(this SyntaxNode syntax);

  public static class Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions

    public static string ToCSharpString(this TypedConstant constant);

  public static class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpFormattingOptions

    public static Option<bool> IndentBlock { get; }
    public static Option<bool> IndentBraces { get; }
    public static Option<bool> IndentSwitchCaseSection { get; }
    public static Option<bool> IndentSwitchSection { get; }
    public static Option<LabelPositionOptions> LabelPositioning { get; }
    public static Option<bool> NewLineForCatch { get; }
    public static Option<bool> NewLineForClausesInQuery { get; }
    public static Option<bool> NewLineForElse { get; }
    public static Option<bool> NewLineForFinally { get; }
    public static Option<bool> NewLineForMembersInAnonymousTypes { get; }
    public static Option<bool> NewLineForMembersInObjectInit { get; }
    public static Option<bool> NewLinesForBracesInAccessors { get; }
    public static Option<bool> NewLinesForBracesInAnonymousMethods { get; }
    public static Option<bool> NewLinesForBracesInAnonymousTypes { get; }
    public static Option<bool> NewLinesForBracesInControlBlocks { get; }
    public static Option<bool> NewLinesForBracesInLambdaExpressionBody { get; }
    public static Option<bool> NewLinesForBracesInMethods { get; }
    public static Option<bool> NewLinesForBracesInObjectCollectionArrayInitializers { get; }
    public static Option<bool> NewLinesForBracesInProperties { get; }
    public static Option<bool> NewLinesForBracesInTypes { get; }
    public static Option<bool> SpaceAfterCast { get; }
    public static Option<bool> SpaceAfterColonInBaseTypeDeclaration { get; }
    public static Option<bool> SpaceAfterComma { get; }
    public static Option<bool> SpaceAfterControlFlowStatementKeyword { get; }
    public static Option<bool> SpaceAfterDot { get; }
    public static Option<bool> SpaceAfterMethodCallName { get; }
    public static Option<bool> SpaceAfterSemicolonsInForStatement { get; }
    public static Option<bool> SpaceBeforeColonInBaseTypeDeclaration { get; }
    public static Option<bool> SpaceBeforeComma { get; }
    public static Option<bool> SpaceBeforeDot { get; }
    public static Option<bool> SpaceBeforeOpenSquareBracket { get; }
    public static Option<bool> SpaceBeforeSemicolonsInForStatement { get; }
    public static Option<bool> SpaceBetweenEmptyMethodCallParentheses { get; }
    public static Option<bool> SpaceBetweenEmptyMethodDeclarationParentheses { get; }
    public static Option<bool> SpaceBetweenEmptySquareBrackets { get; }
    public static Option<bool> SpaceWithinCastParentheses { get; }
    public static Option<bool> SpaceWithinExpressionParentheses { get; }
    public static Option<bool> SpaceWithinMethodCallParentheses { get; }
    public static Option<bool> SpaceWithinMethodDeclarationParenthesis { get; }
    public static Option<bool> SpaceWithinOtherParentheses { get; }
    public static Option<bool> SpaceWithinSquareBrackets { get; }
    public static Option<bool> SpacesIgnoreAroundVariableDeclaration { get; }
    public static Option<bool> SpacingAfterMethodDeclarationName { get; }
    public static Option<BinaryOperatorSpacingOptions> SpacingAroundBinaryOperator { get; }
    public static Option<bool> WrappingKeepStatementsOnSingleLine { get; }
    public static Option<bool> WrappingPreserveSingleLine { get; }

  public static class Microsoft.CodeAnalysis.Classification.ClassificationTypeNames

    public const string ClassName = "class name";
    public const string Comment = "comment";
    public const string DelegateName = "delegate name";
    public const string EnumName = "enum name";
    public const string ExcludedCode = "excluded code";
    public const string Identifier = "identifier";
    public const string InterfaceName = "interface name";
    public const string Keyword = "keyword";
    public const string ModuleName = "module name";
    public const string NumericLiteral = "number";
    public const string Operator = "operator";
    public const string PreprocessorKeyword = "preprocessor keyword";
    public const string PreprocessorText = "preprocessor text";
    public const string Punctuation = "punctuation";
    public const string StringLiteral = "string";
    public const string StructName = "struct name";
    public const string Text = "text";
    public const string TypeParameterName = "type parameter name";
    public const string VerbatimStringLiteral = "string - verbatim";
    public const string WhiteSpace = "whitespace";
    public const string XmlDocCommentAttributeName = "xml doc comment - attribute name";
    public const string XmlDocCommentAttributeQuotes = "xml doc comment - attribute quotes";
    public const string XmlDocCommentAttributeValue = "xml doc comment - attribute value";
    public const string XmlDocCommentCDataSection = "xml doc comment - cdata section";
    public const string XmlDocCommentComment = "xml doc comment - comment";
    public const string XmlDocCommentDelimiter = "xml doc comment - delimiter";
    public const string XmlDocCommentEntityReference = "xml doc comment - entity reference";
    public const string XmlDocCommentName = "xml doc comment - name";
    public const string XmlDocCommentProcessingInstruction = "xml doc comment - processing instruction";
    public const string XmlDocCommentText = "xml doc comment - text";
    public const string XmlLiteralAttributeName = "xml literal - attribute name";
    public const string XmlLiteralAttributeQuotes = "xml literal - attribute quotes";
    public const string XmlLiteralAttributeValue = "xml literal - attribute value";
    public const string XmlLiteralCDataSection = "xml literal - cdata section";
    public const string XmlLiteralComment = "xml literal - comment";
    public const string XmlLiteralDelimiter = "xml literal - delimiter";
    public const string XmlLiteralEmbeddedExpression = "xml literal - embedded expression";
    public const string XmlLiteralEntityReference = "xml literal - entity reference";
    public const string XmlLiteralName = "xml literal - name";
    public const string XmlLiteralProcessingInstruction = "xml literal - processing instruction";
    public const string XmlLiteralText = "xml literal - text";

  public static class Microsoft.CodeAnalysis.Classification.Classifier

    public static IEnumerable<ClassifiedSpan> GetClassifiedSpans(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ClassifiedSpan>> GetClassifiedSpansAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation

    public const string Kind = "CodeAction_Conflict";

    public static SyntaxAnnotation Create(string description);
    public static string GetDescription(SyntaxAnnotation annotation);

  public static class Microsoft.CodeAnalysis.CodeActions.RenameAnnotation

    public const string Kind = "CodeAction_Rename";

    public static SyntaxAnnotation Create();

  public static class Microsoft.CodeAnalysis.CodeActions.WarningAnnotation

    public const string Kind = "CodeAction_Warning";

    public static SyntaxAnnotation Create(string description);
    public static string GetDescription(SyntaxAnnotation annotation);

  public static class Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders

    public static FixAllProvider BatchFixer { get; }

  public static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions

    public static CompilationWithAnalyzers WithAnalyzers(this Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions);
    public static CompilationWithAnalyzers WithAnalyzers(this Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, AnalyzerOptions options = null, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Editing.ImportAdder

    public static Task<Document> AddImportsAsync(Document document, OptionSet options = null, CancellationToken cancellationToken = default);
    public static Task<Document> AddImportsAsync(Document document, SyntaxAnnotation annotation, OptionSet options = null, CancellationToken cancellationToken = default);
    public static Task<Document> AddImportsAsync(Document document, TextSpan span, OptionSet options = null, CancellationToken cancellationToken = default);
    public static Task<Document> AddImportsAsync(Document document, IEnumerable<TextSpan> spans, OptionSet options = null, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions

    public static Task<SyntaxNode> GetBaseOrInterfaceDeclarationReferenceAsync(this SymbolEditor editor, ISymbol symbol, ITypeSymbol baseOrInterfaceType, CancellationToken cancellationToken = default);
    public static Task<ISymbol> SetBaseTypeAsync(this SymbolEditor editor, INamedTypeSymbol symbol, Func<SyntaxGenerator, SyntaxNode> getNewBaseType, CancellationToken cancellationToken = default);
    public static Task<ISymbol> SetBaseTypeAsync(this SymbolEditor editor, INamedTypeSymbol symbol, ITypeSymbol newBaseType, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions

    public static void AddAttribute(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute);
    public static void AddAttributeArgument(this SyntaxEditor editor, SyntaxNode attributeDeclaration, SyntaxNode attributeArgument);
    public static void AddBaseType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode baseType);
    public static void AddInterfaceType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode interfaceType);
    public static void AddMember(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode member);
    public static void AddParameter(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode parameter);
    public static void AddReturnAttribute(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute);
    public static void InsertMembers(this SyntaxEditor editor, SyntaxNode declaration, int index, IEnumerable<SyntaxNode> members);
    public static void SetAccessibility(this SyntaxEditor editor, SyntaxNode declaration, Accessibility accessibility);
    public static void SetExpression(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode expression);
    public static void SetGetAccessorStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable<SyntaxNode> statements);
    public static void SetModifiers(this SyntaxEditor editor, SyntaxNode declaration, DeclarationModifiers modifiers);
    public static void SetName(this SyntaxEditor editor, SyntaxNode declaration, string name);
    public static void SetSetAccessorStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable<SyntaxNode> statements);
    public static void SetStatements(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable<SyntaxNode> statements);
    public static void SetType(this SyntaxEditor editor, SyntaxNode declaration, SyntaxNode type);
    public static void SetTypeConstraint(this SyntaxEditor editor, SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kind, IEnumerable<SyntaxNode> types);
    public static void SetTypeParameters(this SyntaxEditor editor, SyntaxNode declaration, IEnumerable<string> typeParameters);

  public static class Microsoft.CodeAnalysis.FindSymbols.SymbolFinder

    public static Task<IEnumerable<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, IImmutableSet<Document> documents, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<INamedTypeSymbol>> FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet<Project> projects = null, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindImplementationsAsync(ISymbol symbol, Solution solution, IImmutableSet<Project> projects = null, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindImplementedInterfaceMembersAsync(ISymbol symbol, Solution solution, IImmutableSet<Project> projects = null, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindOverridesAsync(ISymbol symbol, Solution solution, IImmutableSet<Project> projects = null, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IImmutableSet<Document> documents, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IFindReferencesProgress progress, IImmutableSet<Document> documents, CancellationToken cancellationToken = default);
    public static IEnumerable<TSymbol> FindSimilarSymbols<TSymbol>(TSymbol symbol, Compilation compilation, CancellationToken cancellationToken = default) where TSymbol : ISymbol;
    public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Project project, Func<string, bool> predicate, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func<string, bool> predicate, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Project project, Func<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken = default);
    public static Task<ISymbol> FindSourceDefinitionAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken = default);
    public static ISymbol FindSymbolAtPosition(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken = default);
    public static Task<ISymbol> FindSymbolAtPositionAsync(Document document, int position, CancellationToken cancellationToken = default);
    public static Task<ISymbol> FindSymbolAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Formatting.Formatter

    public static SyntaxAnnotation Annotation { get; }

    public static SyntaxNode Format(SyntaxNode node, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);
    public static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);
    public static SyntaxNode Format(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);
    public static SyntaxNode Format(SyntaxNode node, IEnumerable<TextSpan> spans, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);
    public static Task<Document> FormatAsync(Document document, OptionSet options = null, CancellationToken cancellationToken = default);
    public static Task<Document> FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet options = null, CancellationToken cancellationToken = default);
    public static Task<Document> FormatAsync(Document document, TextSpan span, OptionSet options = null, CancellationToken cancellationToken = default);
    public static Task<Document> FormatAsync(Document document, IEnumerable<TextSpan> spans, OptionSet options = null, CancellationToken cancellationToken = default);
    public static IList<TextChange> GetFormattedTextChanges(SyntaxNode node, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);
    public static IList<TextChange> GetFormattedTextChanges(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);
    public static IList<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable<TextSpan> spans, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Formatting.FormattingOptions

    public static PerLanguageOption<int> IndentationSize { get; }
    public static PerLanguageOption<string> NewLine { get; }
    public static PerLanguageOption<FormattingOptions.IndentStyle> SmartIndent { get; }
    public static PerLanguageOption<int> TabSize { get; }
    public static PerLanguageOption<bool> UseTabs { get; }

  public static class Microsoft.CodeAnalysis.Host.Mef.ServiceLayer

    public const string Default = "Default";
    public const string Desktop = "Desktop";
    public const string Editor = "Editor";
    public const string Host = "Host";

  public static class Microsoft.CodeAnalysis.Recommendations.RecommendationOptions

    public static PerLanguageOption<bool> FilterOutOfScopeLocals { get; }
    public static PerLanguageOption<bool> HideAdvancedMembers { get; }

  public static class Microsoft.CodeAnalysis.Recommendations.Recommender

    public static IEnumerable<ISymbol> GetRecommendedSymbolsAtPosition(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);
    public static Task<IEnumerable<ISymbol>> GetRecommendedSymbolsAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options = null, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Rename.RenameOptions

    public static Option<bool> PreviewChanges { get; }
    public static Option<bool> RenameInComments { get; }
    public static Option<bool> RenameInStrings { get; }
    public static Option<bool> RenameOverloads { get; }

  public static class Microsoft.CodeAnalysis.Rename.Renamer

    public static Task<Solution> RenameSymbolAsync(Solution solution, ISymbol symbol, string newName, OptionSet optionSet, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Semantics.OperationExtensions

    public static IEnumerable<IOperation> Descendants(this IOperation operation);
    public static IEnumerable<IOperation> DescendantsAndSelf(this IOperation operation);
    public static ImmutableArray<ILocalSymbol> GetDeclaredVariables(this IVariableDeclarationStatement declarationStatement);
    public static IOperation GetRootOperation(this ISymbol symbol, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Semantics.UnaryAndBinaryOperationExtensions

    public static BinaryOperandsKind GetBinaryOperandsKind(this IBinaryOperatorExpression binary);
    public static BinaryOperandsKind GetBinaryOperandsKind(this ICompoundAssignmentExpression compoundAssignment);
    public static BinaryOperandsKind GetBinaryOperandsKind(BinaryOperationKind kind);
    public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(this IBinaryOperatorExpression binary);
    public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(this ICompoundAssignmentExpression compoundAssignment);
    public static SimpleBinaryOperationKind GetSimpleBinaryOperationKind(BinaryOperationKind kind);
    public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(this IIncrementExpression increment);
    public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(UnaryOperationKind kind);
    public static SimpleUnaryOperationKind GetSimpleUnaryOperationKind(this IUnaryOperatorExpression unary);
    public static UnaryOperandKind GetUnaryOperandKind(this IIncrementExpression increment);
    public static UnaryOperandKind GetUnaryOperandKind(UnaryOperationKind kind);
    public static UnaryOperandKind GetUnaryOperandKind(this IUnaryOperatorExpression unary);

  public static class Microsoft.CodeAnalysis.Simplification.SimplificationOptions

    public static Option<bool> AllowSimplificationToBaseType { get; }
    public static Option<bool> AllowSimplificationToGenericType { get; }
    public static Option<bool> PreferAliasToQualification { get; }
    public static Option<bool> PreferImplicitTypeInLocalDeclaration { get; }
    public static Option<bool> PreferImplicitTypeInference { get; }
    public static PerLanguageOption<bool> PreferIntrinsicPredefinedTypeKeywordInDeclaration { get; }
    public static PerLanguageOption<bool> PreferIntrinsicPredefinedTypeKeywordInMemberAccess { get; }
    public static Option<bool> PreferOmittingModuleNamesInQualification { get; }
    public static PerLanguageOption<bool> QualifyEventAccess { get; }
    public static PerLanguageOption<bool> QualifyFieldAccess { get; }
    public static PerLanguageOption<bool> QualifyMemberAccessWithThisOrMe { get; }
    public static PerLanguageOption<bool> QualifyMethodAccess { get; }
    public static PerLanguageOption<bool> QualifyPropertyAccess { get; }

  public static class Microsoft.CodeAnalysis.Simplification.Simplifier

    public static SyntaxAnnotation Annotation { get; }
    public static SyntaxAnnotation SpecialTypeAnnotation { get; }

    public static SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Workspace workspace, Func<SyntaxNode, bool> expandInsideNode = null, CancellationToken cancellationToken = default);
    public static TNode Expand<TNode>(TNode node, SemanticModel semanticModel, Workspace workspace, Func<SyntaxNode, bool> expandInsideNode = null, bool expandParameter = false, CancellationToken cancellationToken = default) where TNode : SyntaxNode;
    public static Task<SyntaxToken> ExpandAsync(SyntaxToken token, Document document, Func<SyntaxNode, bool> expandInsideNode = null, CancellationToken cancellationToken = default);
    public static Task<TNode> ExpandAsync<TNode>(TNode node, Document document, Func<SyntaxNode, bool> expandInsideNode = null, bool expandParameter = false, CancellationToken cancellationToken = default) where TNode : SyntaxNode;
    public static Task<Document> ReduceAsync(Document document, OptionSet optionSet = null, CancellationToken cancellationToken = default);
    public static Task<Document> ReduceAsync(Document document, SyntaxAnnotation annotation, OptionSet optionSet = null, CancellationToken cancellationToken = default);
    public static Task<Document> ReduceAsync(Document document, TextSpan span, OptionSet optionSet = null, CancellationToken cancellationToken = default);
    public static Task<Document> ReduceAsync(Document document, IEnumerable<TextSpan> spans, OptionSet optionSet = null, CancellationToken cancellationToken = default);

  public static class Microsoft.CodeAnalysis.Tags.WellKnownTags

    public const string Assembly = "Assembly";
    public const string Class = "Class";
    public const string Constant = "Constant";
    public const string Delegate = "Delegate";
    public const string Enum = "Enum";
    public const string EnumMember = "EnumMember";
    public const string Error = "Error";
    public const string Event = "Event";
    public const string ExtensionMethod = "ExtensionMethod";
    public const string Field = "Field";
    public const string File = "File";
    public const string Folder = "Folder";
    public const string Interface = "Interface";
    public const string Internal = "Internal";
    public const string Intrinsic = "Intrinsic";
    public const string Keyword = "Keyword";
    public const string Label = "Label";
    public const string Local = "Local";
    public const string Method = "Method";
    public const string Module = "Module";
    public const string Namespace = "Namespace";
    public const string Operator = "Operator";
    public const string Parameter = "Parameter";
    public const string Private = "Private";
    public const string Project = "Project";
    public const string Property = "Property";
    public const string Protected = "Protected";
    public const string Public = "Public";
    public const string RangeVariable = "RangeVariable";
    public const string Reference = "Reference";
    public const string Snippet = "Snippet";
    public const string Structure = "Structure";
    public const string TypeParameter = "TypeParameter";
    public const string Warning = "Warning";

  public static class Roslynator.DiagnosticsExtensions

    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, params object[] messageArgs);
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxNode node, params object[] messageArgs);
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxToken token, params object[] messageArgs);
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, SyntaxTrivia trivia, params object[] messageArgs);
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs);
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    public static void ReportDiagnostic(this SymbolAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs);
    public static void ReportDiagnostic(this SyntaxTreeAnalysisContext context, DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, ImmutableDictionary<string, string> properties, params object[] messageArgs);

  public static class Roslynator.EnumExtensions

    public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2);
    public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2);
    public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2);
    public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2);
    public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3);
    public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3);
    public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3);
    public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3);
    public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4);
    public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4);
    public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4);
    public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4);
    public static bool Is(this Accessibility accessibility, Accessibility accessibility1, Accessibility accessibility2, Accessibility accessibility3, Accessibility accessibility4, Accessibility accessibility5);
    public static bool Is(this MethodKind methodKind, MethodKind methodKind1, MethodKind methodKind2, MethodKind methodKind3, MethodKind methodKind4, MethodKind methodKind5);
    public static bool Is(this SpecialType specialType, SpecialType specialType1, SpecialType specialType2, SpecialType specialType3, SpecialType specialType4, SpecialType specialType5);
    public static bool Is(this TypeKind typeKind, TypeKind typeKind1, TypeKind typeKind2, TypeKind typeKind3, TypeKind typeKind4, TypeKind typeKind5);
    public static bool IsMoreRestrictiveThan(this Accessibility accessibility, Accessibility other);

  public static class Roslynator.FileLinePositionSpanExtensions

    public static int EndLine(this FileLinePositionSpan fileLinePositionSpan);
    public static bool IsMultiLine(this FileLinePositionSpan fileLinePositionSpan);
    public static bool IsSingleLine(this FileLinePositionSpan fileLinePositionSpan);
    public static int StartLine(this FileLinePositionSpan fileLinePositionSpan);

  public static class Roslynator.SemanticModelExtensions

    public static INamedTypeSymbol GetEnclosingNamedType(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default);
    public static TSymbol GetEnclosingSymbol<TSymbol>(this SemanticModel semanticModel, int position, CancellationToken cancellationToken = default) where TSymbol : ISymbol;
    public static ISymbol GetSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default);
    public static INamedTypeSymbol GetTypeByMetadataName(this SemanticModel semanticModel, string fullyQualifiedMetadataName);
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default);

  public static class Roslynator.SymbolExtensions

    public static IEnumerable<INamedTypeSymbol> BaseTypes(this ITypeSymbol type);
    public static IEnumerable<ITypeSymbol> BaseTypesAndSelf(this ITypeSymbol typeSymbol);
    public static bool EqualsOrInheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false);
    public static bool EqualsOrInheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false);
    public static TSymbol FindMember<TSymbol>(this ITypeSymbol typeSymbol, Func<TSymbol, bool> predicate = null) where TSymbol : ISymbol;
    public static TSymbol FindMember<TSymbol>(this ITypeSymbol typeSymbol, string name, Func<TSymbol, bool> predicate = null) where TSymbol : ISymbol;
    public static TSymbol FindMember<TSymbol>(this INamedTypeSymbol typeSymbol, Func<TSymbol, bool> predicate, bool includeBaseTypes = false) where TSymbol : ISymbol;
    public static TSymbol FindMember<TSymbol>(this INamedTypeSymbol typeSymbol, string name, Func<TSymbol, bool> predicate = null, bool includeBaseTypes = false) where TSymbol : ISymbol;
    public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, Func<INamedTypeSymbol, bool> predicate, bool includeBaseTypes = false);
    public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, Func<INamedTypeSymbol, bool> predicate = null, bool includeBaseTypes = false);
    public static INamedTypeSymbol FindTypeMember(this INamedTypeSymbol typeSymbol, string name, int arity, Func<INamedTypeSymbol, bool> predicate = null, bool includeBaseTypes = false);
    public static AttributeData GetAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass);
    public static AttributeData GetAttribute(this ISymbol symbol, in MetadataName attributeName);
    public static bool HasAttribute(this ISymbol symbol, INamedTypeSymbol attributeClass);
    public static bool HasAttribute(this ISymbol symbol, in MetadataName attributeName);
    public static bool HasAttribute(this ITypeSymbol typeSymbol, INamedTypeSymbol attributeClass, bool includeBaseTypes);
    public static bool HasAttribute(this ITypeSymbol typeSymbol, in MetadataName attributeName, bool includeBaseTypes);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, bool value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, char value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, sbyte value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, byte value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, short value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ushort value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, int value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, uint value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, long value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, ulong value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, decimal value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, float value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, double value);
    public static bool HasConstantValue(this IFieldSymbol fieldSymbol, string value);
    public static bool HasMetadataName(this ISymbol symbol, in MetadataName metadataName);
    public static bool Implements(this ITypeSymbol typeSymbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false);
    public static bool Implements(this ITypeSymbol typeSymbol, SpecialType interfaceType, bool allInterfaces = false);
    public static bool Implements(this ITypeSymbol typeSymbol, in MetadataName interfaceName, bool allInterfaces = false);
    public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, bool allInterfaces = false);
    public static bool ImplementsAny(this ITypeSymbol typeSymbol, SpecialType interfaceType1, SpecialType interfaceType2, SpecialType interfaceType3, bool allInterfaces = false);
    public static bool ImplementsInterfaceMember(this ISymbol symbol, bool allInterfaces = false);
    public static bool ImplementsInterfaceMember(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false);
    public static bool ImplementsInterfaceMember<TSymbol>(this ISymbol symbol, bool allInterfaces = false) where TSymbol : ISymbol;
    public static bool ImplementsInterfaceMember<TSymbol>(this ISymbol symbol, INamedTypeSymbol interfaceSymbol, bool allInterfaces = false) where TSymbol : ISymbol;
    public static bool InheritsFrom(this ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces = false);
    public static bool InheritsFrom(this ITypeSymbol type, in MetadataName baseTypeName, bool includeInterfaces = false);
    public static bool IsAsyncMethod(this ISymbol symbol);
    public static bool IsErrorType(this ISymbol symbol);
    public static bool IsIEnumerableOfT(this ITypeSymbol typeSymbol);
    public static bool IsIEnumerableOrIEnumerableOfT(this ITypeSymbol typeSymbol);
    public static bool IsKind(this ISymbol symbol, SymbolKind kind);
    public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2);
    public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3);
    public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4);
    public static bool IsKind(this ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3, SymbolKind kind4, SymbolKind kind5);
    public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, SpecialType specialType);
    public static bool IsNullableOf(this INamedTypeSymbol namedTypeSymbol, ITypeSymbol typeArgument);
    public static bool IsNullableOf(this ITypeSymbol typeSymbol, SpecialType specialType);
    public static bool IsNullableOf(this ITypeSymbol typeSymbol, ITypeSymbol typeArgument);
    public static bool IsNullableType(this ITypeSymbol typeSymbol);
    public static bool IsObject(this ITypeSymbol typeSymbol);
    public static bool IsOrdinaryExtensionMethod(this IMethodSymbol methodSymbol);
    public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType);
    public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2);
    public static bool IsParameterArrayOf(this IParameterSymbol parameterSymbol, SpecialType elementType1, SpecialType elementType2, SpecialType elementType3);
    public static bool IsPubliclyVisible(this ISymbol symbol);
    public static bool IsReducedExtensionMethod(this IMethodSymbol methodSymbol);
    public static bool IsRefOrOut(this IParameterSymbol parameterSymbol);
    public static bool IsReferenceTypeOrNullableType(this ITypeSymbol typeSymbol);
    public static bool IsString(this ITypeSymbol typeSymbol);
    public static bool IsVoid(this ITypeSymbol typeSymbol);
    public static IMethodSymbol ReducedFromOrSelf(this IMethodSymbol methodSymbol);
    public static bool SupportsExplicitDeclaration(this ITypeSymbol typeSymbol);

  public static class Roslynator.SyntaxExtensions

    public static bool All(this SyntaxTokenList list, Func<SyntaxToken, bool> predicate);
    public static bool All(this SyntaxTriviaList list, Func<SyntaxTrivia, bool> predicate);
    public static bool All<TNode>(this SeparatedSyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode;
    public static bool All<TNode>(this SyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode;
    public static bool Any(this SyntaxTokenList list, Func<SyntaxToken, bool> predicate);
    public static bool Any(this SyntaxTriviaList list, Func<SyntaxTrivia, bool> predicate);
    public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode;
    public static bool Any<TNode>(this SyntaxList<TNode> list, Func<TNode, bool> predicate) where TNode : SyntaxNode;
    public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia);
    public static SyntaxToken AppendToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia);
    public static TNode AppendToLeadingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode;
    public static TNode AppendToLeadingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode;
    public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia);
    public static SyntaxToken AppendToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia);
    public static TNode AppendToTrailingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode;
    public static TNode AppendToTrailingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode;
    public static bool Contains(this SyntaxTokenList tokens, SyntaxToken token);
    public static bool Contains<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    public static bool Contains<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    public static bool ContainsDirectives(this SyntaxNode node, TextSpan span);
    public static IEnumerable<SyntaxTrivia> DescendantTrivia<TNode>(this SyntaxList<TNode> list, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    public static IEnumerable<SyntaxTrivia> DescendantTrivia<TNode>(this SyntaxList<TNode> list, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    public static TNode FirstAncestor<TNode>(this SyntaxNode node, Func<TNode, bool> predicate = null, bool ascendOutOfTrivia = true) where TNode : SyntaxNode;
    public static TNode FirstDescendant<TNode>(this SyntaxNode node, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    public static TNode FirstDescendant<TNode>(this SyntaxNode node, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    public static TNode FirstDescendantOrSelf<TNode>(this SyntaxNode node, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    public static TNode FirstDescendantOrSelf<TNode>(this SyntaxNode node, TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false) where TNode : SyntaxNode;
    public static SyntaxTriviaList GetLeadingAndTrailingTrivia(this SyntaxNode node);
    public static SyntaxToken GetTrailingSeparator<TNode>(this SeparatedSyntaxList<TNode> list) where TNode : SyntaxNode;
    public static bool HasTrailingSeparator<TNode>(this SeparatedSyntaxList<TNode> list) where TNode : SyntaxNode;
    public static int IndexOf(this SyntaxTokenList tokens, Func<SyntaxToken, bool> predicate);
    public static int IndexOf(this SyntaxTriviaList triviaList, Func<SyntaxTrivia, bool> predicate);
    public static bool IsFirst<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    public static bool IsFirst<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    public static bool IsLast<TNode>(this SeparatedSyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    public static bool IsLast<TNode>(this SyntaxList<TNode> list, TNode node) where TNode : SyntaxNode;
    public static SyntaxTriviaList LeadingAndTrailingTrivia(this SyntaxToken token);
    public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia);
    public static SyntaxToken PrependToLeadingTrivia(this SyntaxToken token, SyntaxTrivia trivia);
    public static TNode PrependToLeadingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode;
    public static TNode PrependToLeadingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode;
    public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, IEnumerable<SyntaxTrivia> trivia);
    public static SyntaxToken PrependToTrailingTrivia(this SyntaxToken token, SyntaxTrivia trivia);
    public static TNode PrependToTrailingTrivia<TNode>(this TNode node, IEnumerable<SyntaxTrivia> trivia) where TNode : SyntaxNode;
    public static TNode PrependToTrailingTrivia<TNode>(this TNode node, SyntaxTrivia trivia) where TNode : SyntaxNode;
    public static SyntaxTokenList ReplaceAt(this SyntaxTokenList tokenList, int index, SyntaxToken newToken);
    public static SyntaxTriviaList ReplaceAt(this SyntaxTriviaList triviaList, int index, SyntaxTrivia newTrivia);
    public static SeparatedSyntaxList<TNode> ReplaceAt<TNode>(this SeparatedSyntaxList<TNode> list, int index, TNode newNode) where TNode : SyntaxNode;
    public static SyntaxList<TNode> ReplaceAt<TNode>(this SyntaxList<TNode> list, int index, TNode newNode) where TNode : SyntaxNode;
    public static bool SpanContainsDirectives(this SyntaxNode node);
    public static bool TryGetContainingList(this SyntaxTrivia trivia, out SyntaxTriviaList triviaList, bool allowLeading = true, bool allowTrailing = true);
    public static SyntaxToken WithTriviaFrom(this SyntaxToken token, SyntaxNode node);
    public static SeparatedSyntaxList<TNode> WithTriviaFrom<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxNode node) where TNode : SyntaxNode;
    public static SyntaxList<TNode> WithTriviaFrom<TNode>(this SyntaxList<TNode> list, SyntaxNode node) where TNode : SyntaxNode;
    public static TNode WithTriviaFrom<TNode>(this TNode node, SyntaxToken token) where TNode : SyntaxNode;
    public static SyntaxNodeOrToken WithoutLeadingTrivia(this SyntaxNodeOrToken nodeOrToken);
    public static SyntaxToken WithoutLeadingTrivia(this SyntaxToken token);
    public static SyntaxNodeOrToken WithoutTrailingTrivia(this SyntaxNodeOrToken nodeOrToken);
    public static SyntaxToken WithoutTrailingTrivia(this SyntaxToken token);
    public static SyntaxNodeOrToken WithoutTrivia(this SyntaxNodeOrToken nodeOrToken);

  public static class Roslynator.SyntaxTreeExtensions

    public static int GetEndLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default);
    public static int GetStartLine(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default);
    public static bool IsMultiLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default);
    public static bool IsSingleLineSpan(this SyntaxTree syntaxTree, TextSpan span, CancellationToken cancellationToken = default);

  public static class Roslynator.WorkspaceExtensions

    public static Task<Document> InsertNodeAfterAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default);
    public static Task<Document> InsertNodeBeforeAsync(this Document document, SyntaxNode nodeInList, SyntaxNode newNode, CancellationToken cancellationToken = default);
    public static Task<Document> InsertNodesAfterAsync(this Document document, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default);
    public static Task<Document> InsertNodesBeforeAsync(this Document document, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default);
    public static Task<Document> RemoveNodeAsync(this Document document, SyntaxNode node, SyntaxRemoveOptions options, CancellationToken cancellationToken = default);
    public static Task<Document> RemoveNodesAsync(this Document document, IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options, CancellationToken cancellationToken = default);
    public static Task<Document> ReplaceNodeAsync(this Document document, SyntaxNode oldNode, SyntaxNode newNode, CancellationToken cancellationToken = default);
    public static Task<Document> ReplaceNodeAsync(this Document document, SyntaxNode oldNode, IEnumerable<SyntaxNode> newNodes, CancellationToken cancellationToken = default);
    public static Task<Solution> ReplaceNodeAsync<TNode>(this Solution solution, TNode oldNode, TNode newNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode;
    public static Task<Document> ReplaceNodesAsync<TNode>(this Document document, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNode, CancellationToken cancellationToken = default) where TNode : SyntaxNode;
    public static Task<Solution> ReplaceNodesAsync<TNode>(this Solution solution, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNodes, CancellationToken cancellationToken = default) where TNode : SyntaxNode;
    public static Task<Document> ReplaceTokenAsync(this Document document, SyntaxToken oldToken, SyntaxToken newToken, CancellationToken cancellationToken = default);
    public static Task<Document> ReplaceTokenAsync(this Document document, SyntaxToken oldToken, IEnumerable<SyntaxToken> newTokens, CancellationToken cancellationToken = default);
    public static Task<Document> ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia, CancellationToken cancellationToken = default);
    public static Task<Document> ReplaceTriviaAsync(this Document document, SyntaxTrivia oldTrivia, IEnumerable<SyntaxTrivia> newTrivia, CancellationToken cancellationToken = default);
    public static Task<Document> WithTextChangeAsync(this Document document, TextChange textChange, CancellationToken cancellationToken = default);
    public static Task<Document> WithTextChangesAsync(this Document document, TextChange[] textChanges, CancellationToken cancellationToken = default);
    public static Task<Document> WithTextChangesAsync(this Document document, IEnumerable<TextChange> textChanges, CancellationToken cancellationToken = default);

  public static class Roslynator.CSharp.CSharpExtensions

    public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, ArgumentSyntax argument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default);
    public static IParameterSymbol DetermineParameter(this SemanticModel semanticModel, AttributeArgumentSyntax attributeArgument, bool allowParams = false, bool allowCandidate = false, CancellationToken cancellationToken = default);
    public static ExtensionMethodSymbolInfo GetExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static IMethodSymbol GetMethodSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static ExtensionMethodSymbolInfo GetReducedExtensionMethodInfo(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static ISymbol GetSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default);
    public static ISymbol GetSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default);
    public static ISymbol GetSymbol(this SemanticModel semanticModel, CrefSyntax cref, CancellationToken cancellationToken = default);
    public static ISymbol GetSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static ISymbol GetSymbol(this SemanticModel semanticModel, OrderingSyntax ordering, CancellationToken cancellationToken = default);
    public static ISymbol GetSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default);
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken = default);
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken = default);
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static ITypeSymbol GetTypeSymbol(this SemanticModel semanticModel, SelectOrGroupClauseSyntax selectOrGroupClause, CancellationToken cancellationToken = default);
    public static bool HasConstantValue(this SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static bool IsDefaultValue(this SemanticModel semanticModel, ITypeSymbol typeSymbol, ExpressionSyntax expression, CancellationToken cancellationToken = default);

  public static class Roslynator.CSharp.CSharpFactory

    public static AccessorListSyntax AccessorList(AccessorDeclarationSyntax accessor);
    public static AccessorListSyntax AccessorList(params AccessorDeclarationSyntax[] accessors);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax AddAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AddAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AndAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, ExpressionSyntax expression);
    public static ArgumentListSyntax ArgumentList(ArgumentSyntax argument);
    public static ArgumentListSyntax ArgumentList(params ArgumentSyntax[] arguments);
    public static InitializerExpressionSyntax ArrayInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax ArrayInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax AsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentSyntax argument);
    public static AttributeArgumentSyntax AttributeArgument(NameColonSyntax nameColon, ExpressionSyntax expression);
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public static AttributeArgumentListSyntax AttributeArgumentList(AttributeArgumentSyntax attributeArgument);
    public static AttributeArgumentListSyntax AttributeArgumentList(params AttributeArgumentSyntax[] attributeArguments);
    public static AttributeListSyntax AttributeList(AttributeSyntax attribute);
    public static AttributeListSyntax AttributeList(params AttributeSyntax[] attributes);
    public static AccessorDeclarationSyntax AutoGetAccessorDeclaration(SyntaxTokenList modifiers = default);
    public static AccessorDeclarationSyntax AutoSetAccessorDeclaration(SyntaxTokenList modifiers = default);
    public static ConstructorInitializerSyntax BaseConstructorInitializer(ArgumentListSyntax argumentList = null);
    public static ConstructorInitializerSyntax BaseConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList);
    public static BaseListSyntax BaseList(BaseTypeSyntax type);
    public static BaseListSyntax BaseList(params BaseTypeSyntax[] types);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, BaseTypeSyntax baseType);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, params BaseTypeSyntax[] types);
    public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax BitwiseAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax BitwiseNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax BitwiseOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BlockSyntax Block(StatementSyntax statement);
    public static BlockSyntax Block(SyntaxToken openBrace, StatementSyntax statement, SyntaxToken closeBrace);
    public static LiteralExpressionSyntax BooleanLiteralExpression(bool value);
    public static BracketedArgumentListSyntax BracketedArgumentList(ArgumentSyntax argument);
    public static BracketedArgumentListSyntax BracketedArgumentList(params ArgumentSyntax[] arguments);
    public static BracketedParameterListSyntax BracketedParameterList(ParameterSyntax parameter);
    public static BracketedParameterListSyntax BracketedParameterList(params ParameterSyntax[] parameters);
    public static LiteralExpressionSyntax CharacterLiteralExpression(char value);
    public static CheckedExpressionSyntax CheckedExpression(ExpressionSyntax expression);
    public static CheckedExpressionSyntax CheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static ClassOrStructConstraintSyntax ClassConstraint();
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax CoalesceExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static InitializerExpressionSyntax CollectionInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax CollectionInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static CompilationUnitSyntax CompilationUnit(MemberDeclarationSyntax member);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<UsingDirectiveSyntax> usings, MemberDeclarationSyntax member);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members);
    public static InitializerExpressionSyntax ComplexElementInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax ComplexElementInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static LiteralExpressionSyntax DefaultLiteralExpression();
    public static SwitchSectionSyntax DefaultSwitchSection(StatementSyntax statement);
    public static SwitchSectionSyntax DefaultSwitchSection(SyntaxList<StatementSyntax> statements);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, string identifier, ParameterListSyntax parameterList);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList);
    public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax DivideAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static SyntaxTrivia EmptyWhitespace();
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, ExpressionSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier, EqualsValueClauseSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, ExpressionSyntax value);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string name, EqualsValueClauseSyntax value);
    public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, AccessorListSyntax accessorList);
    public static EventDeclarationSyntax EventDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier);
    public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax ExclusiveOrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConversionOperatorDeclarationSyntax ExplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static LiteralExpressionSyntax FalseLiteralExpression();
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, string identifier, ExpressionSyntax value = null);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null);
    public static GenericNameSyntax GenericName(string identifier, TypeSyntax typeArgument);
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeSyntax typeArgument);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax GetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body);
    public static ConversionOperatorDeclarationSyntax ImplicitConversionOperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax type, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxTokenList modifiers, TypeSyntax type, BracketedParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax LeftShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static LiteralExpressionSyntax LiteralExpression(object value);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, EqualsValueClauseSyntax initializer);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, string identifier, ExpressionSyntax value = null);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LogicalAndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax LogicalNotExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LogicalOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax ModuloAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax MultiplyAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static InvocationExpressionSyntax NameOfExpression(ExpressionSyntax expression);
    public static InvocationExpressionSyntax NameOfExpression(string identifier);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, MemberDeclarationSyntax member);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList<MemberDeclarationSyntax> members);
    public static SyntaxTrivia NewLine();
    public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static LiteralExpressionSyntax NullLiteralExpression();
    public static LiteralExpressionSyntax NumericLiteralExpression(int value);
    public static LiteralExpressionSyntax NumericLiteralExpression(uint value);
    public static LiteralExpressionSyntax NumericLiteralExpression(sbyte value);
    public static LiteralExpressionSyntax NumericLiteralExpression(decimal value);
    public static LiteralExpressionSyntax NumericLiteralExpression(double value);
    public static LiteralExpressionSyntax NumericLiteralExpression(float value);
    public static LiteralExpressionSyntax NumericLiteralExpression(long value);
    public static LiteralExpressionSyntax NumericLiteralExpression(ulong value);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList);
    public static InitializerExpressionSyntax ObjectInitializerExpression(SeparatedSyntaxList<ExpressionSyntax> expressions = default);
    public static InitializerExpressionSyntax ObjectInitializerExpression(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax OrAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ParameterSyntax Parameter(TypeSyntax type, string identifier, ExpressionSyntax @default = null);
    public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax @default = null);
    public static ParameterSyntax Parameter(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default);
    public static ParameterListSyntax ParameterList(ParameterSyntax parameter);
    public static ParameterListSyntax ParameterList(params ParameterSyntax[] parameters);
    public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PointerIndirectionExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand);
    public static PostfixUnaryExpressionSyntax PostDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand);
    public static PostfixUnaryExpressionSyntax PostIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PreDecrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PreIncrementExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PredefinedTypeSyntax PredefinedBoolType();
    public static PredefinedTypeSyntax PredefinedByteType();
    public static PredefinedTypeSyntax PredefinedCharType();
    public static PredefinedTypeSyntax PredefinedDecimalType();
    public static PredefinedTypeSyntax PredefinedDoubleType();
    public static PredefinedTypeSyntax PredefinedFloatType();
    public static PredefinedTypeSyntax PredefinedIntType();
    public static PredefinedTypeSyntax PredefinedLongType();
    public static PredefinedTypeSyntax PredefinedObjectType();
    public static PredefinedTypeSyntax PredefinedSByteType();
    public static PredefinedTypeSyntax PredefinedShortType();
    public static PredefinedTypeSyntax PredefinedStringType();
    public static PredefinedTypeSyntax PredefinedUIntType();
    public static PredefinedTypeSyntax PredefinedULongType();
    public static PredefinedTypeSyntax PredefinedUShortType();
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, ArrowExpressionClauseSyntax expressionBody);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, AccessorListSyntax accessorList, ExpressionSyntax value = null);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax RemoveAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax RightShiftAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(BlockSyntax body);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(ArrowExpressionClauseSyntax expressionBody);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax SetAccessorDeclaration(SyntaxTokenList modifiers, ArrowExpressionClauseSyntax expressionBody);
    public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax SimpleAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static ExpressionStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentSyntax argument);
    public static InvocationExpressionSyntax SimpleMemberInvocationExpression(ExpressionSyntax expression, SimpleNameSyntax name, ArgumentListSyntax argumentList);
    public static LiteralExpressionSyntax StringLiteralExpression(string value);
    public static ClassOrStructConstraintSyntax StructConstraint();
    public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, string identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static StructDeclarationSyntax StructDeclaration(SyntaxTokenList modifiers, SyntaxToken identifier, SyntaxList<MemberDeclarationSyntax> members = default);
    public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentExpressionSyntax SubtractAssignmentExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, StatementSyntax statement);
    public static SwitchSectionSyntax SwitchSection(SwitchLabelSyntax switchLabel, SyntaxList<StatementSyntax> statements);
    public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> switchLabels, StatementSyntax statement);
    public static ConstructorInitializerSyntax ThisConstructorInitializer(ArgumentListSyntax argumentList = null);
    public static ConstructorInitializerSyntax ThisConstructorInitializer(SyntaxToken semicolonToken, ArgumentListSyntax argumentList);
    public static SyntaxTokenList TokenList(Accessibility accessibility);
    public static SyntaxTokenList TokenList(SyntaxKind kind);
    public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2);
    public static SyntaxTokenList TokenList(SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static LiteralExpressionSyntax TrueLiteralExpression();
    public static TryStatementSyntax TryStatement(BlockSyntax block, CatchClauseSyntax @catch, FinallyClauseSyntax @finally = null);
    public static TypeArgumentListSyntax TypeArgumentList(TypeSyntax argument);
    public static TypeArgumentListSyntax TypeArgumentList(params TypeSyntax[] arguments);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax identifierName, TypeParameterConstraintSyntax typeParameterConstraint);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name, TypeParameterConstraintSyntax typeParameterConstraint);
    public static TypeParameterListSyntax TypeParameterList(TypeParameterSyntax parameter);
    public static TypeParameterListSyntax TypeParameterList(params TypeParameterSyntax[] parameters);
    public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand, SyntaxToken operatorToken);
    public static CheckedExpressionSyntax UncheckedExpression(ExpressionSyntax expression);
    public static CheckedExpressionSyntax UncheckedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static UsingDirectiveSyntax UsingStaticDirective(NameSyntax name);
    public static UsingDirectiveSyntax UsingStaticDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameSyntax name, SyntaxToken semicolonToken);
    public static IdentifierNameSyntax VarType();
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, VariableDeclaratorSyntax variable);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, string identifier, ExpressionSyntax value = null);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax value = null);
    public static VariableDeclaratorSyntax VariableDeclarator(string identifier, EqualsValueClauseSyntax initializer);
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, EqualsValueClauseSyntax initializer);
    public static PredefinedTypeSyntax VoidType();
    public static YieldStatementSyntax YieldBreakStatement();
    public static YieldStatementSyntax YieldReturnStatement(ExpressionSyntax expression);

  public static class Roslynator.CSharp.CSharpFacts

    public static bool CanBeEmbeddedStatement(SyntaxKind kind);
    public static bool CanHaveEmbeddedStatement(SyntaxKind kind);
    public static bool CanHaveExpressionBody(SyntaxKind kind);
    public static bool CanHaveMembers(SyntaxKind kind);
    public static bool CanHaveModifiers(SyntaxKind kind);
    public static bool CanHaveStatements(SyntaxKind kind);
    public static bool IsAnonymousFunctionExpression(SyntaxKind kind);
    public static bool IsBooleanExpression(SyntaxKind kind);
    public static bool IsBooleanLiteralExpression(SyntaxKind kind);
    public static bool IsCommentTrivia(SyntaxKind kind);
    public static bool IsCompoundAssignmentExpression(SyntaxKind kind);
    public static bool IsConstraint(SyntaxKind kind);
    public static bool IsFunction(SyntaxKind kind);
    public static bool IsIfElseDirective(SyntaxKind kind);
    public static bool IsIncrementOrDecrementExpression(SyntaxKind kind);
    public static bool IsIterationStatement(SyntaxKind kind);
    public static bool IsJumpStatement(SyntaxKind kind);
    public static bool IsLambdaExpression(SyntaxKind kind);
    public static bool IsLiteralExpression(SyntaxKind kind);
    public static bool IsPredefinedType(SpecialType specialType);
    public static bool IsSimpleType(SpecialType specialType);
    public static bool IsSwitchLabel(SyntaxKind kind);
    public static bool SupportsPrefixOrPostfixUnaryOperator(SpecialType specialType);

  public static class Roslynator.CSharp.EnumExtensions

    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2);
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    public static bool Is(this SyntaxKind kind, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);

  public static class Roslynator.CSharp.ModifierList

    public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxKind kind, IComparer<SyntaxKind> comparer = null);
    public static int GetInsertIndex(SyntaxTokenList tokens, SyntaxToken token, IComparer<SyntaxToken> comparer = null);
    public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxKind kind, IComparer<SyntaxKind> comparer = null);
    public static SyntaxTokenList Insert(SyntaxTokenList modifiers, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null);
    public static TNode Insert<TNode>(TNode node, SyntaxKind kind, IComparer<SyntaxKind> comparer = null) where TNode : SyntaxNode;
    public static TNode Insert<TNode>(TNode node, SyntaxToken modifier, IComparer<SyntaxToken> comparer = null) where TNode : SyntaxNode;
    public static TNode Remove<TNode>(TNode node, SyntaxKind kind) where TNode : SyntaxNode;
    public static TNode Remove<TNode>(TNode node, SyntaxToken modifier) where TNode : SyntaxNode;
    public static TNode RemoveAll<TNode>(TNode node) where TNode : SyntaxNode;
    public static TNode RemoveAll<TNode>(TNode node, Func<SyntaxToken, bool> predicate) where TNode : SyntaxNode;
    public static TNode RemoveAt<TNode>(TNode node, int index) where TNode : SyntaxNode;

  public static class Roslynator.CSharp.Modifiers

    public static SyntaxTokenList Const();
    public static SyntaxTokenList Internal();
    public static SyntaxTokenList Internal_Abstract();
    public static SyntaxTokenList Internal_Const();
    public static SyntaxTokenList Internal_Override();
    public static SyntaxTokenList Internal_Partial();
    public static SyntaxTokenList Internal_ReadOnly();
    public static SyntaxTokenList Internal_Static();
    public static SyntaxTokenList Internal_Static_Partial();
    public static SyntaxTokenList Internal_Static_ReadOnly();
    public static SyntaxTokenList Internal_Virtual();
    public static SyntaxTokenList Partial();
    public static SyntaxTokenList Private();
    public static SyntaxTokenList Private_Const();
    public static SyntaxTokenList Private_Partial();
    public static SyntaxTokenList Private_Protected();
    public static SyntaxTokenList Private_ReadOnly();
    public static SyntaxTokenList Private_Static();
    public static SyntaxTokenList Private_Static_Partial();
    public static SyntaxTokenList Private_Static_ReadOnly();
    public static SyntaxTokenList Protected();
    public static SyntaxTokenList Protected_Abstract();
    public static SyntaxTokenList Protected_Const();
    public static SyntaxTokenList Protected_Internal();
    public static SyntaxTokenList Protected_Override();
    public static SyntaxTokenList Protected_ReadOnly();
    public static SyntaxTokenList Protected_Static();
    public static SyntaxTokenList Protected_Static_ReadOnly();
    public static SyntaxTokenList Protected_Virtual();
    public static SyntaxTokenList Public();
    public static SyntaxTokenList Public_Abstract();
    public static SyntaxTokenList Public_Const();
    public static SyntaxTokenList Public_Override();
    public static SyntaxTokenList Public_Partial();
    public static SyntaxTokenList Public_ReadOnly();
    public static SyntaxTokenList Public_Static();
    public static SyntaxTokenList Public_Static_Partial();
    public static SyntaxTokenList Public_Static_ReadOnly();
    public static SyntaxTokenList Public_Virtual();
    public static SyntaxTokenList ReadOnly();
    public static SyntaxTokenList Ref_ReadOnly();
    public static SyntaxTokenList Static();
    public static SyntaxTokenList Static_ReadOnly();
    public static SyntaxTokenList Virtual();

  public static class Roslynator.CSharp.SymbolExtensions

    public static bool SupportsConstantValue(this ITypeSymbol typeSymbol);
    public static TypeSyntax ToMinimalTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
    public static TypeSyntax ToMinimalTypeSyntax(this INamespaceSymbol namespaceSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
    public static TypeSyntax ToMinimalTypeSyntax(this ITypeSymbol typeSymbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
    public static TypeSyntax ToTypeSyntax(this INamespaceOrTypeSymbol namespaceOrTypeSymbol, SymbolDisplayFormat format = null);
    public static TypeSyntax ToTypeSyntax(this INamespaceSymbol namespaceSymbol, SymbolDisplayFormat format = null);
    public static TypeSyntax ToTypeSyntax(this ITypeSymbol typeSymbol, SymbolDisplayFormat format = null);

  public static class Roslynator.CSharp.SyntaxAccessibility

    public static Accessibility GetAccessibility(SyntaxNode declaration);
    public static Accessibility GetDefaultAccessibility(SyntaxNode declaration);
    public static Accessibility GetDefaultExplicitAccessibility(SyntaxNode declaration);
    public static Accessibility GetExplicitAccessibility(SyntaxNode declaration);
    public static Accessibility GetExplicitAccessibility(SyntaxTokenList modifiers);
    public static bool IsPubliclyVisible(MemberDeclarationSyntax declaration);
    public static bool IsValidAccessibility(SyntaxNode node, Accessibility accessibility, bool ignoreOverride = false);
    public static TNode WithExplicitAccessibility<TNode>(TNode node, Accessibility newAccessibility, IComparer<SyntaxKind> comparer = null) where TNode : SyntaxNode;
    public static TNode WithoutExplicitAccessibility<TNode>(TNode node) where TNode : SyntaxNode;

  public static class Roslynator.CSharp.SyntaxExtensions

    public static SyntaxList<StatementSyntax> Add(this SyntaxList<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions);
    public static ClassDeclarationSyntax AddAttributeLists(this ClassDeclarationSyntax classDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists);
    public static InterfaceDeclarationSyntax AddAttributeLists(this InterfaceDeclarationSyntax interfaceDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists);
    public static StructDeclarationSyntax AddAttributeLists(this StructDeclarationSyntax structDeclaration, bool keepDocumentationCommentOnTop, params AttributeListSyntax[] attributeLists);
    public static CompilationUnitSyntax AddUsings(this CompilationUnitSyntax compilationUnit, bool keepSingleLineCommentsOnTop, params UsingDirectiveSyntax[] usings);
    public static IfStatementCascade AsCascade(this IfStatementSyntax ifStatement);
    public static ExpressionChain AsChain(this BinaryExpressionSyntax binaryExpression, TextSpan? span = null);
    public static CSharpSyntaxNode BodyOrExpressionBody(this AccessorDeclarationSyntax accessorDeclaration);
    public static CSharpSyntaxNode BodyOrExpressionBody(this ConstructorDeclarationSyntax constructorDeclaration);
    public static CSharpSyntaxNode BodyOrExpressionBody(this ConversionOperatorDeclarationSyntax conversionOperatorDeclaration);
    public static CSharpSyntaxNode BodyOrExpressionBody(this DestructorDeclarationSyntax destructorDeclaration);
    public static CSharpSyntaxNode BodyOrExpressionBody(this LocalFunctionStatementSyntax localFunctionStatement);
    public static CSharpSyntaxNode BodyOrExpressionBody(this MethodDeclarationSyntax methodDeclaration);
    public static CSharpSyntaxNode BodyOrExpressionBody(this OperatorDeclarationSyntax operatorDeclaration);
    public static TextSpan BracesSpan(this ClassDeclarationSyntax classDeclaration);
    public static TextSpan BracesSpan(this EnumDeclarationSyntax enumDeclaration);
    public static TextSpan BracesSpan(this InterfaceDeclarationSyntax interfaceDeclaration);
    public static TextSpan BracesSpan(this NamespaceDeclarationSyntax namespaceDeclaration);
    public static TextSpan BracesSpan(this StructDeclarationSyntax structDeclaration);
    public static bool Contains(this SyntaxTokenList tokenList, SyntaxKind kind);
    public static bool Contains(this SyntaxTriviaList triviaList, SyntaxKind kind);
    public static bool Contains<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static bool Contains<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2);
    public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    public static bool ContainsAny(this SyntaxTokenList tokenList, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    public static bool ContainsDefaultLabel(this SwitchSectionSyntax switchSection);
    public static bool ContainsYield(this LocalFunctionStatementSyntax localFunctionStatement);
    public static bool ContainsYield(this MethodDeclarationSyntax methodDeclaration);
    public static CSharpSyntaxNode DeclarationOrExpression(this UsingStatementSyntax usingStatement);
    public static SwitchSectionSyntax DefaultSection(this SwitchStatementSyntax switchStatement);
    public static IEnumerable<XmlElementSyntax> Elements(this DocumentationCommentTriviaSyntax documentationComment, string localName);
    public static SyntaxToken Find(this SyntaxTokenList tokenList, SyntaxKind kind);
    public static SyntaxTrivia Find(this SyntaxTriviaList triviaList, SyntaxKind kind);
    public static TNode Find<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static TNode Find<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true);
    public static SyntaxNode FirstAncestor(this SyntaxNode node, Func<SyntaxNode, bool> predicate, bool ascendOutOfTrivia = true);
    public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true);
    public static SyntaxNode FirstAncestor(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true);
    public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true);
    public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, Func<SyntaxNode, bool> predicate, bool ascendOutOfTrivia = true);
    public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, bool ascendOutOfTrivia = true);
    public static SyntaxNode FirstAncestorOrSelf(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, bool ascendOutOfTrivia = true);
    public static IfStatementCascadeInfo GetCascadeInfo(this IfStatementSyntax ifStatement);
    public static DocumentationCommentTriviaSyntax GetDocumentationComment(this MemberDeclarationSyntax member);
    public static SyntaxTrivia GetDocumentationCommentTrivia(this MemberDeclarationSyntax member);
    public static EndRegionDirectiveTriviaSyntax GetEndRegionDirective(this RegionDirectiveTriviaSyntax regionDirective);
    public static DirectiveTriviaSyntax GetFirstDirective(this SyntaxNode node, TextSpan span, Func<DirectiveTriviaSyntax, bool> predicate = null);
    public static DirectiveTriviaSyntax GetNextRelatedDirective(this DirectiveTriviaSyntax directiveTrivia);
    public static SyntaxTrivia GetPreprocessingMessageTrivia(this EndRegionDirectiveTriviaSyntax endRegionDirective);
    public static SyntaxTrivia GetPreprocessingMessageTrivia(this RegionDirectiveTriviaSyntax regionDirective);
    public static RegionDirectiveTriviaSyntax GetRegionDirective(this EndRegionDirectiveTriviaSyntax endRegionDirective);
    public static DocumentationCommentTriviaSyntax GetSingleLineDocumentationComment(this MemberDeclarationSyntax member);
    public static SyntaxTrivia GetSingleLineDocumentationCommentTrivia(this MemberDeclarationSyntax member);
    public static IfStatementSyntax GetTopmostIf(this ElseClauseSyntax elseClause);
    public static IfStatementSyntax GetTopmostIf(this IfStatementSyntax ifStatement);
    public static AccessorDeclarationSyntax Getter(this AccessorListSyntax accessorList);
    public static AccessorDeclarationSyntax Getter(this IndexerDeclarationSyntax indexerDeclaration);
    public static AccessorDeclarationSyntax Getter(this PropertyDeclarationSyntax propertyDeclaration);
    public static bool HasDocumentationComment(this MemberDeclarationSyntax member);
    public static bool HasSingleLineDocumentationComment(this MemberDeclarationSyntax member);
    public static bool IsAutoImplemented(this AccessorDeclarationSyntax accessorDeclaration);
    public static bool IsDescendantOf(this SyntaxNode node, SyntaxKind kind, bool ascendOutOfTrivia = true);
    public static bool IsEmbedded(this StatementSyntax statement, bool canBeBlock = false, bool canBeIfInsideElse = true, bool canBeUsingInsideUsing = true);
    public static bool IsEmptyOrWhitespace(this SyntaxTriviaList triviaList);
    public static bool IsEndOfLineTrivia(this SyntaxTrivia trivia);
    public static bool IsHexNumericLiteral(this LiteralExpressionSyntax literalExpression);
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2);
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2);
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    public static bool IsKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    public static bool IsKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    public static bool IsKind(this SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    public static bool IsLast(this SyntaxList<StatementSyntax> statements, StatementSyntax statement, bool ignoreLocalFunctions);
    public static bool IsParams(this ParameterSyntax parameter);
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind);
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind);
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2);
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5);
    public static bool IsParentKind(this SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    public static bool IsParentKind(this SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4, SyntaxKind kind5, SyntaxKind kind6);
    public static bool IsSimpleIf(this IfStatementSyntax ifStatement);
    public static bool IsTopmostIf(this IfStatementSyntax ifStatement);
    public static bool IsVerbatim(this InterpolatedStringExpressionSyntax interpolatedString);
    public static bool IsVoid(this TypeSyntax type);
    public static bool IsWhitespaceOrEndOfLineTrivia(this SyntaxTrivia trivia);
    public static bool IsWhitespaceTrivia(this SyntaxTrivia trivia);
    public static bool IsYieldBreak(this YieldStatementSyntax yieldStatement);
    public static bool IsYieldReturn(this YieldStatementSyntax yieldStatement);
    public static int LastIndexOf(this SyntaxTriviaList triviaList, SyntaxKind kind);
    public static int LastIndexOf<TNode>(this SeparatedSyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static int LastIndexOf<TNode>(this SyntaxList<TNode> list, SyntaxKind kind) where TNode : SyntaxNode;
    public static StatementSyntax NextStatement(this StatementSyntax statement);
    public static TextSpan ParenthesesSpan(this CastExpressionSyntax castExpression);
    public static TextSpan ParenthesesSpan(this CommonForEachStatementSyntax forEachStatement);
    public static TextSpan ParenthesesSpan(this ForStatementSyntax forStatement);
    public static StatementSyntax PreviousStatement(this StatementSyntax statement);
    public static SyntaxTokenList RemoveRange(this SyntaxTokenList list, int index, int count);
    public static SyntaxTriviaList RemoveRange(this SyntaxTriviaList list, int index, int count);
    public static SeparatedSyntaxList<TNode> RemoveRange<TNode>(this SeparatedSyntaxList<TNode> list, int index, int count) where TNode : SyntaxNode;
    public static SyntaxList<TNode> RemoveRange<TNode>(this SyntaxList<TNode> list, int index, int count) where TNode : SyntaxNode;
    public static TNode RemoveTrivia<TNode>(this TNode node, TextSpan? span = null) where TNode : SyntaxNode;
    public static TNode RemoveWhitespace<TNode>(this TNode node, TextSpan? span = null) where TNode : SyntaxNode;
    public static SyntaxTokenList ReplaceRange(this SyntaxTokenList list, int index, int count, IEnumerable<SyntaxToken> newTokens);
    public static SyntaxTriviaList ReplaceRange(this SyntaxTriviaList list, int index, int count, IEnumerable<SyntaxTrivia> newTrivia);
    public static SeparatedSyntaxList<TNode> ReplaceRange<TNode>(this SeparatedSyntaxList<TNode> list, int index, int count, IEnumerable<TNode> newNodes) where TNode : SyntaxNode;
    public static SyntaxList<TNode> ReplaceRange<TNode>(this SyntaxList<TNode> list, int index, int count, IEnumerable<TNode> newNodes) where TNode : SyntaxNode;
    public static TNode ReplaceWhitespace<TNode>(this TNode node, SyntaxTrivia replacement, TextSpan? span = null) where TNode : SyntaxNode;
    public static bool ReturnsVoid(this DelegateDeclarationSyntax delegateDeclaration);
    public static bool ReturnsVoid(this LocalFunctionStatementSyntax localFunctionStatement);
    public static bool ReturnsVoid(this MethodDeclarationSyntax methodDeclaration);
    public static AccessorDeclarationSyntax Setter(this AccessorListSyntax accessorList);
    public static AccessorDeclarationSyntax Setter(this IndexerDeclarationSyntax indexerDeclaration);
    public static AccessorDeclarationSyntax Setter(this PropertyDeclarationSyntax propertyDeclaration);
    public static SeparatedSyntaxList<TNode> ToSeparatedSyntaxList<TNode>(this IEnumerable<TNode> nodes) where TNode : SyntaxNode;
    public static SeparatedSyntaxList<TNode> ToSeparatedSyntaxList<TNode>(this IEnumerable<SyntaxNodeOrToken> nodesAndTokens) where TNode : SyntaxNode;
    public static SyntaxList<TNode> ToSyntaxList<TNode>(this IEnumerable<TNode> nodes) where TNode : SyntaxNode;
    public static SyntaxTokenList ToSyntaxTokenList(this IEnumerable<SyntaxToken> tokens);
    public static SyntaxToken TrimLeadingTrivia(this SyntaxToken token);
    public static TNode TrimLeadingTrivia<TNode>(this TNode node) where TNode : SyntaxNode;
    public static SyntaxToken TrimTrailingTrivia(this SyntaxToken token);
    public static TNode TrimTrailingTrivia<TNode>(this TNode node) where TNode : SyntaxNode;
    public static SyntaxToken TrimTrivia(this SyntaxToken token);
    public static TNode TrimTrivia<TNode>(this TNode node) where TNode : SyntaxNode;
    public static bool TryGetContainingList(this StatementSyntax statement, out SyntaxList<StatementSyntax> statements);
    public static ExpressionSyntax WalkDownParentheses(this ExpressionSyntax expression);
    public static ExpressionSyntax WalkUpParentheses(this ExpressionSyntax expression);
    public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, MemberDeclarationSyntax member);
    public static ClassDeclarationSyntax WithMembers(this ClassDeclarationSyntax classDeclaration, IEnumerable<MemberDeclarationSyntax> members);
    public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, MemberDeclarationSyntax member);
    public static CompilationUnitSyntax WithMembers(this CompilationUnitSyntax compilationUnit, IEnumerable<MemberDeclarationSyntax> members);
    public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, MemberDeclarationSyntax member);
    public static InterfaceDeclarationSyntax WithMembers(this InterfaceDeclarationSyntax interfaceDeclaration, IEnumerable<MemberDeclarationSyntax> members);
    public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, MemberDeclarationSyntax member);
    public static NamespaceDeclarationSyntax WithMembers(this NamespaceDeclarationSyntax namespaceDeclaration, IEnumerable<MemberDeclarationSyntax> members);
    public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, MemberDeclarationSyntax member);
    public static StructDeclarationSyntax WithMembers(this StructDeclarationSyntax structDeclaration, IEnumerable<MemberDeclarationSyntax> members);

  public static class Roslynator.CSharp.SyntaxInfo

    public static AsExpressionInfo AsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false);
    public static AsExpressionInfo AsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static AssignmentExpressionInfo AssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false);
    public static AssignmentExpressionInfo AssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static BinaryExpressionInfo BinaryExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false);
    public static BinaryExpressionInfo BinaryExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static ConditionalExpressionInfo ConditionalExpressionInfo(ConditionalExpressionSyntax conditionalExpression, bool walkDownParentheses = true, bool allowMissing = false);
    public static ConditionalExpressionInfo ConditionalExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static GenericInfo GenericInfo(TypeParameterConstraintClauseSyntax constraintClause);
    public static GenericInfo GenericInfo(DelegateDeclarationSyntax delegateDeclaration);
    public static GenericInfo GenericInfo(LocalFunctionStatementSyntax localFunctionStatement);
    public static GenericInfo GenericInfo(MethodDeclarationSyntax methodDeclaration);
    public static GenericInfo GenericInfo(SyntaxNode node);
    public static GenericInfo GenericInfo(TypeDeclarationSyntax typeDeclaration);
    public static GenericInfo GenericInfo(TypeParameterSyntax typeParameter);
    public static GenericInfo GenericInfo(TypeParameterConstraintSyntax typeParameterConstraint);
    public static GenericInfo GenericInfo(TypeParameterListSyntax typeParameterList);
    public static IsExpressionInfo IsExpressionInfo(BinaryExpressionSyntax binaryExpression, bool walkDownParentheses = true, bool allowMissing = false);
    public static IsExpressionInfo IsExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false);
    public static LocalDeclarationStatementInfo LocalDeclarationStatementInfo(ExpressionSyntax value, bool allowMissing = false);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(CompilationUnitSyntax compilationUnit);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(NamespaceDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(TypeDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(ClassDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(StructDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(InterfaceDeclarationSyntax declaration);
    public static MemberDeclarationListInfo MemberDeclarationListInfo(SyntaxNode node);
    public static ModifierListInfo ModifierListInfo(AccessorDeclarationSyntax accessorDeclaration);
    public static ModifierListInfo ModifierListInfo(ClassDeclarationSyntax classDeclaration);
    public static ModifierListInfo ModifierListInfo(ConstructorDeclarationSyntax constructorDeclaration);
    public static ModifierListInfo ModifierListInfo(ConversionOperatorDeclarationSyntax conversionOperatorDeclaration);
    public static ModifierListInfo ModifierListInfo(DelegateDeclarationSyntax delegateDeclaration);
    public static ModifierListInfo ModifierListInfo(DestructorDeclarationSyntax destructorDeclaration);
    public static ModifierListInfo ModifierListInfo(EnumDeclarationSyntax enumDeclaration);
    public static ModifierListInfo ModifierListInfo(EventDeclarationSyntax eventDeclaration);
    public static ModifierListInfo ModifierListInfo(EventFieldDeclarationSyntax eventFieldDeclaration);
    public static ModifierListInfo ModifierListInfo(FieldDeclarationSyntax fieldDeclaration);
    public static ModifierListInfo ModifierListInfo(IncompleteMemberSyntax incompleteMember);
    public static ModifierListInfo ModifierListInfo(IndexerDeclarationSyntax indexerDeclaration);
    public static ModifierListInfo ModifierListInfo(InterfaceDeclarationSyntax interfaceDeclaration);
    public static ModifierListInfo ModifierListInfo(LocalDeclarationStatementSyntax localDeclarationStatement);
    public static ModifierListInfo ModifierListInfo(LocalFunctionStatementSyntax localFunctionStatement);
    public static ModifierListInfo ModifierListInfo(MethodDeclarationSyntax methodDeclaration);
    public static ModifierListInfo ModifierListInfo(SyntaxNode node);
    public static ModifierListInfo ModifierListInfo(OperatorDeclarationSyntax operatorDeclaration);
    public static ModifierListInfo ModifierListInfo(ParameterSyntax parameter);
    public static ModifierListInfo ModifierListInfo(PropertyDeclarationSyntax propertyDeclaration);
    public static ModifierListInfo ModifierListInfo(StructDeclarationSyntax structDeclaration);
    public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, NullCheckStyles allowedStyles = ComparisonToNull | IsPattern, bool walkDownParentheses = true, bool allowMissing = false);
    public static NullCheckExpressionInfo NullCheckExpressionInfo(SyntaxNode node, SemanticModel semanticModel, NullCheckStyles allowedStyles = All, bool walkDownParentheses = true, bool allowMissing = false, CancellationToken cancellationToken = default);
    public static RegionInfo RegionInfo(EndRegionDirectiveTriviaSyntax endRegionDirective);
    public static RegionInfo RegionInfo(RegionDirectiveTriviaSyntax regionDirective);
    public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleAssignmentExpressionInfo SimpleAssignmentExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(AssignmentExpressionSyntax assignmentExpression, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(ExpressionStatementSyntax expressionStatement, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleAssignmentStatementInfo SimpleAssignmentStatementInfo(StatementSyntax statement, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleIfElseInfo SimpleIfElseInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleIfStatementInfo SimpleIfStatementInfo(IfStatementSyntax ifStatement, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleIfStatementInfo SimpleIfStatementInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false);
    public static SimpleMemberInvocationExpressionInfo SimpleMemberInvocationExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(ExpressionStatementSyntax expressionStatement, bool allowMissing = false);
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(InvocationExpressionSyntax invocationExpression, bool allowMissing = false);
    public static SimpleMemberInvocationStatementInfo SimpleMemberInvocationStatementInfo(SyntaxNode node, bool allowMissing = false);
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(ExpressionSyntax value);
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(LocalDeclarationStatementSyntax localDeclarationStatement, bool allowMissing = false);
    public static SingleLocalDeclarationStatementInfo SingleLocalDeclarationStatementInfo(VariableDeclarationSyntax variableDeclaration, bool allowMissing = false);
    public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(LambdaExpressionSyntax lambdaExpression, bool allowMissing = false);
    public static SingleParameterLambdaExpressionInfo SingleParameterLambdaExpressionInfo(SyntaxNode node, bool walkDownParentheses = true, bool allowMissing = false);
    public static StatementListInfo StatementListInfo(StatementSyntax statement);
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(BinaryExpressionSyntax binaryExpression, SemanticModel semanticModel, CancellationToken cancellationToken = default);
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(in ExpressionChain expressionChain, SemanticModel semanticModel, CancellationToken cancellationToken = default);
    public static StringConcatenationExpressionInfo StringConcatenationExpressionInfo(SyntaxNode node, SemanticModel semanticModel, bool walkDownParentheses = true, CancellationToken cancellationToken = default);
    public static StringLiteralExpressionInfo StringLiteralExpressionInfo(LiteralExpressionSyntax literalExpression);
    public static StringLiteralExpressionInfo StringLiteralExpressionInfo(SyntaxNode node, bool walkDownParentheses = true);
    public static UsingDirectiveListInfo UsingDirectiveListInfo(CompilationUnitSyntax compilationUnit);
    public static UsingDirectiveListInfo UsingDirectiveListInfo(NamespaceDeclarationSyntax declaration);
    public static UsingDirectiveListInfo UsingDirectiveListInfo(SyntaxNode node);
    public static XmlElementInfo XmlElementInfo(XmlNodeSyntax xmlNode);

  public static class Roslynator.CSharp.SyntaxInverter

    public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, CancellationToken cancellationToken = default);
    public static ExpressionSyntax LogicallyInvert(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken = default);

  public static class Roslynator.CSharp.WorkspaceExtensions

    public static Task<Document> RemoveCommentsAsync(this Document document, CommentFilter comments, CancellationToken cancellationToken = default);
    public static Task<Document> RemoveCommentsAsync(this Document document, TextSpan span, CommentFilter comments, CancellationToken cancellationToken = default);
    public static Task<Document> RemovePreprocessorDirectivesAsync(this Document document, PreprocessorDirectiveFilter directiveFilter, CancellationToken cancellationToken = default);
    public static Task<Document> RemovePreprocessorDirectivesAsync(this Document document, TextSpan span, PreprocessorDirectiveFilter directiveFilter, CancellationToken cancellationToken = default);
    public static Task<Document> RemoveRegionAsync(this Document document, RegionInfo region, CancellationToken cancellationToken = default);
    public static Task<Document> RemoveTriviaAsync(this Document document, TextSpan span, CancellationToken cancellationToken = default);

  public static class Roslynator.CSharp.WorkspaceSyntaxExtensions

    public static ParenthesizedExpressionSyntax Parenthesize(this ExpressionSyntax expression, bool includeElasticTrivia = true, bool simplifiable = true);
    public static SyntaxToken WithFormatterAnnotation(this SyntaxToken token);
    public static TNode WithFormatterAnnotation<TNode>(this TNode node) where TNode : SyntaxNode;
    public static SyntaxToken WithRenameAnnotation(this SyntaxToken token);
    public static SyntaxToken WithSimplifierAnnotation(this SyntaxToken token);
    public static TNode WithSimplifierAnnotation<TNode>(this TNode node) where TNode : SyntaxNode;

  public interface Microsoft.CodeAnalysis.IAliasSymbol : IEquatable<ISymbol>, ISymbol

    INamespaceOrTypeSymbol Target { get; }
  public interface Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader

    void AddDependencyLocation(string fullPath);
    Assembly LoadFromPath(string fullPath);
  public interface Microsoft.CodeAnalysis.IArrayTypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol

    ImmutableArray<CustomModifier> CustomModifiers { get; }
    ITypeSymbol ElementType { get; }
    bool IsSZArray { get; }
    ImmutableArray<int> LowerBounds { get; }
    int Rank { get; }
    ImmutableArray<int> Sizes { get; }

    bool Equals(IArrayTypeSymbol other);
  public interface Microsoft.CodeAnalysis.IAssemblySymbol : IEquatable<ISymbol>, ISymbol

    INamespaceSymbol GlobalNamespace { get; }
    AssemblyIdentity Identity { get; }
    bool IsInteractive { get; }
    bool MightContainExtensionMethods { get; }
    IEnumerable<IModuleSymbol> Modules { get; }
    ICollection<string> NamespaceNames { get; }
    ICollection<string> TypeNames { get; }

    AssemblyMetadata GetMetadata();
    INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    bool GivesAccessTo(IAssemblySymbol toAssembly);
    INamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName);
  public interface Microsoft.CodeAnalysis.ICompilationUnitSyntax

    SyntaxToken EndOfFileToken { get; }
  public interface Microsoft.CodeAnalysis.IDiscardSymbol : IEquatable<ISymbol>, ISymbol

    ITypeSymbol Type { get; }
  public interface Microsoft.CodeAnalysis.IDynamicTypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol
  public interface Microsoft.CodeAnalysis.IErrorTypeSymbol : IEquatable<ISymbol>, INamedTypeSymbol, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol

    CandidateReason CandidateReason { get; }
    ImmutableArray<ISymbol> CandidateSymbols { get; }
  public interface Microsoft.CodeAnalysis.IEventSymbol : IEquatable<ISymbol>, ISymbol

    IMethodSymbol AddMethod { get; }
    ImmutableArray<IEventSymbol> ExplicitInterfaceImplementations { get; }
    bool IsWindowsRuntimeEvent { get; }
    IEventSymbol OriginalDefinition { get; }
    IEventSymbol OverriddenEvent { get; }
    IMethodSymbol RaiseMethod { get; }
    IMethodSymbol RemoveMethod { get; }
    ITypeSymbol Type { get; }
  public interface Microsoft.CodeAnalysis.IFieldSymbol : IEquatable<ISymbol>, ISymbol

    ISymbol AssociatedSymbol { get; }
    object ConstantValue { get; }
    IFieldSymbol CorrespondingTupleField { get; }
    ImmutableArray<CustomModifier> CustomModifiers { get; }
    bool HasConstantValue { get; }
    bool IsConst { get; }
    bool IsReadOnly { get; }
    bool IsVolatile { get; }
    IFieldSymbol OriginalDefinition { get; }
    ITypeSymbol Type { get; }
  public interface Microsoft.CodeAnalysis.ILabelSymbol : IEquatable<ISymbol>, ISymbol

    IMethodSymbol ContainingMethod { get; }
  public interface Microsoft.CodeAnalysis.ILocalSymbol : IEquatable<ISymbol>, ISymbol

    object ConstantValue { get; }
    bool HasConstantValue { get; }
    bool IsConst { get; }
    bool IsFunctionValue { get; }
    bool IsRef { get; }
    ITypeSymbol Type { get; }
  public interface Microsoft.CodeAnalysis.IMethodSymbol : IEquatable<ISymbol>, ISymbol

    int Arity { get; }
    INamedTypeSymbol AssociatedAnonymousDelegate { get; }
    ISymbol AssociatedSymbol { get; }
    IMethodSymbol ConstructedFrom { get; }
    ImmutableArray<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    bool HidesBaseMethodsByName { get; }
    bool IsAsync { get; }
    bool IsCheckedBuiltin { get; }
    bool IsExtensionMethod { get; }
    bool IsGenericMethod { get; }
    bool IsVararg { get; }
    MethodKind MethodKind { get; }
    IMethodSymbol OriginalDefinition { get; }
    IMethodSymbol OverriddenMethod { get; }
    ImmutableArray<IParameterSymbol> Parameters { get; }
    IMethodSymbol PartialDefinitionPart { get; }
    IMethodSymbol PartialImplementationPart { get; }
    ITypeSymbol ReceiverType { get; }
    IMethodSymbol ReducedFrom { get; }
    ImmutableArray<CustomModifier> RefCustomModifiers { get; }
    ITypeSymbol ReturnType { get; }
    ImmutableArray<CustomModifier> ReturnTypeCustomModifiers { get; }
    bool ReturnsByRef { get; }
    bool ReturnsVoid { get; }
    ImmutableArray<ITypeSymbol> TypeArguments { get; }
    ImmutableArray<ITypeParameterSymbol> TypeParameters { get; }

    IMethodSymbol Construct(params ITypeSymbol[] typeArguments);
    DllImportData GetDllImportData();
    ImmutableArray<AttributeData> GetReturnTypeAttributes();
    ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
  public interface Microsoft.CodeAnalysis.IModuleSymbol : IEquatable<ISymbol>, ISymbol

    INamespaceSymbol GlobalNamespace { get; }
    ImmutableArray<AssemblyIdentity> ReferencedAssemblies { get; }
    ImmutableArray<IAssemblySymbol> ReferencedAssemblySymbols { get; }

    ModuleMetadata GetMetadata();
    INamespaceSymbol GetModuleNamespace(INamespaceSymbol namespaceSymbol);
  public interface Microsoft.CodeAnalysis.INamedTypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol

    int Arity { get; }
    ISymbol AssociatedSymbol { get; }
    INamedTypeSymbol ConstructedFrom { get; }
    ImmutableArray<IMethodSymbol> Constructors { get; }
    IMethodSymbol DelegateInvokeMethod { get; }
    INamedTypeSymbol EnumUnderlyingType { get; }
    ImmutableArray<IMethodSymbol> InstanceConstructors { get; }
    bool IsComImport { get; }
    bool IsGenericType { get; }
    bool IsImplicitClass { get; }
    bool IsScriptClass { get; }
    bool IsUnboundGenericType { get; }
    IEnumerable<string> MemberNames { get; }
    bool MightContainExtensionMethods { get; }
    INamedTypeSymbol OriginalDefinition { get; }
    ImmutableArray<IMethodSymbol> StaticConstructors { get; }
    ImmutableArray<IFieldSymbol> TupleElements { get; }
    INamedTypeSymbol TupleUnderlyingType { get; }
    ImmutableArray<ITypeSymbol> TypeArguments { get; }
    ImmutableArray<ITypeParameterSymbol> TypeParameters { get; }

    INamedTypeSymbol Construct(params ITypeSymbol[] typeArguments);
    INamedTypeSymbol ConstructUnboundGenericType();
    ImmutableArray<CustomModifier> GetTypeArgumentCustomModifiers(int ordinal);
  public interface Microsoft.CodeAnalysis.INamespaceOrTypeSymbol : IEquatable<ISymbol>, ISymbol

    bool IsNamespace { get; }
    bool IsType { get; }

    ImmutableArray<ISymbol> GetMembers();
    ImmutableArray<ISymbol> GetMembers(string name);
    ImmutableArray<INamedTypeSymbol> GetTypeMembers();
    ImmutableArray<INamedTypeSymbol> GetTypeMembers(string name);
    ImmutableArray<INamedTypeSymbol> GetTypeMembers(string name, int arity);
  public interface Microsoft.CodeAnalysis.INamespaceSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol

    ImmutableArray<INamespaceSymbol> ConstituentNamespaces { get; }
    Compilation ContainingCompilation { get; }
    bool IsGlobalNamespace { get; }
    NamespaceKind NamespaceKind { get; }

    IEnumerable<INamespaceOrTypeSymbol> GetMembers();
    IEnumerable<INamespaceOrTypeSymbol> GetMembers(string name);
    IEnumerable<INamespaceSymbol> GetNamespaceMembers();
  public interface Microsoft.CodeAnalysis.IOperation

    Optional<object> ConstantValue { get; }
    bool IsInvalid { get; }
    OperationKind Kind { get; }
    SyntaxNode Syntax { get; }
    ITypeSymbol Type { get; }

    void Accept(OperationVisitor visitor);
    TResult Accept<TArgument, TResult>(OperationVisitor<TArgument, TResult> visitor, TArgument argument);
  public interface Microsoft.CodeAnalysis.IParameterSymbol : IEquatable<ISymbol>, ISymbol

    ImmutableArray<CustomModifier> CustomModifiers { get; }
    object ExplicitDefaultValue { get; }
    bool HasExplicitDefaultValue { get; }
    bool IsOptional { get; }
    bool IsParams { get; }
    bool IsThis { get; }
    int Ordinal { get; }
    IParameterSymbol OriginalDefinition { get; }
    ImmutableArray<CustomModifier> RefCustomModifiers { get; }
    RefKind RefKind { get; }
    ITypeSymbol Type { get; }
  public interface Microsoft.CodeAnalysis.IPointerTypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol

    ImmutableArray<CustomModifier> CustomModifiers { get; }
    ITypeSymbol PointedAtType { get; }
  public interface Microsoft.CodeAnalysis.IPreprocessingSymbol : IEquatable<ISymbol>, ISymbol
  public interface Microsoft.CodeAnalysis.IPropertySymbol : IEquatable<ISymbol>, ISymbol

    ImmutableArray<IPropertySymbol> ExplicitInterfaceImplementations { get; }
    IMethodSymbol GetMethod { get; }
    bool IsIndexer { get; }
    bool IsReadOnly { get; }
    bool IsWithEvents { get; }
    bool IsWriteOnly { get; }
    IPropertySymbol OriginalDefinition { get; }
    IPropertySymbol OverriddenProperty { get; }
    ImmutableArray<IParameterSymbol> Parameters { get; }
    ImmutableArray<CustomModifier> RefCustomModifiers { get; }
    bool ReturnsByRef { get; }
    IMethodSymbol SetMethod { get; }
    ITypeSymbol Type { get; }
    ImmutableArray<CustomModifier> TypeCustomModifiers { get; }
  public interface Microsoft.CodeAnalysis.IRangeVariableSymbol : IEquatable<ISymbol>, ISymbol
  public interface Microsoft.CodeAnalysis.ISkippedTokensTriviaSyntax

    SyntaxTokenList Tokens { get; }
  public interface Microsoft.CodeAnalysis.ISourceAssemblySymbol : IEquatable<ISymbol>, IAssemblySymbol, ISymbol

    Compilation Compilation { get; }
  public interface Microsoft.CodeAnalysis.IStructuredTriviaSyntax

    SyntaxTrivia ParentTrivia { get; }
  public interface Microsoft.CodeAnalysis.ISymbol : IEquatable<ISymbol>

    bool CanBeReferencedByName { get; }
    IAssemblySymbol ContainingAssembly { get; }
    IModuleSymbol ContainingModule { get; }
    INamespaceSymbol ContainingNamespace { get; }
    ISymbol ContainingSymbol { get; }
    INamedTypeSymbol ContainingType { get; }
    Accessibility DeclaredAccessibility { get; }
    ImmutableArray<SyntaxReference> DeclaringSyntaxReferences { get; }
    bool HasUnsupportedMetadata { get; }
    bool IsAbstract { get; }
    bool IsDefinition { get; }
    bool IsExtern { get; }
    bool IsImplicitlyDeclared { get; }
    bool IsOverride { get; }
    bool IsSealed { get; }
    bool IsStatic { get; }
    bool IsVirtual { get; }
    SymbolKind Kind { get; }
    string Language { get; }
    ImmutableArray<Location> Locations { get; }
    string MetadataName { get; }
    string Name { get; }
    ISymbol OriginalDefinition { get; }

    void Accept(SymbolVisitor visitor);
    TResult Accept<TResult>(SymbolVisitor<TResult> visitor);
    ImmutableArray<AttributeData> GetAttributes();
    string GetDocumentationCommentId();
    string GetDocumentationCommentXml(CultureInfo preferredCulture = null, bool expandIncludes = false, CancellationToken cancellationToken = default);
    ImmutableArray<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format = null);
    string ToDisplayString(SymbolDisplayFormat format = null);
    ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
    string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
  public interface Microsoft.CodeAnalysis.ITypeParameterSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol, ITypeSymbol

    ImmutableArray<ITypeSymbol> ConstraintTypes { get; }
    IMethodSymbol DeclaringMethod { get; }
    INamedTypeSymbol DeclaringType { get; }
    bool HasConstructorConstraint { get; }
    bool HasReferenceTypeConstraint { get; }
    bool HasValueTypeConstraint { get; }
    int Ordinal { get; }
    ITypeParameterSymbol OriginalDefinition { get; }
    ITypeParameterSymbol ReducedFrom { get; }
    TypeParameterKind TypeParameterKind { get; }
    VarianceKind Variance { get; }
  public interface Microsoft.CodeAnalysis.ITypeSymbol : IEquatable<ISymbol>, INamespaceOrTypeSymbol, ISymbol

    ImmutableArray<INamedTypeSymbol> AllInterfaces { get; }
    INamedTypeSymbol BaseType { get; }
    ImmutableArray<INamedTypeSymbol> Interfaces { get; }
    bool IsAnonymousType { get; }
    bool IsReferenceType { get; }
    bool IsTupleType { get; }
    bool IsValueType { get; }
    ITypeSymbol OriginalDefinition { get; }
    SpecialType SpecialType { get; }
    TypeKind TypeKind { get; }

    ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember);
  public interface Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress

    void OnCompleted();
    void OnDefinitionFound(ISymbol symbol);
    void OnFindInDocumentCompleted(Document document);
    void OnFindInDocumentStarted(Document document);
    void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    void OnStarted();
    void ReportProgress(int current, int maximum);
  public interface Microsoft.CodeAnalysis.Host.IAnalyzerService : IWorkspaceService

    IAnalyzerAssemblyLoader GetLoader();
  public interface Microsoft.CodeAnalysis.Host.ILanguageService
  public interface Microsoft.CodeAnalysis.Host.IPersistentStorage : IDisposable

    Task<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken = default);
    Task<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken = default);
    Task<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken = default);
    Task<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken = default);
    Task<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken = default);
    Task<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken = default);
  public interface Microsoft.CodeAnalysis.Host.IPersistentStorageService : IWorkspaceService

    IPersistentStorage GetStorage(Solution solution);
  public interface Microsoft.CodeAnalysis.Host.ITemporaryStorageService : IWorkspaceService

    ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken = default);
    ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken = default);
  public interface Microsoft.CodeAnalysis.Host.ITemporaryStreamStorage : IDisposable

    Stream ReadStream(CancellationToken cancellationToken = default);
    Task<Stream> ReadStreamAsync(CancellationToken cancellationToken = default);
    void WriteStream(Stream stream, CancellationToken cancellationToken = default);
    Task WriteStreamAsync(Stream stream, CancellationToken cancellationToken = default);
  public interface Microsoft.CodeAnalysis.Host.ITemporaryTextStorage : IDisposable

    SourceText ReadText(CancellationToken cancellationToken = default);
    Task<SourceText> ReadTextAsync(CancellationToken cancellationToken = default);
    void WriteText(SourceText text, CancellationToken cancellationToken = default);
    Task WriteTextAsync(SourceText text, CancellationToken cancellationToken = default);
  public interface Microsoft.CodeAnalysis.Host.IWorkspaceService
  public interface Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory

    ILanguageService CreateLanguageService(HostLanguageServices languageServices);
  public interface Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory

    IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
  public interface Microsoft.CodeAnalysis.Options.IOption

    object DefaultValue { get; }
    string Feature { get; }
    bool IsPerLanguage { get; }
    string Name { get; }
    ImmutableArray<OptionStorageLocation> StorageLocations { get; }
    Type Type { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IAddressOfExpression : IOperation

    IOperation Reference { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IArgument : IOperation

    ArgumentKind ArgumentKind { get; }
    IOperation InConversion { get; }
    IOperation OutConversion { get; }
    IParameterSymbol Parameter { get; }
    IOperation Value { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression : IOperation

    ImmutableArray<IOperation> DimensionSizes { get; }
    ITypeSymbol ElementType { get; }
    IArrayInitializer Initializer { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression : IOperation

    IOperation ArrayReference { get; }
    ImmutableArray<IOperation> Indices { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IArrayInitializer : IOperation

    ImmutableArray<IOperation> ElementValues { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IAssignmentExpression : IOperation

    IOperation Target { get; }
    IOperation Value { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IAwaitExpression : IOperation

    IOperation AwaitedValue { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression : IOperation, IHasOperatorMethodExpression

    BinaryOperationKind BinaryOperationKind { get; }
    IOperation LeftOperand { get; }
    IOperation RightOperand { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IBlockStatement : IOperation

    ImmutableArray<ILocalSymbol> Locals { get; }
    ImmutableArray<IOperation> Statements { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IBranchStatement : IOperation

    BranchKind BranchKind { get; }
    ILabelSymbol Target { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ICaseClause : IOperation

    CaseKind CaseKind { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ICatchClause : IOperation

    ITypeSymbol CaughtType { get; }
    ILocalSymbol ExceptionLocal { get; }
    IOperation Filter { get; }
    IBlockStatement Handler { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression : IOperation, IAssignmentExpression, IHasOperatorMethodExpression

    BinaryOperationKind BinaryOperationKind { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression : IOperation

    IOperation ConditionalInstance { get; }
    IOperation ConditionalValue { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IConditionalAccessInstanceExpression : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression : IOperation

    IOperation Condition { get; }
    IOperation IfFalseValue { get; }
    IOperation IfTrueValue { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IConversionExpression : IOperation, IHasOperatorMethodExpression

    ConversionKind ConversionKind { get; }
    bool IsExplicit { get; }
    IOperation Operand { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IDefaultValueExpression : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.IEmptyStatement : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.IEndStatement : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression : IOperation

    bool Adds { get; }
    IEventSymbol Event { get; }
    IOperation EventInstance { get; }
    IOperation HandlerValue { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IEventReferenceExpression : IOperation, IMemberReferenceExpression

    IEventSymbol Event { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IExpressionStatement : IOperation

    IOperation Expression { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IFieldInitializer : IOperation, ISymbolInitializer

    ImmutableArray<IFieldSymbol> InitializedFields { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IFieldReferenceExpression : IOperation, IMemberReferenceExpression

    IFieldSymbol Field { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IFixedStatement : IOperation

    IOperation Body { get; }
    IVariableDeclarationStatement Variables { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement : IOperation, ILoopStatement

    IOperation Collection { get; }
    ILocalSymbol IterationVariable { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IForLoopStatement : IOperation, IForWhileUntilLoopStatement, ILoopStatement

    ImmutableArray<IOperation> AtLoopBottom { get; }
    ImmutableArray<IOperation> Before { get; }
    ImmutableArray<ILocalSymbol> Locals { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement : IOperation, ILoopStatement

    IOperation Condition { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression : IOperation

    ImmutableArray<IArgument> ArgumentsInEvaluationOrder { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression : IOperation

    IMethodSymbol OperatorMethod { get; }
    bool UsesOperatorMethod { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IIfStatement : IOperation

    IOperation Condition { get; }
    IOperation IfFalseStatement { get; }
    IOperation IfTrueStatement { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IIncrementExpression : IOperation, IAssignmentExpression, ICompoundAssignmentExpression, IHasOperatorMethodExpression

    UnaryOperationKind IncrementOperationKind { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IIndexedPropertyReferenceExpression : IOperation, IHasArgumentsExpression, IMemberReferenceExpression, IPropertyReferenceExpression
  public interface Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression : IOperation

    InstanceReferenceKind InstanceReferenceKind { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IInvalidExpression : IOperation

    ImmutableArray<IOperation> Children { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IInvalidStatement : IOperation

    ImmutableArray<IOperation> Children { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IInvocationExpression : IOperation, IHasArgumentsExpression

    IOperation Instance { get; }
    bool IsVirtual { get; }
    IMethodSymbol TargetMethod { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IIsTypeExpression : IOperation

    ITypeSymbol IsType { get; }
    IOperation Operand { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ILabelStatement : IOperation

    ILabelSymbol Label { get; }
    IOperation LabeledStatement { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ILambdaExpression : IOperation

    IBlockStatement Body { get; }
    IMethodSymbol Signature { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ILateBoundMemberReferenceExpression : IOperation

    IOperation Instance { get; }
    string MemberName { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ILiteralExpression : IOperation

    string Text { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ILocalReferenceExpression : IOperation

    ILocalSymbol Local { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ILockStatement : IOperation

    IOperation Body { get; }
    IOperation LockedObject { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ILoopStatement : IOperation

    IOperation Body { get; }
    LoopKind LoopKind { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression : IOperation

    IOperation Instance { get; }
    ISymbol Member { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression : IOperation, IMemberReferenceExpression

    bool IsVirtual { get; }
    IMethodSymbol Method { get; }
  public interface Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression : IOperation

    IOperation PrimaryOperand { get; }
    IOperation SecondaryOperand { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression : IOperation, IHasArgumentsExpression

    IMethodSymbol Constructor { get; }
    ImmutableArray<IOperation> Initializers { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IOmittedArgumentExpression : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.IParameterInitializer : IOperation, ISymbolInitializer

    IParameterSymbol Parameter { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IParameterReferenceExpression : IOperation

    IParameterSymbol Parameter { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IParenthesizedExpression : IOperation

    IOperation Operand { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IPlaceholderExpression : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.IPointerIndirectionReferenceExpression : IOperation

    IOperation Pointer { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IPropertyInitializer : IOperation, ISymbolInitializer

    IPropertySymbol InitializedProperty { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression : IOperation, IMemberReferenceExpression

    IPropertySymbol Property { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IRangeCaseClause : IOperation, ICaseClause

    IOperation MaximumValue { get; }
    IOperation MinimumValue { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IRelationalCaseClause : IOperation, ICaseClause

    BinaryOperationKind Relation { get; }
    IOperation Value { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IReturnStatement : IOperation

    IOperation ReturnedValue { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause : IOperation, ICaseClause

    BinaryOperationKind Equality { get; }
    IOperation Value { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ISizeOfExpression : IOperation, ITypeOperationExpression
  public interface Microsoft.CodeAnalysis.Semantics.IStopStatement : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.ISwitchCase : IOperation

    ImmutableArray<IOperation> Body { get; }
    ImmutableArray<ICaseClause> Clauses { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ISwitchStatement : IOperation

    ImmutableArray<ISwitchCase> Cases { get; }
    IOperation Value { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ISymbolInitializer : IOperation

    IOperation Value { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ISyntheticLocalReferenceExpression : IOperation

    IOperation ContainingStatement { get; }
    SyntheticLocalKind SyntheticLocalKind { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IThrowStatement : IOperation

    IOperation ThrownObject { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ITryStatement : IOperation

    IBlockStatement Body { get; }
    ImmutableArray<ICatchClause> Catches { get; }
    IBlockStatement FinallyHandler { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ITypeOfExpression : IOperation, ITypeOperationExpression
  public interface Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression : IOperation

    ITypeSymbol TypeOperand { get; }
  public interface Microsoft.CodeAnalysis.Semantics.ITypeParameterObjectCreationExpression : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression : IOperation, IHasOperatorMethodExpression

    IOperation Operand { get; }
    UnaryOperationKind UnaryOperationKind { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IUnboundLambdaExpression : IOperation
  public interface Microsoft.CodeAnalysis.Semantics.IUsingStatement : IOperation

    IOperation Body { get; }
    IVariableDeclarationStatement Declaration { get; }
    IOperation Value { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IVariableDeclaration : IOperation

    IOperation Initializer { get; }
    ImmutableArray<ILocalSymbol> Variables { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement : IOperation

    ImmutableArray<IVariableDeclaration> Declarations { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement : IOperation, IForWhileUntilLoopStatement, ILoopStatement

    bool IsTopTest { get; }
    bool IsWhile { get; }
  public interface Microsoft.CodeAnalysis.Semantics.IWithStatement : IOperation

    IOperation Body { get; }
    IOperation Value { get; }
  public interface Roslynator.ISelection<T> : IReadOnlyList<T>

    int FirstIndex { get; }
    int LastIndex { get; }

    T First();
    T Last();
